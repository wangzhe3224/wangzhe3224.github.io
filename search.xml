<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何转行计算机做程序员</title>
    <url>/2021/11/30/roadpath/</url>
    <content><![CDATA[<h1 id="如何转行计算机？"><a href="#如何转行计算机？" class="headerlink" title="如何转行计算机？"></a>如何转行计算机？</h1><hr>
<ul>
<li>程序员的分类</li>
<li>如何开始</li>
</ul>
<hr>
<h2 id="程序员的分类"><a href="#程序员的分类" class="headerlink" title="程序员的分类"></a>程序员的分类</h2><hr>
<p>职能：</p>
<ul>
<li>前端</li>
<li>后端</li>
</ul>
<hr>
<p>业务知识：</p>
<ul>
<li>互联网</li>
<li>金融</li>
<li>游戏</li>
<li>计算机基础设施</li>
<li>各行业各</li>
</ul>
<hr>
<h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><ul>
<li>基础部分</li>
<li>业务部分</li>
</ul>
<hr>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul>
<li><em>英语</em></li>
<li>计算机基础</li>
<li>计算机进阶</li>
</ul>
<hr>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ol>
<li>计算机导论</li>
<li>数据结构和算法</li>
<li>计算机组成原理</li>
<li>操作系统</li>
<li>计算机网络</li>
<li>查缺补漏的课。。。。。</li>
<li>一些数学</li>
</ol>
<hr>
<ol>
<li><p><strong>计算机导论</strong></p>
<ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/">MIT - 6.0001</a></li>
<li><a href="https://cs50.harvard.edu/college/2020/fall/">Harvard - CS50</a></li>
<li><a href="https://cs61a.org/">Berkeley - CS61A</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>数据结构和算法</strong><ul>
<li><a href="https://web.stanford.edu/class/cs106b/schedule.html">Berkeley - CS61B</a></li>
<li><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part I,II</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm">MIT - 6.006</a></li>
<li><a href="https://leetcode.com/"><strong>Leetcode</strong> <code>:)</code></a></li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>计算机组成原理</strong><ul>
<li><a href="https://cs61c.org/fa21/">Berkeley - CS61C: Great Ideas in Computer Architecture</a></li>
<li><a href="https://www.cs.cmu.edu/~213/">CMU - 15213: Introduction to Computer Systems</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>操作系统</strong><ul>
<li><a href="https://cs162.org/">Berkeley - CS162: Operating Systems and Systems Programming</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT - 6.S081: Operating System Engineering</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><strong>计算机网络</strong><ul>
<li><a href="https://cs144.github.io/">Stanford - CS114: Introduction to Computer Networking</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><strong>查缺补漏的工具啊</strong><ul>
<li><a href="https://missing.csail.mit.edu/">MIT - 6.null: The Missing Semester of Your CS Education</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li><strong>一些数学</strong><ul>
<li><a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/">MIT 18.06: 线性代数</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041-probabilistic-systems-analysis-and-applied-probability-fall-2010/">MIT 6.431: 概率论</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/">MIT 6.042: Mathematics for Computer Science</a></li>
</ul>
</li>
</ol>
<hr>
<h3 id="计算机进阶"><a href="#计算机进阶" class="headerlink" title="计算机进阶"></a>计算机进阶</h3><p>根据业务方向选择：</p>
<ol>
<li>软件工程</li>
<li>数据库</li>
<li>分布式系统</li>
<li>编译系统</li>
<li>机器学习</li>
<li>计算机语言理论</li>
</ol>
<hr>
<ol>
<li><strong>软件工程</strong><ul>
<li><a href="http://web.mit.edu/6.031/www/fa21/">MIT 6.031: Software Construction</a></li>
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2021sp/">Cornell CS3110: Data Structures and Functional Programming</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>数据库</strong><ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2019/assignments.html#">CMU 15445: 数据库系统</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>分布式系统</strong><ul>
<li><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824: 分布式系统</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>编译系统</strong><ul>
<li><a href="https://web.stanford.edu/class/cs143/">Stanford CS143: 编译器</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><strong>机器学习</strong><ul>
<li><a href="https://openlearninglibrary.mit.edu/courses/course-v1:MITx+6.036+1T2019/course/">MIT 6.306: Introduction to Machine Learning</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><strong>计算机语言理论</strong><ul>
<li><a href="https://stanford-cs242.github.io/f19/">Stanford CS242: 计算机语言</a></li>
</ul>
</li>
</ol>
<hr>
<h2 id="业务部分"><a href="#业务部分" class="headerlink" title="业务部分"></a>业务部分</h2><ul>
<li>框架</li>
<li>语言</li>
<li>中间件</li>
<li>数据库</li>
</ul>
]]></content>
      <tags>
        <tag>presentation</tag>
      </tags>
  </entry>
  <entry>
    <title>在VS Code中使用VIM (VIM教程)</title>
    <url>/2021/11/30/vim1/</url>
    <content><![CDATA[<ul>
<li><a href="#在vs-code中使用vim">在VS Code中使用VIM</a><ul>
<li><a href="#一些基本配置">一些基本配置</a><ul>
<li><a href="#中文输入法的梦魇">中文输入法的梦魇</a></li>
<li><a href="#按键绑定">按键绑定</a></li>
</ul>
</li>
<li><a href="#基础">基础</a><ul>
<li><a href="#模式">模式</a></li>
<li><a href="#移动">移动</a><ul>
<li><a href="#normal-mode">Normal Mode</a></li>
<li><a href="#insert-mode">Insert Mode</a></li>
<li><a href="#visual-mode">Visual Mode</a></li>
</ul>
</li>
<li><a href="#页面展示">页面展示</a></li>
<li><a href="#编辑">编辑</a></li>
</ul>
</li>
<li><a href="#常用操作">常用操作</a></li>
<li><a href="#高级主题">高级主题</a><ul>
<li><a href="#寄存器">寄存器</a></li>
<li><a href="#标记">标记</a></li>
</ul>
</li>
<li><a href="#插件">插件</a><ul>
<li><a href="#surround">surround</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一些基本配置"><a href="#一些基本配置" class="headerlink" title="一些基本配置"></a>一些基本配置</h2><p>:information_source: VS Code Vim 不是 Vim。不过他模拟了绝大部分的Vim操作。<br>但是也会出现很多支持不太好的功能，比如宏、Vim script等等。但是，就我个人的使用Code<br>的Vim模拟器已经满足我的需求了。更加复杂的功能，还是需要 code 的命令支持：<code>Cmd+Shift+p</code>.</p>
<h3 id="中文输入法的梦魇"><a href="#中文输入法的梦魇" class="headerlink" title="中文输入法的梦魇"></a>中文输入法的梦魇</h3><p>如何解决VSCode Vim中文输入法切换问题？ - Daniel的回答 - 知乎<br><a href="https://www.zhihu.com/question/303850876/answer/540324790">https://www.zhihu.com/question/303850876/answer/540324790</a></p>
<h3 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">jj -&gt; ESC</span><br><span class="line">enter -&gt; :</span><br><span class="line">caps lock -&gt; ctrl</span><br></pre></td></tr></table></figure>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Vim常用的有三种模式，但是不能孤立的用，要结合起来用。<br>Vim的规则非常简单，但是组合起来非常强大，提供了一套文本编辑的“高级”语言。</p>
<p>Vim语言的基本语法：<code>动词 + 「数量、介词」 + 名词</code><br>Vim语言充满了名词做动词的情况。</p>
<p>Vim的精髓在于重复，<code>.</code></p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>三种基本模式：</p>
<ul>
<li>Normal，用来移动和编辑</li>
<li>Insert，用来输入</li>
<li>Visual/Selection，用来选择编辑块</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Esc                Insert -&gt; Normal</span><br><span class="line">i/I/o/O/c/a/A      Normal -&gt; Insert</span><br><span class="line">v / V              Normal -&gt; Visual</span><br></pre></td></tr></table></figure>

<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><h4 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h4><p>基本操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hjkl       👈 ⬆️ ⬇️ 👉</span><br><span class="line">w&#x2F;b&#x2F;e      按照单词移动</span><br><span class="line">&#123; &#125;        按照段落移动</span><br><span class="line">%          在闭合的括号之间移动</span><br><span class="line">gg         回到文档最上端</span><br><span class="line">G          回到文档最低端</span><br><span class="line">0          回到行首</span><br><span class="line">$          回到行尾</span><br></pre></td></tr></table></figure>

<p>加入数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1j         向下移动1行</span><br><span class="line">8j         向下移动8行</span><br></pre></td></tr></table></figure>

<p>移动到某一行：</p>
<ul>
<li><code>:12&lt;Enter&gt;</code>  移动到12行</li>
<li><code>12gg</code>        移动到12行</li>
</ul>
<p>搜索移动：</p>
<p>这是非常高效移动方式：j</p>
<ul>
<li><code>fa</code>: 向右移动到下一个a</li>
<li><code>ta</code>: 向右移动到下一个a的前一个字符</li>
<li><code>Fa</code>: 向左移动到下一个a</li>
<li><code>Ta</code>: 向左移动到下一个a的前一个字符</li>
</ul>
<p>另外，可以直接按 <code>\</code> 进入搜索模式，去寻找目标单词或字母。</p>
<h4 id="Insert-Mode"><a href="#Insert-Mode" class="headerlink" title="Insert Mode"></a>Insert Mode</h4><p>插入模式就是其他编辑的模式，用来输入信息。但是在插入模式，我们也可以直接移动光标、删除。<br>这进一步增加了Vim的灵活性，也就是说对于很局部化的操作，我们可以在插入模式下进行移动。</p>
<p>在插入模式下，Vim的光标移动遵循了一半 Bash shell 的快捷键。</p>
<p>def cls():<br>    …</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Ctrl+p     up</span><br><span class="line">Ctrl+n     down</span><br><span class="line">Ctrl+b     left</span><br><span class="line">Ctrl+f     right</span><br><span class="line">Ctrl+a     到行首</span><br><span class="line">Ctrl+e     到行位</span><br><span class="line">Ctrl+h     delete 1 </span><br><span class="line">Ctrl+w     delete back 1 word</span><br><span class="line">Ctrl+u     delete back to start of line</span><br></pre></td></tr></table></figure>

<h4 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h4><p>选择模式下的移动与正常模式的完全一致的。</p>
<p>:point_right:<strong>纵向编辑</strong> :point_left: 神器</p>
<p><code>ctrl+v</code></p>
<h3 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h3><p>窗口移动</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zz         把光标置于屏幕中间</span><br><span class="line">ctrl + e   向上移动屏幕</span><br><span class="line">ctrl + y   向下移动屏幕</span><br></pre></td></tr></table></figure>

<p>折叠、展开代码块</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zc        关闭代码块</span><br><span class="line">zo        打开代码块</span><br><span class="line">za        打开、关闭代码块</span><br></pre></td></tr></table></figure>

<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>这就是Vim强大的地方：编辑。</p>
<p>Vim中的动词：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">d</span><br><span class="line">c</span><br><span class="line">y</span><br><span class="line">p</span><br><span class="line">x</span><br><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">u</span><br><span class="line">Ctrl - r</span><br><span class="line">. </span><br></pre></td></tr></table></figure>

<p>名词，这些东西在Vim中成为 Text Object，推荐使用他们进行操作，这是一种高于<code>hjkl</code>移动的抽象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">w       词（可以做动词）</span><br><span class="line">p       段落（可以做动词）</span><br><span class="line">jk      行 （可以做动词）</span><br><span class="line">各种括号、引号等等</span><br><span class="line">s       句子</span><br></pre></td></tr></table></figure>

<p>介词</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i     表示里面</span><br><span class="line">a     表示外面</span><br></pre></td></tr></table></figure>

<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>格式化代码：<code>==</code></li>
<li>注释代码：<code>gc&#123;c,j,k&#125;</code></li>
<li>切换tab：<code>gt&#123;tab的数字&#125;</code></li>
<li>回退：<code>u</code></li>
<li>重做：<code>Ctrl+r</code></li>
</ul>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="surround"><a href="#surround" class="headerlink" title="surround"></a>surround</h3>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>著名空头预言家Michael Burry清仓了</title>
    <url>/2021/11/21/bigshort/</url>
    <content><![CDATA[<h2 id="Micheal-Burry是谁？"><a href="#Micheal-Burry是谁？" class="headerlink" title="Micheal Burry是谁？"></a>Micheal Burry是谁？</h2><p>麦克贝瑞（Micheal Burry）作为对冲基金经理，有着“奇怪”的背景：他同时是一名内科医生。</p>
<p>让他在对冲基金领域声望达到顶点的事件正是成功的预测08年次贷危机，并且顶着各种压力，说服高盛在内的多家投行，卖给他次级贷款CDS，在那次金融海啸中获利超过8亿美金，其中1亿是他自己的收益，其余是他为投资人赚得利润。电影《大空头》就是以他为原型拍的。</p>
<p>其实，麦克并不是依靠运气，他属于价值投资的跟随者，最擅长做空估值过高的股票。2001年，美国标普暴跌11.8%，他的基金，Scion Capital，上涨55%；2002年，标普暴跌22%，Scion再次上涨16%；2003年，标普回暖涨幅28%，Scion却再一次击败了标普，上涨50%。</p>
<h2 id="Scion的持仓"><a href="#Scion的持仓" class="headerlink" title="Scion的持仓"></a>Scion的持仓</h2><p>Micheal早在去年就开始发表一些空头言论了，只不过直到2021年第三季度，他的基金（Scion）才真正减仓！我们看一下他Q3和Q2的持仓变化：</p>
<p><img data-src="https://i.imgur.com/EKXajMa.png" alt=""></p>
<p><img data-src="https://i.imgur.com/CWC40pm.png" alt=""></p>
<p>大家注意前两行就好，当前持仓面值4千万美金，而Q2的持仓面值20亿美金，另外Scion的AUM大约是6亿美金。这些数字告诉我们什么呢？Micheal这次不是用推特看空，而是用真金白银看空了。从20亿到4千万，他几乎等于持有现金了。</p>
<p><img data-src="https://i.imgur.com/XP74Tet.png" alt=""></p>
<p>目前，他只持有6只股票，抛掉绝大部分股票和看涨期权。重仓股票只有三只，分别是CVS、LMT和GEO，分别属于医疗、军工和地产。</p>
<p><img data-src="https://i.imgur.com/SKJ2rdH.png" alt=""></p>
<h2 id="美股怎么样了？"><a href="#美股怎么样了？" class="headerlink" title="美股怎么样了？"></a>美股怎么样了？</h2><p>下面几幅图分别是：PE，Shiller PE，SP500价格和Earning。</p>
<p>这几个图说明啥呢？PE ratio逼近2000年互联网泡沫，SP500经历了长达10年牛市，而经济大周期一般是10年左右，这几个事实通常意味着崩盘；但是另一方面，我们看到Earning也是历史高位，换句话说目前的价格高位有高位的Earning支持，看起来还是比较健康的。</p>
<p><img data-src="https://i.imgur.com/2S9uYVC.png" alt="PE ratio"></p>
<p><img data-src="https://i.imgur.com/CHOsOXK.png" alt="Shiller PE Ratio"></p>
<p><img data-src="https://i.imgur.com/FmbnQ4m.png" alt="S&amp;P 500"></p>
<p><img data-src="https://i.imgur.com/qtnGgpl.png" alt="Earning"></p>
<p>但是，有一个事实我们也不应该忽略，就是10年国债的利息已经是近100年的最低值了。换句话说，政府已经没水可以放了，美国人只能印钱。</p>
<p><img data-src="https://i.imgur.com/eYH6gUk.png" alt=""></p>
<h2 id="我该怎么办"><a href="#我该怎么办" class="headerlink" title="我该怎么办"></a>我该怎么办</h2><p>我目前的持仓是一个近似60股票30债券10其他的投资组合，我认为崩盘发生的几率不大，即使发生也不会产生想2000年那样深远的影响。但是，考虑到我们的Big Short大王已经清仓了，我还是有点慌乱，所以我的策略是：</p>
<ul>
<li>买长期看跌期权做保险</li>
<li>分散股票投资到其他（比如加仓Crypto）</li>
</ul>
<p>我不是一个价值投资者，但是大周期还是参与一下，毕竟趋势还是在的。至于为啥加仓crypto，以后我再分享。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://whalewisdom.com/filer/scion-asset-management-llc">https://whalewisdom.com/filer/scion-asset-management-llc</a></li>
<li><a href="https://www.reddit.com/r/Burryology/comments/qulbfz/michael_burry_scion_asset_management_q3_2021/">https://www.reddit.com/r/Burryology/comments/qulbfz/michael_burry_scion_asset_management_q3_2021/</a></li>
<li><a href="https://www.barchart.com/etfs-funds/quotes/SPY/volatility-greeks?expiration=2022-03-18-m&amp;moneyness=50">https://www.barchart.com/etfs-funds/quotes/SPY/volatility-greeks?expiration=2022-03-18-m&amp;moneyness=50</a></li>
</ul>
]]></content>
      <categories>
        <category>Investing</category>
      </categories>
      <tags>
        <tag>空头</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust包管理和文件组织</title>
    <url>/2021/11/13/rust_module/</url>
    <content><![CDATA[<h2 id="包（package）、Crate"><a href="#包（package）、Crate" class="headerlink" title="包（package）、Crate"></a>包（package）、Crate</h2><p>首先关于文件和文件夹管理的两个概念：</p>
<ul>
<li>包（Package）</li>
<li>Crate（不知道翻译成啥）<ul>
<li>库，lib</li>
<li>二进制，bin</li>
</ul>
</li>
</ul>
<p>一个包，包含一个<code>Cargo.toml</code>文件，描述如何构建这个包内部的一个或者多个<code>Crate</code>。<code>Cargo.toml</code> 负责根据配置将这些Crate进行编译和连接。</p>
<p><strong>规则</strong>：</p>
<ul>
<li>一个包中最多只能包含一个库（lib）Crate</li>
<li>包可以包含多个二进制（bin）Crate</li>
<li>包至少要包含一个Crate（lib或者bin）</li>
</ul>
<p><code>Crate</code> 可以有两种形态：二进制（bin）或者库（lib）。区别这两者的规则是：如果只存在<code>src/main.rs</code>，这是一个与包同名的二进制（bin）Crate，且这个文件就是Crate的根。如果存在<code>src/lib.rs</code>，这是一个与包同名的库（lib）Crate，且这个文件是Crate的根；如果同时含有这两个文件，则这个包包含两个Crate：一个库，一个二进制。</p>
<p>通过将文件放在<code>src/bin</code>目录下，一个包可以包含多个二进制Crate，每一个文件都会被编译成独立的二进制Crate。</p>
<p>注意每一个二进制（bin）Crate都需要有一个main函数作为二进制的入口。</p>
<h2 id="模块（mod）"><a href="#模块（mod）" class="headerlink" title="模块（mod）"></a>模块（mod）</h2><p>模块 帮助代码分组、重用，隐藏内部状态，即封装。使用<code>mod</code>可以生命一个模块，模块可以嵌套子模块。<code>pub</code>用来暴露模块和他的API。</p>
<p>通常一个模块（包括他的子模块）会被放在同一个文件夹内部，有两种主要的方式：内部库，外部库。</p>
<p>内部库的文件结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  - lib1</span><br><span class="line">    - impl.rs，模块的实现</span><br><span class="line">    - mod.rs, 主要包含模块引入</span><br><span class="line">  - lib2</span><br><span class="line">    - impl.rs</span><br><span class="line">    - mod.rs</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>外部库文件结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">  - src</span><br><span class="line">    - main</span><br><span class="line">  - lib_ext</span><br><span class="line">    - src</span><br><span class="line">      - impl.rs</span><br><span class="line">      - mod.rs or lib.rs</span><br><span class="line">    - Cargo.toml</span><br><span class="line">  - Cargo.toml</span><br></pre></td></tr></table></figure>

<p>外层Cargo文件需要增加<code>dependency</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">util</span> = &#123; path = <span class="string">&quot;lib_ext&quot;</span>, version = <span class="string">&quot;0.1.0&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果是二进制Crate，可以直接把文件放入<code>src/bin</code>中，不需要额外引导。</p>
<p>模块的引用方式为：<code>mod1::submod::item</code>，可以采用 <code>use</code> 关键字缩短引用路径。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>自学计算机的5年</title>
    <url>/2021/10/10/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA5%E5%B9%B4/</url>
    <content><![CDATA[<p>今天无意打开了Github主页翻到了2015年9月的第一个commit，突然意识到我的“计算机”转行之旅就是在那段时间正式开始的。（那年，Github还没被微软收购呢）</p>
<p>赖的朋友直接看这里，如何自学计算机？</p>
<ul>
<li>先学一门语言，啥基础没有就Python</li>
<li>Github是最好的资源，学习、接受、贡献</li>
<li>经典书籍要读，练习要做，亲手编码<ul>
<li>CSAPP</li>
<li>SICP</li>
<li>CS3110</li>
</ul>
</li>
<li>注重基础，练习要做，亲手编码<ul>
<li>操作系统</li>
<li>数据结构</li>
<li>数据库</li>
<li>计算机网络</li>
<li>计算机语言原理（编译原理）</li>
</ul>
</li>
<li>寻找自己的业务知识专精，围绕它展开计算机学习</li>
<li>在灵魂语言后，探索多种语言，注意是探索不是精通。<ul>
<li>Python</li>
<li>C</li>
<li>Ocaml/F#</li>
<li>Clojure</li>
<li>Haskell</li>
<li>Erlang</li>
<li>Go</li>
<li>Rust</li>
<li>Java （我真的爱不起来Java，太啰嗦了。。。。）</li>
<li>C++ (我真的爱不起来C++，太复杂了。。。。)</li>
</ul>
</li>
<li>无他，唯手熟尔</li>
</ul>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><p><img data-src="https://i.imgur.com/Hhoybvl.png" alt="2015年的Github主页"></p>
<p>那一年，我做了我的第一个博客，另外两个仓库：一个是 《<code>C++</code>Primer 5th》的练习题，一个是《数据结构与算法分析<code>C++</code>实现（第五版》的练习题。燃鹅，我点进去一看，一个做了三章，一个做了两章，就没有后续了。:) 具体发生了什么已经记不住了，但是隐约感觉自己应该是被C++给恶心到了，感觉自己完全不适合学习计算机，因为练习题都做不出啊，全是抄代码。</p>
<p>同年12月，开了另一个坑《Data Structures and Algorithms in Python》，这次坚持了4章。但是，感觉Python跟<code>C++</code>比起来好舒服啊，算法题居然也能写出几个了。在那个时候，我还不清楚C++和Python究竟哪里不一样，编译型？解释器？分不清，仅仅是听说过。总之，我的自学之旅就这么开始了。</p>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p>2016年，我博士三年级，找到了人生的第一个“计算机”行业的兼职工作。是一家只有两个人的金融公司，老板是半个程序员+交易员，而我，就是所谓的程序员。</p>
<p><img data-src="https://i.imgur.com/cdtzsXv.png" alt="2016"></p>
<p>那一年，我的Github上面有了第一个给其他仓库的PR，<a href="https://github.com/vnpy/vnpy">VNPY</a>。PR的内容竟然是把IB的API接口翻译成了英文哈哈。那时候，VNPY只有几百个星吧，现在已经有足足16k星了！除此之外，我的github没什么动静了。那一年，我大部分时间都用在了工作上。因为公司只有我跟老板两个人，老板大部分时间用来搞业务了，我就成了唯一的开发人员。我魔改了VNPY的事件引擎，做了自己的交易系统，用来交易老板的一个日内CFD策略。而开发语言就是Python。</p>
<p>现在想想也是后怕，当时FUM大概7百万英镑，不是大数目，但是我的代码就那么风风火火的上线了。这期间，乱七八糟的功能修修补补的，也除了各种Bug，也赔过钱。但是，我对编程的理解加深了，然后莫名其妙的学会一些量化交易的知识。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>2017年，那年我博士毕业了（结构工程方向的博士，如果你感兴趣的话）。我的github留下了我的第一个“开源项目”：<a href="https://github.com/wangzhe3224/chanlun">缠论（已经不再维护了）</a>。因为工作一直都是量化交易、金融相关的，哪一年我其实花了很多时间在学些这方面的知识，就是所谓的 Domain Knowledge。</p>
<p>但是，我的计算机知识并没有太多提升，我只是会用Python实现一些不那么优雅的代码，它们刚好可以完成我想做的事情，虽然有各种各样的问题，但是我能忍受，况且，我也不知道要怎么改善它们。但是，好在公司很小很小（虽然陆陆续续又来了几个程序员），我几乎成了全干程序员。从后台数据库、API、到前端的Web我都碰过，因为工作需要，我们不追求好看、高效，仅仅追求快速迭代、上线，实现最基本的监控和操作。</p>
<p>这期间，我给 VNPY 和 QUANTAXIS 这两个仓库提了一些Issue，而我也从这两个项目中间获得了很多灵感。</p>
<p><img data-src="https://i.imgur.com/7vCKXCM.png" alt="我的第一个笔记仓库（已经归档了）"></p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>2018年，我的Github格外安静。这一年除了工作，就是零零星星的学习一些计算机“技术”，为了应付工作中的各种问题，比如AWS全家桶。。。这一年，我开始逐渐意识到计算机科学和所谓的“技术”是不一样的。</p>
<p><img data-src="https://i.imgur.com/HDuxHTu.png" alt=""></p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>这一年，我开始刷leetcode了，因为想要跳槽换工作，换一个平台去学习新的技术。</p>
<p>这一年，我也fork了许多量化交易的框架仓库，比如 <code>AlgoTrade</code>, <code>backtrader</code>, <code>bt</code> 等等，主要是学习他们的框架和编码模式。</p>
<p>这一年，我开源了一个奇葩库：<a href="https://github.com/wangzhe3224/zhihu-hotlist">知乎热榜</a>。哈哈哈，可能算不上库把。。</p>
<p><img data-src="https://i.imgur.com/dAcCPz4.png" alt=""></p>
<p>这一年，我的忘了我的初心：计算机科学。我花了不少时间在量化交易的框架上，也花了很多时间研究一些交易策略。我为数不多的commit都去了自己的一个研究量化策略的私有仓库里。所以，我开始计划零零星星的时间去学习计算机科学的基础知识：计算机组成原理、操作系统、数据库、计算机网路、编译原理。</p>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>啊，2020年，我换了新的工作，到了一个大一些的对冲基金，公司的FUM从1亿美金变成了40亿美金。我终于看到了“大”的对冲基金是怎么用计算机的。每天除了完成被分配的任务，就是疯狂的阅读代码，感受到了真的成长。以前，什么都是自己写，没有参考，在这个更成熟的代码仓库里，我看到了自己曾经想要而不得的东西：如何构建大尺度的项目？如何协调计算机集群进行计算？当然，我也学到了更多关于量化交易的 Domain 知识，如何构建复杂计算？如何处理异常？如何设计API和前端？等等。</p>
<p>啊，2020年，新冠疫情来了，我开始了长达一年的“work from home”。我的Github也热闹起来了。</p>
<p><img data-src="https://i.imgur.com/vMwhfPY.png" alt="2020"></p>
<p>我提交了两个更加有意思的项目：<a href="https://github.com/wangzhe3224/pygraph">Py Graph</a> 和 <a href="https://github.com/wangzhe3224/">pyca</a>。这两个项目，无论是成熟度和完整度都更高了。</p>
<p>这一年，我开始集中补充我的计算机基础知识，开始上一些网上的公开课，写作业，读计算机的经典书籍，基础各种各样的计算机语言：C，Java，Haskell，Ocaml，Erlang，Clojure，基本上是课程或者书籍设计到的语言我都接触一下。</p>
<p>这里是我的<a href="https://github.com/wangzhe3224/books">计算机书单</a>，然而，我又犯了老毛病：没长性。很多课程和书籍都是，学了一点点就放弃了，或者被其他的主题吸引了。所以这一年，我是涨了见识，但是我觉得我的思想似乎没有变得更深邃，我写了一片关于这个的文章：<a href="https://wangzhe3224.github.io/2021/05/30/admin2/">https://wangzhe3224.github.io/2021/05/30/admin2/</a> 。 即便如此，付出还是有收获的，我对计算机本身和编程也算有了更深的认识，也更认识到计算机这行业，基础知识是何等的重要，特别是对于转行的人来说。这不是学习一门语言或者学习一个框架可以带给你的。</p>
<p><strong>框架来框架去，操作系统、数据结构还是你大爷。</strong></p>
<p>同年，我在AWS部署了第一个“自主研发”的比特币日内交易系统。</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>转眼已经是第五年了，兜兜转转我还是决定回到基础了。我终于慢慢的读完了CSAPP这本书，慢慢做了很多练习，慢慢的发现C语言其实挺好理解的，并发和并行也不再神秘。我终于慢慢的读完了SICP这本书，慢慢的做了很多联系，慢慢的发现Clojure其实也挺好理解的。我终于完成CS3110这门课的联系，慢慢的发现组织程序的规则其实也挺好理解的，慢慢的发现Ocaml其实也很有意思，一点都不另类。</p>
<p>这一年，我的博客也开始热闹起来了，我开始更新自己对CPython内部的各种新的认识，毕竟Python仍然是我的灵魂语言！与当年不同的是，因为基础变得好起来了，Python对我来说不再神秘，不再是一个黑盒子，我渐渐的了解如何去分析程序，如何去理解它的性能，如何理解他跟其他语言的区别，明白他的长处和弱点。</p>
<p>这一年，我也开始变成了视频博主，开始把自己的得找分享给更多像我一样的人，像我一样想要在计算机中寻找乐趣的人们。<a href="https://github.com/wangzhe3224/Python-zhifou">Python知否</a></p>
<p><img data-src="https://i.imgur.com/HXk9H9N.png" alt=""></p>
<p>这一年，我也真正意义的开始为开源社区做贡献了！</p>
<p><img data-src="https://i.imgur.com/enU3SoJ.png" alt=""></p>
<h2 id="2026"><a href="#2026" class="headerlink" title="2026"></a>2026</h2><p>我希望5年后，当我再次回首，可以看着过往微笑。然后，写下下一个5年。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾面向对象设计模式</title>
    <url>/2021/10/02/design_pattern/</url>
    <content><![CDATA[<blockquote>
<p>Python的视角<br>转载请注明出处。<br>代码见：<a href="https://github.com/wangzhe3224/Python-zhifou/tree/master/src/todo/design_pattern">https://github.com/wangzhe3224/Python-zhifou/tree/master/src/todo/design_pattern</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>面向对象设计模式就是一系列的组织类和对象的方法，这些方法的目的就是产生更加清晰，且容易拓展和<br>修改的代码。但是，如果我们翻开设计模式的教科书，我们会发现很多的名词，但是这其中很多的模式仅仅<br>是由于语言的限制所产生的的。因为有些语言缺乏函数一等公民或者属于静态类型等等。</p>
<p>尽管如此，学习设计模式仍然非常有用，只不过我们可能需要换一种角度重新审视这些设计模式，去思考<br>这些模式背后的原则：</p>
<ul>
<li>面对接口编程，而不是面对实现</li>
<li>延迟执行，即不到不得不实例化的时候，选择延迟</li>
</ul>
<p>这两个原则不光在面向对象编程中成立，他们在任何一种语言范式中都存在。这两个原则的核心在于如何管理<br>依赖，而管理依赖的方法就是隐藏（或者说封装）和依赖注入。这篇文章我们就讨论如何将这些原则应用到<br>传统的设计模式中：</p>
<ul>
<li>创造模式，Creational Patterns</li>
<li>结构模式，Structural Patterns</li>
<li>行为模式，Behavioral Patterns</li>
</ul>
<h2 id="创造模式，Creational-Patterns"><a href="#创造模式，Creational-Patterns" class="headerlink" title="创造模式，Creational Patterns"></a>创造模式，Creational Patterns</h2><p>创造模式主要是提供一些实例化对象的模式，主要包括：</p>
<ul>
<li>工厂方法</li>
<li>抽象工厂</li>
<li>建造者</li>
<li>原型</li>
<li>单例</li>
</ul>
<p>这些创造模式都是关于实例化一个或者若干个相关的对象的，让我们来看看他们是怎么用到上述两个原则的。<br>下面的小节有如下结构：面临的问题、解决方案、跟原则的关系。由于我们是用Python举例的，Python的<br>很多语言特性，比如鸭子类型、函数一等公民等等，可能会让这些模式看起来与传统的设计模式不太一样，<br>但是，道理是一样的。当然，如果考虑一些更加强大类型系统，比如代数数据类型，很多问题甚至都不存在，<br>比如抽象工厂想要解决的问题，实际上就是 Sum Type 和 Product Type 的组合。。</p>
<h3 id="工厂方法，Factory-Method"><a href="#工厂方法，Factory-Method" class="headerlink" title="工厂方法，Factory Method"></a>工厂方法，Factory Method</h3><p>假设我们有如下类，<code>RobotController</code> 包含一个 <code>Robot</code> 对象，然后可以控制它，<br>比如 <code>some_function</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.robot = Robot()  <span class="comment"># &lt;-- 注意这里，Controller提前实例化的其他的对象，就产生了依赖。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br></pre></td></tr></table></figure>

<p>看起来不错，现在问题来了，这个Controller现在需要为控制另一种机器人，<code>RobotB</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotB</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这时，我们的 controller 类就需要更改代码，才能支持新的 RobotB。其实问题的关键在于<br> controller 过早的实例化 Robot 导致了依赖。这时候我们可以给controller注入一个工厂类，<br> 这个类负责对象的实例化，从而把责任委托给工厂类。而这个工厂类应该是一个抽象（接口）才能保证<br> controller 代码可以实用与更多的不同类型的 Robot。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotInterface</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>():</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">RobotInterface</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotB</span>(<span class="params">RobotInterface</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotCreator</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   这个就是所谓的 工厂方法！   &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>() -&gt; RobotInterface:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotACreator</span>(<span class="params">RobotCreator</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>) -&gt; RobotInterface:</span></span><br><span class="line">        <span class="keyword">return</span> Robot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBCreator</span>(<span class="params">RobotCreator</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>) -&gt; RobotInterface:</span></span><br><span class="line">        <span class="keyword">return</span> RobotB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, creator: RobotCreator</span>):</span></span><br><span class="line">        <span class="comment"># 原则1：针对抽象编程</span></span><br><span class="line">        <span class="comment"># 原则2：延后对象实例化</span></span><br><span class="line">        <span class="comment"># 原则3：委托责任（给 creator 对象）</span></span><br><span class="line">        self.robot: RobotInterface = creator.create()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    creator_a = CreatorA()</span><br><span class="line">    creator_b = CreatorB()</span><br><span class="line">    controller = RobotController(creator_a)</span><br><span class="line">    controller.move()</span><br></pre></td></tr></table></figure>

<p>不过，对于Python来说，我们并不需要 <code>Creator</code> 这一层抽象，因为 Python 可以直接传递类。<br>我们可以直接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略 Creator 的版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, robot_cls: RobotInterface</span>):</span></span><br><span class="line">        <span class="comment"># 原则1：针对抽象编程</span></span><br><span class="line">        <span class="comment"># 原则2：延后对象实例化</span></span><br><span class="line">        self.robot: RobotInterface = robot_cls() <span class="comment"># 注意这里传递的 class 不是对象</span></span><br><span class="line">        <span class="comment"># 对于 Java 这种类不是一等公民的语言，Creator往往是必须的，因为只能传递对象。</span></span><br><span class="line">        <span class="comment"># 如果使用依赖注入，我们·可以直接传入一个对象，就省略了 （）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br></pre></td></tr></table></figure>

<p>如果我们使用依赖注入，我们可以直接传入Robot对象，而不是类。</p>
<p>当然，并不是说 <code>Creator</code> 这一层抽象是没有意义的，当我们的对象实例化变得比价复杂的时候，即<br>不是一个 <code>class()</code> 可以搞定的时候，Creator 的工厂方法 <code>create</code> 可以做很多复杂的工作。<br>我举个简单的例子，比如我们希望实例化 RobotB 的时候打印一些信息，我们就可以把相应的逻辑放入<br><code>create</code> 内部，而不需要让其他的类负责。</p>
<p>我再举个例子，如果Robot的构造变得更加复杂了，比如需要组装不同的部件才能获得一个实例，Creator<br>这层抽象就显得是必须的。当然，这里不讨论依赖注入，即使使用依赖注入，直接传递实例化以后的对象，<br>实例化这个对象的复杂度仍然需要一个对象来负责。这里就引出了下一个创造模式：抽象工厂。</p>
<h3 id="抽象工厂，Abstract-Factory"><a href="#抽象工厂，Abstract-Factory" class="headerlink" title="抽象工厂，Abstract Factory"></a>抽象工厂，Abstract Factory</h3><p>我们延续上一个例子，现在机器人变得复杂了，我们需要两个部件组装一个机器人：外壳和灵魂。而每种<br>部件还可能存在不同的类型，比如金属、塑料、液体等等，电子灵魂、人类灵魂等等。这时候为了生产<br>不同的外壳和灵魂组合，我们需要抽象工厂。再一次，对于Python这不是最优雅的实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotI</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">RobotI</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, shell, soul</span>):</span></span><br><span class="line">        self.shell = shell</span><br><span class="line">        self.soul = soul</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Robot with <span class="subst">&#123;self.shell&#125;</span> and <span class="subst">&#123;self.soul&#125;</span> moves&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryI</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_soul</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>):</span></span><br><span class="line">        shell = self.create_shell()</span><br><span class="line">        soul = self.create_soul()</span><br><span class="line">        <span class="keyword">return</span> Robot(shell, soul)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetalDigitalRobotFactory</span>(<span class="params">FactoryI</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> MetalShell() </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_soul</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> DigitalSoul()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory: FactoryI</span>):</span></span><br><span class="line">        <span class="comment"># 注意这里依赖被转移到了factory</span></span><br><span class="line">        <span class="comment"># App 中的逻辑代码不再依赖于 Robot 的具体组装和实现</span></span><br><span class="line">        self.robot: RobotI = factory.create()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    factory = MetalDigitalRobotFactory()</span><br><span class="line">    app = App(factory)</span><br></pre></td></tr></table></figure>

<p>这里，我们可以通过增加新的工厂轻松的拓展我们的代码，而不用触碰已有的代码。下游的控制类并不需要<br>知道制造机器人的复杂度，因为他们不负责实例化机器人，也不必知道机器人的类型，因为他们是针对接口<br>编程的。</p>
<p>不过，在Python这类动态语言中，我们可以简化工厂类成几个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_metal_digital_robot</span>() -&gt; RobotI:</span></span><br><span class="line">    shell = MetalShell() </span><br><span class="line">    soul = DigitalSoul()</span><br><span class="line">    <span class="keyword">return</span> Robot(shell, soul)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory: <span class="built_in">callable</span></span>):</span></span><br><span class="line">        self.robot: RobotI = factory()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    factory = MetalDigitalRobotFactory()</span><br><span class="line">    app = App(factory = create_metal_digital_robot)</span><br></pre></td></tr></table></figure>

<h3 id="建造者，Builder"><a href="#建造者，Builder" class="headerlink" title="建造者，Builder"></a>建造者，Builder</h3><p>建造者模式其实与抽象工厂异曲同工，都是把一个复杂的对象实例化过程封装在一个对象里，而这个builder<br>抽象通过他不同的实现，生产不同的对象。</p>
<h3 id="单例，Singleton"><a href="#单例，Singleton" class="headerlink" title="单例，Singleton"></a>单例，Singleton</h3><p>单例其实就是一个特殊的工厂，他的<code>create</code>方法永远返回唯一的一个对象，这里是指在同一个内存地址的<br>同一个对象。只不过，按照惯例，Singleton的创造方法一般被叫做<code>get_instance</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果不存在，就创建一个对象</span></span><br><span class="line">            cls._instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="comment"># 永远返回同一对象。</span></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="原型，Prototype"><a href="#原型，Prototype" class="headerlink" title="原型，Prototype"></a>原型，Prototype</h3><p>原型试图解决的是另一个问题：如果复制一个对象。之前的讨论的模式都是如何初始化（实例化）一个对象。<br>即实现一个 <code>clone</code> 方法。这样做的好处是把复制对象的任务交个对象自己完成，不需要暴露内部状态<br>给客户端。</p>
<p>如果是Python实现的话，只需要实现<code>__copy__</code> 和 <code>__deepcopy__</code> 即可。当然也可以使用经典的<br><code>clone</code>接口。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这几个创造模式围绕的核心都是：面向接口编程 和 延迟创建。无论是抽象工厂、单例、原型，他们<br>管理依赖的基石都是通过接口，接口隐藏了细节和复杂度（比如复杂的构造过程、复杂的拷贝过程等等）。<br>也正是因为有了接口，我们就把创建类的任务委托给了其他对象。</p>
<h2 id="结构模式，Structural-Patterns"><a href="#结构模式，Structural-Patterns" class="headerlink" title="结构模式，Structural Patterns"></a>结构模式，Structural Patterns</h2><p>结构模式主要是针对如何把不同的数据（对象）放在一起。我们会分析如下设计模式：</p>
<ul>
<li>组合，Composite</li>
<li>转换器，Adapter</li>
<li>代理，Proxy</li>
<li>装饰器，Decorator</li>
<li>桥接，Bridge</li>
</ul>
<p>随着我们的分析会进一步发现，这些模式可以存在往往是因为原则1，即面向接口编程。</p>
<h3 id="组合，Composite"><a href="#组合，Composite" class="headerlink" title="组合，Composite"></a>组合，Composite</h3><p>在讨论创造模式的时候，我们看到很多模式对于动态语言来说显得过于啰嗦。<br>但是，无论在动态语言，还是静态语言中，组合模式是我认为非常有用且强大的模式。</p>
<p>组合模式适用于组织树状数据结构，组合模式通过结构可以让简单数据和由简单数据复合形成的<br>复杂结构共享同一个结构，实现“一视同仁”。</p>
<p>我们举个简单的例子，假设我们有两种对象：物品和盒子。盒子里面可以包含若干物品，也可以包含<br>更多的盒子。但是物品里面没有盒子，也就是说，物品是我们的最基对象，而盒子是复杂对象。<br>每一个物品都有一个价格，而盒子的价格等于其中物品价格的总和。那么，给出一个对象（盒子或<br>物品），我们需要计算他的价格。如何组织数据结构呢？</p>
<p>一种方式，我们一层一层遍历对象，判断如果是物品，提取价格，如果是盒子，进一步遍历。</p>
<p>另一种方法就是使用组合模式，让基本对象（物品）和复合对象（盒子）共享一个接口，这样我们<br>就不需要判断对象的类型，实现递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThingI</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">ThingI</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._price = price</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._price</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>(<span class="params">ThingI</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, contents: <span class="type">List</span>[ThingI]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 假设没有循环出现</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        sum_price = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.contents:</span><br><span class="line">            sum_price += item.price()</span><br><span class="line">        <span class="keyword">return</span> sum_price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    </span><br><span class="line">    a = Product(<span class="number">1.0</span>)</span><br><span class="line">    b = Product(<span class="number">1.0</span>)</span><br><span class="line">    c = Box(contents=[</span><br><span class="line">        Product(<span class="number">1.0</span>),</span><br><span class="line">        Box(</span><br><span class="line">            contents=[</span><br><span class="line">                Product(<span class="number">1.0</span>)</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">        Box(</span><br><span class="line">            contents=[</span><br><span class="line">                a, b</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Price of c is <span class="subst">&#123;c.price()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>如上面的例子，我们把计算和遍历对象内部状态的事情留给了对象自己，调用者完全不需要知道对象那种<br>类型，也无需知道内部的状态，它仅仅通过调用接口即可。这种通过接口统一不用对象的方法非常实用。<br>当然传统的设计模式中，复合对象（本例中的盒子）还会有一些特殊的方法，比如用来增加和减少他自己的<br>子对象等等。不过加入这些方法，可能会打破基本类型和复合类型的对称性，在后续的代码编写过程中<br>可能会造成问题。</p>
<h3 id="转换器、桥接、装饰器、代理"><a href="#转换器、桥接、装饰器、代理" class="headerlink" title="转换器、桥接、装饰器、代理"></a>转换器、桥接、装饰器、代理</h3><p>这四种模式其实有类似的地方，他们都是通过在原有的对象之间增加一个兼容两边的接口，实现对不同类型<br>的组合。转换器与桥接的主要区别在于，转换器通常是在软件开发的后续过程中由于增加新的功能，需要<br>协调已经有的部分；而桥接主要是在软件设计阶段。其实某种程度上，我们的机器人例子中的组装工厂就<br>有点桥接的意思了。桥接主要是通过对象面A对其他的对象B的结构编程，从而解耦合A和B的具体实现。</p>
<p>代理和装饰器则是通过实现一个与原对象相同的接口，从而实现对原有功能的一个拓展或者更改。设计模式<br>里面的装饰器模式跟Python的装饰器并不是同一个事情，但是实际上实现的功能非常类似。只不过Python<br>的装饰器主要是针对函数的，而函数本身也确实没有类型（其实有，但是对于Python真的不重要）。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过上述分析，可以发现接口在组织数据结构对象和解耦合方面有奇效。依然贯彻面对接口编程的原则。</p>
<h2 id="行为模式，Behavior-Patterns"><a href="#行为模式，Behavior-Patterns" class="headerlink" title="行为模式，Behavior Patterns"></a>行为模式，Behavior Patterns</h2><p>行为模式强调的是对象之间的计算和互动模式。主要涉及：</p>
<ul>
<li>访问者，Visitor</li>
<li>观察者，Observer</li>
<li>命令，Command</li>
<li>迭代器，Iterator</li>
<li>备忘录，Memento</li>
<li>策略，Strategy</li>
<li>状态机，State</li>
</ul>
<p>这类设计模式比较丰富，不同语言特性实现出来的风格迥异，但是他们蕴含的设计里面才是精华。</p>
<h3 id="访问者，Visitor"><a href="#访问者，Visitor" class="headerlink" title="访问者，Visitor"></a>访问者，Visitor</h3><p>访问者模式强调分离同一个数据对象与他的算法。经典的实现如下代码，其核心部分是 <code>Visitor</code> 这个<br>结构以及每一个被访问的对象的 <code>accept</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Visitor Interface declares a set of visiting methods that correspond to</span></span><br><span class="line"><span class="string">    component classes. The signature of a visiting method allows the visitor to</span></span><br><span class="line"><span class="string">    identify the exact class of the component that it&#x27;s dealing with.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element: ConcreteComponentA</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element: ConcreteComponentB</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Component interface declares an `accept` method that should take the</span></span><br><span class="line"><span class="string">    base visitor interface as an argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponentA</span>(<span class="params">Component</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Component must implement the `accept` method in such a way</span></span><br><span class="line"><span class="string">    that it calls the visitor&#x27;s method corresponding to the component&#x27;s class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        visitor.visit_concrete_component_a(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclusive_method_of_concrete_component_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Concrete Components may have special methods that don&#x27;t exist in their</span></span><br><span class="line"><span class="string">        base class or interface. The Visitor is still able to use these methods</span></span><br><span class="line"><span class="string">        since it&#x27;s aware of the component&#x27;s concrete class.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponentB</span>(<span class="params">Component</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Same here: visitConcreteComponentB =&gt; ConcreteComponentB &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>):</span></span><br><span class="line">        visitor.visit_concrete_component_b(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">special_method_of_concrete_component_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor1</span>(<span class="params">Visitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor2</span>(<span class="params">Visitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_code</span>(<span class="params">components: <span class="type">List</span>[Component], visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can run visitor operations over any set of elements without</span></span><br><span class="line"><span class="string">    figuring out their concrete classes. The accept operation directs a call to</span></span><br><span class="line"><span class="string">    the appropriate operation in the visitor object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> component <span class="keyword">in</span> components:</span><br><span class="line">        component.accept(visitor)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="观察者，Observer"><a href="#观察者，Observer" class="headerlink" title="观察者，Observer"></a>观察者，Observer</h3><p>这种设计模式可以说非常常见了，观察者也就是我们经常听到的广播订阅模式。这种模式如今已经走出了<br>设计模式的范畴，在架构领域也是经常见到，比如我们常见的Kafka就是这种设计模式实现的中间件。</p>
<p>同时，与访问者对比，观察者会被动得到通知，而访问者需要主动要求 (调用<code>accept</code>)。</p>
<p>经典的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subject interface declares a set of methods for managing subscribers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Attach an observer to the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Detach an observer from the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Notify all observers about an event.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span>(<span class="params">Subject</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; The Subject owns some important state and notifies observers when the state</span></span><br><span class="line"><span class="string">    changes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _state: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; For the sake of simplicity, the Subject&#x27;s state, essential to all</span></span><br><span class="line"><span class="string">    subscribers, is stored in this variable.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _observers: <span class="type">List</span>[Observer] = []</span><br><span class="line">    <span class="string">&quot;&quot;&quot; List of subscribers. In real life, the list of subscribers can be stored</span></span><br><span class="line"><span class="string">    more comprehensively (categorized by event type, etc.).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Attached an observer.&quot;</span>)</span><br><span class="line">        self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Trigger an update in each subscriber.  &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Notifying observers...&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self._observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_business_logic</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nSubject: I&#x27;m doing something important.&quot;</span>)</span><br><span class="line">        self._state = randrange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Subject: My state has just changed to: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; The Observer interface declares the update method, used by subjects.  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Receive update from subject.  &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverA</span>(<span class="params">Observer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> subject._state &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverA: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverB</span>(<span class="params">Observer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> subject._state == <span class="number">0</span> <span class="keyword">or</span> subject._state &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverB: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    subject = ConcreteSubject()</span><br><span class="line"></span><br><span class="line">    observer_a = ConcreteObserverA()</span><br><span class="line">    subject.attach(observer_a)</span><br><span class="line"></span><br><span class="line">    observer_b = ConcreteObserverB()</span><br><span class="line">    subject.attach(observer_b)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br><span class="line">    subject.some_business_logic()</span><br><span class="line"></span><br><span class="line">    subject.detach(observer_a)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br></pre></td></tr></table></figure>

<h3 id="命令，Command"><a href="#命令，Command" class="headerlink" title="命令，Command"></a>命令，Command</h3><p>命令模式在如今的软件工程中也非常常见，它其实是一种对象之间的通讯方式，命令模式会把一个请求<br>转换成包含完成这个命令的信息的独立对象，这个命令对象随后可以被发送给命令的执行对象执行。<br>从而实现了发送者和接受者的解耦合。看起来与观察者有一点类似，命令的执行者可以算是某种命令的<br>观察者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, payload: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._payload = payload</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SimpleCommand execute with <span class="subst">&#123;self._payload&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, receiver: Receiver, a, b</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._receiver = receiver</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ComplexCommand execute with <span class="subst">&#123;self._receiver&#125;</span>&quot;</span>)</span><br><span class="line">        self._receiver.do_a(self._a)</span><br><span class="line">        self._receiver.do_b(self._b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 包含了业务逻辑，即知道如何响应命令。 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_a</span>(<span class="params">self, a: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> do a with <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_b</span>(<span class="params">self, b: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> do b with <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_on_start</span>(<span class="params">self, command: Command</span>):</span></span><br><span class="line">        self._on_start = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_on_finish</span>(<span class="params">self, command: Command</span>):</span></span><br><span class="line">        self._on_finish = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something_important</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_start, Command):</span><br><span class="line">            self._on_start.execute()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_finish, Command):</span><br><span class="line">            self._on_finish.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    invoker = Invoker()</span><br><span class="line">    invoker.set_on_start(SimpleCommand(<span class="string">&quot;Say Hi!&quot;</span>))</span><br><span class="line">    receiver = Receiver()</span><br><span class="line">    invoker.set_on_finish(ComplexCommand(</span><br><span class="line">        receiver, <span class="string">&quot;Send email&quot;</span>, <span class="string">&quot;Save report&quot;</span>))</span><br><span class="line">    invoker.do_something_important()</span><br></pre></td></tr></table></figure>

<h3 id="迭代器，Iterator"><a href="#迭代器，Iterator" class="headerlink" title="迭代器，Iterator"></a>迭代器，Iterator</h3><p>迭代器是关于如何遍历数据结构的模式。比如一个树结构，我们可以通过定义迭代器接口方法：<code>iterator</code> 来抽象不同的遍历风格，比如深度优先、广度优先等等。</p>
<h3 id="备忘录，Memento"><a href="#备忘录，Memento" class="headerlink" title="备忘录，Memento"></a>备忘录，Memento</h3><p>备忘录是一种在不打破对象封装的前提下，对对象进行快照的方法，通过快照我们可以方便的进行历史重现。其核心在于把管理快照的功能交给其他对象。在Python中快照可以通过不同的序列化实现。</p>
<h3 id="策略，Strategy"><a href="#策略，Strategy" class="headerlink" title="策略，Strategy"></a>策略，Strategy</h3><p>策略模式其实就是为算法定义一个接口，从而实现随意插入任意具体算法的模式。可以参考机器人的例子。<br>抽象工厂可以理解成某个工厂算法。</p>
<h3 id="状态机，State"><a href="#状态机，State" class="headerlink" title="状态机，State"></a>状态机，State</h3><p>状态机也是非常常见的设计模式，也就是一个对象的行为，取决于它内部的状态；而他对事件的相应，也会<br>影响他内部的状态。我认为是一种与组合模式同样影响深远的模式。状态机会把这些复杂度封装在对象内部<br>而不会让客户端通过一些if语句来控制。同样，这也是一种责任交付。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Context 是包含 State 的对象，也就是 state 的客户端 &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    _state = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, state: State</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.transition_to(state)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transition_to</span>(<span class="params">self, state: State</span>):</span></span><br><span class="line">        self._state = state</span><br><span class="line">        self._state.context = self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._state.handle1()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request2</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._state.handle2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">context</span>(<span class="params">self</span>) -&gt; Context:</span></span><br><span class="line">        <span class="keyword">return</span> self._context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @context.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">context</span>(<span class="params">self, context: Context</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._context = context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的状态机有两个状态，A 和 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span>(<span class="params">State</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request1.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateB())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request2.&quot;</span>)    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span>(<span class="params">State</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request2.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateA())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    context = Context(ConcreteStateA())</span><br><span class="line">    context.request1()</span><br><span class="line">    context.request2()</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>可以看出，设计模式主要使用的技巧就是：</p>
<ul>
<li>面对接口编程</li>
<li>延迟执行</li>
<li>依赖注入</li>
<li>组合 而不是 继承</li>
</ul>
<p>在上面的例子中，所有的继承都紧紧是接口的一种实现，并不是真正意义的共享状态，而是共享合同。<br>这种共享接口让程序变更加容易拓展。依赖注入可以看成某种延迟执行。</p>
<p>当然，不同的语言特性会让这些模式实现看起来非常不一样，比如采用鸭子类型的语言，Python或者Go，<br>很多继承是不需要的，我们只需要duck type接口的方法即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://refactoring.guru/design-patterns">https://refactoring.guru/design-patterns</a></li>
<li><a href="https://github.com/faif/python-patterns">https://github.com/faif/python-patterns</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建流计算集群</title>
    <url>/2021/09/04/flink_raspberrypi/</url>
    <content><![CDATA[<h1 id="树莓派搭建流计算集群"><a href="#树莓派搭建流计算集群" class="headerlink" title="树莓派搭建流计算集群"></a>树莓派搭建流计算集群</h1><blockquote>
<p>生活扇了我一巴掌，我能怎么办？擦擦脸，接着与生活同行。:-1</p>
<p>无名 2021</p>
</blockquote>
<p>本篇介绍如何利用（闲置的）树莓派搭设流处理集群。</p>
<p>原材料：树莓派若干。（我有两个ARMv7的树莓派4）</p>
<p>主要用到的技术和软件：</p>
<ul>
<li>Docker, 用来管理集群计算资源</li>
<li>Portainer，集群管理UI</li>
<li>Flink，原生流处理凭条</li>
<li>Redis，缓存+Broker</li>
<li>Prometheus，流监控</li>
<li>Grafana，图形化流监控</li>
</ul>
<p>集群控制没有使用K8s，因为k8s对32位处理器支持一般，而且没有原生的ARM支持，只能用一个API协调的软件叫k3s，后来发现还不如直接用<code>Docker Swarm</code>就行集群资源管理。反正所有的服务都是 docker 容器，后期集群扩容，只需要在新节点上加入集群即可。</p>
<p>最终我的集群包含两个Docker Swarm节点：</p>
<p><img data-src="https://i.imgur.com/qphWSv6.png" alt=""></p>
<p>集群运行服务：</p>
<p><img data-src="https://i.imgur.com/evOfMHt.png" alt=""></p>
<h2 id="树莓派设置"><a href="#树莓派设置" class="headerlink" title="树莓派设置"></a>树莓派设置</h2><p>首先，安装操作系统，具体可以<a href="https://www.raspberrypi.org/documentation/computers/getting-started.html">参考</a>。基本的操作就是下载操作系统，烧录在sd卡里，然后把卡查回树莓派。<br>这里注意SD卡烧制系统结束后，在SD卡跟目录里加入一个空的叫<code>ssh</code>的文件，这样树莓派会自动激活ssh服务。默认用户是<code>pi</code>，密码是<code>raspberry</code>。这样就可以实现headless部署。</p>
<p>将多个树莓派通过集线器或者路由器连接起来，然后设置每个树莓派的hostname和静态IP地址。</p>
<p>静态IP地址可以在这里设置：<code>/etc/dhcpcd.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address &#x3D; 192.168.1.xxx</span><br><span class="line">static domain_name_server &#x3D; 192.168.1.1, 8.8.8.8</span><br></pre></td></tr></table></figure>

<h2 id="创建Docker-Swarm集群"><a href="#创建Docker-Swarm集群" class="headerlink" title="创建Docker Swarm集群"></a>创建Docker Swarm集群</h2><p>SSH进入一个树莓派，将它作为集群的主机：</p>
<ol>
<li>安装 Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 Swarm 集群</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-adr 192.168.1.xxx</span><br></pre></td></tr></table></figure>

<p>其中<code>xxx</code>就是当前选定的集群主机静态IP地址。这个命令会生成一个token，记录token用来后续接入其他集群节点。</p>
<p>在其他节点树莓派中同样安装docker，但是输入如下命令连接入集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm join --token 这里是你的token 192.168.1.xxx:2377</span><br></pre></td></tr></table></figure>

<p>所有节点接入集群后，可以在集群主机查看集群状态：<code>docker node ls</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">4588i2fvipv17led4hptn349s *   pi1        Ready     Active         Leader           20.10.8</span><br><span class="line">uvhsalsyo9zfx8z5ny4nfb4ze     pi2        Ready     Active                          20.10.8</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装 Portainer 监控集群状态</li>
</ol>
<p>在主机执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker volume create portainer_data</span><br><span class="line">$ docker run -d -p 8000:8000 -p 9000:9000 --name&#x3D;portainer --restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer-ce</span><br></pre></td></tr></table></figure>

<p>然后就可用过访问<code>192.168.1.xxx:9000</code>访问集群控制界面了。</p>
<h2 id="部署流处理集群服务"><a href="#部署流处理集群服务" class="headerlink" title="部署流处理集群服务"></a>部署流处理集群服务</h2><p>具体的配置文件见这个<a href="https://github.com/wangzhe3224/flink-fog-cluster">repo</a>。</p>
<p>主要的工作在于自己build可用flink镜像，可以clone仓库，然后自己build一个镜像。也可以直接pull我做的好的镜像：<code>docker pull wangzhe3224/flink-1.13.2-armv7:latest</code>，这是针对的arml7处理器的，后期的树莓派应该都是v8版本了，需要另外重新构建。</p>
<p>下一步就是用docker文件配置各项服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jobmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">digitaljazz/flink-1.8.0-armv7:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">jobmanager.sh</span> <span class="string">start-foreground</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">taskmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">digitaljazz/flink-1.8.0-armv7:latest</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">taskmanager.sh</span> <span class="string">start-foreground</span> <span class="string">-Djobmanager.rpc.address=jobmanager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">flinknet</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="type">!=</span> <span class="string">worker04</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="type">!=</span> <span class="string">worker01</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mosquitto:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eclipse-mosquitto:1.6.5</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1883:1883&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mosquitto</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker01</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/prometheus.yaml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:6.1.3</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD=admin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/provisioning/:/etc/grafana/provisioning/</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">flinknet:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br></pre></td></tr></table></figure>

<p>然后再集群主机：<code>docker stack deploy --compose-file docker-stack.yaml flink</code> 启动所有服务。</p>
<p>可以通过<code>docker service ls</code> 查看集群运行服务。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>Redis</tag>
        <tag>树莓派</tag>
        <tag>Streaming</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动态内存分配</title>
    <url>/2021/08/29/malloc_1/</url>
    <content><![CDATA[<h1 id="关于动态内存分配"><a href="#关于动态内存分配" class="headerlink" title="关于动态内存分配"></a>关于动态内存分配</h1><p>动态内存分配通常是指堆内存（Heap，不是数据结构背景下的堆结构）的动态分配和收回。<br>动态内存分配与程序的性能和内存使用情况息息相关。对于性能主要涉及两个方面：<br>分配和释放内存的性能，即吞吐；内存的局部性（与缓存相关），即缓存友好。<br>对于内存的利用率，主要是关于内存碎片的优化。</p>
<h2 id="Mental-Model-心智模型"><a href="#Mental-Model-心智模型" class="headerlink" title="Mental Model (心智模型)"></a>Mental Model (心智模型)</h2><blockquote>
<p>A mental model is an explanation of someone’s thought process<br>about how something works in the real world.<br>– wiki</p>
</blockquote>
<p>在现代操作系统中，每一个进程都具有自己的独立<em>虚拟内存空间</em>。虚拟内存是一个抽象：<br>它隐藏了硬件存储系统的复杂度。存储系统包括：内存、硬盘、网络上其他计算机的存储系统。<br>进程对存储系统的操作就建立在这个抽象上：每个进程（同一个机器或者不同机器）看到的<br>内存地址空间都是一样的！</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在进一步讨论之前，我们还需要了解另外一个<br>概念：内存映射（Memory Mapping）。Linux类系统在初始化虚拟内存空间时，会将这部分<br>内存与硬盘上的一个对象联系起来。内存映射有两种：</p>
<ul>
<li><em>一般文件</em></li>
<li><em>匿名文件</em></li>
</ul>
<p><em>一般文件</em>：一个正常文件中的内容分页（page）被映射到（虚拟）内存地址上。但是，直到CPU<br>主动请求某个页的时候，文件中的内从才会被拷贝进入内存。</p>
<p><em>匿名文件</em>：系统把一部分内存映射到一个匿名文件中，并且用0填充该内存空间，这些页也被称为<br>demand-zero page。</p>
<p>无论是哪种情况，虚拟内存也被初始化后，他就会与一个交换文件（swap file）连接，并与他不断<br>交换数据。(每一个进程都有一个交换文件吗？)</p>
<p><img data-src="https://i.imgur.com/vRpgBpw.jpg" alt="内存心智模型"></p>
<h3 id="堆内存动态分配"><a href="#堆内存动态分配" class="headerlink" title="堆内存动态分配"></a>堆内存动态分配</h3><p>动态内存分配就是负责管理堆内存空间的，而在内存中申请空间的就是通过内存映射（Demand-zero）。</p>
<p><em>为什么需要动态内存分配</em>？因为程序与在运行过程中不可避免要动态的产生和销毁对象，但是我们不能<br>无限分配内存，而不去回收不再需要的对象，否则内存最终会溢出。</p>
<p>内存分配器主要有两种风格：</p>
<ul>
<li>显式，即应用程序主动申请和释放内存。比如C++中的<code>new</code>和<code>delete</code>，或者C中的<code>malloc</code>和<code>free</code>。</li>
<li>隐式，也成为垃圾回收（GC），即应用程序不主动释放，有分配器自动释放。比如Java、Python、Ocaml都有自己的GC系统</li>
</ul>
<p><strong>显式分配器</strong></p>
<p>显式分配器主要有两个API：alloc和free。alloc返回一个指针指向申请到的空间，<br>free回收某个指针指向的空间。显式分配器需要满足如下设计需求：</p>
<ul>
<li>处理任意组合的alloc和free序列</li>
<li>快速的分配或者释放内存</li>
<li>只使用堆内存</li>
<li>满足特定的对齐标准</li>
<li>不能改变已经分配的内存内容</li>
</ul>
<p>好的分配器需要：</p>
<ul>
<li>高吞吐</li>
<li>高利用率</li>
</ul>
<p>我们会在后面讨论具体的实现，但是分配器的新式模型如下：</p>
<p>在堆内存中构建一系列块（节点、Block等等名字），这些块包含两部分内容：元信息（Meta Data）和数据，这些<br>块有一些写代数据（就是包含了应用程序来的数据），另外一些则是空的，仅仅包含元信息。这些块通过元信息进行<br>连接，从而实现分配和释放。比如，这些块可以是一个链表，也可以是其他更加复杂的数据结构，比如分段链表等等。<br>从概念上，不同的数据结构实现，就会有不同的效率，需要根据具体情况选择。</p>
<p><img data-src="https://i.imgur.com/lem9r6i.jpg" alt=""></p>
<p><strong>隐式分配器</strong></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://users.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">Dynamic Storage Allocation: A Survey and Critical Review</a></li>
<li><a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">jemalloc</a></li>
<li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf">mimalloc</a></li>
</ul>
]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>Memory Allocation</tag>
      </tags>
  </entry>
  <entry>
    <title>Bomb Lab</title>
    <url>/2021/08/08/csapp_bomb_lab/</url>
    <content><![CDATA[<h1 id="Bomb-Lab-解析"><a href="#Bomb-Lab-解析" class="headerlink" title="Bomb Lab 解析"></a>Bomb Lab 解析</h1><p>Bomb Lab 实际就是通过反汇编和GDB对一个二进制文件行进分析，寻找每一个阶段需要输入的特定字符串。主要考察对汇编代码、栈帧、寄存器的熟悉程度以及使用GDB的能力。</p>
<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>推荐大家使用docker构建一个环境方便省时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image = <span class="string">&quot;zwang/csapp&quot;</span></span><br><span class="line">path=<span class="string">&quot;/xxx/xxx&quot;</span>  <span class="comment"># 这里修改成你自己的lab目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! docker container rm csapp_env; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;remove old container.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no old container exist. Create a new one&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker container run -it -v <span class="variable">$&#123;path&#125;</span>:/projects -p 8080:8080 --name=csapp_env --net host wangzhe3224/csapp /bin/bash</span><br></pre></td></tr></table></figure>

<p>上面的命名会直接从远程docker仓库pull一个我设置好的环境，并且进入那个docker的bash。环境中已经装好了：vim, gdb, cgdb 等一些列方便调试的软件和必要的 c 语言相关库。</p>
<h2 id="GDB小抄"><a href="#GDB小抄" class="headerlink" title="GDB小抄"></a>GDB小抄</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- info r, 展示寄存器内容</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://web.stanford.edu/class/cs107/resources/x86-64-reference.pdf">CS107 x86-64 Reference Sheet</a></li>
<li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">x64 Cheat Sheet</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">GDB 参考</a></li>
</ul>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p>首先观察源代码入口 <code>bomb.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">* Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>每一个阶段都是上面的模式，读取输入的字符串，传入每一个阶段的函数体，在函数体中检测输入的字符串是否与程序预设相同，如果相同则进入下一阶段。另外，lab还推荐写一个文本文件作为每一步的结果，这样方便测试，该文件每一行就是每一阶段的答案。本文假设该文件名为<code>psol.txt</code>。</p>
<p>首先，为了更完成的看到反汇编代码，我们做<code>objdump -d bomb &gt; bomb.as</code> 获得二进制炸弹的汇编代码方便查阅。当然，本文使用 cgdb 作为调试工具，可以相对方便的在调试过程看到机器码，也可以不必一直参考汇编代码文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 进入debug模式</span><br><span class="line">cgdb bomb</span><br><span class="line"></span><br><span class="line"># 在phase_1处设置断点</span><br><span class="line">b phase_1</span><br><span class="line">r &lt; psol.txt</span><br></pre></td></tr></table></figure>

<p>得到如下phase_1的汇编：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> 1│ Dump of assembler code for function phase_1:</span><br><span class="line"> 2├──&gt; 0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line"> 3│    0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line"> 4│    0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line"> 5│    0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line"> 6│    0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line"> 7│    0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line"> 8│    0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line"> 9│    0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">10│ End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>我们逐一分析：</p>
<ul>
<li>申请8字节的栈空间</li>
<li>把0x402400放入%esi，我们知道esi会存放接下来函数调用的第二个参数，第一个参数在%edi</li>
<li>然后调用strings_not_equal函数</li>
</ul>
<p>分析到这里已经比较清楚，我们只需要看一下<code>0x402400</code>这个内存地址放了什么东西，我们输入的字符串，应该就是要跟这个东西比较的，因为这是strings_not_equal的第二个参数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>因此，我们只需要把 <code>Border relations with Canada have never been better.</code> 写入 psol.txt 的第一行，作为我们炸弹阶段一的答案。</p>
<p>如果不担心炸弹会爆炸，我们可以试一试：<code>./bomb &lt; psol.txt</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/60237228">https://zhuanlan.zhihu.com/p/60237228</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31269514">https://zhuanlan.zhihu.com/p/31269514</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57977157">https://zhuanlan.zhihu.com/p/57977157</a></li>
</ul>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能Python编程（2）Profiling寻找性能瓶颈</title>
    <url>/2021/07/22/high_perf_python_2/</url>
    <content><![CDATA[<h1 id="高性能Python编程（2）Profiling寻找性能瓶颈"><a href="#高性能Python编程（2）Profiling寻找性能瓶颈" class="headerlink" title="高性能Python编程（2）Profiling寻找性能瓶颈"></a>高性能Python编程（2）Profiling寻找性能瓶颈</h1><blockquote>
<ul>
<li><a href="https://wangzhe3224.github.io/2021/06/24/high_perform_python/">高性能Python编程（1）：理解Python的“性能”</a></li>
</ul>
</blockquote>
<blockquote>
<p>相关源代码：<a href="https://github.com/wangzhe3224/high_performance_python">https://github.com/wangzhe3224/high_performance_python</a><br>更多学习资源：微信搜索   泛程序员   并添加关注，点击资源按钮。<br>更多学习视频：微信视频号  Python知否</p>
</blockquote>
<p><img data-src="https://i.imgur.com/sFSXT7N.jpg" alt=""></p>
<p>上一篇我们分析了计算机的三个组成部分，以及对应到Python程序的意义，这一篇我们从比较概括的角度介绍高性能编程的第一步：Profiling。（这个词我也不知道该怎么翻译，程序侧写？）</p>
<p>Profiling可以帮助我们发现：程序的那个部分运行缓慢（计算单元）、哪个部分占用大量内存（存储单元）、那个部分占用了网络、硬盘IO（通信单元）等等。所以Profiling是我们提高运行效率的第一步。</p>
<p><strong>划重点</strong>：</p>
<blockquote>
<ol>
<li>当你想要优化你的程序以前，先Profile！换句话说，不profile不优化。</li>
<li>无论你怎么Profiling你的代码，确保代码有足够的unit test覆盖，避免一些错误，重构代码也更有信心。</li>
</ol>
</blockquote>
<p>记住这两个原则将会在你的编码生涯中为你节约大量时间。而我们接下来要讨论的就是如何高效Profiling。</p>
<p>首先，讨论最基础的Profiling工具：<code>%timeit</code>，<code>time.time()</code> 和time装饰器。然后介绍<code>cProfiler</code>，这个内置包可以帮助我们查看程序中不同函数占用的时间，帮助发现瓶颈。接下来，<code>line_profiler</code> 可以对选中的瓶颈函数进行逐行profile，比如每一个行被调用多少次，每一行花掉时间的百分比等等。最后，我们还需要提一下<code>memory_profiler</code>，它可以用来分析我们的内存使用情况，可以解决诸如为什么这个函数使用过多的内存之类的问题。</p>
<p>上面提到的都属于静态Profile，对于一些长期驻留内存的进程，可以通过<code>py-spy</code>对进程的CPU和内存使用进行实时动态Profile，这类工具对于在线debug非常有帮助。</p>
<p>有了上面的分析后，我们基本可以确定程序的CPU和内存瓶颈，我们就可以对症下药，提高性能，比如编译、查看ByteCode等等。具体方法我们在后面的文章继续说明。</p>
<h2 id="例子：生成Julia集"><a href="#例子：生成Julia集" class="headerlink" title="例子：生成Julia集"></a>例子：生成Julia集</h2><p>为了让讨论更加具体，这个系列会用通过一个实际的例子说明：生成Julia集。这个例子属于计算密集型函数，覆盖了Python常见的一些操作，比如循环、判断等。<a href="https://github.com/wangzhe3224/high_performance_python/blob/master/src/julia_set.py">具体代码</a>在这里。</p>
<p>直接运行的结果为：</p>
<p><img data-src="https://i.imgur.com/iKTwdN6.png" alt="Julia集"></p>
<p>这一篇我们首先用纯Python实现Julia集，然后以这个函数为例，讲解如何对Python程序Profiling。</p>
<p>下面就是julia集的核心函数，由纯Python实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    output = [<span class="number">0</span>] * <span class="built_in">len</span>(zs)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(zs)):</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        z = zs[i]</span><br><span class="line">        c = cs[i]</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">abs</span>(z)) &lt; <span class="number">2</span> <span class="keyword">and</span> n &lt; max_iter:</span><br><span class="line">            z = z*z + c</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        output[i] = n</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_pure_python</span>(<span class="params">width: <span class="built_in">int</span>, max_iter: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create a list of complex coordinates &quot;&quot;&quot;</span></span><br><span class="line">    x_step = ( x2 - x1 ) / width</span><br><span class="line">    y_step = ( y2 - y1 ) / width</span><br><span class="line">    x, y = [], []</span><br><span class="line">    ycood = y1 </span><br><span class="line">    <span class="keyword">while</span> ycood &lt; y2:</span><br><span class="line">        y.append(ycood)</span><br><span class="line">        ycood += y_step</span><br><span class="line">    xcood = x1</span><br><span class="line">    <span class="keyword">while</span> xcood &lt; x2:</span><br><span class="line">        x.append(xcood)</span><br><span class="line">        xcood += x_step</span><br><span class="line"></span><br><span class="line">    zs = []</span><br><span class="line">    cs = []</span><br><span class="line">    <span class="keyword">for</span> ycoord <span class="keyword">in</span> y:</span><br><span class="line">        <span class="keyword">for</span> xcoord <span class="keyword">in</span> x:</span><br><span class="line">            zs.append(<span class="built_in">complex</span>(xcoord, ycoord)) </span><br><span class="line">            cs.append(<span class="built_in">complex</span>(c_real, c_imag))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Length of x: <span class="subst">&#123;<span class="built_in">len</span>(x)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Total elements: <span class="subst">&#123;<span class="built_in">len</span>(zs)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里我们进行一个简单的计时，来粗略估计函数的运行时间。</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    output = calculate_z_serial_purepython(max_iter, zs, cs)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    secs = end_time - start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;calculate_z_serial_purepython.__name__&#125;</span> took <span class="subst">&#123;secs&#125;</span> seconds.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">sum</span>(output) = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>可以看到，在调用<code>calculate_z_serial_purepython</code>后，通过使用<code>start_time</code>和<code>end_time</code>，可以获得函数运行一次消耗的时间。</p>
<p>在我的电脑上输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Length of x: 1000</span><br><span class="line">Total elements: 1000000</span><br><span class="line">calculate_z_serial_purepython took 5.339544057846069 seconds.</span><br><span class="line">sum(output) &#x3D; 33219980</span><br></pre></td></tr></table></figure>

<p><code>calculate_z_serial_purepython</code> 耗时5.34秒，总计计算了3亿个强度值。（CPython3.9，MacBook Pro 16）</p>
<h2 id="CPU和内存Profile方法"><a href="#CPU和内存Profile方法" class="headerlink" title="CPU和内存Profile方法"></a>CPU和内存Profile方法</h2><h3 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a><code>timeit</code></h3><p>最简单的Profile方法是利用<code>time</code>和<code>print</code>，就像我们上一小节做的一样，但是用起来不是很方便，我们可以写一个装饰器来实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timefn</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">fn</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">measure_time</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;@timefn: <span class="subst">&#123;fn.__name__&#125;</span> took <span class="subst">&#123;t2-t1:<span class="number">.4</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> measure_time</span><br></pre></td></tr></table></figure>

<p>然后我们就可以装饰需要profile的函数，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timefn</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>不过这样profile有一个弊端就是我们只能取一个sample，而好的profile通常需要多次运行，观察统计特征，这样才能排除各种干扰因素。我们可以利用timeit库，然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; python -m timeit -n 5 -r 4 -s &quot;some python code&quot;</span><br><span class="line">&gt; 5 loops, best of 1: 8.45 sec per loop</span><br></pre></td></tr></table></figure>

<p>其中，<code>-n</code> 表示每次运行循环次数，<code>-r</code>表示重复次数，<code>-s</code>后面接测试的代码块。</p>
<p>如果用IPython，可以直接用<code>%timeit</code>。</p>
<h2 id="cProfiler"><a href="#cProfiler" class="headerlink" title="cProfiler"></a><code>cProfiler</code></h2><p>输入如下命令进行Profile，并把结果输出到<code>profile.stats</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m cProfile -o profile.stats src&#x2F;julia_set.py</span><br></pre></td></tr></table></figure>

<p>然后，可以进入Python的Console读取分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line">p = pstats.Stats(<span class="string">&quot;profile.stats&quot;</span>)</span><br><span class="line">p.sort_stats(<span class="string">&quot;cumulative&quot;</span>)</span><br><span class="line">p.print_stats(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tue Jul 20 22:37:12 2021    profile.stats</span><br><span class="line"></span><br><span class="line">         36682126 function calls (36675327 primitive calls) in 10.651 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: cumulative time</span><br><span class="line">   List reduced from 2611 to 10 due to restriction &lt;10&gt;</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">    578&#x2F;1    0.001    0.000   10.652   10.652 &#123;built-in method builtins.exec&#125;</span><br><span class="line">        1    0.032    0.032   10.652   10.652 src&#x2F;julia_set.py:1(&lt;module&gt;)</span><br><span class="line">        1    0.468    0.468    9.979    9.979 src&#x2F;julia_set.py:54(calc_pure_python)</span><br><span class="line">        1    7.072    7.072    9.357    9.357 src&#x2F;julia_set.py:40(calculate_z_serial_purepython)</span><br><span class="line"> 34220076    2.285    0.000    2.285    0.000 &#123;built-in method builtins.abs&#125;</span><br></pre></td></tr></table></figure>

<p>可以很容易识别瓶颈：<code>calculate_z_serial_purepython</code>。不过<code>cProfiler</code>的输出结果非常多，不是很容易读。可是使用<code>snakeviz</code>对profile的结果文件进行可视化：<code>snakeviz profile.stats</code></p>
<p><img data-src="https://i.imgur.com/rjGz6yO.png" alt=""></p>
<h2 id="line-profiler"><a href="#line-profiler" class="headerlink" title="line_profiler"></a><code>line_profiler</code></h2><p>在识别瓶颈函数后，可以通过<code>line_profiler</code>对该函数进行逐行分析，从而进一步了解计算瓶颈。</p>
<p>安装profiler：<code>pip install line_profiler</code></p>
<p>在需要profile 的函数前加入<code>@profile</code>装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> line_profiler</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>执行：<code>kernprof -l -v src/julia_set_kernprof.py</code>，结果会被保存在<code>julia_set_kernprof.py.lprof</code>文件中。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 39.3034 s</span><br><span class="line">File: src&#x2F;julia_set_kernprof.py</span><br><span class="line">Function: calculate_z_serial_purepython at line 43</span><br><span class="line"></span><br><span class="line">Line #      Hits         Time  Per Hit   % Time  Line Contents</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    43                                           @profile</span><br><span class="line">    44                                           def calculate_z_serial_purepython(max_iter, zs, cs):</span><br><span class="line">    45         1       4029.0   4029.0      0.0      output &#x3D; [0] * len(zs)</span><br><span class="line">    46   1000001     327962.0      0.3      0.8      for i in range(len(zs)):</span><br><span class="line">    47   1000000     334117.0      0.3      0.9          n &#x3D; 0</span><br><span class="line">    48   1000000     372342.0      0.4      0.9          z &#x3D; zs[i]</span><br><span class="line">    49   1000000     338387.0      0.3      0.9          c &#x3D; cs[i]</span><br><span class="line">    50  34219980   14987467.0      0.4     38.1          while (abs(z)) &lt; 2 and n &lt; max_iter:</span><br><span class="line">    51  33219980   11923257.0      0.4     30.3              z &#x3D; z*z + c</span><br><span class="line">    52  33219980   10647361.0      0.3     27.1              n +&#x3D; 1</span><br><span class="line">    53   1000000     368513.0      0.4      0.9          output[i] &#x3D; n</span><br><span class="line">    54         1          0.0      0.0      0.0      return output</span><br></pre></td></tr></table></figure>

<p>大家可以发现核心的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50  34219980   14987467.0      0.4     38.1          while (abs(z)) &lt; 2 and n &lt; max_iter:</span><br><span class="line">51  33219980   11923257.0      0.4     30.3              z &#x3D; z*z + c</span><br><span class="line">52  33219980   10647361.0      0.3     27.1              n +&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>即进行基本数学运算的内存循环部分，这部分代码我们可以通过Numba或者Cython直接编译成C然后编译成机器码执行，进行加速。</p>
<h2 id="memory-profiler"><a href="#memory-profiler" class="headerlink" title="memory_profiler"></a><code>memory_profiler</code></h2><p>下一步就是对程序的内存使用进行profile，可以使用<code>memory_profiler</code>，安装：<code>pip install memory_profiler</code>。另外建议同时安装：<code>pip install psutil</code>，这样可以加速profile的速度。</p>
<p><code>mprof run src/julia_set_memory_profiler.py</code></p>
<p>在profile结束后，我们可以用<code>mprof plot</code>画出内存增长的趋势图，并且标注目标函数：</p>
<p><img data-src="https://i.imgur.com/ubbnTIe.png" alt=""></p>
<p>我们发现<code>calculate_z_serial_purepython</code>这段时间内存持续增加，这是由于Python不会断创建新的<code>int</code>和<code>float</code>对象（还记得吗？Python中每一个对象都会占用较大的内存空间，即使是int，因为Python的内存模型就是object，无论是什么对象。）</p>
<p>同样这部分可以通过numba或者cython编译，跳过python解释器执行，降低内存使用。</p>
<h2 id="PySpy"><a href="#PySpy" class="headerlink" title="PySpy"></a><code>PySpy</code></h2><p>最后，介绍一下如何用<code>pyspy</code>对正在运行的Python进程进行实时监测。这种方法可以对进程进行在线debug，工程中非常实用。</p>
<p>安装：<code>pip install py-spy</code></p>
<p>pyspy 主要由两种常用模式：dump和top。dump会为指定的process一个snapshot，然后dump到文件；而top会进行实时采样，或一种类似系统top命名的界面，实时监控进程的内存和CPU使用情况。</p>
<p>也可以通过record获得不同函数的资源图：<code>sudo py-spy record -o profile.svg -- python src/julia_set.py</code></p>
<p><img data-src="https://i.imgur.com/4OO294A.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了4中主要的profile工具，其中2种是CPU相关的，1种是内存相关的，最后的py-spy是针对长寿命进程的采样分析。</p>
<p><img data-src="https://i.imgur.com/ctU3xEJ.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>自学计算机书籍和课程推荐</title>
    <url>/2021/07/18/learning_2/</url>
    <content><![CDATA[<blockquote>
<p>转行程序员的精雕细选、诚心推荐。</p>
<p>文末付下载链接和课程链接。</p>
</blockquote>
<h1 id="自学计算机书籍和课程推荐"><a href="#自学计算机书籍和课程推荐" class="headerlink" title="自学计算机书籍和课程推荐"></a>自学计算机书籍和课程推荐</h1><blockquote>
<p>⚠️ 切记<strong>不要</strong>只读书、看视频，不动手做练习、写程序。</p>
<p>⚠️ 切记<strong>不要</strong>求速度，不做练习、不写程序</p>
</blockquote>
<p>这些课程和书籍是我食用后觉得良心且有帮助的资源，他们不仅仅可以帮助你学习计算机科学，也会帮助你领略一点点计算机的优雅和美丽。这些主题可能听起来没有大数据、云计算那么华丽，但却道出了真正理解这些技术的真正要素。计算机科学太年轻了（不到100年历史），学习技术的收益远没有学习基础高</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>计算机入门书籍，我只推荐三本，而这三本 SICP 和 HTDP 可以先选择其中一本必读, CSAPP 是必读的。但是个人建议如果计算机基础差一些，建议HTDP，SICP 可以以后再读。</p>
<h3 id="《Structure-and-Interpretation-of-Computer-Programs》（SICP）"><a href="#《Structure-and-Interpretation-of-Computer-Programs》（SICP）" class="headerlink" title="《Structure and Interpretation of Computer Programs》（SICP）"></a>《Structure and Interpretation of Computer Programs》（SICP）</h3><blockquote>
<p>《计算机程序的构造和解释》</p>
</blockquote>
<p><img data-src="https://i.imgur.com/rHsSNr8.png" alt="SICP"></p>
<p>这是一本来自麻省理工大学，经历20多年仍然充满活力的好书。这是一本关于计算机程序设计的总体性观念的入门书，书本中采用一种lisp方言 - Scheme作为所有例子和练习的实现语言。作者从基础的程序设计一直讲道了解释器和编译器的实现，编程范式从过程式、函数式到面向对象、面向并发都有涉及，但是讲解非常清晰。小编读完（花了两年时间，期间放弃了无数次）后，只能说：我还想再读一遍。</p>
<blockquote>
<p>小知识：Lisp诞生于1958年，是一个比C和Fortran更古老的函数式编程语言。</p>
</blockquote>
<p>不过，小编的感觉此书当然可以一上来就读，不过如果有了几年的实战经验后重读效果更佳！因为你会有一种这本书中涉及到了你工作中会遇到的大多数事情，比如编程范式、抽象方法等等。</p>
<p>有的小伙伴可能会忧虑：Scheme是个什么鬼？Lisp还活着吗？我不想用这个古老的语言，我要用Python！！好的好的，福音来了：</p>
<p>来自伯克利的同名课程，但是所有课程资料和作业都是Python3！</p>
<p><strong><a href="https://inst.eecs.berkeley.edu/~cs61a/sp12/">CS61A: Structure and Interpretation of Computer Programs</a></strong></p>
<p>如果你对Scheme情有独钟，这里是MIT的原版视频：</p>
<p><strong><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">Structure and Interpretation of Computer Programs</a></strong></p>
<h3 id="《How-to-Design-Programs》"><a href="#《How-to-Design-Programs》" class="headerlink" title="《How to Design Programs》"></a>《How to Design Programs》</h3><blockquote>
<p>《如何设计程序》</p>
</blockquote>
<p><img data-src="https://i.imgur.com/VMju2ju.png" alt="HTDP"></p>
<p>这是同样是一本经典的计算机程序设计入门书，采用另一个更现代的Lisp方言 - Racket 作为实现语言（是的，又是Lisp，这门古老的语言拥有强大的生命力）。与 SICP 相比，HTDP 更加注重程序设计的基本原则，材料组织更加平易近人，更容易读，难度也更低。小编认为是一本非常好的编程入门书，书中有大量的实例和练习题，从最简单的数据结构、递归讲到各种程序设计的抽象方法。</p>
<p>这本书的在线版本：<a href="https://htdp.org">https://htdp.org</a></p>
<h3 id="《Computer-Systems-A-Programmer’s-Perspective》"><a href="#《Computer-Systems-A-Programmer’s-Perspective》" class="headerlink" title="《Computer Systems: A Programmer’s Perspective》"></a>《Computer Systems: A Programmer’s Perspective》</h3><blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>
<p><img data-src="https://i.imgur.com/NkjpmYJ.png" alt="CSAPP"></p>
<p>这本书中文被翻译成：深入理解计算机系统，我觉得不妥。原文的意思是给程序员看的计算机系书。这本书与前两本大不相同，他是从计算机硬件的角度切入的；而前两本是从软件和程序设计的角度切入。因此，这本书会解释你写的程序是如何被翻译成指令，如何被计算机执行，读完此书，你会理解：进程、并发、编译、虚拟内存、缓存等等计算机概念。此书采用C语言作为实现语言，总体来说，这是一门很“底层”的计算机入门课。</p>
<p>如果你觉得只读书有点无趣，可以考虑这门课：</p>
<p><strong><a href="https://www.bilibili.com/video/BV1XW411A7fB/">中文字幕的公开课！</a></strong></p>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>网上很多人推荐经典《Introduction to Algorithms》作为算法入门书，我觉得很不妥，特别对于无法进行全职科班教育的人群。这本书太过于理论了，我自己试了几次都放弃了。所以我推荐下面两本，任选其一。</p>
<h3 id="《Algorithms》"><a href="#《Algorithms》" class="headerlink" title="《Algorithms》"></a>《Algorithms》</h3><blockquote>
<p>《算法》</p>
</blockquote>
<p><img data-src="https://i.imgur.com/g8PPdyW.png" alt=""></p>
<p>此书算是两大算法经典的另一个了，但是内容更加具体和实际一些，Java实现的，全部读完也需要一定的时间和耐心。</p>
<p>可以配合这个Coursera课程：</p>
<p><a href="https://www.coursera.org/learn/algorithms-part1">同名课程</a></p>
<h3 id="《Data-Structures-and-Algorithms-in-Python》"><a href="#《Data-Structures-and-Algorithms-in-Python》" class="headerlink" title="《Data Structures and Algorithms in Python》"></a>《Data Structures and Algorithms in Python》</h3><blockquote>
<p>《数据结构和算法 - Python》</p>
</blockquote>
<p><img data-src="https://i.imgur.com/T7QHhmB.png" alt="Data Structures and Algorithms in Python"></p>
<p>这一本我觉得更加亲民，特别是如果你已经在使用Python了，这本读起来会非常舒服，而且内容覆盖也比较全面。</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>编程语言书籍的推荐比较困难，因为各人的差异巨大。我的建议是根据自己的工作情况选择一个语言，然后再去选择书籍。</p>
<p>这里只推荐一门非常棒的课程，来自康奈尔的 CS3110。这是一门教你学会如何学会任何编程语言的课程，让你成为一个更好的程序员。</p>
<p><a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/">CS3110 Data Structures and Functional Programming</a></p>
<p>如果时间充裕，可以尝试学习以下几种语言来体验不同的编程体验：</p>
<ul>
<li>C</li>
<li>Ocaml</li>
<li>Go</li>
<li>Lisp的一种：Scheme、Racket、Clojure等等</li>
</ul>
<p>我没有列出Python、Java和C++，因为我猜你们一定已经在工作使用这些语言啦！</p>
<p>推荐他们的原因很简单：这些语言本身很简单，他们代表了不同的范式。我会在后续的文章中对不同的语言进行书籍和资源推荐。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>有了计算机和算法基础，加上对编程语言的熟悉，我们就可以开始更加深入的计算机之旅了。计算机的几大浪漫：</p>
<ul>
<li>操作系统</li>
<li>数据库</li>
<li>计算机网络</li>
<li>编译原理</li>
</ul>
<p>编译原理参考书没有提及，初学计算机的人可以先跳过这门课，因为这门课需要太多其他基础，比如操作系统、计算机语言、词法分析等等，而且编译原理通常只有在特定的工作岗位才会需要，一般的知识在计算机基础中已经有足够的涉猎。</p>
<p>下面这些书籍和课程需要在计算基础、算法、编程语言三项学习完成后食用，否则可能会错过这些资源的精华。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>《Operating Systems: Three Easy Pieces》</strong></p>
<blockquote>
<p>《操作系统：三堂简单的课》</p>
</blockquote>
<p>此书是我认为最适合初学者的操作系统书。课程方面，推荐MIT的经典6.S081，这门课程的Lab有一定难度，都做下来对操作系统的重要概念比如：虚拟内存、中断、并发、文件系统等有更加深刻的理解。这门课对 C 语言有要求。</p>
<p><strong><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 6.S081</a></strong></p>
<p>更妙的是：<strong>这门课是有视频的</strong></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库只推荐一个课程，CMU 15-445 包括了SQL原理和数据库底层实现，但是这门课需要良好的C++功底。</p>
<p><strong><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">CMU 15-445</a></strong></p>
<p>更妙的是：<strong>这门课是有视频的</strong></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>CMU 15-441 有不错的结构和合理的Lab。</p>
<p><strong><a href="https://computer-networks.github.io/sp19/index.html">CMU 15-441</a></strong></p>
<h2 id="再进阶"><a href="#再进阶" class="headerlink" title="再进阶"></a>再进阶</h2><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>分布式系统近年来大火，但是这是一个交叉学科，学起来并不容易，需要操作系统、计算机网络和数据库等多种知识做背景。</p>
<p>好在这个领域MIT有一门神课，不仅内容充分，而且配有视频和lab，就是</p>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824: Distributed Systems</a></p>
<p>资源下载：搜索微信公众号：泛程序员 。选择：资源 - 计算机。</p>
]]></content>
      <categories>
        <category>FanCoder</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>系统化程序设计 - 函数式</title>
    <url>/2021/07/17/design_1/</url>
    <content><![CDATA[<h1 id="系统化程序设计-函数式"><a href="#系统化程序设计-函数式" class="headerlink" title="系统化程序设计 - 函数式"></a>系统化程序设计 - 函数式</h1><ol>
<li>从问题分析到数据定义</li>
<li>签名、目的和头文件</li>
<li>函数例子</li>
<li>函数模板</li>
<li>函数定义</li>
<li>测试</li>
</ol>
<h2 id="从问题分析到数据定义"><a href="#从问题分析到数据定义" class="headerlink" title="从问题分析到数据定义"></a>从问题分析到数据定义</h2><p>确定哪些信息需要表达，明确在某个计算机语言中如何表达。确定数据结构后，写出实例。</p>
<h2 id="签名、目的和头文件"><a href="#签名、目的和头文件" class="headerlink" title="签名、目的和头文件"></a>签名、目的和头文件</h2><p>说明那种数据设计的函数接受和返回。回答问题：函数计算什么？定义函数签名。</p>
<h2 id="函数例子"><a href="#函数例子" class="headerlink" title="函数例子"></a>函数例子</h2><p>写出几个实例说明函数如何工作</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>把数据定义翻译成函数的骨架</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>根据上述步骤实现函数。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>把例子、场景分析转化成测试函数，并且确保函数通过测试。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>10年自学编程</title>
    <url>/2021/07/17/learn_coding/</url>
    <content><![CDATA[<h1 id="10年自学编程"><a href="#10年自学编程" class="headerlink" title="10年自学编程"></a>10年自学编程</h1><blockquote>
<p>Teach Yourself Programming in Ten Years</p>
<p>By Peter Norvig (真*大神，不认识的可以自行“Google”）</p>
<p>原文链接：<a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></p>
</blockquote>
<h2 id="为什么大家都很心急？"><a href="#为什么大家都很心急？" class="headerlink" title="为什么大家都很心急？"></a>为什么大家都很心急？</h2><p>如果你走进书店，你就会看到这样的书：Java自学一日通或者C、SQL、Ruby、算法自学三月通。如果去Amazon搜索<a href="https://www.amazon.com/s?i=stripbooks&rh=p_28%3Ateach+yourself+hours&s=relevanceexprank&Adv-Srch-Books-Submit.x=16&Adv-Srch-Books-Submit.y=5&field-dateop=After&field-dateyear=2000&unfiltered=1&ref=sr_adv_b">title: teach, youself, hours, since: 2000</a>，你会发现512本书。前10本书中，有9本是编程书籍，还有一个本是关于书籍管理的。如果把自学替换成学习，小时换成天，会得到类似的结果。</p>
<p>结论是：要么人们很急切的想要学习编程，要么学习编程比学习其他技能更加容易。《How to design programs》的作者们“认可”了这个说法，书中提到：“差劲的编程很简单，傻子都能在21天内学会编程，即使他们是傻子”。Abtruse Goose的搞笑漫画持类似<a href="https://abstrusegoose.com/249">观点</a></p>
<p><img data-src="https://i.imgur.com/SCAQMb5.png" alt="21天学会C++"></p>
<p>我们来分析一下：24小时自学C++：</p>
<ul>
<li><strong>自学</strong>：24小时，你没有时间写出一些有用的程序，并且从这些项目中吸取经验教训。你也没有时间与一个有经验的<code>C++</code>程序员一起工作并且理解真实的<code>C++</code>开发环境。长话短说，你没有时间学很多东西。所以这个本书只能给你一种假的熟悉感，而不是深入理解。就像Alexander Pope说的：学一点点是很危险的！</li>
<li><strong><code>C++</code></strong>：24小时的时间，你可能可以学一点<code>C++</code>的语法（如果你之前接触过其他编程语言），但是你不能学到很多关于如何使用这个语言的内容。总之，假设你是一个Basic程序员，你可能会学会用Basic的模式写<code>C++</code>，但是你不会理解<code>C++</code>实际的长度和弊端。如果这样的话，为什么还要学呢？<a href="http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html">Alan Perlis</a> 说过：“一个计算机语言如果不能影响你思考编程的方式，那么这个语言不值得学习”。还有一个可能的观点是，为了完成一个需要与其他语言交互的任务，你需要学一点点<code>C++</code>（或是 JavaScript 或 Processing）。但是你并没有学习如何编程，而是学习完成一个那个任务。</li>
<li><strong>24小时</strong>：时间不够！下个小节说明</li>
</ul>
<h2 id="10年自学编程-1"><a href="#10年自学编程-1" class="headerlink" title="10年自学编程"></a>10年自学编程</h2><p>研究表明（Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)))：在大多数领域达到专家水平需要大约10年时间，这些领域包括但不完全：象棋、作曲、网球、钢琴、绘画、游泳等等。而成功的关键在于<strong>刻意练习</strong>：不是无意义的重复，而是永远做一些有挑战的事情，并且做得过程中和完成后分析经验教训。然后，需要不断重复这个过程！在成为专家的路上似乎没有捷径：即使是莫扎特也不例外。他4岁就是个音乐奇才了，他仍然花了13年才做出了世界级别的音乐。披头士乐队也是如此，1964年他们在Ed Sullivan秀登台并且带来了一连串的经典歌曲，可是他们从1957年开始就在利物浦和汉堡的小酒吧里演出了，而他们的传奇专辑《Sgt.Peppers》在1967年才问世。</p>
<p><a href="https://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922">Malcolm Gladwell</a>让这个观点更加流行了，尽管他在说中提到的是1万小时而不是10年。Henri Cartier-Bresson (1908-2004) 提到过：“你的前1万张照片是你最差的作品！”（不过在他的时代还没数码相机，现在人们可以在一周实现1万张了）。真正的专业水准需要一生的时间：Samuel Johnson (1709-1784) 说：“在任何领域获得杰出成就的价格都是一生的努力，没有更便宜的价格了”。Chaucer (1340-1400) 抱怨到：“生之有限，学也无涯”。K. Anders Ericsson教授提到：：“在大多数领域中，即使是最有才华的人也需要多少时间才能达到最高水平的表现，这一点很了不起。 1万小时的数字只是让你觉得我们在谈论的是每周 10 到 20 小时，有些人认为这些是最有天赋的人仍然需要达到最高水平。”</p>
<h2 id="所以，你想要成为一个程序员？"><a href="#所以，你想要成为一个程序员？" class="headerlink" title="所以，你想要成为一个程序员？"></a>所以，你想要成为一个程序员？</h2><p>下面我列出成为成功程序员的要素：</p>
<ul>
<li><strong>兴趣</strong>。确保自己对编程有足够的兴趣，因为这样你才愿意话10年或者1万小时编程</li>
<li><strong>程序</strong>。做好的学习就是<a href="https://www.engines4ed.org/hyperbook/nodes/NODE-120-pg.html">实践</a>。从技术角度说，你在某个领域达到的最好程度不一定会随着经验提高，但是通过刻意练习，即使你已经很厉害了，你还是可以获得提高。最有效的学习需要一个明确的、难度合适的任务，同时需要其他人的反馈以及重复和纠错的机会。<a href="https://www.amazon.com/exec/obidos/ASIN/0521357349">Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</a>在这方面很有帮助。</li>
<li><strong>交流</strong>。与其他程序员交流，阅读别人的程序。这一点比任何书籍和课程都重要。</li>
<li>如果你愿意，去大学或者研究生院学习4年。这样你有就会获得一些需要学历的工作，同时你会更加深刻的理解计算机科学。但是如果你不想上学，你也可以通过自学或者工作经验弥补。不论哪种情况，只靠读书是不够的。《The New Hacker’s Dictionary》的作者 Eric Raymond说：“计算机科学教育不可能让每一个学生都成为专家级程序员，就像你不能通过学习画笔和颜料成为一个画家一样”。我（Peter）雇佣过最好的程序员之一只有高中学历，但是他做出了很多出色的<a href="https://www.mozilla.org">软件</a>，他有自己的<a href="http://groups.google.com/groups?q=alt.fan.jwz&meta=site%3Dgroups">新闻组</a>，他甚至得到了足够多的股权去买一个<a href="http://en.wikipedia.org/wiki/DNA_Lounge">夜店</a>。</li>
<li>与其他程序员一起做项目。在一些项目里你是最好的；而另一些里面你是最差的。当你是最好的程序员，你可以测试你的领导能力；当你是最差的，你可以跟那些大师学习，学习他们希望做的和他们不希望做的（因为他们会让你做。。）</li>
<li>追随其他程序员的项目。理解别人写的程序。学会如何理解和修复一个出问题的程序，思考自己的项目怎么写可以让后来的人维护起来更方便，</li>
<li>至少学6个计算机语言。包括一个强调类型抽象的（比如C++，Java），一个强调函数式抽象的（比如Lisp、ML、Haskel），一个支持语法抽象的（比如Lisp），一个支持声明式说明的（比如Prolog或者C++模板），和一个强调并行的（<em>小编：我觉得这里作者可能想说的是并发而不是并行</em>）（比如Clojure或者Go）</li>
<li>记住：计算机科学里面有一个“计算机”。知道你的计算机需要多长时间执行一个指令、从内存读取一个词（有缓存或者没有缓存的情况）、从硬盘读取一个词或者在硬盘寻址。答案在最后一小节 &lt;-</li>
<li>参与一个语言的标准化。可以是ANSI C++委员会，或者是你自己的编码风格是2个还是4个空格。无论哪种方式，你会学习那些东西是其他人喜欢的，以及为什么人们喜欢。</li>
<li>能够感知什么时候放弃语言标准化。</li>
</ul>
<p>说了这么多，我们开始质疑仅仅通过阅读书籍你可以走多远？在我第一个孩子出生以前，我读了各种“如何做”的书，却还是觉得自己是个菜鸟。30个月后，当我的第二个孩子要出生的时候，我回去看那些书了吗？没有！相反，我依靠我的第一个孩子的经验，事实也证明这些经验比那些“专家”给出的建议更有用。</p>
<p>Fred Brooks在他的文章《No Silver Bullet》发现了一个找到好的软件设计者的3步走计划：</p>
<ol>
<li>尽早系统化地识别顶级设计师</li>
<li>指定一个职业导师</li>
<li>提供与其他设计师交流的机会</li>
</ol>
<p>这假设有些人已经具备成为伟大设计师所需的素质； 工作是引导他们前进。 Alan Perlis 更简洁地说：“每个人都可以学会雕刻：米开朗基罗必须学会如何不雕刻。伟大的程序员也是如此”。 玻璃市说，伟人有一些超越他们训练的内在品质。 但是，在没有质量从何而来？ 是天生的吗？ 还是他们通过勤奋来发展它？ 正如 Auguste Gusteau（《料理鼠王》中的虚构厨师）所说，“任何人都可以做饭，但只有无所畏惧的人才是伟大的。” 我认为它更像是愿意将一个人一生的大部分时间用于深思熟虑的实践。 但也许无所畏惧是总结这一点的一种方式。 或者，正如 Gusteau 的评论家 Anton Ego 所说：“不是每个人都能成为伟大的艺术家，但伟大的艺术家可以来自任何地方。”</p>
<p>所以去买那本 Java/Ruby/Javascript/PHP 书吧； 你可能会从中得到一些用处。 但是你不会在 24 小时或 21 天内改变你的生活，或者你作为程序员的真正整体专业知识。努力工作以在 24 个月内持续改进怎么样？好吧，现在开始你的旅程把。。。</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><table>
<thead>
<tr>
<th>任务</th>
<th>时间(纳秒)</th>
</tr>
</thead>
<tbody><tr>
<td>执行一条指令</td>
<td>1</td>
</tr>
<tr>
<td>L1缓存读取</td>
<td>0.5</td>
</tr>
<tr>
<td>分支预测错误</td>
<td>5</td>
</tr>
<tr>
<td>L2缓存读取</td>
<td>7</td>
</tr>
<tr>
<td>互斥锁操作</td>
<td>25</td>
</tr>
<tr>
<td>内存读取</td>
<td>100</td>
</tr>
<tr>
<td>在1Gbps网络发送2kb数据</td>
<td>20000</td>
</tr>
<tr>
<td>从内存顺序读取1MB数据</td>
<td>250000</td>
</tr>
<tr>
<td>从本地磁盘读取一个新的位置（seek）</td>
<td>8毫秒</td>
</tr>
<tr>
<td>从本地磁盘顺序读取1MB数据</td>
<td>20 毫秒</td>
</tr>
<tr>
<td>在美国和欧洲之间传递数据</td>
<td>150 毫秒</td>
</tr>
</tbody></table>
<h2 id="附录：语言选择"><a href="#附录：语言选择" class="headerlink" title="附录：语言选择"></a>附录：语言选择</h2><p>很多人问过：第一个计算机语言应该学什么？没有固定的答案，但是考虑如下三点：</p>
<ul>
<li>选你朋友用的。当被问到：“我该用那个操作系统，Wondows，Unix还是MacOS？” 的时候，我的回答通常是：用你周围朋友用的。您从朋友那里学到的优势将抵消操作系统之间或编程语言之间的任何内在差异。 还要考虑你未来的朋友：如果你继续下去，你将成为其中一员的程序员社区。 你选择的语言有一个庞大的成长社区还是一个正在消亡的小社区？ 是否有书籍、网站和在线论坛可以获取答案？ 你喜欢那些论坛里的人吗？</li>
<li>把事情简单化。 C++ 和 Java 等编程语言是为由关心代码运行时效率的经验丰富的程序员组成的大型团队而设计的。 因此，这些语言具有为这些情况设计的复杂部分。 你关心的是学习编程。 你不需要那种复杂性。 您需要一种设计为易于单个新程序员学习和记忆的语言。</li>
<li>玩。 您更愿意以哪种方式学习弹钢琴：正常的交互式方式，即您在敲击琴键后立即听到每个音符，或“批处理”模式，在这种方式中，您仅在完成一首歌曲后才听到音符 ? 显然，交互模式使钢琴学习和编程更容易。 坚持一种具有交互模式的语言并使用它。</li>
</ul>
<p>鉴于这些标准，我对第一种编程语言的建议是 Python 或 Scheme。 另一个选择是 Javascript，不是因为它非常适合初学者，而是因为它的在线教程太多了，例如可汗学院的教程。 但是您的情况可能会有所不同，还有其他不错的选择。 如果您的年龄是个位数，您可能更喜欢 Alice 或 Squeak 或 Blockly（年龄较大的学习者可能也喜欢这些）。重要的是你选择并开始编程。</p>
<p>欢迎关注 泛程序员 获得更多编程知识：</p>
<p><img data-src="https://i.imgur.com/5e9RRJy.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能Python编程（1）</title>
    <url>/2021/06/24/high_perform_python/</url>
    <content><![CDATA[<h1 id="高性能Python编程（1）：理解Python的“性能”"><a href="#高性能Python编程（1）：理解Python的“性能”" class="headerlink" title="高性能Python编程（1）：理解Python的“性能”"></a>高性能Python编程（1）：理解Python的“性能”</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>Python的性能常常被人诟病，但是另一方面Python却又常常出现在高性能计算库中，比如tensorflow，numpy等等，这是为什么呢？Python的性能究竟差在哪里？理想的高性能程序应该是什么样的？如何能写出高性能的Python程序？这个系列我们就尝试探索这些问题的答案。</p>
<p>首先我们退一步看一下组成计算机的基本部分，这样我们才能下手分析和提高程序的执行性能。</p>
<h2 id="计算机三大部分"><a href="#计算机三大部分" class="headerlink" title="计算机三大部分"></a>计算机三大部分</h2><p>计算机的设备主要分成三类：<strong>计算单元、存贮单元、通讯单元</strong>。</p>
<p>典型的计算机由计算单元（CPU），CPU会连接两类存贮单元：内存和硬盘，通讯单元（总线）就是连接计算单元和存储单元的桥梁。</p>
<p>你可能会问：显卡呢？键盘呢？显示器呢？？懂行的你可能还会问：南北桥呢？细想一下，显卡其实是计算单元（GPU）和存储单元（显存）的组合体；而键盘、显示器、鼠标、网卡这些基本属于IO设备，所谓IO就是Input，字节写入内存，Output，字节读出内存，这类设备通常通过总线与内存沟通，利用中断与CPU协作。硬盘在这个意义上也是IO设备，因此这些设备我们姑且认为属于存储单元吧。南北桥其实算是通讯单元的司令部，北桥芯片，主要负责控制显卡、内存与CPU之间的数据交换；靠近PCI槽的为南桥芯片，主要负责硬盘、键盘以及附加卡的数据交换。</p>
<p>说到底，计算过程就是：把字节（Byte）从存储单元放进计算单元“计算”，然后把结果放回存储单元，而“计算”就是改变字节。</p>
<p>可以看出，影响程序执行效率的主要有两个因素：<strong>移动字节的速度和计算的速度</strong>。移动字节的速度主要受限于存储介质的读写速度和通讯的速度；计算速度的影响因素主要是计算单元的类型和架构，比如CPU和GPU对不同的指令执行效率不尽相同，而更极端的例子量子计算芯片，QPU，则拥有完全不同的“计算”方式。</p>
<h3 id="计算单元"><a href="#计算单元" class="headerlink" title="计算单元"></a>计算单元</h3><p>计算单元种类繁多，有我们常见的CPU，GPU，也有一些不太常见的，比如TPU（张量处理器）,QPU(量子计算处理器)等等。不过不论是那种计算单元，他们的工作就是输入一串比特，输出另一串比特。计算单元的主要衡量标准就是单位时间内可以进行的计算量。</p>
<p>我们那常见的CPU的性能举例，我们关心两个指标：一个cycle可以执行的指令数量；一秒钟最大的cycle数量。前者我们用IPC（Instruction Per Cycle）衡量，后者我们用时钟频率衡量。不同的CPU架构会有截然不同的特性，比如酷睿处理器的IPC非常高，但是频率较低；而早期的奔腾处理器IPC较低，但是频率非常高。</p>
<p>提高主频对提高计算速度有直接的帮助，而提高IPC则可以有效的提高“向量化”操作的速度，即同时处理多组计算。你可以理解成一个是纵向提升，一个是横向提升。</p>
<p>有时候你的编译器也会分析程序，然后根据CPU指令集做一些优化，进一步提升计算效率。</p>
<p>在多核时代，程序尽可能多的利用多个带来的并行能力也是提升计算效率的常见手段。而且，由于目前CPU工艺经很难进一步提高时钟频率了，计算机更倾向于安装更多处理器核心，而不是主频更高的处理器。</p>
<p>不过，在Python诞生的年代（上个世纪90年代），还是单核的时代，CPython实现引入了GIL，即Global Interpreter Lock，来处理多线程下的同步问题，你可以把他理解成一把大锁，用来保护解释器内部状态。这是设计其实在当年大大提高了单核执行效率，特别后来更新GIL调度方式以后，对IO多线程有巨大的贡献。然鹅，进入20世纪后，多核处理器成为了主流，Python的GIL导致解释器不能有效利用多核进行并行计算，不过Python社区也提出了多种方法解决这个问题，比如<code>multiprocessing</code>库，一些第三方库，比如<code>numpy</code>, <code>numexpr</code>等等，<code>Cython</code>编译器，以及利用计算集群进行计算。</p>
<p>以上这些方法，我们在后续的文章中逐步介绍。</p>
<h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>存储单元主要负责储存比特，这些比特可以是计算的输入，也可以是计算的输出。衡量存储单元的指标主要有三个：容量、读写速度、寻址速度。</p>
<p>通常存储单元是分层的，容量从低到高，读写、寻址速度从高到低：</p>
<ul>
<li>CPU缓存L1、L2、L3</li>
<li>内存</li>
<li>固态硬盘</li>
<li>机械硬盘</li>
<li>网络</li>
</ul>
<p>为了提高计算的性能，我们应该尽可能多的使用读写速度更快的单元作为缓存，减少不同层次之间存储单元的数据移动，因为这种数据的时间成本非常高，而且约下层越高。这也是为什么编程时，Locality特别的重要，Locality不但可以降低寻址的时间，还可以最大程度的利用高速缓存。</p>
<p>对于Python而言，Locality通常是被破坏的，这是CPython的实现机制导致的，不过我们也有办法克服。</p>
<h3 id="通讯单元"><a href="#通讯单元" class="headerlink" title="通讯单元"></a>通讯单元</h3><p>典型计算机的通讯是通过某类总线（Bus）实现的，比如前端总线负责L1L2缓存和内存的通讯；而网卡可以认为是机器和机器之间存储单元的通讯。</p>
<p>衡量总线性能指标主要由两个：一次移动比特的数量，即带宽；移动比特的频率，即总线频率。</p>
<h2 id="理想的高性能程序"><a href="#理想的高性能程序" class="headerlink" title="理想的高性能程序"></a>理想的高性能程序</h2><p>现在我们了解了计算机计算的三个组成部分，下面我们用一个检测素数的小程序来说明如何构造一个“完美”的高效程序。</p>
<p>首先我们写一段Python伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_prime</span>(<span class="params">number</span>):</span></span><br><span class="line">    sqrt = math.sqrt(number)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (number / i).is_integer():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">check_prime(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>我们抛开Python的实现机制，看看上面的程序是如何执行的。</p>
<p>首先，为了计算<code>sqrt</code>，我们需要把<code>number</code>的值从内存送往CPU，理想情况下<code>number</code>会驻留在CPU的缓存。CPU计算<code>sqrt</code>后把值送回内存。然后我们进入循环，理想情况我们会一次性把<code>number</code>和<code>i</code>同时送往CPU，然后检查是否整除。</p>
<p>如何进一步优化程序？第一个方法就是利用CPU的向量化能力，一次计算多组<code>number</code>和<code>i</code>。在这过过程中，充分利用缓存来存储尽可能多的i值和结果，这样就可以减少数据传输的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_prime</span>(<span class="params">number</span>):</span></span><br><span class="line">    sqrt_number = math.sqrt(number) </span><br><span class="line">    numbers = <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt_number)+<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(numbers), <span class="number">5</span>):</span><br><span class="line">        result = (number / numbers[i:(i + <span class="number">5</span>)]).is_integer() </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(result):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Python慢在哪里"><a href="#Python慢在哪里" class="headerlink" title="Python慢在哪里"></a>Python慢在哪里</h2><p>好了，下面我们来说说Python究竟慢在哪里了。Python的解释器（虚拟机）是非常好的抽象，程序员不太需要考虑我们上面提到的三种计算单元，比如绝大多数情况下，Python程序员不需要考虑如何分配内存，如何优化缓存，或者如何把变量送到CPU。这是Python的优势，但是这些抽象会损害程序的执行效率。话句话说，Python的执行循环中有很多指令都是为了支持这些抽象的。</p>
<p>当我们谈到Python的性能，其实有不同的维度。</p>
<p>首先，Python代码的性能不容易直接推断，如果你恰好知道一些小技巧，你的程序就会快很多，而同样的业务逻辑其他的实现方法就会慢一些。我举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_unknown1</span>(<span class="params">haystack, needle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>((item == needle <span class="keyword">for</span> item <span class="keyword">in</span> haystack))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_unknown2</span>(<span class="params">haystack, needle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>([item == needle <span class="keyword">for</span> item <span class="keyword">in</span> haystack])</span><br></pre></td></tr></table></figure>

<p>你觉得上面两个函数那个运行更快？？所以，Python这类语言提升性能之前，更应该首先进行Profiling，来确定性能瓶颈。</p>
<p>其次，Python（CPython）的Object内存规划并没有很高效，这与Python的GC和内存池有关。但是这种内存使用和回收机制会破坏缓存，也会导致不能充分利用总线带宽。</p>
<p>另外，Python语言灵活性的代价就是动态类型，解释器需要花费大量时间弄清楚对象的类型，寻找正确的函数等等。不过这个问题其实容易解决，只要我们可以识别性能瓶颈，就可以采用Cython这样的工具突破瓶颈。</p>
<p>最后，就是GIL。上文已经提到了，GIL限制了并行计算能力，但是这个问题其实也很容易解决。</p>
<h2 id="那为啥Python还是这么火？"><a href="#那为啥Python还是这么火？" class="headerlink" title="那为啥Python还是这么火？"></a>那为啥Python还是这么火？</h2><p>既然Python这么“慢”，为啥Python还是这么火？？网上已经很多讨论了，我就说几个：</p>
<p>1、近乎完美的生态。从大数据、机器学习、数值计算到Web，再到量子计算。<br>2、对非计算机科学的小伙伴极度友好<br>3、计算机专业的人用起来真的很舒服，抽象能力还是很不错<br>4、大觉部分性能问题可以很轻松地解决（哈哈哈，这就是这个系列的重点）</p>
<p>OK，下一篇我们来谈谈如何Profiling程序，这是提高执行效率的第一步！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《High Performance Python》</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 12 并发编程 2</title>
    <url>/2021/06/20/csapp_12_2/</url>
    <content><![CDATA[<h1 id="CSAPP-12-并发编程-2"><a href="#CSAPP-12-并发编程-2" class="headerlink" title="CSAPP 12 并发编程 2"></a>CSAPP 12 并发编程 2</h1><p>并发可以增加系统的吞吐量，充分利用多核性能，但是并发系统带来的复杂度也需要额外的注意，以免出现不容易debug的bug。</p>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>并发执行的程序访问<strong>栈外</strong>共享内存，往往不是由一个CPU指令完成，而是一系列指令。这时，这一些列指令就形成了一个 critical section 。如果不对这些critical section进行处理，就会出现并发bug。</p>
<p>为了避免并发bug，Edsger Dijkstra 提出了 Semaphores ，即信号量来保护 critical section 的指令。Semaphore本质上是一个全局变量，类型为正整数，有两个对应的函数来操作Semaphore：P和V：</p>
<ul>
<li><code>P(s)</code> 如果s不为0，P会将s减一，然后返回让线程继续执行；如果s为0，P会阻塞，当前线程挂起直到s为正，线程继续执行。</li>
<li><code>V(s)</code> 会将s加一，如果有其他进程等待s为正，V操作会unblock<strong>一个</strong>等待的线程，被释放的线程的P操作会立刻将s减一。</li>
</ul>
<p>值得注意的是，P和V操作都是不可分的，即PV相关的CPU指令执行不会被中断。另外需要注意的是V操作不能确定哪一个等待的线程会被释放。</p>
<p>Posix定义了如下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="number">0</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">/* V(s) */</span></span><br></pre></td></tr></table></figure>

<p>Semaphore 非常有用，常见的用法有 binary semaphore（BS） 和 counting semaphore （CS）。BS就是我们常说的互斥锁，而CS可以用来控制资源访问。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> niters;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">2</span> * niters)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread routine */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, niters = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin goodcntthread */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">	P(&amp;mutex);</span><br><span class="line">	cnt++;</span><br><span class="line">	V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end goodcntthread */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end goodcnt */</span></span><br></pre></td></tr></table></figure>

<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><p>信号量是很多并发数据结构的基础，比如bounded buffer queue就是通过计数信号量实现的一种资源调度数据结构。</p>
<p>H文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SBUF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SBUF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">/* buf[(front+1)%n] is first item */</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">/* buf[rear%n] is last item */</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">/* Protect access to buf */</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">/* Counts available slots */</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">/* Counts available items */</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>C文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Heap allocation dynamic</span></span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Sem will make sure inc/dec or P/V is atomic action.</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);  <span class="comment">// wait for slot, if slots &gt; 0, dec it. else wait</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// lock buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;</span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// release buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items);  <span class="comment">// inc item in the buffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);  <span class="comment">// wait for item</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// lock buffer</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];</span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;slots);  <span class="comment">// update slot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，利用Semaphore还可以实现其他的并发控制方式，比如 reader-writer 模式。下面的例子是一个有限reader的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> readcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) </span><br><span class="line">            <span class="comment">/* 只要有一个reader在等待，就尝试获得写入锁 </span></span><br><span class="line"><span class="comment">             * 这时，如果有正在进行的写入线程获得锁，read阻塞</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Critical Section: read */</span> </span><br><span class="line"></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* 只有没有reader在等待才会释放写入锁 */</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line"></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Semaphore是并发控制的基本模块，不过一般我们也不会直接使用他们，而是使用高级一点的API，比如Mutex和Condition，或者go中的chan，不过他们基本都可以通过Semaphore实现。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>正确的并发程序运行在多核处理器机器上，Kernel会自动将不同的thread调度在不同的CPU核心，从而获得并行能力，提高计算效率。</p>
<h2 id="多线程编程的一些问题"><a href="#多线程编程的一些问题" class="headerlink" title="多线程编程的一些问题"></a>多线程编程的一些问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数，如果在多个线程并发调用的情况下仍然可以输出预期的结果，那么这个函数就是<strong>线程安全</strong>函数。我们也可以看看那些函数不是线程安全的：</p>
<ul>
<li>类型1：函数内部修改全局变量</li>
<li>类型2：函数具有自己内部状态。比如伪随机数函数</li>
<li>类型3：函数返回一个全库变量的指针</li>
<li>类型4：函数调用其他非线程安全函数</li>
</ul>
<p>类型1最简单的方法是给全局变量加锁，保证线程安全，但是锁这类同步操作也会影响函数运行性能。</p>
<p>类型2最简单的解决方案是把内部变量转换成函数输入参数，不过这样的函数需要函数的调用者负责传入正确的状态参数。</p>
<p>类型3有两种主要的处理方法。第一，重写函数让他接受一个存储结果的指针，这样就可以避免不同线程同时修改全局变量。第二，在不重写函数的情况下，可以做一个线程安全的wrapper函数，调用非安全函数的时候，加锁，并复制结果，然后作为wrapper的返回值。</p>
<p>类型4的处理类似类型3。</p>
<p>还有一类函数值得指出，就是Reentrant（可重入）函数，他是线程安全函数的子集。可重入函数内部没有私有状态，也没有同步操作（比如锁），所以他们的运行效率更高。但是这类函数可以接受指针作为输入，如果指针指向了一个共享内存，那么他们在多线程情况下可能会导致问题，但是函数本身却是线程安全的。</p>
<h3 id="Races"><a href="#Races" class="headerlink" title="Races"></a>Races</h3><p>Race，竞争，是指程序的正确依赖于特定的线程执行顺序，而这种顺序并没有在程序编写阶段加以保证。</p>
<p>比如如下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)                       </span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i); </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中，12行，启动线程时传入了局部变量i的指针，但是如果线程函数，20行，没有在12行执行后立刻执行，而是等待到了下一次12行执行，20行则会错误的接受其他线程的i值，造成竞争错误。</p>
<h3 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h3><p>Dead lock，死锁，是指在多线程执行情况下，两个或多个进程依赖同一个同步实体（比如信号量）才能继续执行，出现的互相等待导致锁死的现象。</p>
<p>死锁的检测和避免并不容易，但是有一个有用的规则可以避免大部分死锁：每一个对mutex，（s，t），每一个线程持有s和t，以相同的顺序加锁。</p>
<p>TODO: </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发编程的基本抽象其实是逻辑执行顺序，CPU在不同执行context下切换，具体实现方法包括：进程、IO复用和线程。</p>
<p>并发编程的基本同步工具是Semaphore，利用Semaphore可以构造其他并发控制结构，比如bufferd queue、互斥锁等等。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程、进程debug技巧</title>
    <url>/2021/06/16/python_debug/</url>
    <content><![CDATA[<h1 id="Python多线程、进程debug技巧"><a href="#Python多线程、进程debug技巧" class="headerlink" title="Python多线程、进程debug技巧"></a>Python多线程、进程debug技巧</h1><ul>
<li>使用 <code>py-spy</code></li>
<li>利用 <code>/proc/&#123;pid&#125;/</code> 中的信息</li>
</ul>
<p>比如查看进程环境变量: <code>cat /proc/&#123;pid&#125;/environ</code></p>
<p>查看实时进程内部线程的CPU和内存状态：<code>py-spy --nonblocking -p &#123;pid&#125;</code></p>
<p>查看线程dump：<code>py-spy dump --nonbloacking -p &#123;pid&#125;</code></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 12 并发编程 1</title>
    <url>/2021/06/15/csapp_12_1/</url>
    <content><![CDATA[<h1 id="CSAPP-12-并发编程-1"><a href="#CSAPP-12-并发编程-1" class="headerlink" title="CSAPP 12 并发编程 (1)"></a>CSAPP 12 并发编程 (1)</h1><p>一般来说，应用级别的并发主要由三种方式实现：</p>
<ul>
<li>进程</li>
<li>I/O多路复用</li>
<li>线程</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是构建并发程序最简单和直接的方式，主要是通过fork, exec, waitpid等系统函数联合实现，而进程间是通过socket两端的文件标识符进行通讯。</p>
<p>以经典的服务器-客户端模式为例，首先服务器端启动主进程（p1），unix系统默认会开放三个文件标识符，即fd0，fd1，fd2，分别对应标准输入、输出、和异常。为了接受其他进程的连接，p1开放一个新的socket标识符，listenfd。由于文件标识符通常是按照顺序取最小的一个可用数字，因此一般系统会分配标识符3给listenfd，但是这个并不重要，我们只需要知道listenfd即可。</p>
<p>在客户端进程中，通过socket连接服务端端口，获得一个客户端的文件标识符，clientfd，这个socket的另一端的是服务器端的一个新的、由accept返回的标识符，connfd，需要注意的是connfd与listenfd是不同的标识符。在服务端，主进程会通过fork得到一个新的子进程来负责与client通讯，而connfd本来是属于主进程，在fork的过程中被子进程获得，而主进程则关闭其对应的connfd，子进程关闭无用的listenfd（从主进程拷贝获得）。至此，客户端与服务端的连接由子进程完成，而主进程已经准备好下一个连接，如下图所示：</p>
<p><img data-src="https://i.imgur.com/RwdRovf.png" alt=""></p>
<p><img data-src="https://i.imgur.com/GXjP3yy.png" alt=""></p>
<p><img data-src="https://i.imgur.com/OHpPbxU.png" alt=""></p>
<p>需要注意的是，子进程结束后会变成僵尸进程，需要由主进程进行清理（reap），否则就会造成内存泄漏。回收工作是通过SIGCHLD信号量的处理函数完成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 清理所有目前看到的僵尸进程</span></span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程并发的优势很明显，即主进程和子进程不共享虚拟内存地址空间，可以有效的避免意外的内存问题。但是，另一方面，进程间共享数据变得困难，需要额外的跨进程通讯机制，这个过程开销较大。</p>
<h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><p>IO复用是进行并发的另一种方法，基本原理是通过select函数实现。select函数会阻塞程序，直到它监控的一系列标识符中的一个或者多个处于可用状态。</p>
<p><code>int select(int n, fd_set *fdset, NULL, NULL, NULL);</code></p>
<p>其中<code>fd_set</code>就是监控的文件标识符集合，Unix还提供了四个宏对集合进行控制：</p>
<ul>
<li>FD_ZERO，初始化flag为0</li>
<li>FD_CLR，清空某一个标识符</li>
<li>FD_SET，激活某一个标识符</li>
<li>FD_ISSET，查看某一个标识符是否激活</li>
</ul>
<p>我们可以通过select在同一个进程中实现一个并发echo服务器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define a pool of connected descriptors */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;  <span class="comment">// largest fd in set</span></span><br><span class="line">    fd_set read_set;  <span class="comment">// all active descriptors</span></span><br><span class="line">    fd_set ready_set;  <span class="comment">// subset of descriptors that ready to be read</span></span><br><span class="line">    <span class="keyword">int</span> nready;  <span class="comment">// number of ready descriptors from select</span></span><br><span class="line">    <span class="keyword">int</span> maxi;    <span class="comment">// highwater index into client array</span></span><br><span class="line">    <span class="keyword">int</span> clientfd[FD_SETSIZE];     <span class="comment">// set of active descriptors, default 1024</span></span><br><span class="line">    <span class="keyword">rio_t</span> clientrio[FD_SETSIZE];  <span class="comment">// set of active read buffers</span></span><br><span class="line">&#125; pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> byte_cnt = <span class="number">0</span>;  <span class="comment">// counts total bytes received by server</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">static</span> pool pool;  <span class="comment">// private variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// server loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// why get ready set and read_set</span></span><br><span class="line">        <span class="comment">// here is a re-initialization copy</span></span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) </span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);  <span class="comment">// add client into pool to be handled</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// initialized to -1 </span></span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initially, listenfd is the only fd of select read set</span></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    p-&gt;nready--; <span class="comment">// ? we didn&#x27;t initialize this ...</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// assign fd and its buffer</span></span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Turn on fd</span></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update pool status</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// find an available slot</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients. Run out of descriptor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, connfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++) &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n=Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>,</span><br><span class="line">                       n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);  <span class="comment">// echo back the received info..</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// EOF detected, remove fd from pool</span></span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>; <span class="comment">// do we need clear related io buffer?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// report pool</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pool:\n    maxfd: %d\n    nready: %d\n    maxi: %d\n&quot;</span>,</span><br><span class="line">           p-&gt;maxfd, p-&gt;nready, p-&gt;maxi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IO复用可以用作事件驱动编程模式，更好的控制不同的逻辑控制流，同时没有切换进程的开销。缺点也比较明显，首先，代码量更大，其次没有任何并行，即使CPU有多核，颇有一些Python AsyncIO 的感觉。。。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（Thread）的执行模式跟进程很像，每一个进程启动的时候，都会启动一个线程，即主线程。主线程可以设置其他线程，他们可以并发执行。线程与IO复用不同之处在于，线程的调度是Kernel自动完成的，不需要用户程序进行干预；线程与进程也不同，主线程和其他线程没有从属关系，这些线程也共享虚拟内存地址空间，包括code, data, heap, shared library以及文件！这让共享信息变得简单和高效。</p>
<p>一个简单的线程例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello thread!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，现在我们可以尝试采用线程实现并发的echo服务器了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp;  <span class="comment">// note: a pointer here..</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">        <span class="comment">// why just use connfd and &amp;connfd?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self()); <span class="comment">// let kernel to reap this thread</span></span><br><span class="line">    Free(vargp); <span class="comment">// free memory</span></span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE]; </span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, n);</span><br><span class="line">	Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序有一些很有意思的地方：</p>
<p>首先22-23行，我们使用了一个指针，而不是直接传递fd数值。这是为了避免race condition造成的bug。因为在多线程执行过程中，我们不确定22行和31行那个先执行，如果在第一个连接以后，对应的31行还没执行之前，另一个连接发生了，就会导致连个线程操作同一个fd。因此，我们通过指针和动态内存分配避免这个问题。</p>
<p>另一个值得注意的地方是，在thread的执行函数中，我们需要自己释放内存，因为vargp是指针传入，对应的内存空间是堆分配的（是吗？）而不是栈分配，因此需要手动回收，否则就会出现内存泄漏。</p>
<h2 id="多线程变量共享"><a href="#多线程变量共享" class="headerlink" title="多线程变量共享"></a>多线程变量共享</h2><p>共享变量是一个很方便，但是容易出问题的技术。要弄清一个变量是不是被共享，需要回答如下几个问题：</p>
<ul>
<li>线程的内存模型是什么样的？</li>
<li>在上述模型中，变量实例是如何被映射到内存的？</li>
<li>有多少线程引用了这个变量实例？</li>
</ul>
<p>我们说一个变量是共享变量意味着：这个变量的内存实例被多个线程引用。</p>
<p>（什么是变量的实例？）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **ptr;  <span class="comment">/* Global variable */</span> <span class="comment">//line:conc:sharing:ptrdec</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *msgs[N] = &#123;</span><br><span class="line">        <span class="string">&quot;Hello from foo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hello from bar&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = (<span class="keyword">int</span>)vargp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">// static make a static memory allocation in 1 adress.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)]\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ .&#x2F;share                                                </span><br><span class="line">[0]: Hello from foo (cnt&#x3D;1)]</span><br><span class="line">[1]: Hello from bar (cnt&#x3D;2)]</span><br></pre></td></tr></table></figure>
<p>注意到其中 cnt 被不同的线程共享。更有意思的是，主线程的ptr也被共享了。下面我们深入看看线程的内存模型，以便可以理解上述现象。</p>
<h3 id="线程的内存模型"><a href="#线程的内存模型" class="headerlink" title="线程的内存模型"></a>线程的内存模型</h3><p>由于线程是在进程的context运行的，每个线程共享进程的一部分内存，包括：read-only text (code), data, heap, shared libraries code，files。另一方面，线程具有独立的：id, stack, stack point, program counter, condition code, register values。</p>
<p>如此我们就可以理解上面为什么不同线程可以访问ptr了，因为全局变量位于内存的data部分，可以被线程共享。</p>
<p>逐一分析下列变量的引用情况：</p>
<table>
<thead>
<tr>
<th>Variable Instance</th>
<th>Ref. main</th>
<th>Ref. t0</th>
<th>Ref. t1</th>
</tr>
</thead>
<tbody><tr>
<td>myid.p1</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>myid.p0</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>msgs.m</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>i.m</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>cnt</td>
<td><strong>Y</strong> (NP!)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>ptr</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 11 网络编程</title>
    <url>/2021/06/06/csapp_11/</url>
    <content><![CDATA[<h1 id="CSAPP-11-网络编程"><a href="#CSAPP-11-网络编程" class="headerlink" title="CSAPP 11 网络编程"></a>CSAPP 11 网络编程</h1><p>网络编程基于之前看到的一些基本概念和抽象：进程、信号、内存映射、内存动态分配。</p>
<p>几乎所有的网络应用程序都基于服务器-客户端模式，即几个或者多个服务度进程和一个或者多个客户端进程，这些进程可以在同一个机器上，也可以分布在其他被网络连接的机器上。</p>
<p>计算机网络包含众多不同类型的机器，这些机器和设备是通过一些列“协议”进行交流的，每一个协议都包含两个基本部分：命名规则和传输规则。</p>
<p><strong>TCP/IP协议</strong></p>
<p>IP协议提供了基本的命名规则和传输规则，但是IP传输过程中会出现破损的包或者重复的包（packet），被称为<code>datagram</code>，而TCP协议则是建立在IP协议的基础上，提供可靠的双向通讯。UDP协议也是IP协议基础上的一个支持进程和进程通讯的协议。</p>
<p>在程序员的视角中，Internet可以认为是一个集合了多个主机的网络，这个网络具有如下属性：</p>
<ul>
<li>主机地址都是32位IP地址（IPv6协议是128位地址）</li>
<li>IP地址可以被映射成域名（domain names）</li>
<li>不同主机的进程可以通过Connection通讯</li>
</ul>
<p><strong>socket</strong></p>
<p>Socket是Connection的一端，每一个socket都有一个地址和一个端口。不过通常客户端的端口是有kernel自动指定的，而服务端口则是通常是程序指定的。一般unix类机器可以在<code>/etc/services</code>目录下找到各种服务。</p>
<p>所以一个Connection可以被一对独特的socket（地址和端口）识别出来。</p>
<h2 id="Sockets-Interface"><a href="#Sockets-Interface" class="headerlink" title="Sockets Interface"></a>Sockets Interface</h2><p>在系统内核的角度，socket是一个Connection的一端，而在程序的角度，socket是一个文件标识符（IO的File）。</p>
<ul>
<li><code>int socket(int domain, int type, int protocal)</code></li>
<li><code>int connect(int sockfd, struct sockaddr *serv_addr, int addlen)</code></li>
<li><code>int bind(int sockfd, struct sockaddr *my_addr, int addrlen)</code></li>
<li><code>int listen(int sockfd, int backlog)</code></li>
<li><code>int accept(int listenfd, struct sockaddr *addr, int *addrlen)</code></li>
</ul>
<h2 id="Web-Servers"><a href="#Web-Servers" class="headerlink" title="Web Servers"></a>Web Servers</h2><p><strong>CGI,Common Gateway Interface</strong></p>
<p>TODO: TINY server!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Socket是网络通讯的核心抽象，而socket在用户程序看来就是一个文件标识符。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 10 系统IO</title>
    <url>/2021/06/05/csapp_10/</url>
    <content><![CDATA[<h1 id="CSAPP-10-系统IO"><a href="#CSAPP-10-系统IO" class="headerlink" title="CSAPP 10 系统IO"></a>CSAPP 10 系统IO</h1><p>Unix系统中的IO，即Input和Output是指从“文件”读入数据到内存和从内存输出数据到“文件”。“文件”是Unix的一个抽象，即一串字节。在概念上所有IO设备都可以抽象成文件，比如网络、硬盘、各种外设等等。这样系统就可以统一接口来操作外设。</p>
<p>Unix系统提供了四个基本的IO API：</p>
<ul>
<li><code>int open(char *filename, int flags, mode_t mode)</code></li>
<li><code>int close(int fd)</code></li>
<li><code>ssize_t read(int fd, void *buf, size_t n)</code></li>
<li><code>ssize_t write(int fd, void *buf, size_t n)</code></li>
</ul>
<p>其实这四个api的道理非常简单，<code>open</code>会返回一个文件标识符，就是打开了一个内存和文件的通道，<code>read</code>就是把文件标识符指向的文件中的字节输入到buf指向的内存空间，而<code>write</code>刚好相反，把buf指向的内存空间的字节输入到文件中。</p>
<h2 id="RIO库"><a href="#RIO库" class="headerlink" title="RIO库"></a><code>RIO</code>库</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file rio.c</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2021-06-05</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2021</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Robustly read n bytes (unbufferred)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf; <span class="comment">// create a new point to manipulate user buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// something wrong branch</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// errno will get updated by the kernel</span></span><br><span class="line">                <span class="comment">// get interrupted, reset readn to read again later</span></span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if it is other reason failure, return -1 for failure</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Robustly write n bytes (unbuffered)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n-nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Associate a file descriptor with a read buffer and reset buffer </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t , -1 for failed, 0 for EOF, positive bytes of read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if buffer empty, refill buffer with read */</span></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * read failed, handle interrupt case only</span></span><br><span class="line"><span class="comment">             * if interrupted, do nothing go to next loop</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf;  <span class="comment">// reset buffer pointer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy min(n, rp-&gt;rio_cnt) bytes from internal buffer to user buffer</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -=cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readnb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rio_read handle interrupt and other -1 cases</span></span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft) &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// EOF</span></span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief read a text line ( buffered )</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param tp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param maxlen </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readlineb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)  <span class="comment">// EOF</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// no data read yet</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;   <span class="comment">// some data read already</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;  <span class="comment">// append &#x27;\0&#x27; at the end of char buffer</span></span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>Unix系统的文件标识符主要由三种数据结构维护：</p>
<ul>
<li>Descriptor table（DT）：每个进程有单独的标识符表</li>
<li>File table（FT）：多个进程共享</li>
<li>v-node table（VT）：多个进程共享</li>
</ul>
<p>这三种结构分别包含一个指针：DT -&gt; FT -&gt; VT。</p>
<p><img data-src="https://i.imgur.com/2jUJ9Lx.png" alt=""></p>
<p>值得注意的是，fork后的父进程和子进程由于共享文件标识符，所以两个进程打开的文件共享file table entry（FTE），因此两个进程共享该文件的读取位置。而同一个进程通过两个<code>open</code>打开同一个文件获得两个标识符，不共享file table entry，因此两个文件标识符的读取和写入是独立的。</p>
<h2 id="IO重新定向"><a href="#IO重新定向" class="headerlink" title="IO重新定向"></a>IO重新定向</h2><p>IO重新定向的秘密在于系统函数：<code>dup2</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup2会把oldfd对应的FTE拷贝到newfd，这样newfd和oldfd都会指向之前的FTE，而newfd如果已经对应了某个FTE，kernel会减少一个引用，如果引用归零，kernel会删除该FTE。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 9 虚拟内存</title>
    <url>/2021/06/03/csapp_9/</url>
    <content><![CDATA[<h1 id="CSAPP-9：虚拟内存"><a href="#CSAPP-9：虚拟内存" class="headerlink" title="CSAPP 9：虚拟内存"></a>CSAPP 9：虚拟内存</h1><p>虚拟内存的三个重要功能：</p>
<ul>
<li>将物理内存作为一种缓存，缓存硬盘上的一个私有内存地址空间</li>
<li>让每一个进程拥有独立的内存地址空间</li>
<li>确保进程之间的内存不会互相影响</li>
</ul>
<p>理解虚拟内存的关键在于意识到：一个数据对象（字节）可以有多个属性（地址）。话句话说，一个内存对象可以有两个地址，一个物理地址，一个虚拟内存地址。</p>
<h2 id="虚拟内存：缓存"><a href="#虚拟内存：缓存" class="headerlink" title="虚拟内存：缓存"></a>虚拟内存：缓存</h2><p>概念上，虚拟内存是硬盘上一串连续的字节空间。一般会规定 m 个字节为一个分页，分页只有三种状态：</p>
<ul>
<li>未分配</li>
<li>缓存</li>
<li>未缓存</li>
</ul>
<h2 id="Linux中的虚拟内存"><a href="#Linux中的虚拟内存" class="headerlink" title="Linux中的虚拟内存"></a>Linux中的虚拟内存</h2><p>Linux Kernel 通常把进程的虚拟内存空间用一系列的 Segment (Area) 表达。Kernel会管理这些segment，进程也只能引用segment指向的内存空间。</p>
<p><img data-src="https://i.imgur.com/ks7WKIw.png" alt=""></p>
<p><strong>demand paging</strong>：只有在需要的时候，硬盘上内容才会被读入物理内存。</p>
<p><strong>copy-on-write</strong>：共享的可写内容，只有在需要写入的时候，才会只做副本。</p>
<p>Linux初始化虚拟内存空间是通过Memory Mapping进行的，kernel会把硬盘上某个文件的内容与该内存空间联系起来。一旦虚拟内存<strong>分页</strong>初始化结束，kernel会在内存和一个特殊的 swap 文件中进行 paging 操作。</p>
<p><strong>Practical Problem 9.5</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapcopy</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bufp;</span><br><span class="line">    <span class="comment">// mmap will ask the kernel to link a VM area with given fd.</span></span><br><span class="line">    bufp = Mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Here we are writing from VM to std 1 </span></span><br><span class="line">    Write(<span class="number">1</span>, bufp, size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use: mapcopy &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = Open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    fstat(fd, &amp;stat);</span><br><span class="line">    mapcopy(fd, stat.st_size);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memory-Allocator"><a href="#Memory-Allocator" class="headerlink" title="Memory Allocator"></a>Memory Allocator</h2><p>未完待续</p>
<h2 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h2><p>未完待续</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>信息爆炸，炸毁了我</title>
    <url>/2021/05/30/admin2/</url>
    <content><![CDATA[<h2 id="信息爆炸，炸毁了我"><a href="#信息爆炸，炸毁了我" class="headerlink" title="信息爆炸，炸毁了我"></a>信息爆炸，炸毁了我</h2><p>最近发现了一个现象，我似乎没有办法坚持做一件事情很长时间了，而且这个“很长时间”变得原来越短了！</p>
<p>上一次我自发的坚持一件事情很长时间应该是考研。那已经是10年前的事情了，那时候我坚持每天去自习室学习超过6小时，持续了将近9个月时间，几乎没有间断过。再上一次可能是高考，算是坚持了三年学习，但那已经是13年前的事情了。</p>
<p>读博士以后，我集中精力做一件事情的能力就慢慢变弱了，那是大概6年前。比如做实验加写论文有时候可以到3个月左右。参加工作后，业余时间我还是想多学点东西或者做一些工作之外的事情，但是我渐渐发现我很难坚持了！开始的时候仅仅是不能坚持学完一门公开课（大概需要3个月左右），后面变成不能完整的阅读一本书（大概1个月左右），目前已经慢慢出现不能完整地读完一篇论文了（大概需要几天到1周时间）。更可怕的，我甚至难以完整的阅读一篇报道或者博客了（十几分钟到几小时），经常是读了一半就是去兴趣或者被其他信息拉走了。比如，我会在上网阅读书籍的时候，不定期的打开知乎、youtube、股票报价、微信等等，浏览一些信息，甚至有时候我会完全无目地滑动网页、切换窗口等等，然后回到我刚才在做的事情上，如此循环。到头来往往是时间过去了，什么都没得到。</p>
<p>短短十几年时间，我坚持做一件事情的能力从3年下降到了30分钟，甚至3分钟。(比如，你可以坚持读完这篇博客吗？)</p>
<p>我发现的一些现象：</p>
<ul>
<li>在做一件事情过程中，不定时、无意识的打开其他网站开始浏览。比如知乎、领英、视频、股票报价、微信等等。</li>
<li>很少能完成一个系列性的事情，比如关于某个主题的多篇博客</li>
<li>很少能保证质量的完成一个公开课（作业），经常是只完成了前几个</li>
<li>经常搜集各种学习网站资料等等，但是每一个都只是展开一点点，然后就会被新的东西吸引而停止已有的学习</li>
<li>经常被新的问题吸引，而停止解决就的问题，然后旧的问题被永远忘记</li>
<li>很容易被打断，即使发生的事情并没有非常重要，仍然被轻易打断</li>
<li>无法完成“大”一点的项目</li>
<li>经常是微信或者其他手机通知一出现，立刻中断手头的事情</li>
<li>长期如此的状态让我充满挫败感，挫败感让上面的问题更加严重了</li>
</ul>
<h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>其实发现这些问题，我想过并做过一些措施来避免，比如</p>
<ul>
<li>告诉自己不要分心，集中注意力</li>
<li>强迫自己不要打开无关的网站</li>
<li>写博客，强迫自己关注手头的东西</li>
<li>隐藏浏览器的书签栏，防止自己无目的的打开其他网站</li>
</ul>
<p>但是仍然没有改变现状，过去的很长时间里，我还是没有办法做更“大”事情，最多就是写了一些“粗制滥造”的博客（比如这一篇哈哈）。我甚至没有办法构思和写出关于某个主题的一系列日志，常常是半途而废。</p>
<h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>因此，我决定对这个问题进行进一步的思考。首先是确定问题。现在问题的症状是：不能长期坚持做一件事情，这个长期甚至是1小时。<br>那么，问题本身到底是什么呢？我写下我的思考过程：</p>
<h3 id="简单的“快乐”"><a href="#简单的“快乐”" class="headerlink" title="简单的“快乐”"></a>简单的“快乐”</h3><p>首先我想到的是，这可能是现有主体（一个）和新的主体（多个）之间的矛盾。我会轻易被新的主体吸引，而放弃现有的主体，所以才会出现不能坚持做一件事情的问题。</p>
<p>但是为什么我会轻易的放弃现有的主体呢？我想到两个原因：</p>
<ul>
<li>坚持现有主体更困难。因为更加深入学习，而深入学习往往意味着需要更多脑力，更加困难</li>
<li>转向新的主体更轻松。因为任何一个事情刚开始读到的内容或者练习都是相对简单的</li>
<li>坚持现有主题缺乏新鲜感，而新主题充满新鲜感</li>
</ul>
<p>这比较显然，一个“无趣”又困难，一个“新鲜”又简单，大脑自然而然的选择了简单的东西。</p>
<blockquote>
<p>假设1：大脑更愿意尝试<strong>简单且新鲜</strong>的活动。</p>
</blockquote>
<p>这个假设看起来是对的，确实符合观察到的现象。但是，为什么会这样？我想到了“贪心算法”。</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>所谓贪心算法就是在解决问题的时候采用的一种策略，即选择局部最优解。</p>
<blockquote>
<p>假设2：大脑（人）倾向正向的反馈，比如满足感、成就感。</p>
</blockquote>
<p>提出上面的假设，当大脑（我）处理问题的时候是为了最终获得正向反馈，比如满足感、成就感等等。</p>
<blockquote>
<p>假设3：大脑（人）倾向采用贪心算法获得正向反馈。</p>
</blockquote>
<p>这个假设可以解释为什么我选择新的东西，因为新的主体会在更短时间内、用最少的努力，换来正相反馈。</p>
<p>我举个例子，比如我在正在写博客，已经过去一段时间了，我仍然没有获得任何满足感，因为还没写完或者遇到了困难，这时候我会想打开知乎看看是不是有新的点赞或者关注，如果有会产生短期的满足感；在比如我正在写关于量子计算的作业遇到了困难，已经两天了也没啥进展，我会打开youtube观看一些量子计算的介绍性视频，因为我能听懂他们，看起来我也获得了“更多”知识，产生了短期的满足感；在比如我在学习分布式计算的公开课，听了两次了，感觉有点无聊，我会搜索另一门类似的课程，然后打开相关的视频或者课件查看，因为是新的，且比较入门的部分，我可以看懂，看起来我也获得了“更多”知识。</p>
<p>如此，我们可以归纳假设1-3：</p>
<blockquote>
<p><strong>公理：大脑（人）倾向采用贪心算法获得正向反馈。</strong></p>
</blockquote>
<p>我认为这是导致无法长期坚持的主要原因，因为贪心算法不会尝试远期最优解。大脑总是希望获得短期的正相反馈。</p>
<p>即便如此，长期坚持所获的正向反馈比短期反馈更加强大，持久，且有意义。举个弹吉他的例子，刚开始学习的几周时间往往是痛苦的，不过很快你就能弹几个曲子了，很开心！再往后事情变得不太顺利了，有几首曲子总是弹不出。这时你的大脑会希望放弃弹吉他，尝试其他的东西，比如箱鼓看起来不错！你开始学了几次，哈哈，确实很好玩儿！不过很快他就变得像弹吉他一样。如此循环。</p>
<p>进一步引申，贪心算法的另一个体现就是停留在舒适圈。</p>
<h3 id="价值认知"><a href="#价值认知" class="headerlink" title="价值认知"></a>价值认知</h3><p>继续思考，贪心算法可能不是问题的全部。我发现还有一个潜在的问题，导致我们放弃目前的主题，就是对当前主题的价值认同度降低。<br>比如我在学习一门新的课程的初期会认为内容很有意义、很重要。但是随着深入，这种认同会逐渐降低，这可能跟自己无法全面认识该课程的内容有关系，特别是在一半的时候。<br>由于自发的学习没有强迫的考试和作业来增加这种价值认知，自发的价值认知很快消退了。加上“贪心算法”，我很快就会决定放弃当前主题。</p>
<h3 id="“一心一意”"><a href="#“一心一意”" class="headerlink" title="“一心一意”"></a>“一心一意”</h3><p>继续思考，我发现最后一个原因是：不能一心一意的同一时间只想做一件事情！这种倾向很可能跟贪心算法有关系，大脑希望在同一时间获得更多的正反馈。如何获得？最简单的办法，同时开始很多“简单”的事情。</p>
<h3 id="懒惰的大脑"><a href="#懒惰的大脑" class="headerlink" title="懒惰的大脑"></a>懒惰的大脑</h3><p>我发现大脑比较懒惰，他更喜欢做自己会做的，或者短期内容易理解和学习的事情。因此大脑产生的懒惰情绪也会导致不能长期坚持。</p>
<h2 id="为什么十年前没有这些问题？"><a href="#为什么十年前没有这些问题？" class="headerlink" title="为什么十年前没有这些问题？"></a>为什么十年前没有这些问题？</h2><blockquote>
<p>公理：大脑（人）倾向采用贪心算法获得正向反馈，而贪心算法带来的往往只能是“简单的快乐”。</p>
</blockquote>
<p>由上面的公理推论：</p>
<ul>
<li>价值认同度降低</li>
<li>不能一心一意的同一时间只想做一件事情</li>
</ul>
<p>那我不禁要问：为什么十年前我没有这个问题？其实，我不觉得我的大脑变了，变化的是周围的环境。</p>
<blockquote>
<p>十年前，信息还没有爆炸。</p>
</blockquote>
<p>十年前，我获取信息和资源的难度比现在大得多。比如我很难获得很多线上的公开课，想要学习新的知识和技能，我必须参加学校设置的、有限的几门课。而且我需要按照学校的计划完成它。虽然我的大脑仍然是“贪婪”的，但是我并没有很多选择。因此，我只能“专注”更长的时间，才能获得正反馈。</p>
<p>十年前，我接触到各种信息的渠道也有限，被分心的可能性也比较低。我还没开始玩知乎、炒股票，我不需要看赞、看股票收益，我获得正反馈的途径非常有限。</p>
<h2 id="再一次的尝试"><a href="#再一次的尝试" class="headerlink" title="再一次的尝试"></a>再一次的尝试</h2><p>所以，整件事情的原因我归纳为：</p>
<blockquote>
<p>信息爆炸的背景下，我大脑的“贪心算法”导致了不能长期有计划地做一件事情。</p>
</blockquote>
<p>因此，解决方案从两方面入手</p>
<ul>
<li>信息爆炸</li>
<li>贪心算法</li>
</ul>
<p>具体方案：</p>
<ul>
<li>减少一段时间的信息摄入量<ul>
<li>如果没有任何目的，不打开知乎、股票等信息</li>
<li>定时查看信息，而不是实时响应信息</li>
<li>不要因为临时看到的一个信息改变计划</li>
</ul>
</li>
<li>制定计划，并无条件执行</li>
<li>一次只做一件事情，并做完</li>
<li>暗示自己长期获得正反馈更加有效，避免短期正反馈<ul>
<li>暗示自己不要从社交媒体中获得正反馈</li>
</ul>
</li>
<li>刻意练习，突破懒惰的舒适圈</li>
</ul>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
  </entry>
  <entry>
    <title>量子计算索引</title>
    <url>/2021/05/23/qc_index/</url>
    <content><![CDATA[<h1 id="量子计算索引"><a href="#量子计算索引" class="headerlink" title="量子计算索引"></a>量子计算索引</h1><h2 id="公开课程"><a href="#公开课程" class="headerlink" title="公开课程"></a>公开课程</h2><ul>
<li><a href="http://theory.caltech.edu/~preskill/ph219/ph219_2020-21.html">Ph219/CS219 Quantum Computation (加州理工)</a> by John Preskill (with <a href="https://www.youtube.com/channel/UCeq4xfwNE6eDK3k1vTfZK8g/playlists">video</a> on Youtube)</li>
<li><a href="https://cs269q.stanford.edu/index.html">CS269Q Quantum Computer Programming (斯坦福)</a> by Dan Boneh</li>
<li><a href="http://www.lassp.cornell.edu/mermin/qcomp/CS483.html">Phys481-681-CS483, Quantum Computation (康奈尔)</a> by David Mermin</li>
<li><a href="https://www.scottaaronson.com/democritus/">PHYS771 Quantum Computing Since Democritus (University of Waterloo)</a> by Scott Aaronson</li>
<li><a href="https://qiskit.org/learn/intro-qc-qh/">Introduction to Quantum Computing and Quantum Hardware</a> by IBM (with <a href="https://www.youtube.com/watch?v=Rs2TzarBX5I&list=PLOFEBzvs-VvrXTMy5Y2IqmSaUjfnhvBHR">video</a> on Youtube)</li>
<li><a href="https://csferrie.medium.com/introduction-to-quantum-computing-df9e1182a831">Introduction to Quantum Computing</a> by Chris Ferrie</li>
<li><a href="https://web.mit.edu/8.371/www/index.html">6.443/8.371/18.436 Quantum Information Science</a></li>
<li><a href="https://learning.edx.org/course/course-v1:MITx+8.371.1x+2T2018/home">Quantum Information Science II, Part 1 - Quantum states, noise and error correction</a></li>
</ul>
<p><strong>其他人整理的资源</strong></p>
<ul>
<li><a href="https://www.cs.umd.edu/~xwu/mini_lib.html">Mini-Library on Quantum Information and Computation</a></li>
<li><a href="https://www.amarchenkova.com/posts/best-quantum-computing-courses-online">Best-quantum-computing-courses-online</a></li>
</ul>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p><strong>硬件公司</strong></p>
<ul>
<li><a href="https://quantum-computing.ibm.com/">IBM Quantum</a></li>
<li><a href="https://www.dwavesys.com/">D-Wave</a></li>
<li><a href="https://www.rigetti.com/">Rigetti</a></li>
<li><a href="https://ionq.com/">IonQ</a></li>
<li><a href="https://quantumai.google/">Google Quantum</a></li>
<li><a href="https://www.honeywell.com/us/en/company/quantum">Honeywell</a></li>
</ul>
<p><strong>软件、研究公司</strong></p>
<ul>
<li><a href="https://cambridgequantum.com/">Cambridge Qauntum Computing (CQC)</a></li>
<li><a href="https://pennylane.ai/">Pennylane</a></li>
<li><a href="https://qcware.com/">QC Ware</a></li>
<li><a href="https://www.xanadu.ai/">Xanadu</a></li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><a href="https://github.com/manjunath5496/Quantum-Computing-Books">量子计算书单</a></p>
<h2 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h2><p><a href="https://github.com/qosf/awesome-quantum-software">量子计算开源软件</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://algassert.com/quirk">Quirk, 量子电路模拟器</a></li>
<li><a href="https://javafxpert.github.io/grok-bloch/">Bloch Sphare 模拟器</a></li>
</ul>
]]></content>
      <categories>
        <category>Quantum Computing</category>
      </categories>
      <tags>
        <tag>Qauntum Computing</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 8 异常控制流</title>
    <url>/2021/05/21/csapp_8/</url>
    <content><![CDATA[<h1 id="CSAPP-8-异常控制流（ECF）"><a href="#CSAPP-8-异常控制流（ECF）" class="headerlink" title="CSAPP 8 异常控制流（ECF）"></a>CSAPP 8 异常控制流（ECF）</h1><p>异常控制流，Exception Control Flow，是操作系统实现IO、进程、虚拟内存、并发等等功能的的重要基础工具。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>这里提到的异常不是通常意义的异常，而是分成四类：Interrupt, faults, aborts, and trap.</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>异常机制是操作系统提供下一个重要抽象，进程，的基石。</p>
<blockquote>
<p>进程就是一个正在执行的程序实例</p>
</blockquote>
<p>每一个进程都包含了程序运行的全部上下文（context），这个context包含：程序代码、数据、栈、寄存器状态、程序指针、环境变量、打开的文件标识符等等。</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p><strong>并发</strong></p>
<p>两个任务A和B，如果我们说AB是并发执行的，等价于说：A在B开始后，B结束前，开始；或者反过来B在A开始后，A结束前，开始。</p>
<p><em>Problem 8.1</em></p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Start</th>
<th>End</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>C</td>
<td>3</td>
<td>5</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A: - -</span><br><span class="line">B:   - - -</span><br><span class="line">C:     - - -</span><br></pre></td></tr></table></figure>

<p>从上面的图可以看出，AB，BC分别是并发的，而AC则不是。</p>
<p><strong>User and Kernel Mode</strong></p>
<p>Linux系统通过CPU上的一个特殊的寄存器来识别那些进程是系统进程，哪些是用户进程。系统进程可以执行一些高权限的指令。</p>
<p><strong>Contex Switch</strong></p>
<p>值得注意的是，系统缓存通常跟ECF相关的操作相互冲突。换句话说，ECF相关的活动，比如异常或者切换上下文，都会造成缓存污染。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>API：</p>
<ul>
<li><code>int getpid(void)</code></li>
<li><code>int getppid(void)</code></li>
<li><code>pid_t fork(void)</code></li>
<li><code>waitpid</code></li>
<li><code>execve</code></li>
</ul>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h3><p><code>fork</code>会产生一个内存内容跟父进程一样的子进程，镜像的内容包括：text, data, bss segments, heap, user stack以及父进程的拥有的所有文件标识符（file discriptors)。</p>
<p><strong>Practice Problem 8.2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;printf1: x=%d\n&quot;</span>, ++x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf2: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf2: x&#x3D;0   # From parent</span><br><span class="line">printf1: x&#x3D;2   # From child </span><br><span class="line">printf2: x&#x3D;1   # From child </span><br></pre></td></tr></table></figure>

<p><strong>zombie</strong></p>
<p>当子进程结束时，kernel不会立刻移除该子进程，而是将它的状态改成 <code>terminated</code>，等待父进程 reap 它。一旦父进程收割了终止的子进程，kernel会把子进程的退出状态传递给父进程，然后从系统中移除该子进程。暂时还未被移除的子进程就叫做僵尸进程。</p>
<p>如果父进程在收割子进程前以外终结了，kernel会使用<code>init</code>进程终结僵尸进程。init 进程的 Pid 为 1，是kernel启动的第一个进程。（这个进程会终结吗？他是干啥的？）</p>
<p>收割子进程是通过 <code>pid_t waitpid</code> 系统函数实现的，该函数会挂起调用进程（option=1），直到子进程被收割。这个函数还有一些其它选项，可以调整行为。</p>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a><code>waitpid</code></h3><p><strong>Practice Problem</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Only child process goes here.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// pid = -1 means wait set consists all child processes</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<code>acbc</code>。</p>
<p><strong>Practice Problem 8.4</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !pid);  <span class="comment">// make it 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// only parent process goes here</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, WEXITSTATUS(pid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            | - parent -&gt; 0 -&gt; 2 -&gt; Bye</span><br><span class="line">&quot;Hell0&quot; -&gt;  |</span><br><span class="line">            | - child  -&gt; 1 -&gt; Bye</span><br></pre></td></tr></table></figure>

<p><strong>Practice Problem 8.5</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">snooze</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rc = sleep(secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %u of %u secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    snooze(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a><code>execve</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"><span class="comment">// Dose NOT return if OK, else return -1 on error.</span></span><br></pre></td></tr></table></figure>

<p>与 fork 不同（调用一次，返回两次），execve 调用后不返回。在execve将目标文件的程序读入内存，就会为它分配栈，并把执行权限交给该目标程序。</p>
<p><img data-src="https://i.imgur.com/oK74LQj.png" alt="新的目标程序的内存配置"></p>
<p><strong>Practice Problem 8.6</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix&gt; .&#x2F;myecho arg1 arg2 </span><br><span class="line">Command line arguments:</span><br><span class="line">    argv[ 0]: myecho</span><br><span class="line">    argv[ 1]: arg1</span><br><span class="line">    argv[ 2]: arg2</span><br><span class="line">Environment variables:</span><br><span class="line">    envp[ 0]: PWD&#x3D;&#x2F;usr0&#x2F;droh&#x2F;ics&#x2F;code&#x2F;ecf</span><br><span class="line">    envp[ 1]: TERM&#x3D;emacs</span><br><span class="line">...</span><br><span class="line">    envp[25]: USER&#x3D;droh</span><br><span class="line">    envp[26]: SHELL&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;tcsh</span><br><span class="line">    envp[27]: HOME&#x3D;&#x2F;usr0&#x2F;droh</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line arguments: \n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    argv[%2d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Environment variables: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; envp[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    envp[%2d]: %s\n&quot;</span>, i, envp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fork-execve"><a href="#fork-execve" class="headerlink" title="fork + execve"></a><code>fork</code> + <code>execve</code></h3><p>= shell ….</p>
<p><code>waitpid</code>可以用于shell执行阻塞任务。</p>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal是一种另个进程或者kernel中断另一个进程的方式。通常signal是有kernel发送给用户进程的，比如，如果一个进程尝试0除法，内核会发送<code>SIGFPE (8)</code>信号给该进程，而该信号的默认行为是终结进程并且dump core。</p>
<p>什么是发送信号？Sending a Signal。Kernel发送signal给某个进程，意味着更新该进程的context中的某些状态。有两种情况Kernel会发送Signal给进程：</p>
<ul>
<li>发现了一些系统事件，比如0除、分页错误、子进程终结等等</li>
<li><code>kill</code>程序</li>
</ul>
<p>什么是接受信号？进程收到信号后会进行相应的处理，比如忽略、结束、或者捕捉信号（Signal handling）。</p>
<p>Signal在还没有被接受的情况下，叫做Pending Signal，挂起信号。一个进程，最多只能有一个同类型的挂起信号。</p>
<h3 id="Send-Signal"><a href="#Send-Signal" class="headerlink" title="Send Signal"></a>Send Signal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> beeps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BEEP\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++beeps &lt; <span class="number">5</span>) </span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, handler);</span><br><span class="line">    alarm(<span class="number">1</span>);  <span class="comment">// arange kernel to send alarm to this process </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// signal hander will return to here, which is the next instruction</span></span><br><span class="line">        <span class="comment">// after the interupt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Never reach here. Because program exit in the handler...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-Signal"><a href="#Receive-Signal" class="headerlink" title="Receive Signal"></a>Receive Signal</h3><p>进程可以选择修改Signal的默认行为，除了SIGSTOP and SIGKILL。</p>
<p><strong>Pratical Problem 8.7</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">snooze</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rc = sleep(secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %u of %u secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;secs&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR)</span><br><span class="line">        <span class="comment">// install a hander for SIGINT</span></span><br><span class="line">        <span class="comment">// once catched, program return to the next instruction</span></span><br><span class="line">        <span class="comment">// which is printf in this case</span></span><br><span class="line">        unix_error(<span class="string">&quot;signal error\n&quot;</span>);</span><br><span class="line">    (<span class="keyword">void</span>)snooze(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Signal-Handling-Issues"><a href="#Signal-Handling-Issues" class="headerlink" title="Signal Handling Issues"></a>Signal Handling Issues</h3><blockquote>
<p>signals can block, but only 1 signal will be queued, following signal is discarded.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler2</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid=waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child %d\n&quot;</span>, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler2) == SIG_ERR)</span><br><span class="line">        unix_error(<span class="string">&quot;signal error.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        pid = Fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">            Sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> ( errno != EINTR )</span><br><span class="line">            unix_error(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该格外注意signal和他们的handler之间的并发问题，fork会让问题变得更加困难。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 10的新特性</title>
    <url>/2021/05/15/python310/</url>
    <content><![CDATA[<h1 id="Python3-10的新特性！"><a href="#Python3-10的新特性！" class="headerlink" title="Python3.10的新特性！"></a>Python3.10的新特性！</h1><p>新版本的Python 3.10主要有三个大变化：</p>
<ul>
<li>增加模式匹配</li>
<li>更好的错误提示</li>
<li>更好的类型检查</li>
</ul>
<h2 id="结构化模式匹配"><a href="#结构化模式匹配" class="headerlink" title="结构化模式匹配"></a>结构化模式匹配</h2><p>模式匹配主要通过<code>mathc</code>和<code>case</code>关键字，具有如下实现方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match subject:</span><br><span class="line">    case &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    case &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    case &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    case _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure>

<p>模式匹配大大增加了控制流的清晰度和表达能力:</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">command = <span class="built_in">input</span>()</span><br><span class="line">match command.split():</span><br><span class="line">    case [<span class="string">&quot;quit&quot;</span>]:</span><br><span class="line">        quit()</span><br><span class="line">    case [<span class="string">&quot;load&quot;</span>, filename]:</span><br><span class="line">        load_from(filename)</span><br><span class="line">    case [<span class="string">&quot;save&quot;</span>, filename]:</span><br><span class="line">        save_to(filename)</span><br><span class="line">    case _:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;Command &#x27;<span class="subst">&#123;command&#125;</span>&#x27; not understood&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以匹配类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">match media_object:</span><br><span class="line">    case Image(<span class="built_in">type</span>=media_type):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;Image of type <span class="subst">&#123;media_type&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>还可以配合守卫使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">match point:</span><br><span class="line">    case Point(x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The point is located on the diagonal Y=X at <span class="subst">&#123;x&#125;</span>.&quot;</span>)</span><br><span class="line">    case Point(x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Point is not on the diagonal.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="更好的错误提示"><a href="#更好的错误提示" class="headerlink" title="更好的错误提示"></a>更好的错误提示</h2><p>Python3.9采用了新的Parser，这给3.10更加人性的错误提示奠定了基础。</p>
<p>比如在3.8，如下代码的错误提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;Hello&quot;</span><br><span class="line">print (&quot;What&#39;s going on?&quot;)</span><br><span class="line"></span><br><span class="line">  File &quot;.\test.py&quot;, line 2</span><br><span class="line">    print (&quot;What&#39;s going on?&quot;)</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>而在3.10中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  File &quot;.\test.py&quot;, line 1</span><br><span class="line">    print (&quot;Hello&quot;</span><br><span class="line">          ^</span><br><span class="line">SyntaxError: &#39;(&#39; was never closed</span><br></pre></td></tr></table></figure>

<p>在比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;x,y for x,y in range(100)&#125;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    &#123;x,y for x,y in range(100)&#125;</span><br><span class="line">     ^</span><br><span class="line">SyntaxError: did you forget parentheses around the comprehension target?</span><br></pre></td></tr></table></figure>

<h2 id="更好的类型检查支持"><a href="#更好的类型检查支持" class="headerlink" title="更好的类型检查支持"></a>更好的类型检查支持</h2><p>增加了ParamSpec和TypeVar，可以让函数的类型检查再有装饰器的情况下正常工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Awaitable, <span class="type">Callable</span>, ParamSpec, TypeVar</span><br><span class="line"></span><br><span class="line">P = ParamSpec(<span class="string">&quot;P&quot;</span>)</span><br><span class="line">R = TypeVar(<span class="string">&quot;R&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_logging</span>(<span class="params">f: <span class="type">Callable</span>[P, R]</span>) -&gt; <span class="type">Callable</span>[P, Awaitable[R]]:</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args: P.args, **kwargs: P.kwargs</span>) -&gt; R:</span></span><br><span class="line">    <span class="keyword">await</span> log_to_database()</span><br><span class="line">    <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@add_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takes_int_str</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> takes_int_str(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>) <span class="comment"># Accepted</span></span><br><span class="line"><span class="keyword">await</span> takes_int_str(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>) <span class="comment"># Correctly rejected</span></span><br></pre></td></tr></table></figure>

<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><ul>
<li>新的union type表达：<code>A|B</code></li>
<li>多重上下文</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html">https://docs.python.org/3.10/whatsnew/3.10.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 7 连接</title>
    <url>/2021/05/08/csapp_7/</url>
    <content><![CDATA[<h1 id="CSAPP-7-连接，Linking"><a href="#CSAPP-7-连接，Linking" class="headerlink" title="CSAPP 7 连接，Linking"></a>CSAPP 7 连接，Linking</h1><p>连接是将程序的不同部分（指令和数据）组合成一个二进制文件，该文件可以被读入内存并被CPU执行。连接可以发生在编译时，即程序从源代码转换成机器码的过程中（Static Linking）；也可以发生在装载阶段，即程序被读入内存的阶段（Dynamic Linking）；甚至可以在运行时，即程序已经被读入内存且已经开始执行的时候。</p>
<p>连接器操作的对象被称为目标文件：<code>Relocatable object file</code>, <code>Executable object file</code>, <code>Shared object file</code>。</p>
<p>目标文件的格式是约定俗成的，最常见的是<code>ELF</code>, Executable and Linkable Format。</p>
<blockquote>
<p>在C语言中，<code>static</code> 关键字通常用来隐藏变量或者函数。</p>
</blockquote>
<p><strong>Practice Problem 7.1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *bufp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">    temp = *bufp0;</span><br><span class="line">    *bufp0 = *bufp1;</span><br><span class="line">    *bufp1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>Symbol</th>
<th>.symtab?</th>
<th>Symbol type</th>
<th>Module defined</th>
<th>Section</th>
</tr>
</thead>
<tbody><tr>
<td>buf</td>
<td>yes</td>
<td>extern</td>
<td>main.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp0</td>
<td>yes</td>
<td>global</td>
<td>swap.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp1</td>
<td>yes</td>
<td>global</td>
<td>swap.o</td>
<td>.bss</td>
</tr>
<tr>
<td>swap</td>
<td>yes</td>
<td>global</td>
<td>swap.0</td>
<td>.text</td>
</tr>
<tr>
<td>temp</td>
<td>no</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p><code>buf</code>由于有extern关键字，内存分配实在调用文件中完成的，而<code>temp</code>是局部变量，是运行时栈分配。</p>
<blockquote>
<p>连接器在处理多个静态库文件的时候，即symbol resolve stage，是从左向右扫描进行归档。</p>
</blockquote>
<p>连接的步骤：</p>
<ul>
<li>Symbole Resolution</li>
<li>Relocation</li>
</ul>
<p>程序连接完成后，就可以被系统从硬盘读入内存了，并且系统找到程序的“入口”指令并开始执行。每一个程序开始执行后，都有如下虚拟内存配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------    &lt;- high addres</span><br><span class="line">Kernel Memory</span><br><span class="line">--------------</span><br><span class="line">User Stack</span><br><span class="line">--------------    &lt;- %esp (stack pointer)</span><br><span class="line">|</span><br><span class="line">| ( grow )</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">-------------</span><br><span class="line">Share lib</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">-------------    &lt;- brk</span><br><span class="line">Runtime Heap</span><br><span class="line">by &#96;malloc&#96;</span><br><span class="line">-------------</span><br><span class="line">R&#x2F;W segment</span><br><span class="line">(.data, .bss)</span><br><span class="line">-------------</span><br><span class="line">RO segment</span><br><span class="line">(.init, .text)</span><br><span class="line">-------------    &lt;- 0x08048000</span><br><span class="line"></span><br><span class="line">-------------    &lt;- 0x0</span><br></pre></td></tr></table></figure>

<p><strong>Practice Problem 7.5</strong></p>
<ul>
<li>为什么每一个C程序都需要一个main函数？</li>
<li>为什么当main函数没有调用return或者exit，程序也会自然结束？</li>
</ul>
<p>main函数的程序被载入内存后的执行入口。<code>_exit</code> 都会被调用，然后把执行权交还给OS。</p>
<p><strong>Runtime动态连接</strong></p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>874. Walking Robot Simulation</title>
    <url>/2021/04/27/leetcode_robot/</url>
    <content><![CDATA[<h1 id="874-Walking-Robot-Simulation"><a href="#874-Walking-Robot-Simulation" class="headerlink" title="874. Walking Robot Simulation"></a>874. Walking Robot Simulation</h1><ul>
<li><a href="https://leetcode.com/problems/walking-robot-simulation/">874. Walking Robot Simulation</a></li>
</ul>
<p>这是一个简单，但是设计的很好的面试题。并没有困难的算法，考验的是一个软件工程师能都写出清晰、简洁代码的能力，以及一些细节问题。</p>
<p><strong>问题</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A robot on an infinite XY-plane starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands:</span><br><span class="line"></span><br><span class="line">-2: turn left 90 degrees,</span><br><span class="line">-1: turn right 90 degrees, or</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 9: move forward k units.</span><br><span class="line">Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] &#x3D; (xi, yi).</span><br><span class="line"></span><br><span class="line">If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</span><br><span class="line"></span><br><span class="line">Return the maximum Euclidean distance that the robot will be from the origin squared (i.e. if the distance is 5, return 25).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">North means +Y direction.</span><br><span class="line">East means +X direction.</span><br><span class="line">South means -Y direction.</span><br><span class="line">West means -X direction.</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: commands &#x3D; [4,-1,3], obstacles &#x3D; []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: The robot starts at (0, 0):</span><br><span class="line">1. Move north 4 units to (0, 4).</span><br><span class="line">2. Turn right.</span><br><span class="line">3. Move east 3 units to (3, 4).</span><br><span class="line">The furthest point away from the origin is (3, 4), which is 32 + 42 &#x3D; 25 units away.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: commands &#x3D; [4,-1,4,-2,4], obstacles &#x3D; [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: The robot starts at (0, 0):</span><br><span class="line">1. Move north 4 units to (0, 4).</span><br><span class="line">2. Turn right.</span><br><span class="line">3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).</span><br><span class="line">4. Turn left.</span><br><span class="line">5. Move north 4 units to (1, 8).</span><br><span class="line">The furthest point away from the origin is (1, 8), which is 12 + 82 &#x3D; 65 units away.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>我是这样想这个题的，为了模拟机器人行动，我们需要一对坐标记录机器人的位置，需要一个方向状态跟踪路径，最后计算长度。首先肯定要遍历所有的指令，而指令分三种：前进、左转和右转。那么程序的基本架构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">robotSim</span>(<span class="params">self, commands: <span class="type">List</span>[<span class="built_in">int</span>], obstacles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    </span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    direction = <span class="string">&#x27;n&#x27;</span>  <span class="comment"># 这里可一个是一个 Enum，分别代表四个方向</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">        <span class="keyword">if</span> c == -<span class="number">2</span>:  <span class="comment"># 左转</span></span><br><span class="line">           <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> c == -<span class="number">1</span>:  <span class="comment"># 右转</span></span><br><span class="line">           <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 前进</span></span><br><span class="line">           <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>现在我们只需要分别应对三种不同的命令。对于，左右转我们需要弄清执行指令后的方向，即需要一个<code>(当前方向，行动) -&gt; 新方向</code>的映射，我们可以写函数，或者直接用字典，总共是8中情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步就是前进的部分。这部分有两个问题：xy方向的变化，处理障碍物。xy的方向变化其实是一个<code>(方向) -&gt; (dx, dy)</code>的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">step = &#123;</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="string">&#x27;s&#x27;</span>: (<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">    <span class="string">&#x27;w&#x27;</span>: (-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>: (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果dx dy 让我们移动到了障碍物，则这个移动不能完成。</p>
<p>最终我们得到如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span>(<span class="params">self, commands: <span class="type">List</span>[<span class="built_in">int</span>], obstacles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 0. </span></span><br><span class="line">        direction = <span class="string">&#x27;n&#x27;</span> <span class="comment"># s e w</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 1.</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 2.</span></span><br><span class="line">        step = &#123;</span><br><span class="line">            <span class="string">&#x27;n&#x27;</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;s&#x27;</span>: (<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;w&#x27;</span>: (-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">&#x27;e&#x27;</span>: (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 这个部分是为了增加检测存在的效率，使用set</span></span><br><span class="line">        obstacles = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, obstacles))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> c == -<span class="number">2</span>:  <span class="comment"># left turn</span></span><br><span class="line">                direction = state[(direction, <span class="string">&#x27;l&#x27;</span>)]</span><br><span class="line">            <span class="keyword">elif</span> c == -<span class="number">1</span>: <span class="comment"># right turn</span></span><br><span class="line">                direction = state[(direction, <span class="string">&#x27;r&#x27;</span>)]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># move</span></span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                    dx, dy = step[direction]</span><br><span class="line">                    <span class="keyword">if</span> (x+dx, y+dy) <span class="keyword">not</span> <span class="keyword">in</span> obstacles:</span><br><span class="line">                        x += dx</span><br><span class="line">                        y += dy</span><br><span class="line">                        <span class="comment"># 3. dont want to go back...</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, x*x+y*y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode"><a href="#tags-Leetcode" class="headerlink" title="tags: Leetcode"></a>tags: <code>Leetcode</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dict</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 6 存储的层次</title>
    <url>/2021/04/24/csapp_6/</url>
    <content><![CDATA[<h1 id="CSAPP-6-存储的层次"><a href="#CSAPP-6-存储的层次" class="headerlink" title="CSAPP 6 存储的层次"></a>CSAPP 6 存储的层次</h1><p>本书之前讨论的模型注重CPU执行程序的过程和方式，而其中内存被当做一个简单的byte array，可以实现O(1)访问。但是，这个内存模型是简化的，实际计算的内存是一个层状模型，每一层都有不同的承载力和访问开销。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p><strong>Temporal Locality</strong>：一个内存地址如果被引用了一次，那么它很可能在将来还会被引用。<strong>Spatial Locality</strong>：一个地址如果被引用，那么它周围的地址也能被引用。</p>
<p>现代计算机和操作系统都会做上述假设，如果程序可以满足上述假设，那么程序的运行速度就会提升。</p>
<p>因此：</p>
<ul>
<li>反复访问同一个内存地址效率更高</li>
<li>多维数组row基更快，因为内存连续</li>
<li>多维数组，<code>a[][][]</code> 将最后一个index作为变化最快的index</li>
<li>循环最好是大量的短代码块</li>
</ul>
<p><strong>Problem 6.9</strong></p>
<p>定义如下结构体，注意结构体在C中其实也是一段连续的内存，循环赋值的时候如果关注效率，应该采用<code>clear1</code>的方法。结构体其实相当于多维数组，只不过第二维度是一个field，而不是index。因此 j 应该是变化最快的index，而且不宜把vel和acc放在同一个loop里面，这样写起来方便，但是 Locality 不好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> vel[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> acc[<span class="number">3</span>];</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line">point p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear1</span><span class="params">(point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">            p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">            p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储的层次"><a href="#存储的层次" class="headerlink" title="存储的层次"></a>存储的层次</h2><p>从寄存器到硬盘，再到网络服务器，计算机系统的存储系统是一个层状结构。越往上读写速度越快，但是价格也越高，相应的存储空间也越小。所以上一层的内存通常是作为下一层内存的<strong>缓存（Cache）</strong> 使用。</p>
<p><img data-src="https://i.imgur.com/8BRKwX4.png" alt=""></p>
<p>通常k和k+1的缓存关系具有固定的block大小。如果程序想要读取k+1的信息，会搜索k中k+1的缓存block，如果找到（cache hit）读取，如果没找到（cache miss）则会从K+1读取，并放入k层缓存，不过放入缓存的具体方式跟不同的缓存策略有关。</p>
<p>Cache hit 大家都开心，如果出现 Cache miss，我们需要分析原因。一般miss可以分成：</p>
<ul>
<li>cold miss</li>
<li>confilt miss</li>
<li>capacity miss</li>
</ul>
<p>既然每一层都是下一层的缓存，那么谁来负责管理每一层之间的数据流动呢？存储的最顶层是寄存器，这部分内存由编译器负责管理；而L1-3缓存则是由硬件负责管理；而主内存，在有虚拟内存的情况下，是有操作系统和硬件共同完成管理的，</p>
<p>正是因为存储的这种层状缓存关系，程序的Locality才对提升性能格外重要：</p>
<ul>
<li>Temporal Locality，可以提高cache hit</li>
<li>Spatial Locality，可以提高一个block空间的利用率</li>
</ul>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>如果系统的地址宽度为$m$ bits，则系统可以寻址$M=s^m$，那么缓存一般被划分成 $S=2^s$ 个缓存集（Cache set），每一个缓存集包含 $E$ 调缓存记录，而每一个缓存记录的宽度恰好是系统地址宽度 $m$。每个缓存记录包含：</p>
<ul>
<li>数据块，$B=2^b$ 字节；</li>
<li>valid bit，1 bit，用来表明该记录是否存有可用信息；</li>
<li>Tag，$t=m-(b+s)$，这部分是当前内存块地址的一个子集。</li>
</ul>
<p>由此得出缓存的大小：$C=B<em>E</em>S$，我们可以用一个4维元组定义一个缓存：$(S, E, B, m)$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 0, cache line 0</span><br><span class="line"></span><br><span class="line">| valid bit | -- t bits -- | --  b blocks  -- |</span><br><span class="line">   Valid          Tag          B &#x3D; 2^b bytes</span><br></pre></td></tr></table></figure>

<p>那么缓存是如何寻址的呢？假设我们要看缓存是否包含地址A对应的数据。首先我们把地址划分成三个部分：</p>
<ul>
<li>tag</li>
<li>set index</li>
<li>block offset</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         m-1                                    0</span><br><span class="line">address: |-- t bits --|-- s bits --|-- b bits --|</span><br><span class="line">              tag       set index   block offset</span><br></pre></td></tr></table></figure>

<p>首先，set index 部分指明缓存集（cache set）位置，然后 Tag 部分会指明那个缓存记录包含该地址的内容；最后，通过 block offset 找到读取的缓存的最终位置。</p>
<h4 id="Problem-6-10"><a href="#Problem-6-10" class="headerlink" title="Problem 6.10"></a>Problem 6.10</h4><ul>
<li>$S = C / (B * E)$</li>
<li>$s = log_2(S)$</li>
<li>$b = log_2(B)$</li>
<li>$t = m - (s+b)$</li>
</ul>
<table>
<thead>
<tr>
<th>Cache</th>
<th>m</th>
<th>C</th>
<th>B</th>
<th>E</th>
<th>S</th>
<th>t</th>
<th>s</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>2.</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>3.</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody></table>
<h3 id="直接映射缓存"><a href="#直接映射缓存" class="headerlink" title="直接映射缓存"></a>直接映射缓存</h3><p>直接映射缓存就是 $E=1$ 的缓存，即每一个缓存集只有一条缓存记录。缓存的读取分成三部：</p>
<ul>
<li>选取set</li>
<li>匹配line</li>
<li>抽取word</li>
</ul>
<p>跟上上面练习的表格，可以知道 s 的宽度是 5 比特，也就是我们需要抽取读取地址中的5位，换算成无符号整数，作为cache set索引。比如如下示意，我们的地址中 s 的部分是<code>00001</code>就会对应cache set索引1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m-1                                        0</span><br><span class="line">|--  t bits -- | 0 0 0 0 1 | --  b bits -- |</span><br></pre></td></tr></table></figure>

<p>找到 cache set 的位置后，我们需要找到对应的 cache line，由于选择了E=1，每一个 cache set 都只有一个 cache line，这一步就没什么好选择的了。</p>
<p>最后一步就是抽取数据。</p>
<ol>
<li>检查 vilid bit 是否是1，</li>
<li>检查 tag 部分（0110）是否与缓存tag部分相等，</li>
<li>继续读取offset的部分（本例子中是二进制100，即十进制4）找到对应的数据。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache set 的结构</span><br><span class="line"></span><br><span class="line">| valid bit | Tag | Block </span><br><span class="line">    &#x3D;1 ?     0110   </span><br><span class="line">    </span><br><span class="line">m-1                                        0</span><br><span class="line">|--  t bits -- | 0 0 0 0 1 | --  b bits -- |</span><br><span class="line">|   0 1 1 0    |     i     |     1 0 0     |</span><br></pre></td></tr></table></figure>

<p>如果步骤1、2都满足，成为 cache hit，即命中。否则为cache miss，这时系统需要继续访问内存读取数据，然后将数据按照规则写入cache。这时候，如果缓存已经满了，就需要一些evicted策略。对于直接映射缓存，情况比较简单，就是直接用新的数据替换该cache line。</p>
<p><strong>值得注意的是，如果一个cache line出现cache miss，系统会直接读取所有的block进入缓存，而不是只读取请求的部分。</strong></p>
<p><strong>由于缓存较小，同一个cache line会被映射到不同的内存地址，这就可能导致Conflit miss，即一个cache line被返回的清除，或交替出现cache miss</strong>。</p>
<p><strong>为什么采用中间的bit作为set索引，而不是高位的bit？因为我们希望连续的内存被映射到不同的set区间，增加连续访问的cache hit</strong></p>
<h4 id="Problem-6-11"><a href="#Problem-6-11" class="headerlink" title="Problem 6.11"></a>Problem 6.11</h4><p>padding后，75%的访问会命中。</p>
<h4 id="Problem-6-13"><a href="#Problem-6-13" class="headerlink" title="Problem 6.13"></a>Problem 6.13</h4><table>
<thead>
<tr>
<th>Cache</th>
<th>m</th>
<th>C</th>
<th>B</th>
<th>E</th>
<th>S</th>
<th>t</th>
<th>s</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>13</td>
<td>32</td>
<td>4</td>
<td>1</td>
<td>8</td>
<td>8</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tag: 8 bit</span><br><span class="line">index: 3 bits</span><br><span class="line">offset: 2 bits</span><br></pre></td></tr></table></figure>

<h4 id="Problem-6-14"><a href="#Problem-6-14" class="headerlink" title="Problem 6.14"></a>Problem 6.14</h4><p><code>0x0E34</code> -&gt; <code>0111000110100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache block offset (CO)   0x00</span><br><span class="line">Cache set index (CI)      0x05</span><br><span class="line">Cache tag (CT)            0x71</span><br><span class="line">Cache Hit?                Yes</span><br><span class="line">Cache byte return         0x0B</span><br></pre></td></tr></table></figure>

<h4 id="Problem-6-15"><a href="#Problem-6-15" class="headerlink" title="Problem 6.15"></a>Problem 6.15</h4><p><code>0x0DD5</code> -&gt; <code>110111010101</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache block offset (CO)   0x01</span><br><span class="line">Cache set index (CI)      0x05</span><br><span class="line">Cache tag (CT)            0x6E</span><br><span class="line">Cache Hit?                No</span><br><span class="line">Cache byte return         -</span><br></pre></td></tr></table></figure>



<h3 id="写入缓存的问题"><a href="#写入缓存的问题" class="headerlink" title="写入缓存的问题"></a>写入缓存的问题</h3><p>上述方法用于读取缓存没有问题，当程序想要向缓存写入数据的时候，系统需要考虑不同的方案。我们有两种情况：Write hit 和 Write miss。</p>
<p>Write hit 的情况下，我们有两种方案：<code>write-though</code>和<code>write-back</code>。前一种方案会在写入缓存的同事，更新对应的内存空间；后一种方案，只有在该缓存被清除的时候，才会向对应内存写入更新的数值。</p>
<p>Write miss 的情况下，也是两种方案：<code>write-allocate</code>和<code>no-write-allocate</code>。前一种方案会读取数据到缓存，然后写入缓存；后一种会直接写入内存或下一层缓存。</p>
<h3 id="i-cache-和-d-cache"><a href="#i-cache-和-d-cache" class="headerlink" title="i-cache 和 d-cache"></a>i-cache 和 d-cache</h3><p>缓存不仅会存储数据，也会存储CPU指令。</p>
<h3 id="缓存参数对性能影响指标"><a href="#缓存参数对性能影响指标" class="headerlink" title="缓存参数对性能影响指标"></a>缓存参数对性能影响指标</h3><p>我们有如下指标评估缓存的性能：</p>
<ul>
<li>Miss Rate</li>
<li>Hit Rate</li>
<li>Hit time</li>
<li>Miss penalty</li>
</ul>
<h2 id="如何利用缓存特性写更快的程序？"><a href="#如何利用缓存特性写更快的程序？" class="headerlink" title="如何利用缓存特性写更快的程序？"></a>如何利用缓存特性写更快的程序？</h2><ol>
<li>让公共代码跑的更快</li>
<li>减少内层循环的cache miss</li>
<li>再循环中不断访问局部变量（编译器会优化到寄存器）</li>
<li>把变化最快层放在最内层索引</li>
</ol>
<p>概念上：</p>
<ul>
<li>关注程序的最内层循环</li>
<li>为了最大化空间局部性，stride 1 模式读取对象</li>
<li>为了最大化临时局部性，反复使用已经从内存读取的对象</li>
</ul>
<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>1192 Critical Connections in a Network</title>
    <url>/2021/04/24/leetcode_graph/</url>
    <content><![CDATA[<h1 id="1192-Critical-Connections-in-a-Network"><a href="#1192-Critical-Connections-in-a-Network" class="headerlink" title="1192. Critical Connections in a Network"></a>1192. Critical Connections in a Network</h1><ul>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/">1192. Critical Connections in a Network</a></li>
<li><a href="https://leetcode.com/problems/all-paths-from-source-to-target/">797. All Paths From Source to Target</a></li>
</ul>
<h2 id="1192-Critical-Connections-in-a-Network-1"><a href="#1192-Critical-Connections-in-a-Network-1" class="headerlink" title="1192. Critical Connections in a Network"></a>1192. Critical Connections in a Network</h2><p><strong>问题</strong></p>
<blockquote>
<p>There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.A critical connection is a connection that, if removed, will make some server unable to reach some other server.<br>Return all critical connections in the network in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, connections &#x3D; [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">Output: [[1,3]]</span><br><span class="line">Explanation: [[3,1]] is also accepted.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>思路1：暴力破解</p>
<p>按照循序分别移除一个边，然后dfs剩下的图，如果DFS的深度小于节点数，说明移除的边是关键路线。这个思路简单，一旦边数量多起啦，就会超时。</p>
<p>思路2：找循环</p>
<p>关键路线其实就是不在 cycle 中的 edge，我们只需要找到所有不在循环中边，就是此题答案。</p>
<p>下一个问题是：如何找到循环？无论哪种方法，我们需要遍历图，为了找到循环，最好的办法是DFS。DFS的过程中，需要一个特殊标记表明节点的深度，因为如果我们发现循环，等价于发现了一个节点，两次访问他深度不相同！</p>
<p>现在还有一个问题，我们可以用标记在当前的搜索层发现循环，但是上一个层并不知道这个信息，我们需要把这个信息返回到上一层，其实就是回溯（backtraking）。</p>
<p>我们的DFS函数永远返回当前节点的最小深度。</p>
<p>假设我们在一个长度（深度）为<code>k</code>的DFS路径上（<code>dfs(node, k)</code>），看到了节点<code>node</code>，如果这个节点没有见过，标记他的深度；然后遍历他的相邻节点，如果发现相邻节点的深度刚好是k-1，说明这是他的父节点，跳过避免循环搜索；如果不是父节点，进入下一层搜索，<code>k+1</code>。</p>
<p>然后我们分析回溯的部分，<code>back_depth = dfs(adj, depth+1)</code>。比较当前深度<code>k</code>和下一层回溯回来的深度<code>back_depth</code>，如果回溯回来的深度<code>dfs(adj)</code>小于<code>dfs(k)</code>，则<code>k</code>发现他的邻居<code>adj</code>找到了一个可以回到<code>k</code>或者<code>k</code>的祖先的循环，则边<code>(k, adj)</code>一定属于某个循环，移除。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">connections, n</span>):</span></span><br><span class="line">    graph = build(connections, n)</span><br><span class="line">    mark = [-<span class="number">2</span>] * n</span><br><span class="line">    connections = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, (<span class="built_in">map</span>(<span class="built_in">sorted</span>, connections))))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, depth</span>):</span></span><br><span class="line">        <span class="keyword">if</span> mark[node] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># visited already!</span></span><br><span class="line">            <span class="keyword">return</span> mark[node]</span><br><span class="line">        </span><br><span class="line">        mark[node] = depth</span><br><span class="line">        min_back_depth = n</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> mark[adj] == depth - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># visited from prev level</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            back_depth = dfs(adj, depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> back_depth &lt;= depth:  <span class="comment"># found cycle</span></span><br><span class="line">                connections.discard(<span class="built_in">tuple</span>(<span class="built_in">sorted</span>((node, adj))))</span><br><span class="line">            </span><br><span class="line">            min_back_depth = <span class="built_in">min</span>(back_depth, min_back_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_back_depth</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(connections)</span><br></pre></td></tr></table></figure>

<h2 id="797-All-Paths-From-Source-to-Target"><a href="#797-All-Paths-From-Source-to-Target" class="headerlink" title="797. All Paths From Source to Target"></a>797. All Paths From Source to Target</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1, and return them in any order.</p>
<p>The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1],[]]</span><br><span class="line">Output: [[0,1]]</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1,2,3],[2],[3],[]]</span><br><span class="line">Output: [[0,1,2,3],[0,2,3],[0,3]]</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1,3],[2],[3],[]]</span><br><span class="line">Output: [[0,1,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>基本的DFS回溯问题，我们套用模板。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        <span class="comment"># backtrack</span></span><br><span class="line">        res = []</span><br><span class="line">        path = [<span class="number">0</span>]</span><br><span class="line">        N = <span class="built_in">len</span>(graph) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="comment"># 模板：结束条件</span></span><br><span class="line">            <span class="keyword">if</span> node == N:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 模板：遍历所有下一个步骤</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">                path.append(i)</span><br><span class="line">                <span class="comment"># 模板：走向更深</span></span><br><span class="line">                _dfs(i)</span><br><span class="line">                <span class="comment"># 模板：恢复状态，继续循环</span></span><br><span class="line">                path.pop()</span><br><span class="line">                </span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution">https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution</a></li>
</ul>
<h6 id="tags-Leetcode-Graph-BFS-DFS"><a href="#tags-Leetcode-Graph-BFS-DFS" class="headerlink" title="tags: Leetcode Graph BFS DFS"></a>tags: <code>Leetcode</code> <code>Graph</code> <code>BFS</code> <code>DFS</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree层遍历</title>
    <url>/2021/04/20/leetcode_tree1/</url>
    <content><![CDATA[<h1 id="Tree层遍历"><a href="#Tree层遍历" class="headerlink" title="Tree层遍历"></a>Tree层遍历</h1><ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102 Binary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107 Binary Tree Level Order Traversal II</a></li>
<li><a href="https://leetcode.com/problems/deepest-leaves-sum/">1302. Deepest Leaves Sum</a></li>
<li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637 Average of Levels in Binary Tree</a></li>
</ul>
<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102 Binary Tree Level Order Traversal"></a>102 Binary Tree Level Order Traversal</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题属于比较常见的BFS遍历，即通过一个队列将同一层的节点遍历一遍，然后入列下一层的节点，循环。不过需要注意一些 None 的conner case处理。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            </span><br><span class="line">            res.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107 Binary Tree Level Order Traversal II"></a>107 Binary Tree Level Order Traversal II</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
</blockquote>
<p><strong>思路</strong></p>
<p>此题是上一题的倒叙模式。最直接的方法是采用上题的解法，然后reverse结果。或者我们也可以直接采用queue进行，不过需要多一个状态记录层数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dfs recursively</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom1</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    self.dfs(root, <span class="number">0</span>, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, level, res</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level + <span class="number">1</span>:</span><br><span class="line">            res.insert(<span class="number">0</span>, [])</span><br><span class="line">        res[-(level+<span class="number">1</span>)].append(root.val)</span><br><span class="line">        self.dfs(root.left, level+<span class="number">1</span>, res)</span><br><span class="line">        self.dfs(root.right, level+<span class="number">1</span>, res)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># dfs + stack</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom2</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    stack = [(root, <span class="number">0</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, level = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>, [])</span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            stack.append((node.right, level+<span class="number">1</span>))</span><br><span class="line">            stack.append((node.left, level+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bfs + queue   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    queue, res = collections.deque([(root, <span class="number">0</span>)]), []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node, level = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>, [])</span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            queue.append((node.left, level+<span class="number">1</span>))</span><br><span class="line">            queue.append((node.right, level+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    deque, ret = collections.deque(), []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        deque.append(root)</span><br><span class="line">    <span class="keyword">while</span> deque:</span><br><span class="line">        level, size = [], <span class="built_in">len</span>(deque)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        ret.append(level)</span><br><span class="line">    <span class="keyword">return</span> ret[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637 Average of Levels in Binary Tree"></a>637 Average of Levels in Binary Tree</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,15,7]</span><br><span class="line">Output: [3.00000,14.50000,11.00000]</span><br><span class="line">Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.</span><br><span class="line">Hence return [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>简单说这题就是求每一层的平均数。同样的思路，用一个queue包括所有的该层节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">        q, res  = collections.deque(), []</span><br><span class="line">        </span><br><span class="line">        q.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            size = <span class="built_in">len</span>(q)</span><br><span class="line">            _s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    _s += node.val</span><br><span class="line">                    <span class="keyword">if</span> node.left: q.append(node.left) </span><br><span class="line">                    <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">                    </span><br><span class="line">            res.append(_s/size)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1302-Deepest-Leaves-Sum"><a href="#1302-Deepest-Leaves-Sum" class="headerlink" title="1302. Deepest Leaves Sum"></a>1302. Deepest Leaves Sum</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the sum of values of its deepest leaves.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root &#x3D; [1,2,3,4,5,null,6,7,null,null,null,null,8]</span><br><span class="line">Output: 15</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root &#x3D; [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]</span><br><span class="line">Output: 19</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题仍然是安层遍历，只不过我们只关心最后一层的数据。因此我们写一个循环，每一次搜集所有该层的节点，直到没有节点为止，此时queue剩下的元素就是我们需要的。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            q_new = [ x.left <span class="keyword">for</span> x <span class="keyword">in</span> q <span class="keyword">if</span> x.left ] </span><br><span class="line">            q_new += [ x.right <span class="keyword">for</span> x <span class="keyword">in</span> q <span class="keyword">if</span> x.right ] </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q_new:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            q = q_new</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([ node.val <span class="keyword">for</span> node <span class="keyword">in</span> q ])</span><br></pre></td></tr></table></figure>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://leetcode.com/problems/deepest-leaves-sum/discuss/499023/Two-python-O(n)-sol.-by-level-order-traversal.-93%2B-With-explanation">https://leetcode.com/problems/deepest-leaves-sum/discuss/499023/Two-python-O(n)-sol.-by-level-order-traversal.-93%2B-With-explanation</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的算术 LL1 Parser</title>
    <url>/2021/04/19/parser/</url>
    <content><![CDATA[<h1 id="一个简单的算术-LL-1-Parser"><a href="#一个简单的算术-LL-1-Parser" class="headerlink" title="一个简单的算术 LL(1) Parser"></a>一个简单的算术 LL(1) Parser</h1><p>这篇文章探索如何手写一个简单的算术表达式 Parser。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们要解决的问题是把一个算术表达式字符串转化成语法树（Abstract Syntax Tree，AST），就像通用计算机语言一样，然后evaluate该AST。算术表达式包含：<code>+ - * / ( )</code> 以及数字。</p>
<h2 id="LL-1-Parsing"><a href="#LL-1-Parsing" class="headerlink" title="LL(1) Parsing"></a>LL(1) Parsing</h2><p>这里我们采用LL(1）parsing。LL(1) parser 属于自顶向下的分析器，分析时不断用当前匹配的规则对分析器栈顶的元素进行替换。我们需要如下两个信息来进行分析：</p>
<ul>
<li>分析器栈顶的词法单元（token），要么是终端字符（Terminal），要么是非终端字符（Non-Terminal）。比如 <code>+</code> 就是终端字符，而非终结字符就是语法规则左手侧的，比如 <code>Exp</code>。</li>
<li>当前正在处理的终结词法单元</li>
</ul>
<p>比如当前的栈顶单元是<code>S</code>，而当前处理的终结字符是<code>a</code>，同时我们以这样一个语法规则：<code>S -&gt; a P</code>。这时，我们需要将<code>S</code>替换成<code>a P</code>，其中<code>S</code>和<code>P</code>都是非终端字符，而<code>a</code>是终端。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Exp -&gt; Exp [ + | - ] Exp2</span><br><span class="line">2. Exp -&gt; Exp2</span><br><span class="line">3. Exp2 -&gt; Exp2 [ * | &#x2F; ] Exp3</span><br><span class="line">4. Exp2 -&gt; Exp3</span><br><span class="line">5. Exp3 -&gt; ( Exp )</span><br><span class="line">6. Exp3 -&gt; Num</span><br></pre></td></tr></table></figure>

<p>按照上述语法，我们展开<code>2+3*4</code>： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exp</span><br><span class="line">1. Exp + Exp2</span><br><span class="line">2. Exp2 + Exp2</span><br><span class="line">3. Exp3 + Exp2</span><br><span class="line">6. Num + Exp2</span><br><span class="line">3. Num + Exp2 * Exp3</span><br><span class="line">4. Num + Exp3 * Exp3</span><br><span class="line">6. Num + Num * Exp3</span><br><span class="line">6. Num + Num * Num</span><br></pre></td></tr></table></figure>

<p>不过目前这个语法，我们还不能用<code>LL(1)</code>分析器分析，因为 LL1 要求只能每次看一个词法单元，而我们的语法的右手侧不是唯一的。我们需要重写语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. S      -&gt; Exp $</span><br><span class="line">2. Exp    -&gt; Exp2 Exp&#39;</span><br><span class="line">3. Exp&#39;   -&gt; [ + | - ] Exp2 Exp&#39;</span><br><span class="line">4. Exp&#39;   -&gt; none</span><br><span class="line">5. Exp2   -&gt; Exp3 Exp2&#39;</span><br><span class="line">6. Exp2&#39;  -&gt; [ * | - ] Exp3 Exp2&#39;</span><br><span class="line">7. Exp2&#39;  -&gt; none</span><br><span class="line">8. Exp3   -&gt; num</span><br><span class="line">9. Exp3   -&gt; ( Exp )</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先定义词法单元，和AST节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenT</span>(<span class="params">enum.Enum</span>):</span></span><br><span class="line">    T_NUM = <span class="number">0</span></span><br><span class="line">    T_PLUS = <span class="number">1</span></span><br><span class="line">    T_MINUS = <span class="number">2</span></span><br><span class="line">    T_MULT = <span class="number">3</span></span><br><span class="line">    T_DIV = <span class="number">4</span></span><br><span class="line">    T_LPAR = <span class="number">5</span></span><br><span class="line">    T_RPAR = <span class="number">6</span></span><br><span class="line">    T_END = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, token_t, value=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.token_t = token_t</span><br><span class="line">        self.value = value </span><br><span class="line">        self.children = []</span><br></pre></td></tr></table></figure>

<p>然后我们写词法器，Lexer：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lex</span>(<span class="params">exp</span>):</span></span><br><span class="line">    mapping = &#123;</span><br><span class="line">        <span class="string">&quot;+&quot;</span>: TokenT.T_PLUS,</span><br><span class="line">        <span class="string">&quot;-&quot;</span>: TokenT.T_MINUS,</span><br><span class="line">        <span class="string">&quot;*&quot;</span>: TokenT.T_MULT,</span><br><span class="line">        <span class="string">&quot;/&quot;</span>: TokenT.T_DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exp:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> mapping:</span><br><span class="line">            token_t = mapping[c]</span><br><span class="line">            token = Node(token_t=token_t, value=c)</span><br><span class="line">        <span class="keyword">elif</span> re.match(<span class="string">r&quot;\d&quot;</span>, c):</span><br><span class="line">            token = Node(TokenT.T_NUM, value=<span class="built_in">int</span>(c))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknow token <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        tokens.append(token)</span><br><span class="line"></span><br><span class="line">    tokens.append(Node(TokenT.T_END))</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br></pre></td></tr></table></figure>

<p>然后我们按照上面的语法写分析器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">tokens, token</span>):</span></span><br><span class="line">    <span class="keyword">if</span> tokens[<span class="number">0</span>].token_t == token:</span><br><span class="line">        <span class="keyword">return</span> tokens.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_e</span>(<span class="params">tokens</span>):</span>  <span class="comment"># + -</span></span><br><span class="line">    left_node = parse_e2(tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> tokens[<span class="number">0</span>].token_t <span class="keyword">in</span> [TokenT.T_PLUS, TokenT.T_MINUS]:</span><br><span class="line">        node = tokens.pop(<span class="number">0</span>)</span><br><span class="line">        node.children.append(left_node)</span><br><span class="line">        node.children.append(parse_e2(tokens))</span><br><span class="line">        left_node = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_e2</span>(<span class="params">tokens</span>):</span>  <span class="comment"># * /</span></span><br><span class="line">    left_node = parse_num(tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> tokens[<span class="number">0</span>].token_t <span class="keyword">in</span> [TokenT.T_MULT, TokenT.T_DIV]:</span><br><span class="line">        node = tokens.pop(<span class="number">0</span>)</span><br><span class="line">        node.children.append(left_node)</span><br><span class="line">        node.children.append(parse_num(tokens))</span><br><span class="line">        left_node = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_num</span>(<span class="params">tokens</span>):</span>  <span class="comment"># num</span></span><br><span class="line">    <span class="keyword">if</span> tokens[<span class="number">0</span>].token_t == TokenT.T_NUM:</span><br><span class="line">        <span class="keyword">return</span> tokens.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    match(tokens, TokenT.T_LPAR)</span><br><span class="line">    expression = parse_e(tokens)</span><br><span class="line">    match(tokens, TokenT.T_RPAR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    <span class="comment"># 返回语法树</span></span><br><span class="line">    tokens = lex(inouts)</span><br><span class="line">    ast = parse_e(tokens)</span><br><span class="line">    match(tokens, TokenT.T_END)</span><br><span class="line">    <span class="keyword">return</span> ast</span><br></pre></td></tr></table></figure>

<p>当我们得到语法树后，就可以实现计算了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ops = &#123;</span><br><span class="line">    TokenT.T_PLUS: <span class="keyword">lambda</span> x,y: x+y,</span><br><span class="line">    TokenT.T_MINUS: <span class="keyword">lambda</span> x,y: x-y,</span><br><span class="line">    TokenT.T_MULT: <span class="keyword">lambda</span> x,y: x*y,</span><br><span class="line">    TokenT.T_DIV: <span class="keyword">lambda</span> x,y: <span class="built_in">int</span>(x/y),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node.token_t == TokenT.T_NUM:</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    </span><br><span class="line">    left = compute(node.children[<span class="number">0</span>])</span><br><span class="line">    right = compute(node.children[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> ops[node.token_t](left, right)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = <span class="string">&quot;1+2*(3-5)&quot;</span></span><br><span class="line">ast = parse(strings)</span><br><span class="line">res = compute(ast)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># output: -3</span></span><br></pre></td></tr></table></figure>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/gnebehay/parser/blob/master/parser.py">https://github.com/gnebehay/parser/blob/master/parser.py</a></li>
</ul>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>LL1</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯 DFS</title>
    <url>/2021/04/18/leetcode_dfs/</url>
    <content><![CDATA[<h1 id="回溯，DFS"><a href="#回溯，DFS" class="headerlink" title="回溯，DFS"></a>回溯，DFS</h1><ul>
<li><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></li>
<li><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></li>
<li><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466. Reorder Routes to Make All Paths Lead to the City Zero</a></li>
<li><a href="https://leetcode.com/problems/24-game/submissions/">679. 24 Game</a></li>
<li><a href="https://leetcode.com/problems/expression-add-operators/">282. Expression Add Operators</a></li>
</ul>
<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>还是从简单的思考过程出发，假设给出 <code>[1,2,3]</code> 我们如何写出全排列呢？一个方法可以是：<code>1 ? ?？</code>，第一个？可以选择2或者3，然后会影响？？的选择。这种思路是典型的回溯，即穷举每一个位置的可能性，然后继续下一个选择，直到结束，回退一层，换一个选择。</p>
<p>实现起来就是一个深度优先搜索，但是所搜一层结束后，要回档当前层的状态。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, track</span>):</span></span><br><span class="line">            <span class="comment"># end condition</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(track):</span><br><span class="line">                res.append(track[:])  <span class="comment"># take a copy...</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 穷举</span></span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">in</span> track:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 选择</span></span><br><span class="line">                track.append(n)</span><br><span class="line">                <span class="comment"># 递归进入下一层选择</span></span><br><span class="line">                backtrack(nums, track)</span><br><span class="line">                <span class="comment"># 回档</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrack(nums, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题与上一题的思路是一致的，只不过由于重复的存在，我们需要穷举不同的数字，而且应该记录该数字当前可用的数量（这只一个状态），并且在回档的时候记得补回使用的数量。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">path, counter</span>):</span></span><br><span class="line">            <span class="comment"># 结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> counter:</span><br><span class="line">                <span class="keyword">if</span> counter[num] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 增加路径</span></span><br><span class="line">                    path.append(num)</span><br><span class="line">                    <span class="comment"># 改变状态</span></span><br><span class="line">                    counter[num] -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># DFS</span></span><br><span class="line">                    backtrack(path, counter)</span><br><span class="line">                    <span class="comment"># 回滚</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                    counter[num] += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        backtrack([], Counter(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>


<h2 id="466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="466. Reorder Routes to Make All Paths Lead to the City Zero"></a>466. Reorder Routes to Make All Paths Lead to the City Zero</h2><p><strong>问题</strong></p>
<blockquote>
<ul>
<li><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466. Reorder Routes to Make All Paths Lead to the City Zero</a></li>
</ul>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>首先把图改造成 undirected，同时标记那些路径是新加入的，那些是原有的。然后从0点出发做 DFS 搜索，如果途中经历了原有的路线，计数器加一。因为这些路线是需要改造的路线。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 转化成 undirected graph，并记录那些路径是原始路径，0，那些是增加路径，+1</span></span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># 构造无方向图</span></span><br><span class="line">        <span class="keyword">for</span> s, d <span class="keyword">in</span> connections:</span><br><span class="line">            graph[s].append((d, <span class="number">1</span>))  <span class="comment"># 这是s-&gt;d的原有路线，需要+1</span></span><br><span class="line">            graph[d].append((s, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur, parent, graph</span>):</span></span><br><span class="line">            <span class="keyword">for</span> node, cost <span class="keyword">in</span> graph[cur]:</span><br><span class="line">                <span class="comment"># node != parent 为了防止往回走。。</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> node != parent:</span><br><span class="line">                    self.res += cost</span><br><span class="line">                    visited.add(node)</span><br><span class="line">                    dfs(node, cur, graph)</span><br><span class="line">                    </span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>, graph) </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<p>当然这题也可以用 BFS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># 构造无方向图</span></span><br><span class="line">        <span class="keyword">for</span> s, d <span class="keyword">in</span> connections:</span><br><span class="line">            graph[s].append((d, <span class="number">1</span>))  <span class="comment"># 这是s-&gt;d的原有路线，需要+1</span></span><br><span class="line">            graph[d].append((s, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = [<span class="number">0</span>]</span><br><span class="line">        visited = <span class="built_in">set</span>([<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> n, cost <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visted:</span><br><span class="line">                    visited.add(n)</span><br><span class="line">                    res += cost</span><br><span class="line">                    queue.append(n)</span><br><span class="line">                    </span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="679-24-Game"><a href="#679-24-Game" class="headerlink" title="679. 24 Game"></a>679. 24 Game</h2><p><strong>问题</strong></p>
<blockquote>
<p>You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [4, 1, 8, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: (8-4) * (7-1) &#x3D; 24</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1, 2, 1, 2]</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>基本问题是给出四个数和四则运算，搜索满足条件的数字组合。典型的搜索问题。对于没两个数字，我们需要尝试四种运算，得到结果A，然后再A和剩下的三个数字里继续搜索。</p>
<p>这题被划分成困难，但是其实代码非常简单和清楚，就是典型的DFS通过递归实现。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">round</span>(nums[<span class="number">0</span>], <span class="number">4</span>) == <span class="number">24</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                first, second = nums[i], nums[j]</span><br><span class="line">                left = nums[:i] + nums[i+<span class="number">1</span>: j] + nums[j+<span class="number">1</span>: ]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first+second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first*second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first-second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[second-first]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> second <span class="keyword">and</span> self.judgePoint24(left+[first/second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> first <span class="keyword">and</span> self.judgePoint24(left+[second/first]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-DFS"><a href="#tags-Leetcode-DFS" class="headerlink" title="tags: Leetcode DFS"></a>tags: <code>Leetcode</code> <code>DFS</code></h6><h2 id="282-Expression-Add-Operators"><a href="#282-Expression-Add-Operators" class="headerlink" title="282. Expression Add Operators"></a>282. Expression Add Operators</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a string num that contains only digits and an integer target, return all possibilities to add the binary operators ‘+’, ‘-‘, or ‘*’ between the digits of num so that the resultant expression evaluates to the target value.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;123&quot;, target &#x3D; 6</span><br><span class="line">Output: [&quot;1*2*3&quot;,&quot;1+2+3&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;232&quot;, target &#x3D; 8</span><br><span class="line">Output: [&quot;2*3+2&quot;,&quot;2+3*2&quot;]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;105&quot;, target &#x3D; 5</span><br><span class="line">Output: [&quot;1*0+5&quot;,&quot;10-5&quot;]</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;00&quot;, target &#x3D; 0</span><br><span class="line">Output: [&quot;0*0&quot;,&quot;0+0&quot;,&quot;0-0&quot;]</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;3456237490&quot;, target &#x3D; 9191</span><br><span class="line">Output: []ing</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题显然是一个搜索问题，或者说回溯问题。基本思路是深度优先搜索，从左向右读取字符，组成数字（不同位数），然后分别尝试三种运算，并组合得出可以得到target的组合字符串。递归是写起来最方便的方法了，下一步就是确定递归携带的状态参数。</p>
<p>首先，我们需要记录当前截取的字符串位置，需要两个参数：<code>l</code>和<code>r</code>，分别代表当前截取的左右索引值；然后，需要记录当前的表达式，<code>expr</code>，即当前路径上目前的表达式；当前的计算结果，<code>cur</code>；上一步的计算结果，<code>last</code>；最后需要记录已经取得的结果，<code>res</code>，这是一个结果表达式的列表。</p>
<p>搜索过程是：从左边的0开始不断向右r搜索，终结条件是：</p>
<ul>
<li>l == r，即已经搜索了全部字符串</li>
<li>cur == target，即结果等于目标值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">l, r, expr, cur, last, res</span>):</span></span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> l == r <span class="keyword">and</span> cur == target:</span><br><span class="line">        res.append(expr)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">1</span>, r+<span class="number">1</span>): <span class="comment"># why l+1? r+1?</span></span><br><span class="line">        <span class="keyword">if</span> i == l+<span class="number">1</span> <span class="keyword">or</span> (i &gt; l+<span class="number">1</span> <span class="keyword">and</span> num[l] != <span class="string">&quot;0&quot;</span>):  <span class="comment"># avoid start with 0</span></span><br><span class="line">            s, x = num[l:i], <span class="built_in">int</span>(num[l:i])  <span class="comment"># from l to i !</span></span><br><span class="line">            <span class="keyword">if</span> last <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                dfs(i, r, s, x, x, res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;+&quot;</span> + s, cur+x, x, res)</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;-&quot;</span> + s, cur-x, -x, res)</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;*&quot;</span> + s, cur-last+last*x, res)</span><br></pre></td></tr></table></figure>

<p>如果没有乘法，即不改变结合优先级，我们不需要<code>last</code>状态来复原。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap 使用</title>
    <url>/2021/04/18/leetcode_heap1/</url>
    <content><![CDATA[<h1 id="Heap（堆）的使用"><a href="#Heap（堆）的使用" class="headerlink" title="Heap（堆）的使用"></a>Heap（堆）的使用</h1><ul>
<li><a href="https://leetcode.com/problems/last-stone-weight/">1046. Last Stone Weight</a></li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">703. Kth Largest Element in a Stream</a></li>
<li><a href="https://leetcode.com/problems/maximum-average-pass-ratio/">1792. Maximum Average Pass Ratio</a></li>
<li><a href="https://leetcode.com/problems/task-scheduler/">621. Task Schedule</a></li>
</ul>
<h2 id="1046-Last-Stone-Weight"><a href="#1046-Last-Stone-Weight" class="headerlink" title="1046. Last Stone Weight"></a>1046. Last Stone Weight</h2><p><strong>思路</strong></p>
<p>此题比较直接，直接采用heap来维护最重的数值在头部，需要注意的是 Python 的 heap 都是 min heap，所以需要取负数来实现此题。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        h = [-s <span class="keyword">for</span> s <span class="keyword">in</span> stones]</span><br><span class="line">        heapify(h)</span><br><span class="line">        <span class="built_in">print</span>(h)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(h) &gt;= <span class="number">2</span>:</span><br><span class="line">            fst = heappop(h)</span><br><span class="line">            snd = heappop(h)</span><br><span class="line">            <span class="keyword">if</span> fst != snd:</span><br><span class="line">                heappush(h, fst-snd)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="built_in">sum</span>(h)</span><br></pre></td></tr></table></figure>


<h2 id="703-Kth-Largest-Element-in-a-Stream"><a href="#703-Kth-Largest-Element-in-a-Stream" class="headerlink" title="703. Kth Largest Element in a Stream"></a>703. Kth Largest Element in a Stream</h2><p><strong>思路</strong><br>这题的要点在于维护一个固定长度的heap。可以采用 <code>heapreplace</code> 函数实现 push和pop 的组合操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.k = k</span><br><span class="line">        heapify(self.nums)</span><br><span class="line">        <span class="comment"># 保持头部是 kth largest </span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.nums) &gt; k:</span><br><span class="line">            heappop(self.nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.k:</span><br><span class="line">            heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">            heapreplace(self.nums, val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>


<h2 id="1792-Maximum-Average-Pass-Ratio"><a href="#1792-Maximum-Average-Pass-Ratio" class="headerlink" title="1792. Maximum Average Pass Ratio"></a>1792. Maximum Average Pass Ratio</h2><p><strong>思路</strong></p>
<p>这道题的关键在于想要找到最大平均数，需要把好学生分配到改变通过率最大的班级，即 delta 最大的班级。根据这个特征，我们需要一个堆来决绝，按照每个班增加一个好学生后的 delta 作为 Priority。永远把好学生分配到怼的头部。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAverageRatio</span>(<span class="params">self, classes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], extraStudents: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        h = [((x/t - (x+<span class="number">1</span>)/(t+<span class="number">1</span>)), x, t) <span class="keyword">for</span> x, t <span class="keyword">in</span> classes]</span><br><span class="line">        heapify(h)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> extraStudents:</span><br><span class="line">            v, x, t = heappop(h)</span><br><span class="line">            x, t = x+<span class="number">1</span>, t+<span class="number">1</span></span><br><span class="line">            heappush(h, (x/t-(x+<span class="number">1</span>)/(t+<span class="number">1</span>), x, t))</span><br><span class="line">            extraStudents -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([x/t <span class="keyword">for</span> _,x,t <span class="keyword">in</span> h]) / <span class="built_in">len</span>(h)</span><br></pre></td></tr></table></figure>

<h2 id="621-Task-Schedule"><a href="#621-Task-Schedule" class="headerlink" title="621. Task Schedule"></a>621. Task Schedule</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        h = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> Counter(tasks).items():</span><br><span class="line">            heappush(h, (-<span class="number">1</span>*v, k))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            tmp =  []</span><br><span class="line">            <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h:</span><br><span class="line">                    left, task = heappop(h)</span><br><span class="line">                    <span class="keyword">if</span> left != -<span class="number">1</span>:</span><br><span class="line">                        tmp.append((left+<span class="number">1</span>, task))</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> h <span class="keyword">and</span> <span class="keyword">not</span> tmp:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> tmp:</span><br><span class="line">                heappush(h, item)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode-Heap"><a href="#tags-Leetcode-Heap" class="headerlink" title="tags: Leetcode Heap"></a>tags: <code>Leetcode</code> <code>Heap</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Palindrome Pairs and the Trie</title>
    <url>/2021/04/17/leetcode_trie_tree/</url>
    <content><![CDATA[<h1 id="Prefix-tree"><a href="#Prefix-tree" class="headerlink" title="Prefix tree"></a>Prefix tree</h1><ul>
<li><a href="https://leetcode.com/problems/stream-of-characters/">208. Implement Trie (Prefix Tree)</a> </li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">1032. Stream of Characters</a></li>
<li><a href="https://leetcode.com/problems/palindrome-pairs/">336. Palindrome Pairs</a></li>
</ul>
<p>这两个题都提到了一种树：Trie，也叫做 prefix tree 或者 digital tree，属于所搜树的一种。通常用于字符串的分段搜索，也可以用来做输入提示，即给出一些字母，搜索后续可用的路径。搜索方式属于 DFS，每个节点可以通过带有一些属性，从而实现其他功能，比如不同的action等等。</p>
<p>第三题呢，乍一看跟 Trie 没关系但是，用 Trie 可以大大提高效率。</p>
<p>第一个题是中等，后两个都是困难题。</p>
<h2 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h2><p><strong>问题</strong></p>
<blockquote>
<p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.<br>Implement the Trie class:<br>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题就是实现一个<code>prefix tree</code>。我们采用字典构造树，基本插入算法是：对每一个词，构建一个path，path上的节点就是词内的字母，这些字母节点可以被很多词共享。搜索操作就是按照字母顺序遍历树的path，如果遍历成功到达一个leaf节点，搜索成功，否则失败，中途一旦发现不能继续，直接失败。对于 prefix 操作，思路与搜索类似，只不过不需要到达一个leaf节点，只要所有的字母都在某一个path即可。</p>
<p>其实，此题就算不清楚prefix tree的存在也是可以思考的。因为这个问题明显是一个搜索问题，搜索无非就是线性、树状或者图三种。这题由于涉及路径搜索，即给出一个字母序列，能在已有的结构中找到一个路径吗？找路径就是搜索树。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.children = collections.defaultdict(Node)</span><br><span class="line">                self.end = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.tree = Node()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        cur.end = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> cur.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.children[c]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur.end</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> cur.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.children[c]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="1032-Stream-of-Characters"><a href="#1032-Stream-of-Characters" class="headerlink" title="1032. Stream of Characters"></a>1032. Stream of Characters</h2><p><strong>问题</strong></p>
<blockquote>
<p>Implement the StreamChecker class as follows:</p>
<p>StreamChecker(words): Constructor, init the data structure with the given words.<br>query(letter): returns true if and only if for some k &gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StreamChecker streamChecker &#x3D; new StreamChecker([&quot;cd&quot;,&quot;f&quot;,&quot;kl&quot;]); &#x2F;&#x2F; init the dictionary.</span><br><span class="line">streamChecker.query(&#39;a&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;b&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;c&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;d&#39;);          &#x2F;&#x2F; return true, because &#39;cd&#39; is in the wordlist</span><br><span class="line">streamChecker.query(&#39;e&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;f&#39;);          &#x2F;&#x2F; return true, because &#39;f&#39; is in the wordlist</span><br><span class="line">streamChecker.query(&#39;g&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;h&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;i&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;j&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;k&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;l&#39;);          &#x2F;&#x2F; return true, because &#39;kl&#39; is in the wordlist</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题的关键在于我们不断读入新的字母，形成一个字母序列，我们需要反向搜索当前stream形成的path是不是在我们的树上。所以，对于给出的词，我们需要逆向构造。而且我们需要每个节点包含一个<code>is_end</code>flag用来表明当前这个节点是不是一个词。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">&quot;children&quot;</span>, <span class="string">&quot;is_end&quot;</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = defaultdict(Node)</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">words</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给出一个词的列表，我们需要构造一个搜索树</span></span><br><span class="line">    root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        cur = root </span><br><span class="line">        w = w[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> w:</span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        <span class="comment"># cur is now the end of the path</span></span><br><span class="line">        cur.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Build a trie for each word in reversed order</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># for user query record, init as empty string</span></span><br><span class="line">        self.prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># for root node of trie, init as empty Trie</span></span><br><span class="line">        self.trie = build_tree(words)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, letter: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Search user input in trie with reversed order</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">        self.prefix += letter</span><br><span class="line">        </span><br><span class="line">        cur_node = self.trie</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">reversed</span>(self.prefix):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> cur_node.children:</span><br><span class="line">                <span class="comment"># current char not in Trie, impossible to match words</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            cur_node = cur_node.children[char]</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> cur_node.is_end:</span><br><span class="line">                <span class="comment"># user input match a word in Trie</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># No match</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-Tree"><a href="#tags-Leetcode-Tree" class="headerlink" title="tags: Leetcode Tree"></a>tags: <code>Leetcode</code> <code>Tree</code></h6><h2 id="336-Palindrome-Pairs"><a href="#336-Palindrome-Pairs" class="headerlink" title="336. Palindrome Pairs"></a>336. Palindrome Pairs</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span><br><span class="line">Output: [[0,1],[1,0],[3,2],[2,4]]</span><br><span class="line">Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br><span class="line">Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;a&quot;,&quot;&quot;]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>我们可以暴力解，即<code>O(k*n^2)</code>，反复遍历检查。k 是词的长度，如果 n 远远大于 k，这个算法的效率就会非常低。</p>
<p>假设我们考虑两个词，A和B。检查 A+B 是否形成回文，怎么办呢？首先，我们看 <code>A[0] ?= B[-1]</code>，如果是，继续看；如果不是，即可确定他们不能形成回文。所以，当我们再检查一个词是否可以与给出词组形成回文的时候，我们可以只看那些词头和词尾相同的词，缩小所搜范围。同样的思路可以进一步延伸☞倒数第二个，倒数第三个。。。字母。</p>
<p>实际上这就形成了一个多级的map，用来缩小搜索范围。这个多级map也就是 Trie 的数据结构。</p>
<p>我们反向构造一个 Trie，每个节点有一个flag表示到这个node为止是否形成了一个词。当我们拿到以一个词A，需要与 trie 路径上的词匹配的时候，有两种情况：</p>
<ol>
<li>匹配词长度 &lt;= A的长度</li>
<li>匹配词长度 &gt;  A的长度</li>
</ol>
<p>假设我们有一个 word list： <code>[&#39;acbe&#39;, &#39;ca&#39;, &#39;bca&#39;, &#39;bbac&#39;]</code>，反向可以形成如下 Trie：</p>
<p><img data-src="https://i.imgur.com/wn2uMo1.jpg" alt=""></p>
<p>现在我们看情况1：匹配词长度 &lt;= A的长度，假设我们搜索 <code>acbe</code> 可以匹配出回文的词。首先，我们选择 <code>a</code> 开头的path，因为其他path没有可能。然后看 <code>c</code>，也发现了一个路径，而且c有index标记，是一个终端词。这时候，我们检查余下的部分be是否是回文（也就是看这个组合<code>acbe + ac</code>），发现不是回文，继续看下一个字母b，又发现了一个路径，且是终端词，检查余下的部分，<code>e</code>，是回文（只有一个字母），此时我们就发现了一组，即<code>acbe + bca</code>（记得我们的Trie是逆向构建的，acb就是词bac）。</p>
<p>继续看情况2：匹配词长度 &gt;  A的长度，假设我们搜索<code>ca</code>的可能匹配。选择了上图中间的路径，不过因为ca短，没有到达任何一个词，但是这样也意味着，ca可能跟这个路径上剩下词形成回文，只要剩下的部分是回文。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> w == w[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = defaultdict(Trie1)</span><br><span class="line">        self.index = -<span class="number">1</span></span><br><span class="line">        self.palindrome_below = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_word</span>(<span class="params">self, word, index</span>):</span></span><br><span class="line">        trie = self</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(word)):</span><br><span class="line">            <span class="keyword">if</span> is_palindrome(word[<span class="number">0</span>:<span class="built_in">len</span>(word)-i]):</span><br><span class="line">                trie.palindrome_below.append(index)</span><br><span class="line">            trie = trie.children[c]</span><br><span class="line">        trie.index = index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_trie</span>(<span class="params">words</span>):</span></span><br><span class="line">    trie = Trie1()</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">        trie.add_word(word, i)</span><br><span class="line">    <span class="keyword">return</span> trie</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span>(<span class="params">trie, word, index</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> word:</span><br><span class="line">        <span class="keyword">if</span> trie.index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> is_palindrome(word):</span><br><span class="line">                res.append(trie.index)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word[<span class="number">0</span>] <span class="keyword">in</span> trie.children:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        trie = trie.children[word[<span class="number">0</span>]]</span><br><span class="line">        word = word[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trie.index &gt;= <span class="number">0</span>:</span><br><span class="line">        res.append(trie.index)</span><br><span class="line">    res.extend(trie.palindrome_below)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">words</span>):</span></span><br><span class="line">    trie = make_trie(words)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">        selected = get_palindrome(trie, word, i)</span><br><span class="line">        res.extend([i, c] <span class="keyword">for</span> c <span class="keyword">in</span> selected <span class="keyword">if</span> i!=c)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://fizzbuzzed.com/top-interview-questions-5/">https://fizzbuzzed.com/top-interview-questions-5/</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 4 处理器架构</title>
    <url>/2021/04/16/csapp_4/</url>
    <content><![CDATA[<h1 id="CSAPP-4-处理器架构"><a href="#CSAPP-4-处理器架构" class="headerlink" title="CSAPP 4 处理器架构"></a>CSAPP 4 处理器架构</h1><p>CPU Pipeline 的基本原理，通过将任务拆解成不同的阶段，并行执行多个任务，增加 throughput，相应的会提高延迟。不过这样可以提高CPU的时钟频率，降低延迟。</p>
<p>这是比指令集更低一个的一个层次，每一个指令集指令都被分解成多个不同的阶段，由对应的硬件分别执行。分解后，为并行提供了可能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B C</span><br><span class="line">  A B C</span><br><span class="line">    A B C</span><br></pre></td></tr></table></figure>

<p>Pipeline 的复杂度在于错误处理、每个阶段的延迟等等。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 5 程序的优化</title>
    <url>/2021/04/16/csapp_5/</url>
    <content><![CDATA[<h1 id="CSAPP-5-程序的优化"><a href="#CSAPP-5-程序的优化" class="headerlink" title="CSAPP 5 程序的优化"></a>CSAPP 5 程序的优化</h1><p>优化方式：</p>
<ul>
<li>程序层面<ul>
<li>loop unrolling</li>
<li>减少内存renference</li>
<li>减少函数调用</li>
<li>分支优化</li>
</ul>
</li>
<li>内存优化<ul>
<li>读写循环优化</li>
</ul>
</li>
</ul>
<p>现代CPU都有独立的功能组件进行内存的读取和写入，这些组件通常都有自己的缓存。比如Intel i7处理器的读取单元可以缓存48个读取指令，他们通常可以在一个cycle内完成一个操作。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3 程序的机器层面表达</title>
    <url>/2021/04/15/csapp_3/</url>
    <content><![CDATA[<h1 id="CSAPP-3-程序的机器层面表达"><a href="#CSAPP-3-程序的机器层面表达" class="headerlink" title="CSAPP 3 程序的机器层面表达"></a>CSAPP 3 程序的机器层面表达</h1><p>这一章主要从汇编程序和机器码的角度看程序。包括<code>call stack</code>, <code>local variable</code>, 以及一些基本的数据结构，比如<code>array</code>, <code>structure</code>, <code>union</code> 等等。</p>
<blockquote>
<p>Fun fact: 64位寻址空间是<code>2**48</code> 而不是 <code>2**64</code>。为什么？</p>
</blockquote>
<p>IA32机器码与C语言代码不同，可以接触到一些CPU 的计算状态：</p>
<ul>
<li>程序指针，PC</li>
<li>寄存器文件，regiester file</li>
<li>条件寄存器，</li>
<li>浮点数寄存器</li>
</ul>
<p>机器码层面，类型已经不能存在了，一切都是内存上的字节。</p>
<p>指令集中操作包括：</p>
<ul>
<li>访问内存地址</li>
<li>计算</li>
<li>控制</li>
<li>Procedures</li>
</ul>
<h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><p>寄存器的使用规则一般是依靠规定，比如<code>eax</code>, <code>edx</code>,<code>ecx</code> 是调用者（caller）保留使用的。<code>ebx</code> <code>esi</code> <code>edi</code> 是被调用函数（callee）保留使用的。换句话说，callee必须在执行其他操作前，将 <code>eax</code>, <code>edx</code>,<code>ecx</code> 进栈保存，然后再返回以前，恢复这三个寄存器的值。</p>
<h2 id="Array-Allocation"><a href="#Array-Allocation" class="headerlink" title="Array Allocation"></a>Array Allocation</h2><p>我们需要两个寄存器来进行 Arrary 的读取，一个用来存储Array的地址，另一个用来存储index，例如 <code>(%edx,%ecx,4)</code> 就是一个<code>char *D[5]</code>数列的读取命令，edx存储D的位置，ecx存储需要访问的index，而4就是<code>char *</code>的长度（32位内存地址）。</p>
<h2 id="Structure-和-Union"><a href="#Structure-和-Union" class="headerlink" title="Structure 和 Union"></a>Structure 和 Union</h2><p>一般栈内存分配都是 4 byte 为单位的。Structure就是每个格子长度大小不一致的Array，也是一块连续的内存空间。而union则会划分一块类型不确定的内存空间，可以存储任意类型（长度允许的情况下）。</p>
<p>Union会容易导致bug，但是可以有效的节约内存。比如如下二叉树节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> &#123;</span></span><br><span class="line">    <span class="comment">// 4+4+8 = 16 bytes memory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> &#123;</span></span><br><span class="line">    <span class="comment">// max(8, 4+4) = 8 bytes</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> *<span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125; inernel;</span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> N_LEAF, N_INTERNAL &#125; <span class="keyword">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> &#123;</span></span><br><span class="line">    <span class="comment">// 12 bytes</span></span><br><span class="line">    <span class="keyword">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="keyword">double</span> data;</span><br><span class="line">    &#125; info</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="Problem-3-1"><a href="#Problem-3-1" class="headerlink" title="Problem 3.1"></a>Problem 3.1</h3><p>值包括三种：register, memory, immediate.</p>
<ul>
<li><code>%eax</code>: 0x100，register</li>
<li><code>0x104</code>: 0xAB, memory</li>
<li><code>$0x108</code>: 0x108, Immediate</li>
<li><code>(%eax)</code>: 0xFF，Memory，Address 0x100</li>
<li><code>4(%eax)</code>: 0xAB，偏移量 4 byte, Address 0x104</li>
<li><code>9(%eax,%edx)</code>: 0x11, EAX + 9 + EDX</li>
<li><code>260(%ecx,%edx)</code>: 0xAB, ECX + 260 + EDX，260是十进制的</li>
<li><code>0xFC(,%ecx,4)</code>: 0xFF, 0xFC + ECX * 4, 0x4 + 0xFC = 0x100</li>
<li><code>(%eax,%edx,4)</code>: 0x11, address of 0x10C</li>
</ul>
<h3 id="Problem-3-2"><a href="#Problem-3-2" class="headerlink" title="Problem 3.2"></a>Problem 3.2</h3><p><img data-src="https://i.imgur.com/yJpWTI9.png" alt="寄存器分布"></p>
<p>1 word = 2 byte = 16 bits，所以一个32位寄存器包含4个byte或者2个word或者32bit。</p>
<p>一个16进制的单位，包含4个bit。所以16进制经常是两个两个写在一起，代表一个byte的宽度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl %eax, (%esp)       将 EAX 寄存器的内容移动到 ESP 指向的内存空间</span><br><span class="line">movw (%eax), %dx        将 EAX 寄存器指向的内存空间内容移动到 DX 寄存器，</span><br><span class="line">movb $0xFF, %bl         bl 是特殊寄存器，可以分别单独访问低位的两个byte空间</span><br><span class="line">movb (%esp,%edx,4)     </span><br><span class="line">pushl $0xFF</span><br><span class="line">movw %dx, (%eax)        dx 是高位的两个byte，即 1 word</span><br><span class="line">popl %edi</span><br></pre></td></tr></table></figure>

<p>例子：栈操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subl $4, %esp</span><br><span class="line">movl %ebp, (%esp)       一般采用 pushl ebp 到 栈顶（指向的内存空间）</span><br><span class="line"></span><br><span class="line">movl (%esp),%eax</span><br><span class="line">addl $4,%esp            pop %exa</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-3"><a href="#Problem-3-3" class="headerlink" title="Problem 3.3"></a>Problem 3.3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movb $0xF, (%bl)        bl 只有 8 bit，不能作为 32 bit 内存地址</span><br><span class="line">movl %ax, (%esp)        ax 是高位 2 byte，应该是 movw, movl 需要 4 byte</span><br><span class="line">movw (%eax), (%esp)     不能直接做内存 对 内存 的移动。 （为啥？）</span><br><span class="line">movb %ah,%sh            sh不存在</span><br><span class="line">movl %eax,$0x123        目标不能是 immediate</span><br><span class="line">movl %eax,%dx           dx 长度不够</span><br><span class="line">movb %si, 8(%ebp)       si 长度不够</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-4"><a href="#Problem-3-4" class="headerlink" title="Problem 3.4"></a>Problem 3.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stc_t</span> v;</span><br><span class="line"><span class="keyword">dest_t</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出下面语句的汇编程序</span></span><br><span class="line">*p = (<span class="keyword">dest_t</span>) v;</span><br><span class="line"><span class="comment">// 指针 p 的寄存器是 %edx</span></span><br><span class="line"><span class="comment">// v 的寄存器可以根据数据宽度选择 %eax</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>src_t</th>
<th>dest_t</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>int</td>
<td>movl %eax,(%edx)</td>
</tr>
<tr>
<td>char</td>
<td>int</td>
<td>movsbl %al,(%edx)</td>
</tr>
<tr>
<td>char</td>
<td>unsigned</td>
<td>movsbl %al,(%edx)</td>
</tr>
</tbody></table>
<h3 id="Problen-3-5"><a href="#Problen-3-5" class="headerlink" title="Problen 3.5"></a>Problen 3.5</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode1</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp, <span class="keyword">int</span> *zp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = *xp;  <span class="comment">// %ebx</span></span><br><span class="line">    <span class="keyword">int</span> y = *yp; <span class="comment">// %ebi</span></span><br><span class="line">    <span class="keyword">int</span> z = *zp;<span class="comment">// %eax</span></span><br><span class="line">    </span><br><span class="line">    *yp = x;</span><br><span class="line">    *zp = y;</span><br><span class="line">    *xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-6"><a href="#Problem-3-6" class="headerlink" title="Problem 3.6"></a>Problem 3.6</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leal 6(%eax),%edx         6+x</span><br><span class="line">leal (%eax,%ecx),%edx     x+y</span><br><span class="line">leal (%eax,%ecx,4), %edx  x+4y</span><br><span class="line">leal 7(%eax,%eax,8), %edx 7+8x</span><br><span class="line">leal 0xA(,%ecx,4), %edx   10+4y</span><br><span class="line">leal 9(%eax,%ecx,2), %edx 9+x+2y</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-7"><a href="#Problem-3-7" class="headerlink" title="Problem 3.7"></a>Problem 3.7</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addl  %ecx,(%eax)           0x100    0x100</span><br><span class="line">subl  %edx,4(%eax)          0x104    0xAB - 0x3&#x3D;0xA8</span><br><span class="line">imull $16,(%eax,%edx,4)     0x10C    16 * 0x11&#x3D;0x110</span><br><span class="line">incl  8(%eax)               0x108    0x14</span><br><span class="line">decl  %ecx                  %ecx     0x0</span><br><span class="line">subl  %edx,%eax             %eax     0xFD</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-30"><a href="#Problem-3-30" class="headerlink" title="Problem 3.30"></a>Problem 3.30</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  call next</span><br><span class="line">next:</span><br><span class="line">  popl %eax</span><br></pre></td></tr></table></figure>

<p><code>%eax</code> 的值应该是栈顶刚被推出的值，而<code>call</code>会首先将返回地址压进栈顶，所以<code>%eax</code>应该是函数的返回值地址。但是这不是一个Procedure call，也没有对应的<code>ret</code>指令。这是一个IA32指令集的trick，用来获取 PC 的地址。</p>
<h3 id="Problem-3-32"><a href="#Problem-3-32" class="headerlink" title="Problem 3.32"></a>Problem 3.32</h3><p><code>*p</code> 是第3个参数，<code>d</code> 是第二个参数，</p>
<p><code>short c, char d, int *p, int x</code></p>
<h3 id="Problen-3-43"><a href="#Problen-3-43" class="headerlink" title="Problen 3.43"></a>Problen 3.43</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在第七行：</span><br><span class="line">        80 04 86 43          返回值地址</span><br><span class="line">%ebp -&gt; bf ff fc 94          存储%ebp，push %ebp -&gt; mov %esp,%ebp</span><br><span class="line">        00 00 00 03          存储%edi</span><br><span class="line">        00 00 00 02          存储%exi</span><br><span class="line">        00 00 00 01          %ebx</span><br><span class="line">                             buff[4-7]</span><br><span class="line">                             buff[0-3]</span><br><span class="line">SP   -&gt;</span><br></pre></td></tr></table></figure>


<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculator 123</title>
    <url>/2021/04/15/leetcode_calculator/</url>
    <content><![CDATA[<h1 id="Calculator-I-II-III"><a href="#Calculator-I-II-III" class="headerlink" title="Calculator I,II,III"></a>Calculator I,II,III</h1><ul>
<li><a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a></li>
</ul>
<p>问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s which represents an expression, evaluate this expression and return its value. </span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这道题检测的是栈的使用，基本策略是一个一个的过char，如果看见数字，就累加数字（考虑进位），如果看见操作符号：比如 + -，就把当前结果进栈；如果看见 * / 就从栈顶取出一个数字，操作后进栈。过程中需要保存的状态：上一个符号，当前的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        idx, stack = <span class="number">0</span>, []</span><br><span class="line">        res = <span class="number">0</span>     <span class="comment"># 当前的数字</span></span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span>  <span class="comment"># 前一个符号</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">op, v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>: stack.append(v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;-&quot;</span>: stack.append(-v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>: stack.append(stack.pop() * v)           <span class="comment">#for BC II and BC III</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;/&quot;</span>: stack.append(<span class="built_in">int</span>(stack.pop() / v))      <span class="comment">#for BC II and BC III</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[idx].isdigit():</span><br><span class="line">                res = res*<span class="number">10</span>+<span class="built_in">int</span>(s[idx])</span><br><span class="line">                <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="keyword">elif</span> s[idx] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                update(sign, res)</span><br><span class="line">                <span class="built_in">print</span>(res, sign)</span><br><span class="line">                res, sign = <span class="number">0</span>, s[idx]</span><br><span class="line">                <span class="built_in">print</span>(res, sign)</span><br><span class="line">                <span class="built_in">print</span>(stack)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里不要忘记，因为还有最后一个符号没有处理</span></span><br><span class="line">        update(sign, res)</span><br><span class="line">        <span class="built_in">print</span>(stack)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>

<p>对于有括号的情况，我们需要用到递归，把括号内部的表达式当做一个子问题处理。当遇到左括号的时候，递归计算后面的表达式；遇到右括号的时候，update 函数，然后返回结果以及下一个步的index。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> s[it] == <span class="string">&quot;(&quot;</span>:                                        <span class="comment"># For BC I and BC III</span></span><br><span class="line">    num, j = self.calculate(s[it + <span class="number">1</span>:])</span><br><span class="line">    it = it + j</span><br><span class="line"><span class="keyword">elif</span> s[it] == <span class="string">&quot;)&quot;</span>:                                        <span class="comment"># For BC I and BC III</span></span><br><span class="line">    update(sign, num)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack), it + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode-Stack"><a href="#tags-Leetcode-Stack" class="headerlink" title="tags: Leetcode Stack"></a>tags: <code>Leetcode</code> <code>Stack</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Jump Game (1-3)</title>
    <url>/2021/04/13/leetcode_jump_game/</url>
    <content><![CDATA[<h1 id="Leetcode-Jump-Game-1-3"><a href="#Leetcode-Jump-Game-1-3" class="headerlink" title="Leetcode Jump Game (1-3)"></a>Leetcode Jump Game (1-3)</h1><p>这个系列的三个题虽然名字很像，但是第一和第二个思路类似，属于贪心问题，而第三题其实是搜索问题。</p>
<h2 id="55-Jump-Game-I"><a href="#55-Jump-Game-I" class="headerlink" title="55. Jump Game I"></a>55. Jump Game I</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
</blockquote>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line"> </span><br><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">index.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>给出一个非负数组，要求判断从数组 0 下标开始，能否到达数组最后一个位置。<br>这个题采用贪心算法，在每一个节点都选择跳最远的距离，如果遇到一个点的index超过了能跳的最大距离，则不能到达，否则可以到达。</p>
<p>原理就是在每一个 index 的地方重新评估我们能到达的最远距离，如果 index 已经超过这个最远距离，就断开了。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">    longest = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> i &gt; longest:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    longest = <span class="built_in">max</span>(longest, i+v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>


<h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h2><blockquote>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.<br>Your goal is to reach the last index in the minimum number of jumps.<br>You can assume that you can always reach the last index.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [2,3,0,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>这道题跟上一道题类似，不过是求到达最后一个index的最小步数。还是采用贪心算法，在每一个index地方选择最大的跳跃。如果我们还没有到达最后，就继续跳跃（增加一步）。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        jumps = <span class="number">0</span></span><br><span class="line">        longest = <span class="number">0</span></span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[:-<span class="number">1</span>]):</span><br><span class="line">            longest = <span class="built_in">max</span>(longest, i+v)</span><br><span class="line">            <span class="keyword">if</span> i == cur_pos:</span><br><span class="line">                jumps += <span class="number">1</span></span><br><span class="line">                cur_pos = longest</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure>

<h2 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a>1306. Jump Game III</h2><blockquote>
<p>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.<br>Notice that you can not jump outside of the array at any time.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line"></span><br><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">Output: true </span><br><span class="line">Explanation: </span><br><span class="line">One possible way to reach at index 3 with value 0 is: </span><br><span class="line">index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>这题看起来跟前两个很像，但是其实一个搜索问题。即从 start 开始跳出，每次有两个选择：向左或者向右。具有递归的性质，我们可以做 DFS，需要设置一个 visited 的 set 确保我们不会循环搜索。思路比较清楚：start 点进栈，判断结束条件，然后分别向左、向右所搜，进栈。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack, visited = [start], <span class="built_in">set</span>()</span><br><span class="line">        nums = arr</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            idx = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[idx] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            left = idx - nums[idx]</span><br><span class="line">            right = idx + nums[idx]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                stack.append(left)</span><br><span class="line">                visited.add(left)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                stack.append(right)</span><br><span class="line">                visited.add(right)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-DP-Greedy"><a href="#tags-Leetcode-DP-Greedy" class="headerlink" title="tags: Leetcode DP Greedy"></a>tags: <code>Leetcode</code> <code>DP</code> <code>Greedy</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>DP</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 1 概览</title>
    <url>/2021/04/09/csapp1/</url>
    <content><![CDATA[<h1 id="CSAPP-1-概览"><a href="#CSAPP-1-概览" class="headerlink" title="CSAPP 1 概览"></a>CSAPP 1 概览</h1><p>这本书之前非常简略的阅读过一次，过了这么一年多，重新拿起这本书反倒有了更多理解。可能这就是一本好书的特点把，他随着你的经验增加，提供给你更多的信息。给人的感觉就是，第一次读醍醐灌顶，第二次读，还是醍醐灌顶。。。</p>
<p>作者首先描述了一个 <code>hello</code> 程序是如何从源代码变成可以被执行的机器码，然后通过简单介绍计算机的硬件组成说明了程序是如何被执行的。在这个过程中有几个比较重要的点：</p>
<ul>
<li>编译器就是一个把一段程序（源代码）翻译成另一种程序（机器码）一个程序（机器码）</li>
<li>计算机的主要操作就是读取指令（数据），运算，输出数据</li>
<li>由于不同数据存储介质的读取速度和容量负相关，缓存机制尤其重要</li>
</ul>
<p>随后引入了操作系统的三个重要抽象：</p>
<ul>
<li>进程、线程</li>
<li>文件</li>
<li>虚拟内存</li>
</ul>
<p>作者高度概括了计算机系统设计的两个基本概念：</p>
<ul>
<li>并发和并行</li>
<li>抽象</li>
</ul>
<h2 id="操作系统抽象"><a href="#操作系统抽象" class="headerlink" title="操作系统抽象"></a>操作系统抽象</h2><p><strong>进程</strong></p>
<p>进程，是一个运行的程序的抽象。是实现并发的基本元素，操作系统通过上下文（context）切换让 CPU 在不同进程之间交替执行，从而实现多个程序的并发执行。Context 包括寄存器、内存、程序指针（PC）等。</p>
<p><strong>线程</strong></p>
<p>线程，是存在于进程内部的更小的运行的程序。他们共享父进程的内存空间，但是切换更加迅速。（他们共享 stack 吗？共享 heap 吗？）</p>
<p><strong>虚拟内存</strong></p>
<p>虚拟内存，是一个进程的内存空间抽象。每一个进程虽然都共享主内存，因为有这个抽象，每个进程拥有独立的内存空间。而操作系统和硬件负责虚拟内存和物理内存的映射。</p>
<blockquote>
<p>The basic idea is to store the contents of a process’s virtual memory on disk, and then use the main memory as a <strong>cache</strong> for the disk. </p>
</blockquote>
<p><strong>文件</strong></p>
<p>文件，就是一段连续的字节（byte）。所有的 IO 设备都被抽象成文件。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发和并行是提高运行效率的主要手段，他们体现在不同的层次上，从 CPU 层次，到操作系统，最后是应用程序。</p>
<ul>
<li><strong>线程级别并发</strong></li>
<li>指令级别并行</li>
<li>Single-Instruction, Multiple-Data (SIMD) </li>
<li>green thread</li>
</ul>
<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 2 信息的表达和操作</title>
    <url>/2021/04/09/csapp_2/</url>
    <content><![CDATA[<h1 id="CSAPP-2-信息的表达和操作"><a href="#CSAPP-2-信息的表达和操作" class="headerlink" title="CSAPP 2 信息的表达和操作"></a>CSAPP 2 信息的表达和操作</h1><p>目前的计算机技术存储信息是二进制的，我们用0和1表达信息。最基本的信息有两种：整数和浮点数。字符串也会被编码成整数表达。从根本上说，我们规定了一些规则（向下文）来解释这些0和1。通过基本的代数法则就可以实现运算了。</p>
<p>为了方便人类阅读，常用的编码进制包括8进制和16进制。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;int: %d\n&quot;</span>, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dbl</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;double: %g\n&quot;</span>, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int_arr</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int array: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=(<span class="keyword">sizeof</span>(a))/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_default</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;unknown argument&quot;</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(X) _Generic((X), \</span></span><br><span class="line">        <span class="keyword">int</span>: print_int, \</span><br><span class="line">        <span class="keyword">double</span>: print_dbl, \</span><br><span class="line">        <span class="keyword">int</span>*: print_int_arr, \</span><br><span class="line">        <span class="keyword">default</span>: print_default)(X)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> problem(x) printf(<span class="meta-string">&quot;\n * Problem %s: \n&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> comment(x) printf(<span class="meta-string">&quot;%s\n&quot;</span>, x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span>* x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    *y = *x^*y;</span><br><span class="line">    *x = *x^*y; <span class="comment">/*Step2*/</span></span><br><span class="line">    *y = *x^*y; <span class="comment">/*Step3*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1,2,3  -&gt; 3,2,1</span></span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="keyword">for</span> (first=<span class="number">0</span>, last=cnt<span class="number">-1</span>;</span><br><span class="line">        first &lt; last;</span><br><span class="line">        first++, last--) &#123;</span><br><span class="line">            swap(&amp;a[first], &amp;a[last]);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">1.0</span>;</span><br><span class="line">    show_int(x);</span><br><span class="line">    show_float(y);</span><br><span class="line">    show_pointer(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof float is %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof int is %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">// Problem 2.6</span></span><br><span class="line">    problem(<span class="string">&quot;2.6&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3510593</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3510593.0</span>;</span><br><span class="line">    show_int(b);   <span class="comment">// ? why this shows as same as a?</span></span><br><span class="line">    show_int(a);   <span class="comment">//        1101011001000101000001</span></span><br><span class="line">    show_float(b); <span class="comment">// 1001010010101100100010100000100</span></span><br><span class="line">    <span class="comment">// Problem 2.7</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    show_bytes((byte_pointer)s, <span class="built_in">strlen</span>(s)); <span class="comment">//  61 62 63 64 65 66</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a = 110</span></span><br><span class="line"><span class="comment">    b = 001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    b = a ^ b  -&gt; b = 110 ^ 001 = 111</span></span><br><span class="line"><span class="comment">    a = a ^ b  -&gt; a = 110 ^ 111 = 001</span></span><br><span class="line"><span class="comment">    b = a ^ b  -&gt; b = 001 ^ 111 = 110</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    problem(<span class="string">&quot;2.10&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="number">2</span>;</span><br><span class="line">    swap(&amp;aa, &amp;bb);</span><br><span class="line">    print(aa);</span><br><span class="line">    print(bb);</span><br><span class="line"></span><br><span class="line">    problem(<span class="string">&quot;2.11&quot;</span>);</span><br><span class="line">    comment(<span class="string">&quot;Note that a ^ a = 0&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    print(a2);</span><br><span class="line">    reverse_array(a2, <span class="number">3</span>);</span><br><span class="line">    print(a2);</span><br><span class="line"></span><br><span class="line">    problem(<span class="string">&quot;2.12&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x12 = <span class="number">0x87654321</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, x12 &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, ~( x12 ^ <span class="number">0xFF</span> ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, x12 | <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, ~( <span class="number">0x11</span> ^ <span class="number">0xFF</span> ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>nSum 问题</title>
    <url>/2021/04/09/leetcode_nSum/</url>
    <content><![CDATA[<h1 id="nSum-问题"><a href="#nSum-问题" class="headerlink" title="nSum 问题"></a>nSum 问题</h1><h2 id="2-Sum"><a href="#2-Sum" class="headerlink" title="2 Sum"></a>2 Sum</h2><p>方法1：去重、排序、字典、穷举</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            residual = target - nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> residual <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> [cache[residual], i]</span><br><span class="line">            </span><br><span class="line">            cache[nums[i]] = i</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="3-Sum"><a href="#3-Sum" class="headerlink" title="3 Sum"></a>3 Sum</h2><p>方法1：去重、排序、字典、穷举</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">sum</span>(nums)!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        counter = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            counter[i] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        nums = <span class="built_in">sorted</span>(counter.keys())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            a = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="number">3</span>*a == <span class="number">0</span> <span class="keyword">and</span> counter[a] &gt;= <span class="number">3</span>:</span><br><span class="line">                res.append([a,a,a])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                b = nums[j]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span>*b + a == <span class="number">0</span> <span class="keyword">and</span> counter[b] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res.append([a, b, b])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span>*a + b == <span class="number">0</span> <span class="keyword">and</span> counter[a] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res.append([a, a, b])</span><br><span class="line">                    </span><br><span class="line">                c = -a-b</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> c &gt; b <span class="keyword">and</span> counter[c] &gt;= <span class="number">1</span>:</span><br><span class="line">                    res.append([a, b, c])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-nSum"><a href="#tags-Leetcode-nSum" class="headerlink" title="tags: Leetcode nSum"></a>tags: <code>Leetcode</code> <code>nSum</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>nSum</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题</title>
    <url>/2021/04/08/leetcode_dp/</url>
    <content><![CDATA[<h1 id="动态规划问题"><a href="#动态规划问题" class="headerlink" title="动态规划问题"></a>动态规划问题</h1><p>动态规划问题最鲜明的特点是求最值，问题本身一般可以用重复的、更小的子问题解决（递归特性）。解决方法通常是：递归、备忘录递归、迭代、备忘录迭代。要素是找到：</p>
<ul>
<li>重复子问题</li>
<li>最优子结构</li>
<li>状态转移方程</li>
</ul>
<p>基本套路：<code>写出 base -&gt; 明确所有状态 -&gt; 明确每个状态的选择 -&gt; 定义 dp 数组</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<p>当然也会有一些问题没有明显的求最值的要求，比如 62 Unique Path，但是该问题可以用递归解决，同样的分析也可以用 DP 进行穷举。</p>
<p>问题举例：</p>
<ul>
<li>简单题：<ul>
<li><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></li>
<li><a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></li>
</ul>
</li>
<li>中度题：<ul>
<li><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://leetcode.com/problems/coin-change-2/submissions/">518. Coin Change 2</a></li>
<li><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/combination-sum-iv">377. Combination Sum IV</a></li>
</ul>
</li>
</ul>
<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber</span><br></pre></td></tr></table></figure>

<p>要点在于不能抢隔壁，获得最大收益。最大值是典型的动态规划问题，首先明确状态。面对一个房子（i），我们有两种选择：抢或者不抢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max(抢， 不抢)   # 找到最大值</span><br><span class="line">抢就意味着前一个不能抢，所以抢的收益是： dp[i-2] + num[i]</span><br><span class="line">不抢的收益： dp[i-1]</span><br><span class="line">所以：</span><br><span class="line">max(dp[i-1], dp[i-2]+num[i])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        prev2, prev1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tmp = prev1</span><br><span class="line">            prev1 = <span class="built_in">max</span>(prev2+num, prev1)</span><br><span class="line">            prev2 = tmp</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>

<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>这个问题跟上面的问题其实类似，目标是求最大值。接下来分析状态，可以发现除了 index 以外，我们其实有两个状态：买卖次数 k 和持股状态（0代表持币，1代表持股）。然后可以据此构造 DP 数组：<code>dp[i][k][0|1]</code>，例如 <code>dp[1][1][0]</code> 的意思就是，第一天，还可以交易1次，当前持币。</p>
<p>那么每一天我们的最优解是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + price[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>有了个这个，我们现在只需要搞清楚 base：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][0][0] &#x3D; 0</span><br><span class="line">dp[i][0][1] &#x3D; -inf   # 这种不可能存在，因为 k &#x3D; 0 意味着不能买入，则不可能持有股票</span><br></pre></td></tr></table></figure>

<p>再具体到我们这个问题，k=1，<code>dp[i-1][0][0] = 0</code> 不能交易，又持币，显然不可能有收益。而且注意到 k 其实不能影响状态方程了，也可以省略。我们的 dp 数组就退化成二维了。继续观察，其实只有i 和 i-1 两个状态相关，不需要记录所有的 i，数组就变成 1 维。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        dp_i_0, dp_i_1 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, -prices[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure>

<p>你可能已经发现了，这两个题的解法和代码几乎是一样的。</p>
<p>在 II 的题中，去掉了 <code>k = 1</code> 约束，k 可以无限大，我们只需要稍微更改上面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        dp_i_0, dp_i_1 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            temp = dp_i_0</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, temp-prices[i])  <span class="comment"># 这里 dp[i-1][k-1][0] - prices[i]</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure>


<h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure>

<p>首先这也是个最值问题：最少几个硬币。怎么分析这个问题呢？采用穷举的思想，假设我们需要换 10 元，比较复杂。但是如果我们换 1 元，就很简单，知道了 1 元的方法，2元的最少硬币个数 = min(用这个硬币，不用这个硬币）。对于每一个数量，每一个硬币，我们有两个选择：用这个硬币 和 不用这个硬币。</p>
<p>我们根据这个关系，可以写出如下算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coin_change_322</span>(<span class="params">coins: [<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line">    dp = [amount+<span class="number">1</span>] * ( amount+<span class="number">1</span> )  <span class="comment"># 初始化成最大值，+1 用来标记无解。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 状态1 是总共换钱的数量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 状态2 是硬币的种类</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= c:  <span class="comment"># 只有总量大于该硬币的时候才有意义。</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != amount+<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h3 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a>509. Fibonacci Number</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br><span class="line">给你 n ，请计算 F(n)</span><br></pre></td></tr></table></figure>

<p>这个题其实不属于 DP 问题，因为并不涉及最值求解，但是思路确实非常类似，代码看起来也很类似，只不过去掉了最值的部分，状态只有一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n_1 = <span class="number">0</span></span><br><span class="line">        n_2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            temp = n_2</span><br><span class="line">            n_2 = n_2 + n_1</span><br><span class="line">            n_1 = temp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> n_2</span><br></pre></td></tr></table></figure>


<h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><p>上面的问题多数都有对应的中难度版本，但是只要按照这个框架，也很容易解答。</p>
<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p>这个题的区别在于，头尾相接了。我们只需要重复简单题的算法，然后注意 coner case 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">simple_rob</span>(<span class="params">nums</span>):</span></span><br><span class="line">            prev2, prev1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                tmp = prev1</span><br><span class="line">                prev1 = <span class="built_in">max</span>(prev2+num, prev1)</span><br><span class="line">                prev2 = tmp</span><br><span class="line">            <span class="keyword">return</span> prev1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(simple_rob(nums[<span class="number">1</span>:]), simple_rob(nums[:-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>


<h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure>
<p>这道题难度在于 k=2，不是 1 也不是无穷，更加泛化了。对应到 DP 问题比前两个位多了一个维度，k。回顾我们的状态方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + price[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>现在我们需要两层循环来体现两个状态了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i10, i11 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        i20, i21 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 因为k只有两个状态，我们这里直接展开写了</span></span><br><span class="line">            i20 = <span class="built_in">max</span>(i20, i21+prices[i])</span><br><span class="line">            i21 = <span class="built_in">max</span>(i21, i10-prices[i])</span><br><span class="line">            i10 = <span class="built_in">max</span>(i10, i11+prices[i])</span><br><span class="line">            i11 = <span class="built_in">max</span>(i11, -prices[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> i20</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h3><p>此题存疑，为什么一定要 coin 在外层，而 amoung 在内层才能得到正确答案？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= c:</span><br><span class="line">                    dp[i] = dp[i] + dp[i-c]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Path"><a href="#62-Unique-Path" class="headerlink" title="62. Unique Path"></a>62. Unique Path</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">                <span class="comment"># 注意这里，i j 是两个状态，到达这个状态 有两个子情况</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &lt;= i: </span><br><span class="line">                    dp[i] += dp[i-num]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, N: <span class="type">List</span>[<span class="built_in">int</span>], T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (T + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> N:</span><br><span class="line">                <span class="keyword">if</span> num + i &lt;= T: dp[i+num] += dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[T]</span><br></pre></td></tr></table></figure>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://bbs.cvmart.net/topics/1232">https://bbs.cvmart.net/topics/1232</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349940945">https://zhuanlan.zhihu.com/p/349940945</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349591952">一个大龄博士的刷题转码之路</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie</a></li>
<li><a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems">https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems</a>.</li>
</ul>
<h6 id="tags-Leetcode-DP"><a href="#tags-Leetcode-DP" class="headerlink" title="tags: Leetcode DP"></a>tags: <code>Leetcode</code> <code>DP</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记 Memory Access Synchronization</title>
    <url>/2021/04/05/go_sync/</url>
    <content><![CDATA[<h1 id="Go-学习笔记-Memory-Access-Synchronization"><a href="#Go-学习笔记-Memory-Access-Synchronization" class="headerlink" title="Go 学习笔记 Memory Access Synchronization"></a>Go 学习笔记 Memory Access Synchronization</h1><p>Go 对并发有良好的支持，主要支持两种模式：CSP 和 MAS。前一种是大家熟知的Go常用模式（<code>goroutine</code> + <code>chan</code>），后面一种其实就是传统的带锁的并发编程（<code>sync</code> 包）。Go 对这两种并发都有良好的支持，同时也提倡在合适的时候混合使用他们，因为这两种并发的应用场景不太一样。</p>
<p>但是总体老说，MAS 不是 Go 并发的首选模式，应该在谨慎考虑后使用，尽量多使用 CSP 构造函数。Go 的基本哲学是：</p>
<blockquote>
<p>在可能的场景下使用 channel，将 goroutine 视为非常廉价的操作。</p>
</blockquote>
<h2 id="何时（不）选择-MAS"><a href="#何时（不）选择-MAS" class="headerlink" title="何时（不）选择 MAS"></a>何时（不）选择 MAS</h2><p>MAS实际上就是通过共享内存实现通讯，而CSP正好相反，通过通信实现共享内存。那么他们的应用场景是什么呢？</p>
<p><strong>传递值的所有者</strong></p>
<p>这种场景通常是把一个函数产生的结果（值），传递给另一个函数作为输入。为了确保并发安全，我们需要确保同一时间只有一个 goroutine拥有这个值。<strong>这种场景应该使用 <code>chan</code> 而不是共享内存</strong>，因为通过 channel 可以解耦两个函数，同时确保并发安全。而且，如果使用 buffer channel 还可以实现生产者-消费者模式。</p>
<p><strong>保护某个结构体内部的状态</strong></p>
<p>这种场景锁，即MAS，是最好的工具。因为当出现这种需求的时候，应该用锁把细节隐藏起来，这样调用者不需要担心破坏内部状态。换句话说，用锁控制的 critical section 被很好的局部化了。当你发现你想要传递一个锁来实现某些功能的时候，就应该小心，因为这通常意味着你应该使用 channel 而不是 锁。因为这时候，状态不再是内部状态，破坏了封装特性。</p>
<p><strong>需要协调多个函数的逻辑</strong></p>
<p>这时候应该使用 <code>chan</code>，因为 channel 的组合性更好。Go 通过 select 语句可以很好的支持组合、协作不同的 channle。</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a><code>WaitGroup</code></h2><p><code>WaitGroup</code> 的使用场景：需要等待多个 goroutine 完成，但是不在乎结果，或者有其他的 goroutine 处理结果。如果不符合这个场景，应该考虑使用 <code>chan</code> 和 <code>select</code> 来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hello from %v\n&quot;</span>, id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> numGreeters = <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(numGreeters)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGreeters; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> hello(&amp;wg, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// wait</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的例子，我们启动了5个 goroutine，然后通过 wg 的计数器识别是否所有的 goroutine 已经完成。</p>
<h2 id="Mutex-和-RWMutex"><a href="#Mutex-和-RWMutex" class="headerlink" title="Mutex 和 RWMutex"></a><code>Mutex</code> 和 <code>RWMutex</code></h2><p><code>Mutex</code> 其实就是互斥锁，用来确保内存数据的并发安全。常见的应场景如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span> <span class="comment">// 共享内存</span></span><br><span class="line">	<span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">	increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这是一个常用模式，用来确保锁被释放</span></span><br><span class="line">		<span class="comment">// 因为即使函数 panic 了，defer 也会被执行</span></span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		count++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;增加： %d\n&quot;</span>, count)</span><br><span class="line">	&#125;</span><br><span class="line">	decreament := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		count--</span><br><span class="line">		fmt.Printf(<span class="string">&quot;减小： %d\n&quot;</span>, count)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> arithmetic sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">			increment()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">			decreament()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arithmetic.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序最终输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加： 1</span><br><span class="line">减小： 0</span><br><span class="line">减小： -1</span><br><span class="line">减小： -2</span><br><span class="line">减小： -3</span><br><span class="line">减小： -4</span><br><span class="line">减小： -5</span><br><span class="line">增加： -4</span><br><span class="line">增加： -3</span><br><span class="line">增加： -2</span><br><span class="line">增加： -1</span><br><span class="line">增加： 0</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>如果，我们不用锁来保护共享内存 <code>count</code>，可以发现输出结果是错的。</p>
<p>不过，critical section 的存在影响并发性能，因为这部分的代码是不允许并发的。但是如果仔细思考，如果在没有写入的情况下，read是不需要锁的，可以支持任意数量的并发。因此，引入了 <code>RWMutex</code> 锁，理论上 RW 锁的效率应该更高，但是我们作如下试验：通过增加 observer 协程的数量来观察两种锁的性能区别。结果却不如所料。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			l.Lock()</span><br><span class="line">			l.Unlock()</span><br><span class="line">			time.Sleep(<span class="number">100</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	observer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		l.Lock()</span><br><span class="line">		<span class="keyword">defer</span> l.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	test := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="keyword">int</span>, mutex, rwMutex sync.Locker)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		wg.Add(count + <span class="number">1</span>)</span><br><span class="line">		begineTime := time.Now()</span><br><span class="line">		<span class="keyword">go</span> producer(&amp;wg, mutex)</span><br><span class="line">		<span class="keyword">for</span> i := count; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">go</span> observer(&amp;wg, rwMutex)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> time.Since(begineTime)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tw := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">defer</span> tw.Flush()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">	fmt.Fprintf(tw, <span class="string">&quot;Reader\tRWMutex\tMutex\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">		count := <span class="keyword">int</span>(math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(i)))</span><br><span class="line">		fmt.Fprintf(</span><br><span class="line">			tw,</span><br><span class="line">			<span class="string">&quot;%d\t%v\t%v\n&quot;</span>,</span><br><span class="line">			count,</span><br><span class="line">			test(count, &amp;m, m.RLocker()),</span><br><span class="line">			test(count, &amp;m, &amp;m),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察程序输出，并没有发现明显的效率提升，猜测 Go 的编译器应该是进行了相关的优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reader  RWMutex       Mutex</span><br><span class="line">1       31.407µs      2.889µs</span><br><span class="line">2       9.281µs       28.884µs</span><br><span class="line">4       16.783µs      5.699µs</span><br><span class="line">8       18.108µs      29.188µs</span><br><span class="line">16      17.546µs      21.928µs</span><br><span class="line">32      37.897µs      46.451µs</span><br><span class="line">64      138.729µs     59.443µs</span><br><span class="line">128     84.53µs       84.29µs</span><br><span class="line">256     162.436µs     134.7µs</span><br><span class="line">512     257.119µs     177.244µs</span><br><span class="line">1024    498.188µs     421.574µs</span><br><span class="line">2048    638.593µs     688.569µs</span><br><span class="line">4096    1.282961ms    1.181315ms</span><br><span class="line">8192    2.411899ms    2.194452ms</span><br><span class="line">16384   4.324171ms    4.209515ms</span><br><span class="line">32768   8.863672ms    8.364724ms</span><br><span class="line">65536   17.675036ms   16.549381ms</span><br><span class="line">131072  36.074797ms   32.332008ms</span><br><span class="line">262144  71.848213ms   63.451094ms</span><br><span class="line">524288  146.209094ms  122.38836ms</span><br></pre></td></tr></table></figure>

<p>不过结果仍然可以看出，Go 的运行时在家用机上处理5百万个 goroutine 是非常轻松的。</p>
<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a><code>Cond</code></h2><p><code>Cond</code> 的应用场景是：当一个任务需要等待另一个任务给他信号才能继续的时候，我们需要 Cond 作为信号。换句话说，我们希望等待某个条件成立后，再继续执行后面的指令。</p>
<p>假设我们现在有一个队列，长度限制为2，我们有10个任务需要入列，我们希望一旦队列允许（长度小于2），就马上放入新的任务等待处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	queue := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">	removeFromQueue := <span class="function"><span class="keyword">func</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">		time.Sleep(delay * time.Second)</span><br><span class="line">		c.L.Lock()</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		fmt.Println(<span class="string">&quot;remove from queue&quot;</span>)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">        <span class="comment">// 发送信号</span></span><br><span class="line">		c.Signal()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		c.L.Lock()</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 queue 慢了就等待，阻塞，直到收到信号</span></span><br><span class="line">			c.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;adding to queue&quot;</span>)</span><br><span class="line">		queue = <span class="built_in">append</span>(queue, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> removeFromQueue(<span class="number">1</span>)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cond</code> 还有非常有用的函数：<code>Broadcast</code>。这个函数会像所有等待条件的 goroutine 发送信号！<code>signal</code> 功能可以轻松采用 <code>chan</code> 来模拟，但是 <code>broadcast</code> 就不那么容易，而且它的效率很高。</p>
<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a><code>Once</code></h2><p><code>Once</code> 其实是一个比较常用的抽象，他确保一个函数只会被调用一次，无论有多少个并发的 goroutine 在执行这个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> one sync.Once</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			one.Do(increment)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Count is %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序会打印 1，而不是100。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count++ &#125; </span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count-- &#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once </span><br><span class="line">once.Do(increment) </span><br><span class="line">once.Do(decrement)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count: %d\n&quot;</span>, count)</span><br></pre></td></tr></table></figure>

<p>但是 有个地方需要注意 Once，就是 <code>Once.Do</code> 不会关心调用的函数是不是一样，他只确保 Do 被调用一次！</p>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a><code>Pool</code></h2><p>Pool 是一个并发安全的对象池，主要是用来维护一些开销较大且数量有新的资源，比如数据库连接等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myPool := &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Creating new instance.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;, <span class="comment">// hmm 这是个必要的逗号，但是感觉好多鱼</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inst := myPool.Get()</span><br><span class="line">	myPool.Put(inst)</span><br><span class="line">	myPool.Get()</span><br><span class="line">	<span class="comment">// 这段程序只会维护一个 instance，即使反复的 Get，因为我们 Put</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，Pool 维护的对象是不会被垃圾回收的，这也是我们用 Pool 的主要原因。我们希望维持这些对象，而不是被回收。而且在一些需要性能场景，我们还会提前创立很多对象，形成一个 Pool，以便在需要的时候节约时间，提高吞吐量。</p>
<p>举个网络连接的例子，一下的代码是不采用 pool 的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;cannot listen: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> server.Close()</span><br><span class="line">		wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := server.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;cnanot accept connection: %v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			connectToService()</span><br><span class="line">			fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	daemonStarted := startNetworkDaemon()</span><br><span class="line">	daemonStarted.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNetworkRequest</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;cannot dial host: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := ioutil.ReadAll(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;cannot read: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行： <code>go test -benchtime=10s -bench=.</code> 得到测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: gopl.io&#x2F;ch8</span><br><span class="line">BenchmarkNetworkRequest-12            10        1004815055 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      gopl.io&#x2F;ch8     11.255s</span><br></pre></td></tr></table></figure>

<p>下面我们看一下 Pool 的版本，我们只需要改动两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">warmServiceConnCache</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">	p := &amp;sync.Pool&#123;</span><br><span class="line">		New: connectToService,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		p.Put(p.New())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		connPool := warmServiceConnCache()</span><br><span class="line"></span><br><span class="line">		server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;cannot listen: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">		wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := server.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;cannot accept connection: %v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			svcConn := connPool.Get()</span><br><span class="line">			fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			connPool.Put(svcConn)</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: gopl.io&#x2F;ch8</span><br><span class="line">BenchmarkNetworkRequest-12          1822           7720869 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      gopl.io&#x2F;ch8     32.769s</span><br></pre></td></tr></table></figure>

<p>注意到 ns/op 降低到了 7，000，000 ns， 对比之前的版本是性能提高了约100倍！</p>
<p>但是使用 Pool 也应该注意：</p>
<ul>
<li>New 函数调用时线程安全的！</li>
<li>Get 返回的对象的状态是不完全确定的</li>
<li>记得用 Put 返回对象，不然 Pool 就没有意义了！</li>
<li>一个 Pool 只有一类对象。。。很专一</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/">Concurrency in Go</a></li>
</ul>
<h6 id="tags-Go-Sync"><a href="#tags-Go-Sync" class="headerlink" title="tags: Go Sync"></a>tags: <code>Go</code> <code>Sync</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Sync</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python重建Go并发模型 1</title>
    <url>/2021/04/04/go_python_1/</url>
    <content><![CDATA[<h1 id="用Python重建Go并发模型-1"><a href="#用Python重建Go并发模型-1" class="headerlink" title="用Python重建Go并发模型 1"></a>用Python重建Go并发模型 1</h1><blockquote>
<p>主要译自<a href="http://www.doxsey.net/blog/go-concurrency-from-the-ground-up">Go Concurrency from the Ground Up</a></p>
</blockquote>
<p>通过实现 Go 的并发模型增加对并发的理解和使用。</p>
<p>本文一共四个部分，部分1 针对前两个，后面两个在部分2：</p>
<ul>
<li><a href="#设计">设计</a>：介绍 Go 的并发模型基本API</li>
<li><a href="#实现1：非抢占调度">实现1</a>：实现一个非抢占、单线程的 goroutine 调度器</li>
<li>实现2：带缓冲的 Channel</li>
<li>实现3：Async/Await 范式实现</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我们的设计主要包含三个主要部分：调度器、channel和select操作。有了这几个东西，我们就可以重建 go 的并发模型。</p>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><p>考虑如下简单程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125; <span class="comment">// prevent the program from terminating, ignore for now</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> aa()</span><br><span class="line">	<span class="keyword">go</span> ab()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aa</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;aa&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ab</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;ab&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> ba()</span><br><span class="line">	<span class="keyword">go</span> bb()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ba</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;ba&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bb</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;bb&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>go run main.go</code> 会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ go run main.go</span><br><span class="line">bb</span><br><span class="line">ba</span><br><span class="line">ab</span><br><span class="line">aa</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">        mani.go:6 +0x52</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>程序首先启动两个 goroutine，<code>a</code> 和 <code>b</code>，然后他们分别会启动两个给子的子协程。这里需要注意，goroutine 本身是没有父子关系的（对吗？）。程序的执行情况如下所示：</p>
<p><img data-src="https://i.imgur.com/TKxKBUK.png" alt="并行执行"></p>
<p>每一个 goroutine 会占据一个线程，实现了并行并发。但是执行顺序也是随机的，我们看到 <code>bb</code> 比 <code>ab</code> 更先被打印了。</p>
<p>但是，我们也观察到程序出现了 fatal error，因为 select 是阻塞操作，为了让方便观察结果，但是由于 runtime 已经没有任何活跃的 goroutine 了，程序就会报错。（当然，main goroutine 仍然是活跃的）。</p>
<p>当然，我们也可以通过同步操作，让所有 goroutine 在一个线程中执行。</p>
<p><img data-src="https://i.imgur.com/YbRfzzW.png" alt="顺序执行"></p>
<p>这两种调度方式都可以，但是为了简化我们后面的实现，我们选择后者，即单线程并发。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Go 通过 Chan 实现并发通讯。考虑如下程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> a(ch)</span><br><span class="line">	<span class="keyword">go</span> b(ch)</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125; <span class="comment">// prevent the program from terminating, ignore for now</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;a before&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="number">5</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;a after&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;b before&quot;</span>)</span><br><span class="line">	<span class="built_in">println</span>(&lt;-ch)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;b after&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ch</code> 对象，我们可以确保 “b after” 一定会在 “a before” 以后执行。这就是所谓的同步，而两个 goroutine 就是在 <code>ch</code> 发生连接。</p>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ go run main.go</span><br><span class="line">b before</span><br><span class="line">a before</span><br><span class="line">5</span><br><span class="line">b after</span><br><span class="line">a after</span><br></pre></td></tr></table></figure>

<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>Go  的 <code>select</code> 语句可以用来等待多个 Chan，然后处理第一个被释放的 Chan。</p>
<p>看如下程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1, ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> a(ch2)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch1:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;1:&quot;</span>, value)</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch2:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;2:&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select 会同时等待 ch1 和 ch2，由于 a 会向 ch2 传递值，select 选择第二个branch，打印 <code>2：</code>。</p>
<h2 id="实现1：非抢占调度"><a href="#实现1：非抢占调度" class="headerlink" title="实现1：非抢占调度"></a>实现1：非抢占调度</h2><p>我们首先来看下 Go 的并发 API：</p>
<table>
<thead>
<tr>
<th></th>
<th>Python</th>
<th>Go</th>
</tr>
</thead>
<tbody><tr>
<td><code>go</code></td>
<td><code>go(lambda: print(&quot;in py routine&quot;))</code></td>
<td><code>go println(&quot;in py routine&quot;)</code></td>
</tr>
<tr>
<td><code>make</code></td>
<td><code>ch = make()</code></td>
<td><code>ch := make(chan int)</code></td>
</tr>
<tr>
<td><code>len</code></td>
<td><code>len(ch)</code></td>
<td><code>len(ch)</code></td>
</tr>
<tr>
<td><code>cap</code></td>
<td><code>cap(ch)</code></td>
<td><code>cap(ch)</code></td>
</tr>
<tr>
<td><code>send</code></td>
<td><code>send(ch, 5, lambda: print(&quot;sent&quot;))</code></td>
<td><code>ch &lt;- 5</code></td>
</tr>
<tr>
<td><code>recv</code></td>
<td><code>recv(ch, lambda value, ok: pass)</code></td>
<td><code>value, ok := &lt;- ch</code></td>
</tr>
<tr>
<td><code>close</code></td>
<td><code>close(ch)</code></td>
<td><code>close(ch)</code></td>
</tr>
<tr>
<td><code>select</code></td>
<td><code>select([(), ()])</code></td>
<td><code>select &#123;case ..&#125;</code></td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>run()</code></td>
<td>在主函数自动执行</td>
</tr>
</tbody></table>
<p>我们看到 Python 版本的 API 中 send 和 recv 函数都有带有一个回调函数，这些是为了在阻塞之后可以继续执行回调函数。这种方式比较容易实现调度，但是看起来有点不舒服，在最后一个部分，我们会采用 python 的 <code>async</code> 和 <code>await</code> 语法去掉回调函数。</p>
<p>API 有了，我们还需要实现一些数据结构，比如 Channel。Channel 的本质其实就是阻塞队列。我们采用如下实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.closed = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 这里是两个队列用来存放发送和接受的信息</span></span><br><span class="line">        self.waiting_to_send = WaitingQueue()</span><br><span class="line">        self.waiting_to_recv = WaitingQueue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingQueue</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        self.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self, x=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x = self.pop(<span class="number">0</span>)</span><br><span class="line">            WaitingQueue.total -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = self.index(x)</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.pop(idx)</span><br><span class="line">                WaitingQueue.total -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>接下来我们实现调度相关的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">execution_queue = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span>(<span class="params">callback</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>:</span><br><span class="line">        execution_queue.appendc(callback)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    WaitingQueue.total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> execution_queue:</span><br><span class="line">        <span class="comment"># 进入执行循环</span></span><br><span class="line">        f = execution_queue.pop(<span class="number">0</span>)</span><br><span class="line">        f()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> WaitingQueue.total &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果执行队列已经空了，但是还有在等待的任务，就会形成 deadlock</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;fatal error: all goroutines are asleep - deadlock&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Channel Methods</strong></p>
<p>相关的解释直接放在代码注释，目的就是模拟 Go 对 API 的各种 spec。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span>():</span></span><br><span class="line">    <span class="keyword">return</span> Channel()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">chan</span>):</span></span><br><span class="line">    <span class="comment"># unbuffered channel 长度永远是0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cap</span>(<span class="params">chan</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">chan, value, callback</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Go&#x27;s Spec: </span></span><br><span class="line"><span class="string">    Communication blocks until the send can proceed.</span></span><br><span class="line"><span class="string">    A send on an unbuffered channel can proceed if a receiver is ready.</span></span><br><span class="line"><span class="string">    [...] A send on a closed channel proceeds by causing a run-time panic. </span></span><br><span class="line"><span class="string">    A send on a nil channel blocks forever.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Nil chan 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># chan 关闭，panic</span></span><br><span class="line">    <span class="keyword">if</span> chan.closed:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;panic: send on closed channel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 有接受请求，处理</span></span><br><span class="line">    <span class="keyword">if</span> chan.waiting_to_recv:</span><br><span class="line">        receiver = chan.waiting_to_recv.dequeue()</span><br><span class="line">        go(callback)</span><br><span class="line">        go(<span class="keyword">lambda</span>: receiver(value, <span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无接收请求，入队，阻塞</span></span><br><span class="line">    chan.waiting_to_send.enqueue((value, callback))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">channel, callback</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Go&#x27;s Spec:</span></span><br><span class="line"><span class="string">    The expression blocks until a value is available. </span></span><br><span class="line"><span class="string">    Receiving from a nil channel blocks forever.</span></span><br><span class="line"><span class="string">    A receive operation on a closed channel can always proceed immediately, </span></span><br><span class="line"><span class="string">     yielding the element type&#x27;s zero value after any previously sent values have been received.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># &quot;Receiving from a nil channel blocks forever.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;if anything is currently blocked on sending for this channel, receive it&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel.waiting_to_send:</span><br><span class="line">        value, sender = channel.waiting_to_send.dequeue()</span><br><span class="line">        go(<span class="keyword">lambda</span>: callback(value, <span class="literal">True</span>))</span><br><span class="line">        go(sender)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;A receive operation on a closed channel can always proceed immediately,</span></span><br><span class="line">    <span class="comment"># yielding the element type&#x27;s zero value after any previously sent values have been received.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel.closed:</span><br><span class="line">        go(<span class="keyword">lambda</span>: callback(<span class="literal">None</span>, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    channel.waiting_to_recv.enqueue(callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">channel</span>):</span></span><br><span class="line">    <span class="comment"># if the channel is already closed, we panic</span></span><br><span class="line">    <span class="keyword">if</span> channel.closed:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;close of closed channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">    channel.closed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># complete any senders</span></span><br><span class="line">    <span class="keyword">while</span> channel.waiting_to_send:</span><br><span class="line">        value, callback = channel.waiting_to_send.dequeue()</span><br><span class="line">        send(channel, value, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># complete any receivers</span></span><br><span class="line">    <span class="keyword">while</span> channel.waiting_to_recv:</span><br><span class="line">        callback = channel.waiting_to_recv.dequeue()</span><br><span class="line">        recv(channel, callback)</span><br></pre></td></tr></table></figure>

<p><code>select</code> API 实现相对复杂，我们的目的是如下使用场景：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select(</span><br><span class="line">  [</span><br><span class="line">    (recv, ch1, <span class="keyword">lambda</span> v1, ok: <span class="built_in">print</span>(<span class="string">&quot;received!&quot;</span>, v1, ok)),</span><br><span class="line">    (send, ch2, v2, <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;sent!&quot;</span>)),</span><br><span class="line">    (default, <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;default!&quot;</span>))</span><br><span class="line">  ],</span><br><span class="line">  <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;after select&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对应的 Go 程序为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v1, ok := &lt;-ch1:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;received!&quot;</span>, v1, ok)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- v2:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;sent!&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;default!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;after select&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>根据 Spec，select的行为如下：</p>
<ul>
<li>如果有一个或以上 case 可以执行，随机选择一个执行</li>
<li>如果没有 case 可以执行，执行 default</li>
<li>如果内有 case 可以执行，也没有 default，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># used to indicate the default case in a select</span></span><br><span class="line">default = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span>(<span class="params">cases, callback=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_ready</span>(<span class="params">case</span>):</span></span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            <span class="keyword">return</span> case[<span class="number">1</span>].closed <span class="keyword">or</span> case[<span class="number">1</span>].waiting_to_recv</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            <span class="keyword">return</span> case[<span class="number">1</span>].closed <span class="keyword">or</span> case[<span class="number">1</span>].waiting_to_send</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == default:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first see if any of the cases are ready to proceed</span></span><br><span class="line">    ready = [case <span class="keyword">for</span> case <span class="keyword">in</span> cases <span class="keyword">if</span> is_ready(case)]</span><br><span class="line">    <span class="keyword">if</span> ready:</span><br><span class="line">        <span class="comment"># pick a random one</span></span><br><span class="line">        case = ready[randint(<span class="number">0</span>, builtins.<span class="built_in">len</span>(ready)-<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            send(case[<span class="number">1</span>], case[<span class="number">2</span>], case[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            recv(case[<span class="number">1</span>], case[<span class="number">2</span>])</span><br><span class="line">        go(callback)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># next see if there&#x27;s a default case</span></span><br><span class="line">    defaults = [case <span class="keyword">for</span> case <span class="keyword">in</span> cases <span class="keyword">if</span> case[<span class="number">0</span>] == default]</span><br><span class="line">    <span class="keyword">if</span> defaults:</span><br><span class="line">        defaults[<span class="number">0</span>]()</span><br><span class="line">        go(callback)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># finally we will enqueue each case into the waiting queues</span></span><br><span class="line">    <span class="comment"># we also update each callback so it will cleanup all the</span></span><br><span class="line">    <span class="comment"># other cases so only one is fired</span></span><br><span class="line"></span><br><span class="line">    wrapped = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanup</span>():</span></span><br><span class="line">        <span class="keyword">for</span> case <span class="keyword">in</span> wrapped:</span><br><span class="line">            <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">                case[<span class="number">1</span>].waiting_to_send.dequeue((case[<span class="number">2</span>], case[<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">                case[<span class="number">1</span>].waiting_to_recv.dequeue(case[<span class="number">2</span>])</span><br><span class="line">        go(callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overwrite all the callbacks and enqueue into the waiting queues</span></span><br><span class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> cases:</span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            new_case = (case[<span class="number">0</span>], case[<span class="number">1</span>], case[<span class="number">2</span>],</span><br><span class="line">                        <span class="keyword">lambda</span>: (cleanup(), case[<span class="number">3</span>]()))</span><br><span class="line">            case[<span class="number">1</span>].waiting_to_send.enqueue((new_case[<span class="number">2</span>], new_case[<span class="number">3</span>]))</span><br><span class="line">            wrapped.append(new_case)</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            new_case = (case[<span class="number">0</span>], case[<span class="number">1</span>],</span><br><span class="line">                        <span class="keyword">lambda</span> value, ok: (cleanup(), case[<span class="number">2</span>](value, ok)))</span><br><span class="line">            case[<span class="number">1</span>].waiting_to_recv.enqueue(new_case[<span class="number">2</span>])</span><br><span class="line">            wrapped.append(new_case)</span><br></pre></td></tr></table></figure>

<h2 id="一个例子-Concurrent-Merge-Sort"><a href="#一个例子-Concurrent-Merge-Sort" class="headerlink" title="一个例子 Concurrent Merge Sort"></a>一个例子 Concurrent Merge Sort</h2><p>一下是一个 go 版本的并发排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(l, r []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(l)+<span class="built_in">len</span>(r))</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(l) &gt; <span class="number">0</span> || <span class="built_in">len</span>(r) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">len</span>(l) == <span class="number">0</span>:</span><br><span class="line">			m = <span class="built_in">append</span>(m, r[<span class="number">0</span>])</span><br><span class="line">			r = r[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">len</span>(r) == <span class="number">0</span>:</span><br><span class="line">			m = <span class="built_in">append</span>(m, l[<span class="number">0</span>])</span><br><span class="line">			l = l[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> l[<span class="number">0</span>] &lt;= r[<span class="number">0</span>]:</span><br><span class="line">			m = <span class="built_in">append</span>(m, l[<span class="number">0</span>])</span><br><span class="line">			l = l[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> l[<span class="number">0</span>] &gt; r[<span class="number">0</span>]:</span><br><span class="line">			m = <span class="built_in">append</span>(m, r[<span class="number">0</span>])</span><br><span class="line">			r = r[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMergSort</span><span class="params">(xs []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(xs) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> merge(xs[:<span class="number">1</span>], xs[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lc, rc := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lc &lt;- ConcurrentMergSort(xs[:<span class="built_in">len</span>(xs)/<span class="number">2</span>])</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			rc &lt;- ConcurrentMergSort(xs[<span class="built_in">len</span>(xs)/<span class="number">2</span>:])</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> merge(&lt;-lc, &lt;-rc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	b := ConcurrentMergSort(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用对应的Python API 实现为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l, r</span>):</span></span><br><span class="line">    m = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(l) &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(r) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">0</span>:</span><br><span class="line">            m.append(r[<span class="number">0</span>])</span><br><span class="line">            r = r[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(r) == <span class="number">0</span>:</span><br><span class="line">            m.append(l[<span class="number">0</span>])</span><br><span class="line">            l = l[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> l[<span class="number">0</span>] &lt;= r[<span class="number">0</span>]:</span><br><span class="line">            m.append(l[<span class="number">0</span>])</span><br><span class="line">            l = l[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m.append(r[<span class="number">0</span>])</span><br><span class="line">            r = r[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concurrent_merge_sort</span>(<span class="params">xs, callback</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(xs) &lt;= <span class="number">1</span>:</span><br><span class="line">        callback(xs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lc, rc = make(), make()</span><br><span class="line">        go(<span class="keyword">lambda</span>: concurrent_merge_sort(xs[:<span class="built_in">len</span>(xs)//<span class="number">2</span>], <span class="keyword">lambda</span> l:</span><br><span class="line">                                         send(lc, l, <span class="keyword">lambda</span>: <span class="literal">None</span>)))</span><br><span class="line">        go(<span class="keyword">lambda</span>: concurrent_merge_sort(xs[<span class="built_in">len</span>(xs)//<span class="number">2</span>:], <span class="keyword">lambda</span> r:</span><br><span class="line">                                         send(rc, r, <span class="keyword">lambda</span>: <span class="literal">None</span>)))</span><br><span class="line">        recv(lc, <span class="keyword">lambda</span> l, ok:</span><br><span class="line">             recv(rc, <span class="keyword">lambda</span> r, ok:</span><br><span class="line">                  callback(merge(l, r))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># example usage:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_concurrent_merge_sort</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">result</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> result == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    concurrent_merge_sort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], callback)</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>


<h6 id="tags-Go-Python"><a href="#tags-Go-Python" class="headerlink" title="tags: Go Python"></a>tags: <code>Go</code> <code>Python</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>Go</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记5 并发编程</title>
    <url>/2021/04/02/go_5/</url>
    <content><![CDATA[<h1 id="Go-学习笔记5-并发编程"><a href="#Go-学习笔记5-并发编程" class="headerlink" title="Go 学习笔记5 并发编程"></a>Go 学习笔记5 并发编程</h1><p>Go 的一个主要的特征是对多核并发的支持，特别是 CSP（Communicating Sequential Processes） 模型。Go 主要支持两类并发模型：CSP 和 共享内存。</p>
<h2 id="CSP-模型"><a href="#CSP-模型" class="headerlink" title="CSP 模型"></a>CSP 模型</h2><p>Go 的 CSP 模型主要是通过 goroutine 和 channel 两个基本模块完成的。</p>
<h3 id="Goroutine-（协程）"><a href="#Goroutine-（协程）" class="headerlink" title="Goroutine （协程）"></a>Goroutine （协程）</h3><p>goroutine 本质上属于协程，即可以多次中断和重启的函数。而当go执行进入main函数的时候，都会启动一个 goroutine，即 main goroutine。值得注意的是，一旦主协程结束，Go 会结束其他一切协程。后文中协程和goroutine取相同的意思。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// spinner 会跟 fib 函数“同时”进行</span></span><br><span class="line">	<span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">	fibN := fib(n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\rFib(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">			time.Sleep(delay)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个简单的例子，一个普通函数在调用时加入 go 关键字后，runtime会启动一个新的协程运行该函数。Goroutine 是可以nested的，即可以在goroutine内部启动其他的协程。</p>
<h3 id="Chan"><a href="#Chan" class="headerlink" title="Chan"></a>Chan</h3><p>Goroutine 实现了任务的并发执行，而任务之间的沟通是通过 <code>channel</code> 完成的。一个 goroutine 可以通过 channel 发送信息给其他 goroutine 或者接受信息。我们可以通过<code>make(chan [T])</code> 来获得一个类型为 T 的 chan 的指针。 chan 类型支持两个通讯操作：<code>ch &lt;- x</code> 和 <code>&lt;-ch</code>，分别代表发送和接受。支持一个 close 函数来关闭Chan。Chan还有自己的承载能力（capacity）。</p>
<h4 id="无缓冲-Chan"><a href="#无缓冲-Chan" class="headerlink" title="无缓冲 Chan"></a>无缓冲 Chan</h4><p>Chan 的通讯操作都是阻塞的，无缓冲管道也叫做同步管道。因为这种管道可以保证信息的读取和发送顺序。</p>
<p>Chan 可以用来连接多个 goroutine 形成一个 pipeline。这种模式形成了有趣的编程模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">			naturals &lt;- x</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// without this, dead lock , guess why?</span></span><br><span class="line">		<span class="built_in">close</span>(naturals)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			x, ok := &lt;-naturals</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			squares &lt;- x * x</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(squares)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">		fmt.Println(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向-Chan"><a href="#单向-Chan" class="headerlink" title="单向 Chan"></a>单向 Chan</h4><p>上面提到的 Chan 是双向，我们也可以指定单向 Chan。上面的管道程序可以重写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">		out &lt;- x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		out &lt;- v * v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> counter(naturals)</span><br><span class="line">	<span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">	printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲-Chan"><a href="#缓冲-Chan" class="headerlink" title="缓冲 Chan"></a>缓冲 Chan</h4><p>缓冲 Chan 某种程度解除了同步性。</p>
<p>Chan 与 Go 的调度器有紧密的联系，应该谨慎使用，特别是应该确保他们有接收端和发送端。如果一个 goroutine 永远无法从 chan 获得信息，或造成 goroutine 泄漏，即使 GC 也无法回收他们。</p>
<p>选择缓冲 Chan 的 capacity 也很重要，如果缓冲值不够，会造成 deadlock。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们举个例子，我们有10个计算任务，但是每个任务的执行时间随机，我们希望并发执行，并且搜集结果。</p>
<p>首先，我们通过一个缓冲 Chan 存储计算结果并且确定何时全部任务完成。然后，我们把任务包裹进入 goroutine进行执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n := rand.Intn(<span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Executing task, need %d second\n&quot;</span>, n)</span><br><span class="line">	time.Sleep(time.Duration(n) * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	number <span class="keyword">int</span></span><br><span class="line">	err    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">var</span> tasksNum <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> finalRes []result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> result, tasksNum)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">var</span> res result</span><br><span class="line">			res.number, res.err = task()</span><br><span class="line">			ch &lt;- res</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">		res := &lt;-ch</span><br><span class="line">		finalRes = <span class="built_in">append</span>(finalRes, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(finalRes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h2><p>讨论了半天并发，究竟什么是并发？假设我们有两个任务，A 和 B，什么叫 AB 的并发执行？其实，并发这个概念是针对事件，event，的发生顺序定义的。当我们可以确定的知道两个事件的发生顺序，那么这两个事件就是顺序的，反之就是并发的。</p>
<p>共享内存模型有一个常见且严重的问题：race condition，RC。RC是指一个内存区域（变量）被两个或以上线程/协程/进程并发访问且其中至少一个是写入操作的状态。根据定义，我们有三种方式避免RC：</p>
<ul>
<li>不要写入内存</li>
<li>不要并发访问内存，比如通过使用 Chan</li>
<li>并发访问内存，但是一次只允许一个线程访问，mutual exclusion</li>
</ul>
<p>第三种其实就是锁。Go 可以使用 buffer 为 1 的 Chan 模拟，或者直接使用 <code>sync.Mutex</code>。</p>
<p>使用锁或者 Chan 也会影响到内存的同步。现代的 CPU 一般都有内存缓存，CPU核心不会直接把内容写入内存，而是先写入缓存，然后再特定的时间Commit到内存上。这个过程commit的顺序不一定与写入的顺序的同步的。</p>
<p>常用的模式就是：在可能地方，把变量控制在同一个协程内部，对于其他变量采用锁控制访问。</p>
<p>Go 提供了 <code>-face</code> flag 来帮助检测 RC。</p>
<h2 id="Goroutine-和-线程-的异同"><a href="#Goroutine-和-线程-的异同" class="headerlink" title="Goroutine 和 线程 的异同"></a>Goroutine 和 线程 的异同</h2><p>最大的区别在于 call stack 的大小。线程根据系统不同，通常分配一个固定大小的 call stack ，通常是 2MB。而 Goroutine 的 call stack 大小是可变的，初始值只有 2KB，而通常可以增大到 1GB。</p>
<p>第二个区别在于调度。线程由系统负责调度，每个几百ms，会通过触发中断将CPU的执行权交还给 kernel，而 kernel 需要一些列的操作完成线程切换：保存用户线程状态，读取下一个线程的状态，更新调度器数据结构。而 Go 的运行时则不是完全抢占式调度，它会根据 goroutine 执行的指令进行灵活调度，比如一个 goroutine 调用 sleep，Go 会中断他执行另一个协程，而在苏醒的时候唤醒之前的进程。而且切换过程不涉及 kernel 的一系列转换。</p>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记3 程序的构成</title>
    <url>/2021/03/30/go_3/</url>
    <content><![CDATA[<h1 id="Go-学习笔记3-程序的构成"><a href="#Go-学习笔记3-程序的构成" class="headerlink" title="Go 学习笔记3 程序的构成"></a>Go 学习笔记3 程序的构成</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>Go 采用驼峰命名：<code>thisVarIsGood</code>。如果一个 package 中的函数采用大写字母开头，这个函数可以被外界调用，否则隐藏，比如 <code>fmt.Println</code>。</p>
<p>Go 的声明语句主要有四种：<code>var</code>, <code>const</code>, <code>type</code>, <code>func</code>。</p>
<p><code>var</code>，变量声明：<code>var name type = expression</code>。如果省略 expression 的部分，Go 会给变量合法的初始值。<code>:=</code> 表达式，是简化的声明。</p>
<p>指针是变量的地址，并不是每一个值都有地址，但是每一个变量都有地址。<code>new</code> 函数会返回该类型的指针。</p>
<p>Go 的编译器会根据变量的具体生命周期决定是堆分配还是栈分配，生命周期也会影响垃圾回收的效率，如果一个局部变量被外部变量引用，那么即使函数已经返回，这个局部变量也不会被回收，同时编译器也会对他进行堆分配，而不是栈分配。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Go 的类型系统相对比较简单（简陋？），主要类型包括四种：基本类型、组合类型、引用类型和接口类型。</p>
<p>基本类型主要包括：</p>
<ul>
<li>整数, int8, int16, int32, int64, 还有无符号版本，uintptr</li>
<li>浮点数, float16, float32</li>
<li>复数, complex(r, i)</li>
<li>布尔, true, false</li>
<li>字符串, an immutable sequence of bytes. 可以是任何byte，通常是可读的字符串</li>
</ul>
<h2 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h2><ul>
<li>Array</li>
<li>Slice</li>
<li>Map</li>
<li>Struct</li>
</ul>
<p>Array 是长度固定、类型固定的连续内存空间。Array 初始化方式比较丰富：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Array 也可以用指针访问（就像 C 一样，<code>[]</code> 仅仅是指针的语法糖）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Slice 是长度可变的、类型固定的连续内存空间。一个 Slice 包含三个部分：头指针、长度、长度极限。Slice 与 Array 不同，是不可比的。但是，可以测试 Slice 是否是 Nil。</p>
<p>Maps 是哈希表，可以nest。</p>
<p>Struct 类似 C 的结构体，是一个多种类型的组合类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>整体感觉 Go 的程序构成与 C 语言非常类似。看起来就像带有 GC 和 并发内置的现代版本的 C 语言。</p>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记4 抽象方法</title>
    <url>/2021/03/30/go_4/</url>
    <content><![CDATA[<h1 id="Go-学习笔记4-抽象模式"><a href="#Go-学习笔记4-抽象模式" class="headerlink" title="Go 学习笔记4 抽象模式"></a>Go 学习笔记4 抽象模式</h1><p>Go 的抽象方法主要通过函数、方法和接口三种方式。</p>
<h2 id="函数，Function"><a href="#函数，Function" class="headerlink" title="函数，Function"></a>函数，Function</h2><p>Go 中函数是一等公民，可以被传递、返回，具有类型，是组织程序的基本元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func name(params-list) (returns-list) &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>returns-list 是可选的，但是如果写明，则函数内部构造局部变量，并且会被返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">funcsub(x,yint)(zint) &#123;z=x-y;<span class="keyword">return</span>&#125;  <span class="comment">// 注意这里需要 return 关键字，但是不需要 z</span></span><br></pre></td></tr></table></figure>

<p>Go 的函数参数没有默认值，参数的名字也不重要。（ hmm 会不会很不方便？）函数全部是 call by value，即复制传入参数。</p>
<p>Go 递归函数的深度可以非常深，call stack 可以达到几个G大小。</p>
<p>Go 的函数支持多值返回。（很方便，而且返回值和状态是常用模式）</p>
<p>Go 的函数没有异常捕捉机制，而是显式采用 error 处理，如果真的出现异常，程序会直接 panic 终止，以避免进一步的问题。（ 有意思，不知道工程特性如何。好处是可以尽早的发现bug地点 ）</p>
<p>Go 支持参数可变函数。</p>
<p><code>defer</code> 很特别，可以延迟调用函数，有点类似 Python 的上下文管理。但是可能有更多的使用场景。</p>
<p><code>panic</code> 以后，defer 的函数仍然会执行！</p>
<p>panic 之后一般程序就会放弃执行，但是可以通过 recover 恢复执行。</p>
<h2 id="组合和封装"><a href="#组合和封装" class="headerlink" title="组合和封装"></a>组合和封装</h2><h3 id="绑定类型和函数"><a href="#绑定类型和函数" class="headerlink" title="绑定类型和函数"></a>绑定类型和函数</h3><p>Go 的面向对象功能主要是通过 Method 实现封装和组合。我们可以为结构体类型指定相应的方法。所以在 Go 中并不强制绑定类型和方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// &quot;5&quot;, function call</span></span><br><span class="line">fmt.Println(p.Distance(q))  <span class="comment">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>

<p>按照如下语法定义方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里直接传入Path的拷贝，（path Path）叫做 receiver argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过传入指针避免拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path *Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该注意的是，如果一个对象的方法是指针传入，那么按照传统，所有的其他方法都应该是指针传入，即使某些方法并不需要指针。</p>
<h3 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h3><p>组合类型主要是通过重复使用struct。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可一个 unnamed strcut 使用 method</span></span><br><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loopup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>Go 通过首字母大小写区分是否 export 该变量或者函数。大写首字母会被export，小写则被封装。</p>
<h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口, Interface"></a>接口, Interface</h2><p>Go 的接口与其他语言类型，但是是隐式满足的，即一个类型不需要实现全部接口。（这是一个好主意么？）</p>
<p>接口类型与之前提到的concrete类型不用，一个实类型会明确数据结构以及该类型支持的具体函数（方法）。换句话说，当我们看到一个实类型，我们明确的知道这个类型可以做什么。而 Interface 类型属于抽象类型，他们仅仅确定该类型应该支持的操作函数的签名，但是不知道他具体会做什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们还可以组合 interface</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让函数接受任意类型，我们可以传入 <code>interface&#123;&#125;</code> 类型。编译器会负责检查结构是否满足。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>Go 的 interface 可以有两种不同的使用范式：subtype polymorphism 和 ad hoc polymorphism。</p>
<p>后续专门讨论。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记2 语法、语义</title>
    <url>/2021/03/28/go_2/</url>
    <content><![CDATA[<h1 id="Go-学习笔记2：语法和语义"><a href="#Go-学习笔记2：语法和语义" class="headerlink" title="Go 学习笔记2：语法和语义"></a>Go 学习笔记2：语法和语义</h1><p>这个部分主要总结 Go 涉及的基本语法和语义，即之前提到的前两个角度。</p>
<h2 id="整体印象"><a href="#整体印象" class="headerlink" title="整体印象"></a>整体印象</h2><ul>
<li>语法简单</li>
<li>过程式语言 + 函数一等公民</li>
<li>通过结构体 + 接口实现抽象</li>
<li>协程并发</li>
<li>GC，value-oriented language</li>
<li>FFI支持很好</li>
</ul>
<p>Go 的语法比较简单，涉及到的关键字大约只有27个，对比 Python 大概有33个，而 Rust 则超过40个，Java 保留了约52个关键字，而 C++ 则保留了超过90个关键字。</p>
<p>Go 语法比较简洁，看起来像是加了大括号的 Python，比如 <code>for</code> 语句；继承了 C 的很多表达方式，比如指针、结构体等（但是去掉了分号，简直不能太舒服）。</p>
<p>从编程范式的角度看，属于过程式语言，但是支持高阶函数，支持闭包、多值函数等等，大大增加了语言的灵活性。没有复杂的“面向对象”支持，比如继承，语言的抽象是通过结构体和接口实现的。</p>
<p>Go的运行时有两个主要的任务，一个是GC，另一个就是携程调度。通常 Go 可以支持超过10万协程的调度工作。</p>
<p>协程原生支持，即 <code>goroutine</code>。协程的通讯是通过 <code>channel</code> 完成的，由于 channel 是一个阻塞的、有类型的数据管道，大大提高了通讯的可靠性（不过这个部分将来可能需要花更多精力去了解）。</p>
<p>最后就是 Go 是 GC 语言，由于 Go 语言本身运行时比较简单，所以GC也应该不像Java那么复杂，性能方面已经将延迟降低到1ms以下。（这个部分也可以详细了解一下）。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键词分成四类：声明、数据结构、控制流、函数控制和构造函数。</p>
<p><strong>声明</strong> 6 个</p>
<p><code>const</code>, <code>var</code>, <code>func</code>, <code>type</code>, <code>import</code>, <code>package</code></p>
<p><strong>数据结构</strong> 4 个</p>
<p><code>chan</code>, <code>interface</code>, <code>map</code>, <code>struct</code></p>
<p><strong>控制流</strong> 13 个</p>
<p><code>break</code>, <code>case</code>, <code>continue</code>, <code>default</code>, <code>if</code>, <code>else</code>, <code>fallthrough</code>, <code>for</code>, <code>goto</code>, <code>range</code>, <code>return</code>, <code>select</code>, <code>switch</code></p>
<p><strong>函数控制</strong> 2 个</p>
<p><code>defer</code>, <code>go</code></p>
<p><strong>构造函数</strong> 2 个</p>
<p><code>make</code>, <code>new</code></p>
<h2 id="语法、语义"><a href="#语法、语义" class="headerlink" title="语法、语义"></a>语法、语义</h2><p>一个简单的 Go 程序看起来如下，乍一看像 C + Python（带类型注释）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Create a huge number by shifting a 1 bit left 100 places.</span></span><br><span class="line">	<span class="comment">// In other words, the binary number that is 1 followed by 100 zeroes.</span></span><br><span class="line">	Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">	<span class="comment">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.</span></span><br><span class="line">	Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(needInt(Small))</span><br><span class="line">	fmt.Println(needFloat(Small))</span><br><span class="line">	fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct 和 interface</li>
<li>数据结构</li>
<li>高阶函数</li>
<li>控制语句</li>
<li>指针</li>
<li>goroutines</li>
<li>error处理</li>
</ul>
<h3 id="struct-和-interface"><a href="#struct-和-interface" class="headerlink" title="struct 和 interface"></a>struct 和 interface</h3><p>结构体也基本上维持了 C 的语法和语义，只不过所有的类型都变成了后缀，而不是前缀，比较现代，Python 的类型注释也是后缀的。访问方式也是通过 <code>.</code> 运算符。还有一个不一样的地方是，<code>.</code> 运算符不仅可以用在结构体本身，也可以直接用在结构体的指针上。</p>
<p>Go 不支持“面向对象”，是通过接口实现抽象的。Go 的接口实现是隐式的，不是显式的。</p>
<p>关于这个部分需要专门的展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">1e9</span>  <span class="comment">// 注意这里， p 是 Vertex 的指针</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>主要的数据结构有：</p>
<ul>
<li>Array，<code>[n]T</code>，固定长度</li>
<li>Slice，<code>[]T</code>，即长度可变的 Array</li>
<li>Map, <code>map[T1]T2</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">    <span class="comment">// array</span></span><br><span class="line">	primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(primes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(q)</span><br><span class="line">    </span><br><span class="line">    s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		i <span class="keyword">int</span></span><br><span class="line">		b <span class="keyword">bool</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// make 函数可以构造数据结构的本身</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Map</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">	m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个部分需要专门的展开。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>Go 里面函数是一等公民，可以作为值来传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(compute(hypot))</span><br><span class="line">	fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个部分需要专门的展开。</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>循环的语法其实跟Python很像。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针这块 Go 基本继承了 C 的语法和语义，采用 <code>*</code> 和 <code>&amp;</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">	p := &amp;i         <span class="comment">// point to i</span></span><br><span class="line">	fmt.Println(*p) <span class="comment">// read i through the pointer</span></span><br><span class="line">	*p = <span class="number">21</span>         <span class="comment">// set i through the pointer</span></span><br><span class="line">	fmt.Println(i)  <span class="comment">// see the new value of i</span></span><br><span class="line"></span><br><span class="line">	p = &amp;j         <span class="comment">// point to j</span></span><br><span class="line">	*p = *p / <span class="number">37</span>   <span class="comment">// divide j through the pointer</span></span><br><span class="line">	fmt.Println(j) <span class="comment">// see the new value of j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="goroutines"><a href="#goroutines" class="headerlink" title="goroutines"></a>goroutines</h3><p>协程是 Go 实现并发的手段，需要配合 channel 进行通讯。这里需要以后展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Error处理"><a href="#Error处理" class="headerlink" title="Error处理"></a>Error处理</h3><p>Go 的异常处理比较独特，需要进一步展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	When time.Time</span><br><span class="line">	What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">		e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">		time.Now(),</span><br><span class="line">		<span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇快速的浏览了一些 Go 的基本语法和语义。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://medium.com/wesionary-team/know-about-25-keywords-in-go-eca109855d4d">https://medium.com/wesionary-team/know-about-25-keywords-in-go-eca109855d4d</a></li>
<li><a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a></li>
<li><a href="https://tour.golang.org/list">https://tour.golang.org/list</a></li>
</ul>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>雅各书 5 13-20</title>
    <url>/2021/03/28/%E9%9B%85%E5%90%84%E4%B9%A65/</url>
    <content><![CDATA[<h1 id="雅各书-5：13-20"><a href="#雅各书-5：13-20" class="headerlink" title="雅各书 5：13-20"></a>雅各书 5：13-20</h1><p>这段经文的大背景是雅各写信提醒教会的弟兄姐妹不要心怀二意，一心一意为神而活。</p>
<p>这段经文的重点在于<strong>祷告</strong>，这是基督徒在试炼中站立不跌倒的唯一方法。神希望我们随时随地的、本能的对神祷告。受苦，要祷告；喜乐，要祷告（歌颂）；我们要在一切事情上祷告。</p>
<h2 id="我们为什么祷告？"><a href="#我们为什么祷告？" class="headerlink" title="我们为什么祷告？"></a>我们为什么祷告？</h2><blockquote>
<p>13 你们中间有人受苦吗？他就应该 <em><strong>祷告</strong>_。有人心情愉快吗?他就应该歌颂。 14 你们中间有人患病吗？他就应该请教会的长老来，让他们奉主的名为他抹油 _<strong>祷告</strong>_。 15 出于信心的 _<strong>祷告</strong>_，可以使病人康复，主必叫他起来；他若犯了罪，也必蒙赦免。 16 所以你们应当彼此认罪，互相代求，这样你们就可以痊愈。义人 _<strong>祷告</strong></em> 所发出的力量，是大有功效的。 17 以利亚是与我们性情相同的人；他恳切祈求不要下雨，地上就三年零六个月没有雨; 18 他又 _<strong>祷告</strong>_，天就下雨，地就生出土产来。</p>
</blockquote>
<p>这里有一点难解的经文，就是关于 14 节医治和患病的经文。15 节的康复这个词跟拯救是同一个词，根据这本书的上下文，雅各通篇再说属灵的疾病。所以这个词翻译成拯救更加恰当。</p>
<p>紧接着以利亚先知的例子也印证了上面的说法。以利亚当时为什么祷告呢？他是为了提醒当时君王，不要三心二意的拜别的神。因为当时君王带头拜他妻子带来的假神，以利亚祷告旱灾是为了要提醒君王 耶和华神才是唯一的真神。</p>
<p>雅各这里提到，以利亚是与我们心情相通的人，我们也应该想伊利亚一样通过祷告与神同工，因为祷告是大有功效的！雅各不希望我们中间的弟兄姐妹离开真道，就像以利亚不希望当时的君王要离开耶和华神。灵魂的死亡才是罪严重的“疾病”。</p>
<blockquote>
<p>我的弟兄们，你们中间若有人被骗离开了真道，如果有人使他回头， 20 <strong>你们应该知道，那使罪人从歧途上转回的，就会拯救他的灵魂脱离死亡，也会遮盖许多罪恶。</strong></p>
</blockquote>
<p>作为基督徒，我们不光要为自己的属灵生活祷告，也应该关心其他的弟兄姐妹，为其他人的属灵生活祷告。</p>
<p>我们要在一切事情上祷告，仰赖神。没有比互相带求更好的互相服侍的事情了！一切事情：</p>
<ul>
<li>认罪</li>
<li>倾吐心声</li>
<li>互相鼓励</li>
<li>等等。。。</li>
</ul>
<h2 id="为什么我们不祷告？"><a href="#为什么我们不祷告？" class="headerlink" title="为什么我们不祷告？"></a>为什么我们不祷告？</h2><p>自信，骄傲，不交托。</p>
<p>更深层次的，我们其实不愿意承认自己拒绝神，就会导致不祷告。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>2021 年新冠疫情，这一篇是雅各书系列的最后一个系列。雅各提醒我们，心怀二意是更加严重的属灵疾病，我们需要不断的祷告医治我们的属灵。</p>
<p>因为认罪悔改是一个持续的过程，而不是一次性的。所以我们需要通过祷告帮助我们世界警醒。</p>
<p>雅各书 还有很多细节帮助我们。继续阅读。</p>
<p>—————  <a href="https://github.com/wangzhe3224/wangzhe3224.github.io/blob/hexo-source/source/pdfs/%E9%9B%85%E5%90%84%E4%B9%A65%2013-20.pdf">PDF文件</a>  —————-</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>雅各书</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（8）PyObject</title>
    <url>/2021/03/26/python_8/</url>
    <content><![CDATA[<h1 id="重新认识-Python（8）PyObject"><a href="#重新认识-Python（8）PyObject" class="headerlink" title="重新认识 Python（8）PyObject"></a>重新认识 Python（8）PyObject</h1><blockquote>
<p>开发环境设置和入门请看：<a href="https://zhuanlan.zhihu.com/p/358690339">https://zhuanlan.zhihu.com/p/358690339</a></p>
</blockquote>
<p>本片主要介绍 Python 对象的内存构成，以及如何组织对象的方法。更多内容可以看： <a href="https://wangzhe3224.github.io/">https://wangzhe3224.github.io/</a></p>
<h2 id="PyObject-和-PyTypeObject"><a href="#PyObject-和-PyTypeObject" class="headerlink" title="PyObject 和 PyTypeObject"></a><code>PyObject</code> 和 <code>PyTypeObject</code></h2><p><code>PyObject</code> 可说是 CPython 最核心的数据结构了，在 Python 的世界里，几乎任何元素都是 PyObject 的指针（注意这里是指针，不是实际内存空间）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p>所有分配在堆内存中的python对象都具有上述结构：</p>
<ul>
<li><code>_PyObject_HEAD_EXTRA</code> 包含两个指向前后对象的指针，这样堆内存中的对象就会连接成为链表，以便进行内存管理。</li>
<li><code>ob_refcnt</code> 是对象的引用计数器，是GC的一部分，refcnt归零，该对象内存被回收。<code>Py_INCREF</code> 和 <code>Py_DECREF</code> 两个宏操作。</li>
<li><code>*ob_type</code> 是对象的类型指针，决定了这个对象是什么类型，比如 int 或者 其他自定义类型。</li>
</ul>
<p>实际上，<strong>所有</strong> Python 在内存中的头部都是一个 <code>PyObject</code> 结构，如下图所示。</p>
<p><img data-src="https://i.imgur.com/qBt3pvW.png" alt="对象的内存分布"></p>
<p>让我们继续看 <code>PyTypeObject</code> 这个结构体，内部定义了类型支持的操作的<em>指针</em>。举个例子，<code>*tp_as_number</code> 是一个指向 <code>PyNumberMethod</code> 结构体的指针。这个结构体包含了一系列函数指针，这些函数就是数字类型支持的计算，比如 <code>nb_add</code>, <code>nb_and</code> 等等。这里也包含了指向魔法函数的指针，比如 <code>tp_new</code> 指向的就是 <code>__new__</code> 的函数代码。这个类型结构体囊括了python类型可能支持的所有功能，其中有些其他类型是强制必须实现的，比如 <code>tp_new</code>，有些则是可选的，比如 <code>tp_init</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/cpython/object.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    Py_ssize_t tp_vectorcall_offset;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    </span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//此处省略</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">    <span class="comment">//此处省略</span></span><br><span class="line">    &#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p>你可能已经发现，<code>PyTypeObject</code> 其实就是定义一个接口，所有对象必须满足这个接口。其中有几个值得注意的子接口：</p>
<ul>
<li><code>PyNumberMethods</code>，定义了数字相关的结构，比如 +,-,&gt;，等等。换句话说，一个类型要向支持这些运算符，就必须实现这个接口</li>
<li><code>PySequenceMethods</code>，定义了序列相关的函数，比如 len, in 等等</li>
<li><code>PyMappingMethods</code>，定义了一些字典类的函数</li>
</ul>
<p>总结一下 Python 内存中的对都拥有类似的头部和组织结构：</p>
<p><img data-src="https://i.imgur.com/D3euvFc.png" alt=""></p>
<h2 id="tuple-类"><a href="#tuple-类" class="headerlink" title="tuple 类"></a><code>tuple</code> 类</h2><p>我们来看一个具体的例子，<code>tuple</code>。这里先介绍语言的内建类型，对于自定义类型（自己写的类）的说明，放在后面说。</p>
<p><code>PyTuple_Type</code> 就是 <code>PyTypeObject</code> 的一个实例：</p>
<p>首先，第一个 field 是 tuple 的基类：<code>PyType_Type</code>，其实在 python 解释器中就是 <code>type</code> 。第二个 field 是这个类打印出来的名字，这里就是 tuple，也就是解释器中 <code>type(a_tuple)</code> 的返回值。接下来就是tuple对象的大小和其内部元素的大小。注意到其中很多 0，这就表示这个类型没有实现哪些接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyTuple_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;tuple&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyTupleObject) - <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    (destructor)tupledealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)tuplerepr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;tuple_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;tuple_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)tuplehash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    tuple_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)tupletraverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    tuplerichcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    tuple_iter,                                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    tuple_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    tuple_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    .tp_vectorcall = tuple_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="实例化-type"><a href="#实例化-type" class="headerlink" title="实例化 type"></a>实例化 type</h2><p>接下来我们看当我们在python里创建一个 tuple 的时候发生了什么？构造函数会被调用，比如 <code>tuple_new</code>。也就是 pytype 里面的 <code>tp_new</code> 指针指向的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/tupleobject.c</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">tuple_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *return_value = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *iterable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((type == &amp;PyTuple_Type) &amp;&amp;</span><br><span class="line">        !_PyArg_NoKeywords(<span class="string">&quot;tuple&quot;</span>, kwargs)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_PyArg_CheckPositional(<span class="string">&quot;tuple&quot;</span>, PyTuple_GET_SIZE(args), <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyTuple_GET_SIZE(args) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip_optional;</span><br><span class="line">    &#125;</span><br><span class="line">    iterable = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">skip_optional:</span><br><span class="line">    return_value = tuple_new_impl(type, iterable);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造函数会返回一个 <code>PyTupleObject</code>，正是这个结构包含了一个指向 tuple 内部真正元素的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;ob_size&#x27; elements.</span></span><br><span class="line"><span class="comment">       Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">       the tuple is not yet visible outside the function that builds it. */</span></span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里需要注意</strong>：<code>PyTupleObject</code> 是实际被分配在堆内存的对象，我们可以创建很多对象，但是他们对应的函数都被包含在 <code>PyTuple_Type</code> 中，而这个对象是唯一的，所有 tuple 对象都会指向他。</p>
<p><img data-src="https://i.imgur.com/LxvTRK4.png" alt=""></p>
<h2 id="实例化自定义类型"><a href="#实例化自定义类型" class="headerlink" title="实例化自定义类型"></a>实例化自定义类型</h2><p>那么当我们实例化自定义类型的时候，发生了什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure>

<p>这里 A 是我们的自定义类，它默认继承了 <code>type</code>。当我们写 <code>()</code> 这个语法的时候，实际上会触发 <code>tp_call</code> 指向的函数，即 type 的 call 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);  <span class="comment">// 注意这里调用了 new 方法</span></span><br><span class="line">    obj = _Py_CheckFunctionResult(tstate, (PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the returned object is not an instance of type,</span></span><br><span class="line"><span class="comment">       it won&#x27;t be initialized. */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert(_PyErr_Occurred(tstate));</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!_PyErr_Occurred(tstate));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记 1</title>
    <url>/2021/03/25/go_study_1/</url>
    <content><![CDATA[<h1 id="Go-学习笔记-1"><a href="#Go-学习笔记-1" class="headerlink" title="Go 学习笔记 1"></a>Go 学习笔记 1</h1><p>我是一个有5年 Python 开发经验的混迹在量化交易行业的后端程序员，这个系列开个坑学习 Golang。为什么选择 Go？</p>
<blockquote>
<p>“A language that doesn’t affect the way you think about programming is not worth knowing.” —Alan J. Perlis (1922-1990)</p>
</blockquote>
<p>图灵奖的第一任得主，图灵说如是：一个语言如果不能影响你对编程的看法，那么这个语言不值得学习。所以这些年接触了奇奇怪怪的语言：Clojure，Ocaml，Erlang等等。Go 我刚开始看到的时候觉得另类：看起来是 C 系的，不赶时髦，支持的功能异常少。但是有理由相信这是一个工程导向的，年轻的语言，没有沉重的历史包袱，出生在多核并发时代。</p>
<p>我觉得他会改变我对并发和现代软件工程的看法。</p>
<p>这是第一篇，主要记录一下我学习语言的几个角度：</p>
<ul>
<li>语法</li>
<li>语义</li>
<li>该语言的最佳实践</li>
<li>标准库</li>
<li>工具链</li>
<li>语言实现细节</li>
</ul>
<p><strong>语法</strong>，这是最基础的层面，即写出合法的表达式。这其实也是不同计算机语言中最千差万别的部分，即 Lexer 部分。想想看 Clojure 的满屏括号对比 C 的满屏分号可见一斑。</p>
<p><strong>语义</strong>，是下一个层次即符合语法的表达式的意义。通常对于静态类型语言，可以分成动态语义和静态语义。动态语义即程序在运行时的行为；而静态语义通常就是编译阶段的类型检查。</p>
<p><strong>最佳实践</strong>，在熟悉上面两个的基础上，还应该学习该门语言的业界最佳实践。即给出一个逻辑，在该语言下的通常写法。</p>
<p><strong>标准库</strong>，避免重复造轮子，同时也熟悉他们的工程性能。</p>
<p><strong>工具链</strong>，包括编译器、编辑器、测试环境、部署环境等等。</p>
<p><strong>语言实现细节</strong>，包括编译器、运行时、垃圾回收机制等等。</p>
<h6 id="tags-Go"><a href="#tags-Go" class="headerlink" title="tags: Go"></a>tags: <code>Go</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Python 加速飞</title>
    <url>/2021/03/21/python_spped/</url>
    <content><![CDATA[<h1 id="让-Python-加速飞"><a href="#让-Python-加速飞" class="headerlink" title="让 Python 加速飞"></a>让 Python 加速飞</h1><p>Python 是一个开发很快的语言，相应的他不是一个运行速度很快的语言。原因呢，主要是动态类型设计，导致类型需要在运行时检查。在一般的应用中，特别是 IO 密集应用里，性能往往构不成问题。</p>
<p>对于 CPU 密集问题，Python 的科学计算生态其实非常好，得益于 CPython 的 C API，numpy, scipy 已经把科学计算性能提升了一个档次，深度学习基本也是python API的天下了。这些库已经把性能瓶颈从 Python 中剥离了。</p>
<p>其实 Python 最致命的性能问题在于循环，一旦代码中出现了大量循环计算，又没有现成的 numpy 函数可以用，性能往往就会成问题。今天我们介绍两个主要的方法，让 Python 的循环飞起来。这两个工具是：<code>Cython</code> 和 <code>Numba</code>。</p>
<h2 id="Cython"><a href="#Cython" class="headerlink" title="Cython"></a>Cython</h2><p><a href="https://cython.org/">Cython</a> 包含两个部分：语言和编译器。Cython 从概念上说是一门新的语言，但是他是 Python 语言的超集，即合法的 Python 代码（大部分）都是合法的 Cython 代码。第二个部分是 <code>cython</code> 编译器，这个编译器会把 Cython 代码编译成相应的 C 代码，这些 C 代码会调用 CPython 的 C API。编译后会直接生成 Python 的 extension，并且可以直接被其他纯 Python 代码引入和调用。</p>
<blockquote>
<p>Cython is a programming language that makes writing C extensions for the Python language as easy as Python itself.</p>
</blockquote>
<p>原理上，Cython 是通过编译出来的 C 目标文件直接编程 Python 拓展，被Python调用的方式来提升速度。因为编译出来的拓展函数，与 C 语言写的函数性能一致。换句话说， Cython 产生的代码会具备 c 的性能，同时可以与 Python 的 runtime 通过 C API 互动实现兼容。</p>
<h3 id="安装-Cython"><a href="#安装-Cython" class="headerlink" title="安装 Cython"></a>安装 Cython</h3><p><code>pip install cython</code></p>
<p>建议安装 0.29 版本。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>举个求质数的函数作为例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes_python</span>(<span class="params">nb_primes</span>):</span></span><br><span class="line">    p = []</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; nb_primes:</span><br><span class="line">        <span class="comment"># Is n prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If no break occurred in the loop</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>我们存储文件为：<code>python_prime.py</code>。这个函数的主体是一个循环。</p>
<p>我们说过 Cython 是 Python 的超集，cython 编译器可以直接编译上述函数。我们拷贝文件存储成：<code>cython_python_prime.py</code>，一会儿我们编译这个文件。</p>
<p>我们也可以通过加入类型声明，进一步提升性能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span>(<span class="params"><span class="built_in">int</span> nb_primes</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> n, i, len_p</span><br><span class="line">    cdef <span class="built_in">int</span> p[<span class="number">1000</span>]</span><br><span class="line">    <span class="keyword">if</span> nb_primes &gt; <span class="number">1000</span>:</span><br><span class="line">        nb_primes = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    len_p = <span class="number">0</span></span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len_p &lt; nb_primes:</span><br><span class="line">        <span class="comment"># is n a prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p[: len_p]:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p[len_p] = n </span><br><span class="line">            len_p += <span class="number">1</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    result = [prime <span class="keyword">for</span> prime <span class="keyword">in</span> p[:len_p]]</span><br><span class="line">    <span class="keyword">return</span> resul</span><br></pre></td></tr></table></figure>

<p>我们把上述文件存储为：<code>cython_primer.pyx</code>。这里 pyx 就是 cython 的拓展名。这时候，我们根目录目前有三个文件：</p>
<ul>
<li><code>python_prime.py</code></li>
<li><code>cython_python_prime.py</code></li>
<li><code>cython_primer.pyx</code></li>
</ul>
<p>为了编译 cpython 目标文件，我们还需要创建一个 <code>setup.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;Hello world app&#x27;</span>,</span><br><span class="line">    ext_modules=cythonize([<span class="string">&quot;cython_primer.pyx&quot;</span>, <span class="string">&quot;cython_python_prime.py&quot;</span>],</span><br><span class="line">                          annotate=<span class="literal">True</span>),</span><br><span class="line">    zip_safe=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>好，准备就绪。编译：<code>python setup.py build_ext --inplace</code>。编译完成后，根目录会生成一个 <code>.so</code> 文件，就是我们 Python 拓展的目标文件。</p>
<p>我们来测试一下三个函数的性能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; python -m timeit -s &#39;from python_prime import primes&#39; &#39;primes(1000)&#39;</span><br><span class="line">10 loops, best of 5: 22.9 msec per loop</span><br><span class="line">&gt; python -m timeit -s &#39;from cython_python_prime import primes&#39; &#39;primes(1000)&#39;</span><br><span class="line">20 loops, best of 5: 11 msec per loop</span><br><span class="line">&gt; python -m timeit -s &#39;from cython_primer import primes&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">200 loops, best of 5: 1.36 msec per loop</span><br></pre></td></tr></table></figure>

<p>可以看出，即使直接编译纯 Python 文件，性能也提升近2倍，而使用 Cython 语法后，性能提升约20倍。而且，这个函数比较简单，大部分代码的都在与 CPython 运行时互动，如果是复杂的函数，性能提升更加明显。</p>
<p>编译器还会生成一个函数与Cpython互动的 html 文件用来检查：</p>
<p><img data-src="https://i.imgur.com/n1GILGd.png" alt=""></p>
<h2 id="Numba"><a href="#Numba" class="headerlink" title="Numba"></a>Numba</h2><p>Numba 走的是 JIT 的路线，不需要 Cython 哪样提前编译。使用起来非常简单！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes_python</span>(<span class="params">nb_primes</span>):</span></span><br><span class="line">    p = []</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; nb_primes:</span><br><span class="line">        <span class="comment"># Is n prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If no break occurred in the loop</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>只需要加一个 <code>@jit</code> 的装饰器，性能就达到了 Cython 的水平。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ python -m timeit -s &#39;from numba_primer import primes_python&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">1 loop, best of 5: 1.99 msec per loop</span><br><span class="line">❯ python -m timeit -s &#39;from numba_primer import primes_python&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">200 loops, best of 5: 1.45 msec per loop</span><br></pre></td></tr></table></figure>

<p>不过可以看到，由于是 JIT，函数需要一些预热，第一次测试性能不如后面的好。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Cython</tag>
        <tag>Numba</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（7）CPython初探</title>
    <url>/2021/03/20/python_6/</url>
    <content><![CDATA[<h1 id="重新认识-Python（7）CPython初探"><a href="#重新认识-Python（7）CPython初探" class="headerlink" title="重新认识 Python（7）CPython初探"></a>重新认识 Python（7）CPython初探</h1><p>CPython 是 Python 社区的标准，其他版本的 Python，比如 pypy，都会遵行 CPython 的标准API实现。想要更深入的认识 Python，就需要了解 CPython 实现。这一期，我就带大家认识一下 CPython 源代码，为日后改造 Python 做准备。首先，展示如何本地编译最新的 CPython代码。然后，展示如何 debug 编译好的解释器。最后我们会利用 CPython 实现简单的函数调用。</p>
<p>本文会为你揭开 CPython 的面纱，带你进入 C + Python 的世界。文章的最后，你也会对 Python 中最重要的概念：一切皆对象（object）有更深刻的认识；你还会发现一点点线索，为什么Python用起来比其他语言，比如 C 慢很多。</p>
<p>请打开编辑器和命令行，我们开始。（本文主要使用MacOS，Windows 不一定可以直接实现）。</p>
<h2 id="当我们再说-Python，我们在说什么？"><a href="#当我们再说-Python，我们在说什么？" class="headerlink" title="当我们再说 Python，我们在说什么？"></a>当我们再说 Python，我们在说什么？</h2><p>在我还是小小白的时候，我经常会想：当我们说 Python 的时候，我们到底在说什么？后来当我学了编译原理，我变成了一个小白，我知道了，当我们说 Python 的时候，我们其实再说两个东西：语言的语法和语言的运行时。</p>
<p>语法主要规定了如何表达程序，比如我们写 <code>a = 1</code> 是合法的，且有语义；而当我写 <code>for i in 1:</code> 的时候，是不合法的，语义也就无法确定。运行时（run time）是指运行我们写好的代码的另一个“程序”。也就是当我们输入 <code>python test.py</code> 的时候，这里面的 python 就是我们的“程序”，这个运行时负责执行我们的代码。</p>
<p>而这个 runtime，可以有很多不同的实现，比如 CPython 实现就是一个用 C 语言实现运行时，而 pypy 则是用 RPython 实现的运行时等等。这个 runtime 可以理解我们写的 python 代码，并且把它编译成 python 的字节码，然后执行。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>上面的代码在屏幕打印1。如何实现的呢？其实是我们的运行时“程序” <code>python</code> 实现的。首先，python 会把上面的源代码翻译成字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import dis</span><br><span class="line"></span><br><span class="line">dis.dis(&quot;a&#x3D;1;print(1)&quot;)  # 这一行会把源代码编译成字节码，就是 python 认识的操作。</span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              2 STORE_NAME               0 (a)</span><br><span class="line">              4 LOAD_NAME                1 (print)</span><br><span class="line">              6 LOAD_NAME                0 (a)</span><br><span class="line">              8 CALL_FUNCTION            1</span><br><span class="line">             10 POP_TOP</span><br><span class="line">             12 LOAD_CONST               1 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>上面的字节码，背后就是 python 程序提供的一些基本操作。比如 <code>LOAD_CONST</code>，加载常数 1 进入内存。你可以在<a href="https://github.com/python/cpython/blob/master/Include/opcode.h">这里</a>找到所有的字节码。</p>
<p>一句话总结，<code>CPython</code> 就是一个可以执行你写的python代码的另一个由 C 语言写的程序。</p>
<h2 id="编译-CPython"><a href="#编译-CPython" class="headerlink" title="编译 CPython"></a>编译 CPython</h2><p>首先，我们要去 github fork CPython 的代码到自己的账户下：<a href="https://github.com/python/cpython">https://github.com/python/cpython</a> 。然后我们作如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line">brew install git</span><br><span class="line">brew install openssl</span><br><span class="line">brew install readline</span><br><span class="line"></span><br><span class="line"><span class="comment"># mac 需要 xcode 才能编译</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:&#123;你的账户。。&#125;/cpython.git</span><br><span class="line"><span class="built_in">cd</span> cpython</span><br><span class="line">git remote add upstream git@github.com:python/cpython.git</span><br><span class="line"><span class="comment"># 把原始仓库加入</span></span><br><span class="line"><span class="comment"># 编译 python，加入debug选项，方便我们后面进一步探索。</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="string">&quot;<span class="subst">$(brew --prefix openssl)</span>/lib/pkgconfig&quot;</span> \</span><br><span class="line">CPPFLAGS=<span class="string">&quot;-I<span class="subst">$(brew --prefix readline)</span>/include&quot;</span> \</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L<span class="subst">$(brew --prefix readline)</span>/lib&quot;</span> \</span><br><span class="line">./configure --with-pydebug \</span><br><span class="line">&amp;&amp; make</span><br></pre></td></tr></table></figure>

<p>很快编译就会成功，此时你的当前目录下会出现一个 <code>python.exe</code> 的可执行文件，这就是我们编译好的 Python！</p>
<p>输入 <code>./python.exe</code> 就会看见熟悉的python解释器了提示符了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 3.10.0a6+ (heads&#x2F;master:f00e82f8b8, Mar 13 2021, 23:26:48) [Clang 11.0.3 (clang-1103.0.32.59)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Debug-CPython"><a href="#Debug-CPython" class="headerlink" title="Debug CPython"></a>Debug CPython</h2><p>编译完成后，我们就可以来看看 CPython 内部的“秘密”了。这里我用的 <code>lldb</code> 因为 Mac 的安装 gdb 比较复杂。基本步骤是一样的。</p>
<p>输入 <code>lldb python.ext</code>。接下来，我们需要在 <code>Programs/python.c</code> 的 main 函数处设置一个断点。这个函数就整个解释器的入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b main</span><br><span class="line">Breakpoint 1: where &#x3D; python.exe&#96;main + 22 at python.c:15:25, address &#x3D; 0x0000000100000856</span><br><span class="line">(lldb) r</span><br><span class="line">Process 43373 launched: &#39;&#x2F;Users&#x2F;zhewang&#x2F;Projects&#x2F;cpython&#x2F;python.exe&#39; (x86_64)</span><br><span class="line">Process 43373 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">    frame #0: 0x0000000100000856 python.exe&#96;main(argc&#x3D;1, argv&#x3D;0x00007ffeefbff330) at python.c:15:25</span><br><span class="line">   12  	int</span><br><span class="line">   13  	main(int argc, char **argv)</span><br><span class="line">   14  	&#123;</span><br><span class="line">-&gt; 15  	    return Py_BytesMain(argc, argv);</span><br><span class="line">   16  	&#125;</span><br><span class="line">   17  	#endif</span><br></pre></td></tr></table></figure>

<p>好，现在我们就停留在了 CPython 世界的入口了！</p>
<h2 id="简单的加法！"><a href="#简单的加法！" class="headerlink" title="简单的加法！"></a>简单的加法！</h2><p>现在我们在 debug 环境下，用 CPython 来实现一个整数的加法。</p>
<p>首先，我们来看一下 int 这个 object。我把部分 int object 的代码放在下面。可以看出，python 里面连最基本的 int 对象都别有洞天！要知道python运行的时候，每一个整数在内存里其实都包含了下面结构体所有的变量。具体文件可以在 <code>Objects/longobject.c</code> 找到。</p>
<p><code>PyVarObject_HEAD_INIT</code> 定义了 int 的类型，int 的类型其实叫 <code>PyLong_Type</code>，他的基类是一个叫 <code>PyType_Type</code> 的类型。比如在python中，<code>type(1)</code> 会返回 <code>int</code>，即下面的 tp_name，而 <code>type(type(1))</code> 则返回 <code>type</code>，即<code>PyType_Type</code>。当然 python 的整数做的这么复杂主要是为了保持所有对象类型协调统一，即无论是复杂的类型还是简单的类型，他们的内存结构都是样的！（ 这里插一嘴，python的int是long，也就是说可以是任意大的整数，不会溢出！）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们现在在debug 环境里面可以尝试创造一个 int 对象！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b pymain_import_readline</span><br><span class="line">Breakpoint 1: where &#x3D; python.exe&#96;pymain_import_readline + 12 at main.c:205:9, address &#x3D; 0x000000010032ad1c</span><br><span class="line">(lldb) r</span><br><span class="line">Process 54697 launched: &#39;&#x2F;Users&#x2F;zhewang&#x2F;Projects&#x2F;cpython&#x2F;python.exe&#39; (x86_64)</span><br><span class="line">Python 3.10.0a6+ (heads&#x2F;master:f00e82f8b8, Mar 20 2021, 21:50:27) [Clang 11.0.3 (clang-1103.0.32.59)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Process 54697 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">    frame #0: 0x000000010032ad1c python.exe&#96;pymain_import_readline(config&#x3D;0x00000001007503d0) at main.c:205:9</span><br><span class="line">   202 	static void</span><br><span class="line">   203 	pymain_import_readline(const PyConfig *config)</span><br><span class="line">   204 	&#123;</span><br><span class="line">-&gt; 205 	    if (config-&gt;isolated) &#123;</span><br><span class="line">   206 	        return;</span><br><span class="line">   207 	    &#125;</span><br><span class="line">   208 	    if (!config-&gt;inspect &amp;&amp; config_run_code(config))</span><br></pre></td></tr></table></figure>

<p>我们停在这里，Python已经完成一些初始化设置，但是还没有进入 &gt;&gt;&gt; 交互环境。这时，我们使用 CPython 的底层函数创建两个 int 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) call PyLong_FromLong(10)</span><br><span class="line">(PyObject *) $0 &#x3D; 0x00000001007a8500</span><br><span class="line">(lldb) call PyLong_FromLong(20)</span><br><span class="line">(PyObject *) $1 &#x3D; 0x00000001007a8780</span><br></pre></td></tr></table></figure>

<p>可以看到，返回的是一个指向 <code>PyObject</code> 的指针。其实这个就是一切皆对象中的对象啦，就是这个 <code>PyObject</code>，Python中所有类型实例化后都是这个这个 PyObject。来看一下这两对象的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *$0</span><br><span class="line">(PyObject) $2 &#x3D; &#123;</span><br><span class="line">  ob_refcnt &#x3D; 10</span><br><span class="line">  ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$1</span><br><span class="line">(PyObject) $3 &#x3D; &#123;</span><br><span class="line">  ob_refcnt &#x3D; 8</span><br><span class="line">  ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，他们有两个field，一个是 refcnt 用来管理垃圾回收，另一个是 ob_type 指向对象类型的内存。通过访问 ob_type 可以看到该类型的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *$1-&gt;ob_type</span><br><span class="line">(PyTypeObject) $5 &#x3D; &#123;</span><br><span class="line">  ob_base &#x3D; &#123;</span><br><span class="line">    ob_base &#x3D; &#123;</span><br><span class="line">      ob_refcnt &#x3D; 68</span><br><span class="line">      ob_type &#x3D; 0x000000010049a620</span><br><span class="line">    &#125;</span><br><span class="line">    ob_size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  tp_name &#x3D; 0x0000000100407b51 &quot;int&quot;</span><br><span class="line">  tp_basicsize &#x3D; 24</span><br><span class="line">  tp_itemsize &#x3D; 4</span><br><span class="line">  tp_dealloc &#x3D; 0x00000001001707c0 (python.exe&#96;object_dealloc at typeobject.c:4062)</span><br><span class="line">  tp_vectorcall_offset &#x3D; 0</span><br><span class="line">  。。。省略</span><br></pre></td></tr></table></figure>

<p>接下来我们看看我们的 PyLong_Type 支持哪些运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *PyLong_Type-&gt;tp_as_number</span><br><span class="line">(PyNumberMethods) $9 &#x3D; &#123;</span><br><span class="line">  nb_add &#x3D; 0x000000010011b180 (python.exe&#96;long_add at longobject.c:3065)</span><br><span class="line">  nb_subtract &#x3D; 0x000000010011ae00 (python.exe&#96;long_sub at longobject.c:3099)</span><br><span class="line">  nb_multiply &#x3D; 0x000000010011dac0 (python.exe&#96;long_mul at longobject.c:3533)</span><br><span class="line">  nb_remainder &#x3D; 0x000000010011dda0 (python.exe&#96;long_mod at longobject.c:3966)</span><br><span class="line">  nb_divmod &#x3D; 0x000000010011dee0 (python.exe&#96;long_divmod at longobject.c:3982)</span><br><span class="line">  nb_power &#x3D; 0x000000010011e0b0 (python.exe&#96;long_pow at longobject.c:4098)</span><br><span class="line">  nb_negative &#x3D; 0x000000010011aca0 (python.exe&#96;long_neg at longobject.c:4318)</span><br><span class="line">  nb_positive &#x3D; 0x000000010011c570 (python.exe&#96;long_long at longobject.c:4692)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>我们来试一下加法！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *PyLong_Typp.tp_as_number-&gt;nb_add</span><br><span class="line">(PyObject *(*)(PyObject *, PyObject *)) $10 &#x3D; 0x000000010011b180 (python.exe&#96;long_add at longobject.c:3065)</span><br></pre></td></tr></table></figure>

<p>可以看到，加法的函数签名是：<code>(PyObject *(*)(PyObject *, PyObject *))</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p PyLong_Type.tp_as_number-&gt;nb_add((PyObject *) 0x00000001007a8500,(PyObject *) 0x00000001007a8780)</span><br><span class="line">(PyObject *) $15 &#x3D; 0x00000001007a8a00</span><br></pre></td></tr></table></figure>

<p>我们得到了另一个 PyObject 的指针，0x00000001007a8a00。这个理论上就是 10+20 的结果，30。我们来验证一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *(PyLongObject *) 0x00000001007a8a00</span><br><span class="line">(PyLongObject) $30 &#x3D; &#123;</span><br><span class="line">  ob_base &#x3D; &#123;</span><br><span class="line">    ob_base &#x3D; &#123;</span><br><span class="line">      ob_refcnt &#x3D; 8</span><br><span class="line">      ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">    &#125;</span><br><span class="line">    ob_size &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">  ob_digit &#x3D; ([0] &#x3D; 30)  # &lt;--- 这里就是我们的答案。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇 CPython 初探就到这里，我们学会了如何编译、debug我们的Python解释器，用CPython的API实现了简答的加法。有了这些基础知识我们就可以开始进一步探索CPython的世界了！</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（5）再谈并发</title>
    <url>/2021/03/11/python_5/</url>
    <content><![CDATA[<h1 id="重新认识-Python（5）：再谈并发"><a href="#重新认识-Python（5）：再谈并发" class="headerlink" title="重新认识 Python（5）：再谈并发"></a>重新认识 Python（5）：再谈并发</h1><p>之前写了一个关于<a href="https://zhuanlan.zhihu.com/p/354982602">Python并发模型</a>的小文，主要讨论利用协程实现并发的一些基本方法和规则，文章的重点是 coroutine 的使用。这两天琢磨了一下为什么 Python 要提出基于协程的并发模型，以及跟线程、进程实现的并发有什么区别和联系？最后，我还想简单讨论一下这三种并发模型是否协调在一起工作。</p>
<h2 id="进程、线程、协程并发的特点"><a href="#进程、线程、协程并发的特点" class="headerlink" title="进程、线程、协程并发的特点"></a>进程、线程、协程并发的特点</h2><p>首先明确明确一点，Python一般的协程库，比如 <code>asyncio</code> ，不存在任何并行，即一个时间只有一个任务（协程或者普通函数）在运行。而线程和进程在多核CPU的情况下通常是存在并行的，不过由于Python的GIL，Python的线程不存在并行计算，即使运行在多核CPU上。</p>
<p>我们再来看这三个模型的特点。</p>
<p><strong>进程</strong>：在 Python 的世界里，如果想实现并行计算，进程应该是唯一的选择了，通常进程池数量不会超过CPU的核心数量，以免频繁的进行切换。所以，采用进程实现并发，可以实现并行计算，但是并发任务的数量非常有限。</p>
<p><strong>线程</strong>：Python 的线程直接调用OS提供的线程，并没有特别的处理。所以，线程的调度是由OS主要负责的，属于抢占式。线程的开销比进程更低，所以一般一个应用有上百线程问题不大。但是线程的两个主要问题：抢占，程序基本不能控制OS会给那个线程执行权；race condition，当有并行的时候，由于共享内存，需要锁来控制共享内存。关于线程调度，其实Python的运行时有自己的调度，但是CPython的调度也是依赖于OS的，Python 只能告诉OS这个现在需要被抢占了，如果有还有其他等待的线程，它会让OS来分配下一个执行的线程。</p>
<p><strong>协程</strong>：协程并发最主要的特点是合作式调度，不是抢占式。程序主动控制执行权的交接，而不是OS控制。这样就给调度器提供了非常强的定制性，可以根据具体需求进行调度。另外，协程基本上全部运行于一个OS线程内部，切换开销非常小，创建、销毁协程的开销也非常小。所以协程特别适合数量庞大、寿命较短的任务。通常一个线程可以轻松处理超过1万个协程，所以对于高并发场景，协程并发非常合适。</p>
<p>但是协程并发也有一些局限性：对于 CPU 计算密集或者一些阻塞的任务会让整个调度器卡在这个任务，直到计算结束。真正的解决方案只能是借助其他线程或者进程。还有一个问题就是生态的问题，Python的很多库其实对协程并发没有支持，容易出现处理不良的阻塞任务。这就导致了在采用协程编写并发系统时候，需要造轮子。</p>
<p>下面这个表格大致总结一下三个模型的特征：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>内存</th>
<th>CPU</th>
<th>开销</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>不共享内存</td>
<td>多核并行</td>
<td>大</td>
<td>~ 10</td>
</tr>
<tr>
<td>线程</td>
<td>共享内存</td>
<td>Python不支持并行</td>
<td>中</td>
<td>~ 100</td>
</tr>
<tr>
<td>协程</td>
<td>共享内存</td>
<td>一般无并行</td>
<td>小</td>
<td>~ 1000+</td>
</tr>
</tbody></table>
<p>对于具体的内存和CPU开销，总结如下：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>内存</th>
<th>CPU</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>线程</td>
<td>~ 8MB</td>
<td>-</td>
</tr>
<tr>
<td>协程</td>
<td>&lt; 0.8kb</td>
<td>~ 100 ns</td>
</tr>
</tbody></table>
<p>我没统计全，如果有知道的朋友请留言，我会补上。谢谢</p>
<h2 id="为什么加入协程"><a href="#为什么加入协程" class="headerlink" title="为什么加入协程"></a>为什么加入协程</h2><p>从上面的讨论也可以看出，协程无论实在内存和CPU的开销都有明显的优势，在一个OS进程中可以轻松孵化超过1万个协程进行并发计算，用完后这些协程可以被轻松回收，基本上不需要协程池。而进程和线程的并发，基本都会建立一个数量有限的线程或者进程池，能够并发的任务数量始终有限。协程的另一个好处在于，由于是单线程，本身不存在竞争。综合上面这些因素，协程并发很适合高并发 IO 开发。对于 CPU 密集的任务，或者需要 Blocking 的任务，线程或者进程仍然是首选。当然如果可以融合三种模型在同一个套API下就更好了。</p>
<p>对于 Python，由于GIL的存在，处理高并发最好的选择应该是协程，而不是线程。因为线程本来的优势在于有一定的并行能力，但是GIL剥夺了这个优势。</p>
<p>本质上协程并发就是把调度工作从OS中抽离，由应用端实现，增加了效率和可定制性。但是，协程的复杂度在于调度器的编写，以及执行权的移交等等。</p>
<h2 id="如何融合三种并发基本工具"><a href="#如何融合三种并发基本工具" class="headerlink" title="如何融合三种并发基本工具?"></a>如何融合三种并发基本工具?</h2><p>从 Python 的角度说，并发模型目前主要由两个阵营：<code>concurrent.future</code> 和 <code>asyncio</code>，前者主要针对线程和进程并发，后者针对协程并发。当然新的协程语法 <code>async/await</code> 是 3.5 以后才加入，协程并发慢慢进入更多开发者的视野。对于协程并发，<code>curio</code> 这个库也很值得关注，它提供了一套不同于 <code>asyncio</code> 的API，但是基本原理都是提供了一个调度器来实现并发功能的封装。</p>
<p>本质上，进程、线程、协程都是实现并发的基本工具，并发编程的核心在于<strong>通讯</strong>方式。通讯模式通常分成三种：</p>
<ul>
<li>队列, <code>A ----&gt; 队列 ----&gt; B</code></li>
<li>Actor，<code>A &lt;---- ?</code></li>
<li>Pub/Sub，<code>A &lt;---&gt; 网关 &lt;---&gt; B</code></li>
</ul>
<p>只要我们搞清楚这几种模型，就有希望提供一个融合三种工具的并发编程API。下面我们用线程举例说明每一个模型，原因是比较简单，因为我们不需要操心调度的事情。然后我们可以探索一下用协程来实现，不过我们需要自己造点轮子，比如异步队列、调度器等等。</p>
<h3 id="队列通讯"><a href="#队列通讯" class="headerlink" title="队列通讯"></a>队列通讯</h3><p><code>A ----&gt; 队列 ----&gt; B</code></p>
<p>原理非常简单，A B 两个线程通过队列进行沟通，A 向队列写入，B 从队列读取。最基本的操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">out_q</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 放入数据</span></span><br><span class="line">        out_q.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;放入数据&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>(<span class="params">in_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = in_q.get(timeout=<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;读取数据&#x27;</span>, d)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列超时，退出&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    t1 = Thread(target=A, args=(q,))</span><br><span class="line">    t2 = Thread(target=B, args=(q,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p>Python中的 <code>Queue</code> 是线程安全的，而且可以保证数据的顺序，因此是很好的沟通工具。需要注意的是，这里 get 和 put 都是阻塞函数。</p>
<p>当然，除了通过 get 和 put 通讯，还有一些基本的信号工具，比如 <code>Event</code> 。比如如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">out_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ...</span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((<span class="string">&#x27;data&#x27;</span>, evt))</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 等待B的信号</span></span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>(<span class="params">in_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 给A信号</span></span><br><span class="line">        evt.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>值得注意的是，队列通讯传递的是数据的reference，因此数据是可变且共享的，实际使用应该注意，避免改写数据。</p>
<h3 id="Actor通讯"><a href="#Actor通讯" class="headerlink" title="Actor通讯"></a>Actor通讯</h3><p><code>A &lt;---- ?</code></p>
<p>上面看到队列通讯的特点是<em>共享内存</em>加<em>阻塞</em>。A 和 B 是事实上通过队列偶合在一起。而 Actor通讯中，A 不再与队列耦合，而是从外部接收消息，然后进行计算。当然他也可以给其他 Actor发送消息。类似于一种点对点的通讯，根据内部实现的不同，发送和接受信息可以是阻塞的，也可以是非阻塞的。</p>
<p>下面举个例子说明<a href="https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/">参考</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActorExit</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line">        self._terminated = <span class="literal">None</span>  <span class="comment"># type: Event</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        <span class="comment"># 发送信息给 Actor</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Actor 读取信息</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit(<span class="string">&#x27;Actor exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 阻塞等待完成</span></span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这个函数包含了 Actor 的处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Processing &quot;</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintActor</span>(<span class="params">Actor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Got:&#x27;</span>, msg)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = PrintActor()</span><br><span class="line">    p.start()</span><br><span class="line">    p.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Got: Hello</span></span><br><span class="line"><span class="comment"># Got: World</span></span><br></pre></td></tr></table></figure>

<p>上述实现是通过队列完成的， send 和 recv 都是阻塞的。其实，这个Actor的行为跟协程已经很像了，比如我们可以用携程重新实现上面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_actor</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = <span class="keyword">yield</span>   <span class="comment"># 等待接收信息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Got:&quot;</span>, msg)</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Actor terminated&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = print_actor()</span><br><span class="line">    <span class="built_in">next</span>(p)  <span class="comment"># 开始，函数执行到yield部分</span></span><br><span class="line">    p.send(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>

<p>效果是完全一样的，只不过前一个是通过线程和队列完成，后面的是通过协程，背后的调度的机制不同，但是通讯方式都是点对点的通讯。</p>
<p>Actor 是一个独立个体，他不与其他 Actor 共享内存，通讯接口只有一个 send 函数。这种模式给出了统一不同并发组件（线程、进程、协程）的可能性，即 Actor 的实现可以是上述任意一种，用来因对不同的任务类型。比如 CPU 密集的任务可以通过 Process Actor 完成，而 IO 密集任务则可以通过 Coroutine Actor 处理。</p>
<h3 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h3><p><code>A &lt;---&gt; 网关 &lt;---&gt; B</code></p>
<p>最后这个模式综合了前两种，把 队列 换成了网关，就是一个交换信息的地方，而 A 和 B 都是 Actor。网关的好处在于，Actor 之间不会产生直接的联系，因此各项业务逻辑被很好的分离开来。而且网关还具有一些额外的功能，比如广播，把同一个消息发送给多个 Actor。各种复杂的路由逻辑可以被封装在 网关 里进行处理，而其他 Actor 就实现了并发。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>实现高并发需要三个基本组件：调度器、任务、通讯。而任务的实现可以有不同的方法，比如线程、进程或者协程。通讯通常是通过队列或者网关，而调度器需要另外实现，负责只能依赖操作系统的线程调度。在很多高并发的场景下并不理想。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/55761652/what-is-the-overhead-of-an-asyncio-task">https://stackoverflow.com/questions/55761652/what-is-the-overhead-of-an-asyncio-task</a></li>
<li><a href="https://effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently">https://effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently</a></li>
<li><a href="https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/">https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Concurrent</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS 3</title>
    <url>/2021/03/07/pyos_3/</url>
    <content><![CDATA[<blockquote>
<p>PyOS 0.3</p>
</blockquote>
<h1 id="PyOS-一个Python写的OS（3）"><a href="#PyOS-一个Python写的OS（3）" class="headerlink" title="PyOS - 一个Python写的OS（3）"></a>PyOS - 一个Python写的OS（3）</h1><p>目录：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/355189750">PyOS - 一个Python写的OS（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/355297680">PyOS - 一个Python写的OS（2）</a></li>
</ul>
<h2 id="实现子函数"><a href="#实现子函数" class="headerlink" title="实现子函数"></a>实现子函数</h2><p>在之前实现的OS中，我们的任务存在一个问题，就是不能进行非阻塞子函数调用。为啥呢？看如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> a + b</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    y = <span class="keyword">yield</span> add(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    m      = main()       </span><br><span class="line">    sub    = m.send(<span class="literal">None</span>)             </span><br><span class="line">    result = sub.send(<span class="literal">None</span>)</span><br><span class="line">    m.send(result)</span><br><span class="line">    </span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>上面这段函数的调用过程如下图：</p>
<p><img data-src="https://i.imgur.com/WBtCFuj.png" alt="Copyright (C) 2009, David Beazley, http://www.dabeaz.com"></p>
<p>问题出在我们的 Task 的结构，如果我们想要进行子函数调用，我们就需要一个 栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line">        self.stack   = []            <span class="comment"># Call stack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入 栈 后我们需要更新 task 的运行</span></span><br><span class="line">    <span class="comment"># 之前我们只需要直接通过send 触发 协程，现在我们需要考虑函数栈的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 执行到下一个 yield</span></span><br><span class="line">                result = self.target.send(self.sendval)</span><br><span class="line">                <span class="comment"># 检查结果</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall): <span class="keyword">return</span> result</span><br><span class="line">                <span class="comment"># 我们关心返回值为协程的调用，意味着发生了子函数调用</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, types.GeneratorType):</span><br><span class="line">                    <span class="comment"># 我们需要把 主函数 进栈，把执行对象换成 子函数</span></span><br><span class="line">                    self.stack.append(self.target)</span><br><span class="line">                    self.sendval = <span class="literal">None</span></span><br><span class="line">                    self.target  = result</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果返回值不是协程，说明子函数已经返回了</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.stack: <span class="keyword">return</span></span><br><span class="line">                    <span class="comment"># 这时，我们把子函数的返回值发送给 主函数，并把当前执行对象换成主函数</span></span><br><span class="line">                    self.sendval = result</span><br><span class="line">                    self.target  = self.stack.pop()</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.stack: <span class="keyword">raise</span></span><br><span class="line">                self.sendval = <span class="literal">None</span></span><br><span class="line">                self.target = self.stack.pop()</span><br></pre></td></tr></table></figure>

<p>具体解释在注释里。</p>
<h2 id="封装一些IO操作"><a href="#封装一些IO操作" class="headerlink" title="封装一些IO操作"></a>封装一些IO操作</h2><p>有了子函数后，我们就可以对之前的一些 IO 操作进行封装，隐藏 具体的 yield 信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Library Functions ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Accept</span>(<span class="params">sock</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">    <span class="keyword">yield</span> sock.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Send</span>(<span class="params">sock,buffer</span>):</span></span><br><span class="line">    <span class="keyword">while</span> buffer:</span><br><span class="line">        <span class="keyword">yield</span> WriteWait(sock)</span><br><span class="line">        <span class="built_in">len</span> = sock.send(buffer)</span><br><span class="line">        buffer = buffer[<span class="built_in">len</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recv</span>(<span class="params">sock,maxbytes</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">    <span class="keyword">yield</span> sock.recv(maxbytes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如上面就是三个Socket相关的函数，现在我们可以用这些系统库重写我们上一次的 Echo Server。</p>
<h2 id="重写-Echo-Server"><a href="#重写-Echo-Server" class="headerlink" title="重写 Echo Server"></a>重写 Echo Server</h2><p>这里我们不再需要直接OS call，而是使用一些封装的库函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutine.os.pyos1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span>(<span class="params">client, addr</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from &#x27;</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># OS call： read</span></span><br><span class="line">        <span class="comment"># 注意这里不再是OS call， 而是一个OS 的library call</span></span><br><span class="line">        data = <span class="keyword">yield</span> Recv(client,<span class="number">65536</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server receive &#x27;</span>, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># FD 已经关闭了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Echo</span></span><br><span class="line">        <span class="comment"># 注意这里不再是OS call， 而是一个OS 的library call</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server echo back&#x27;</span>, data)</span><br><span class="line">        <span class="keyword">yield</span> Send(client,data)</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Client closed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">port</span>):</span></span><br><span class="line">    <span class="comment"># 这是一个支持并发的 echo server</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Server start..&#x27;</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">&quot;&quot;</span>,port))</span><br><span class="line">    sock.listen(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        <span class="keyword">yield</span> NewTask(handle_client(client, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sched = Scheduler()</span><br><span class="line">sched.schedule(Task(server(<span class="number">45000</span>)))</span><br><span class="line"><span class="comment"># 启动系统</span></span><br><span class="line">sched.mainloop()</span><br></pre></td></tr></table></figure>


<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个系列就高于段落了，我们的PyOS停留在了0.3，其实还有很多东西可以考虑，比如：</p>
<ul>
<li>任务之间的通讯</li>
<li>阻塞任务，比如数据库读取</li>
<li>任务和线程结合</li>
<li>异常处理</li>
</ul>
<h2 id="最后最后"><a href="#最后最后" class="headerlink" title="最后最后"></a>最后最后</h2><p>其实，这个系列主要是想探索Python的协程并发编程，Python 3.5 以后引入了 <code>async/await</code> 关键字和一个相关的异步IO库 <code>asyncio</code>，这些内容都跟这个系列有些许的联系。</p>
<p>关于Python的并发，如果感兴趣还可以看：</p>
<ul>
<li>Stackless Python</li>
<li>Greenlet</li>
<li>Eventlet</li>
<li>Cogen</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>雅各书 3-4</title>
    <url>/2021/03/07/yageshu_13/</url>
    <content><![CDATA[<h1 id="雅各书-3：13-4：14"><a href="#雅各书-3：13-4：14" class="headerlink" title="雅各书 3：13 - 4：14"></a>雅各书 3：13 - 4：14</h1><h2 id="真正的智慧"><a href="#真正的智慧" class="headerlink" title="真正的智慧"></a>真正的智慧</h2><blockquote>
<p>13 你们中间谁是智慧、有见识的呢？他就应该有美好的生活，用明智的温柔，把自己的行为表现出来。14 如果你们心中存着刻薄的嫉妒和自私，就不可夸口，也不可说谎抵挡真理。15 这种智不是从天上来的，是属地的、属血气的和属鬼魔的。16 因为凡有嫉妒和自私的地方，就必有 扰乱和各样的坏事。 17 <strong>至于从天上来的智慧，首先是纯洁的，其次是和平的，温柔的，谦逊的， 满有恩慈和善果，没有偏袒，没有虚伪。 18 这是缔造和平的人，用和平所培植出来的义果。</strong><br>[name=雅各书13]</p>
</blockquote>
<p>从神而来的智慧，应该是表里如一的。不可当面一套，心理一套，教会一套，生活一套。这样割裂的状态就不是智慧的。作为一个基督徒，作为一个智慧的基督徒，应该是始终如一的。</p>
<h2 id="放纵私欲，做世界的朋友"><a href="#放纵私欲，做世界的朋友" class="headerlink" title="放纵私欲，做世界的朋友"></a>放纵私欲，做世界的朋友</h2><p>雅各笔锋锐利，丝毫不留面子。</p>
<blockquote>
<p>4 你们中间的争执和打斗是从哪里来的呢?不是从你们肢体中好斗的私欲来的吗? 2 你们放纵贪 欲，如果得不到，就杀人;你们嫉妒，如果一无所得，就打斗争执。你们得不到，因为你们不求; 3 你们求也得不到，因为你们的动机不良，要把所得的耗费在你们的私欲上。 4 淫乱的人哪，你们不知道与世俗为友，就是与 神为敌吗?所以与世俗为友的，就成了 神的仇敌。 <strong>5 圣经说:“ 神爱他那安置在我们里面的灵，爱到嫉妒的地步” 你们想这话是徒然的吗? 6 但 神所赐的恩更大; 所以圣经上说:“ 神抵挡骄傲的人，赐恩给谦卑的人。”</strong><br>[name=雅各书14]</p>
</blockquote>
<p>婚姻是神的奥秘，就是用来展示人和神的关系。</p>
<h2 id="谦卑悔改，恩典便会降临"><a href="#谦卑悔改，恩典便会降临" class="headerlink" title="谦卑悔改，恩典便会降临"></a>谦卑悔改，恩典便会降临</h2><blockquote>
<p>7 你们应当顺服 神，抵挡魔鬼，魔鬼就逃避你们。8 你们应当亲近 神， 神就亲近你们。罪人 啊，要洁净你们的手;三心两意的人哪，要清洁你们的心。 9 你们要愁苦、悲哀、哭泣，把欢笑 变为伤痛，把快乐变为忧愁。 10 你们务要在主面前谦卑，他就使你们高升。<br>[name=雅各书14]</p>
</blockquote>
<p>基督徒就有能力抵挡撒旦，神希望我们痛彻心扉的悔改。这悔改的权利，恰恰是神的恩典。求神赐给我们这样的谦卑和悔改。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>雅各书</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS</title>
    <url>/2021/03/06/pyos_1/</url>
    <content><![CDATA[<h1 id="PyOS-一个Python写的OS（1）"><a href="#PyOS-一个Python写的OS（1）" class="headerlink" title="PyOS - 一个Python写的OS（1）"></a>PyOS - 一个Python写的OS（1）</h1><blockquote>
<p>引用自David Beazley的视频PPT</p>
</blockquote>
<p>PyOS 这个系列，我们进一步利用协程的特性，一步一步的构建一个多任务操作系统。系列的最后，我们会在我们自己写的PyOS上实现一个 Web Client/Server。</p>
<p>当然，这不是真正的操作系统，而是一个操作系统上的操作系统。。哈哈。完成这个系列可以对并发编程、协程、操作系统多任务管理、IO有更深刻的认识。当然，你还会收货成就感。</p>
<p>对协程不太了解的同学请看：<a href="https://zhuanlan.zhihu.com/p/354982602">https://zhuanlan.zhihu.com/p/354982602</a></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>需要指出的是，当CPU（假设只有一个核心）运行你的代码时，OS自己的代码就不可能被执行。那么，操作系统是如何拿回控制权的呢？通常，操作系统有两种方式拿回CPU的控制权：Interrupt和Traps。Interrupt通常是IO或者计时器发出的，而Trap是其他软件生成的给CPU的信号。当CPU收到这两种信号后，会挺会手上的活，移交执行权给OS代码。当应用程序调用OS提供的底层函数时，通常会产生Trap，从而把执行权交还OS。</p>
<p>所以，某种程度上说，OS的一个重要的组成部分就是多任务切换和管理，充分利用有限的CPU资源。</p>
<p><img data-src="https://i.imgur.com/pYNOZgW.png" alt="OS多任务"></p>
<h2 id="用-协程-构建OS"><a href="#用-协程-构建OS" class="headerlink" title="用 协程 构建OS"></a>用 协程 构建OS</h2><p>如果你还记得上一次我们讲到的<code>yield</code>关键字，你会发现他就是一个Trap，一个协程会在 yield的时候交出执行权！利用这点，我们就可以用 协程 构建一个多任务操作系统！不需要线程、进程。</p>
<p>首先，既然是多任务系统，我们首先要抽象一个Task对象出来，代表任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple generator/coroutine function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span> ( <span class="string">&quot;Part 1&quot;</span> )</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span> ( <span class="string">&quot;Part 2&quot;</span> )</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">t1 = Task(foo())</span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot;Running foo()&quot;</span> )</span><br><span class="line">t1.run()</span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot;Resuming foo()&quot;</span> )</span><br><span class="line">t1.run()</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>foo</code> 是一个 协程，然后被放入Task中，foo 会在 yield 的地方把执行权交还系统。接下来，我们需要实现一个 调度器，对任务进行管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">           <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            result = task.run()</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Two tasks</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span> ( <span class="string">&quot;I&#x27;m foo&quot;</span> )</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span> ( <span class="string">&quot;I&#x27;m bar&quot;</span> )</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Run them</span></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>上面的例子中，foo bar程序会在调度器的控制下交替执行，直到永远。。对应的代码即见注释。简单来说，就是系统会不断轮训任务队列，并执行任务，直到任务的下一个 yield，系统进入新的循环。</p>
<p>现在有一个问题，就是我们的 任务其实是协程，Python的协程在执行接触后，会抛出<code>StopIteration</code> 异常，我们的系统主循环就会crash。所以，我们需要一个优雅的结束任务的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 优雅的结束任务！</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.taskid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.taskid]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m bar&quot;</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<h2 id="OS-call"><a href="#OS-call" class="headerlink" title="OS call"></a>OS call</h2><p>是不是很有成就感？我们的多任务OS已经基本可以运行了！其实，这里的 Scheduler 就是我们的OS，而Task就是跑在系统中的一个个进程。现在，我们给我们的OS提供一些基本的 System Call。因为在现实的OS中，应用程序需要 system call 来操作系统资源。为了请求系统资源，任务会用到带值的 yield 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>首先，我们 写一个 system call 的基类作为其他 OS call 的接口。然后，我们需要修改OS 的循环来处理 OS call。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这里仅给出了 mainloop 部分。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br></pre></td></tr></table></figure>

<p>ok，框架搭好了，我们来实现第一个 OS call： GetTid，向系统请求任务ID。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;I&#x27;m foo&quot;</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;I&#x27;m bar&quot;</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>恭喜你！PyOS 0.1 已经实现了！</p>
<p>接下来我们会增加更多的 OS call，然后我们会进入 I/O 相关的任务，最后，我们会在PyOS上跑一个web server。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS 2</title>
    <url>/2021/03/06/pyos_2/</url>
    <content><![CDATA[<h1 id="PyOS-一个Python写的OS（2）"><a href="#PyOS-一个Python写的OS（2）" class="headerlink" title="PyOS - 一个Python写的OS（2）"></a>PyOS - 一个Python写的OS（2）</h1><p><a href="https://zhuanlan.zhihu.com/p/355189750">上文</a>我们的PyOS已经可以处理多任务了，而且加入了第一个 OS call：<code>GetTid</code> 来获取任务ID。今天，我们继续开发我们的OS，增加更多的 OS call。</p>
<h2 id="更多-OS-call"><a href="#更多-OS-call" class="headerlink" title="更多 OS call"></a>更多 OS call</h2><p>我们需要增加两个基本的系统函数：<code>NewTask</code> 和 <code>KillTask</code> 让操作系统进行基本的任务管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了基本的任务管理功能，尝试下面的程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        pid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>, pid)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        child = <span class="keyword">yield</span> NewTask(foo())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> KillTask(child)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Main task done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(main())</span><br><span class="line">    sched.mainloop()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">Main task done.</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们在主进程里面启动了一个子任务，并且实现了并发和任务结束。</p>
<h2 id="实现-WaitTask"><a href="#实现-WaitTask" class="headerlink" title="实现 WaitTask"></a>实现 WaitTask</h2><p>WaitTask 这个功能相对复杂一点，我们想实现一个费阻塞的等待功能。这个需要修改一下我们的 调度器。实现原理不复杂，当一个任务A请求等待另一个任务B退出后再继续执行的时候，调度器首先检查B任务是否存在，如果B不存在，立即返回。如果B存在，我们把A放入B的等待退出队列中，然后交出执行权。然后，在调度器的 <code>exit</code> 函数中增加一个检查，当一个任务结束时会将等待它退出的任务重新放入执行队列。完整程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 用来记录等待退出的任务</span></span><br><span class="line">        self.exit_waiting = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.tid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">        <span class="comment"># 通知其他等待退出的任务，这个任务结束了，可以恢复执行了</span></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> self.exit_waiting.pop(task.tid,[]):</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforexit</span>(<span class="params">self, task, waittid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> waittid <span class="keyword">in</span> self.taskmap:</span><br><span class="line">            self.exit_waiting.setdefault(waittid, []).append(task)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    <span class="comment"># task 和 sched 都是调用OS call 的任务的信息</span></span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                   === System Calls ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a task to exit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        pid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>, pid)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        child = <span class="keyword">yield</span> NewTask(foo())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Waiting for child task exit&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> WaitTask(child)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Child task terminated.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(main())</span><br><span class="line">    sched.mainloop()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Waiting for child task exit</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">Child task terminated.</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>目前我们的OS可以：</p>
<ul>
<li>并发运行多任务</li>
<li>启动、终结任务</li>
<li>基本的任务管理，比如等待</li>
</ul>
<h2 id="实现-非阻塞IO"><a href="#实现-非阻塞IO" class="headerlink" title="实现 非阻塞IO"></a>实现 非阻塞IO</h2><p>由于我们的PyOS运行在真正的OS上，OS的IO操作会挂起整个Python解释器，我们需要实现一个费阻塞IO的功能。为了实现这个功能，需要用到Python的 <code>select</code> 模块。完整代码如下，注释会解释新增的部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 用来记录等待退出的任务</span></span><br><span class="line">        self.exit_waiting = &#123;&#125;</span><br><span class="line">        <span class="comment"># IO 队列</span></span><br><span class="line">        self.read_waiting = &#123;&#125;</span><br><span class="line">        self.write_waiting = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.tid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">        <span class="comment"># 通知其他等待退出的任务，这个任务结束了，可以恢复执行了</span></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> self.exit_waiting.pop(task.tid,[]):</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforexit</span>(<span class="params">self, task, waittid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> waittid <span class="keyword">in</span> self.taskmap:</span><br><span class="line">            self.exit_waiting.setdefault(waittid, []).append(task)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># IO 功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforread</span>(<span class="params">self,task,fd</span>):</span></span><br><span class="line">        self.read_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforwrite</span>(<span class="params">self,task,fd</span>):</span></span><br><span class="line">        self.write_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iopoll</span>(<span class="params">self, timeout</span>):</span></span><br><span class="line">        <span class="comment"># io poll 返回当前可用的文件标识符，然后把等待它的任务，重新放入执行队列，等待执行</span></span><br><span class="line">        <span class="keyword">if</span> self.read_waiting <span class="keyword">or</span> self.write_waiting:</span><br><span class="line">            r, w, e = select.select(self.read_waiting,</span><br><span class="line">                                    self.write_waiting,[],timeout)</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> r:</span><br><span class="line">                self.schedule(self.read_waiting.pop(fd))</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> w:</span><br><span class="line">                self.schedule(self.write_waiting.pop(fd))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iotask</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># IO 任务队列循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ready.empty():</span><br><span class="line">                self.iopoll(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.iopoll(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里加入一个 IO 自己的 任务循环</span></span><br><span class="line">        self.new(self.iotask())</span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    <span class="comment"># task 和 sched 都是调用OS call 的任务的信息</span></span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                   === System Calls ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a task to exit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for reading</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWait</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,f</span>):</span></span><br><span class="line">        <span class="comment"># 这里的 f 就是 fd</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforread(self.task,fd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for writing</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteWait</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,f</span>):</span></span><br><span class="line">        <span class="comment"># 这里的 f 就是 fd</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforwrite(self.task,fd)</span><br></pre></td></tr></table></figure>


<h2 id="我们的第一个应用程序！"><a href="#我们的第一个应用程序！" class="headerlink" title="我们的第一个应用程序！"></a>我们的第一个应用程序！</h2><p>现在我们的PyOS已经可以支持IO了，让我们来写第一个应用程序：Echo Server！这是一个支持并发的server！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span>(<span class="params">client, addr</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from &#x27;</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># OS call： read</span></span><br><span class="line">        <span class="keyword">yield</span> ReadWait(client)</span><br><span class="line">        data = client.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server receive &#x27;</span>, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># FD 已经关闭了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Echo</span></span><br><span class="line">        <span class="keyword">yield</span> WriteWait(client)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server echo back&#x27;</span>, data)</span><br><span class="line">        client.send(data)</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Client closed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">port</span>):</span></span><br><span class="line">    <span class="comment"># 这是一个支持并发的 echo server</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Server start..&#x27;</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">&quot;&quot;</span>,port))</span><br><span class="line">    sock.listen(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        <span class="keyword">yield</span> NewTask(handle_client(client, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sched = Scheduler()</span><br><span class="line">sched.schedule(Task(server(<span class="number">45000</span>)))</span><br><span class="line"><span class="comment"># 启动系统</span></span><br><span class="line">sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>运行上述程序后，会看到 <code>Server start..</code>。这是后你可以打开 terminal，输入：<code>telnet localhost 45000</code> 来建立连接。然后你就可以看到 server echo 你输入的信息了。是不是很有成就感！！</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前PyOS还有一个比较致命的问题：任务不能 yield 到另一个任务，只能把执行权交还给操作系统，而不能交给其他任务。。下一篇我们看如何解决这个问题。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（4）并发模型</title>
    <url>/2021/03/05/python_concurrent/</url>
    <content><![CDATA[<h1 id="重新认识-Python（4）并发模型"><a href="#重新认识-Python（4）并发模型" class="headerlink" title="重新认识 Python（4）并发模型"></a>重新认识 Python（4）并发模型</h1><h2 id="并发是什么？"><a href="#并发是什么？" class="headerlink" title="并发是什么？"></a>并发是什么？</h2><p>并发一般是指多个计算在时间上无固定先后顺序的执行。并发程序不一定存在并行。举个例子<a href="https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/#message_passing_example">reference</a>: </p>
<p><img data-src="https://i.imgur.com/LG0PL9t.png" alt="并发实例"></p>
<p>上面的例子中我们有三个任务，T1~3，这三个任务就属于并发执行，而且因为有两个CPU，所以存在一定的并行。左图是每一个任务在CPU核心的执行情况，而右图是从任务自身的时间线角度表达任务的执行情况。可以看到任务通常不是连续执行，而是根据调度情况间断执行。</p>
<p>并发编程的一个好处就是可以让数量有限的CPU核心，“看起来”同时执行数量远远大于核心数量的任务，换句话说，增加系统的对请求的响应程度。</p>
<p>并发模型最常见的程序其实就是操作系统，一个普通的操作系统运行在一个8核CPU上，却可以“看起来”同时执行成千上万个任务，这就是并发模型的效果。</p>
<p>如果不谈操作系统，而是其他基于操作系统的应用的例子，比如Web 服务器，需要同时对众多请求作出回应。</p>
<h2 id="Python怎么搞并发？"><a href="#Python怎么搞并发？" class="headerlink" title="Python怎么搞并发？"></a>Python怎么搞并发？</h2><p>Python提供了三种并发的工具：多线程（threading）、多进程（process）和协程（Coroutine）。前两种其实就是利用了操作系统提供的并发模型。</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>CPython的Thread其实就是操作系统的线程，基本没有overhead。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PYTHREAD_NAME <span class="meta-string">&quot;pthread&quot;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(NT_THREADS)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PYTHREAD_NAME <span class="meta-string">&quot;nt&quot;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_nt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> <span class="meta-string">&quot;Require native threads. See https://bugs.python.org/issue31370&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码可见，Python会根据操作系统调用对应系统的线程API，然后把调度工作移交OS。这里需要注意的是，由于GIL的存在，每一个Python解释器进程中，同一时间只能有一个线程执行。这意味着，在这种情况下，利用线程实现的并发模型中，不存在并行。</p>
<p>线程实现的并发模型比较容易理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    target = <span class="keyword">lambda</span> : <span class="built_in">print</span>(<span class="string">&#x27;Hello from NEW thread\n&#x27;</span>)</span><br><span class="line">    my_thread = threading.Thread(target=target)</span><br><span class="line">    my_thread.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello from MAIN thread\n&#x27;</span>)</span><br><span class="line">    my_thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>开进程，指定任务，执行就可以了。其余的调度工作完全移交操作系统统一管理。当然，这样做的弊端也很明显：</p>
<ul>
<li>线程创建和切换的开销都比较大，数量有限</li>
<li>移交操作系统调度后，程序员基本失去了对任务的控制，属于抢占式</li>
</ul>
<h3 id="协程，Coroutine"><a href="#协程，Coroutine" class="headerlink" title="协程，Coroutine"></a>协程，Coroutine</h3><p>为了解决上面的弊端，Python也给出了协程的方案。协程跟线程的最大区别就是：协程是协作式的，线程是抢占式的。具体讲就是一个协程会在预订的位置让出执行权，并且主动的移交给其他协程，而线程则是抢占式的，一个线程会在任意时间被夺去执行权。</p>
<p>协程可以理解成是一般函数的泛化。一般的函数只有一个入口和若干个出口，协程具有多个入口和出口。</p>
<p>在Python中主要涉及到<code>yield</code> 和 <code>yield from</code> 关键字。</p>
<p>下面举几个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Hello &quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;World!&quot;</span></span><br><span class="line"></span><br><span class="line">hw = hello_world()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Hello </span></span><br><span class="line"><span class="comment"># World!</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure>

<p><code>next</code> 函数会逐一访问到每一个yield点，知道没有其他 yield 为止。而 yield 的功能就是让函数交出执行权，知道下一次被调用，他会从上一个yield点开始执行。严格来讲，上面这个 hello_world 还不是完整的协程，因为 yield 仅仅把执行权交还给调用方，而不是任意其它协程。我们看下一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">co1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;co1&#x27;</span></span><br><span class="line"></span><br><span class="line">c1 = co1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">co2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> c1</span><br><span class="line"></span><br><span class="line">c2 = co2()</span><br><span class="line"><span class="built_in">next</span>(c2)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># World</span></span><br><span class="line"><span class="comment"># co1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，协程 co2 把执行权主动交给 co1 而不是交还给调用方。</p>
<p>不过，Python 3.5以后引入了<code>asnyc/await</code> 作为协程的原生支持。其实就是是避免写 <code>yield</code> 与 生成器混淆，如果你trace down代码的话，所有的 await 最后都会在某处出现 <code>yield</code> 关键字。我们举个例子就会发现其实 async/await 就是 yield 的语法糖，表明函数时协程，而不是普通函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awaitable</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__await__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_</span>():</span></span><br><span class="line">    <span class="keyword">return</span> Awaitable()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">a1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> yield_()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = a1()</span><br><span class="line">a.send(<span class="literal">None</span>)</span><br><span class="line">a.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># World!</span></span><br></pre></td></tr></table></figure>

<p>可以看出，async 定义的函数就是一个协程。</p>
<p>至此，我们已经了解协程的基本原理，下面我们来看一下如何利用协程实现并发。</p>
<h3 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h3><p>假设我们有两个任务需要并发执行，一个向上数，一个向下数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">countdown(<span class="number">5</span>)</span><br><span class="line">countup(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>运行上面程序肯定无法实现并发，而是顺序执行。由于loop和sleep的存在程序也会block。那么我们如何实现并发？</p>
<p>首先，我们需要把函数改写成 协程 ，这样这两个任务就可以主动交出执行权。然后需要我们自己写一个 调度器 来实现不同任务的并发调度。最后我们还需要处理一下sleep的block问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 这样，函数就可以在loop的途中交出执行权</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 这样，函数就可以在loop的途中交出执行权</span></span><br><span class="line">        x += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过加入 yield，这两个任务现在会在每一次loop的时候主动交出控制权。接下来，我们来实现一个简单的调度器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.current = <span class="literal">None</span>  <span class="comment"># 当前任务的指针</span></span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span>(<span class="params">self, coro</span>):</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.ready:</span><br><span class="line"></span><br><span class="line">            self.current = self.ready.popleft()</span><br><span class="line">            <span class="comment"># 执行下一步</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current.send(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> self.current:</span><br><span class="line">                    self.ready.append(self.current)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sched = Scheduler1()</span><br><span class="line">sched.new_task(countdown(<span class="number">5</span>))</span><br><span class="line">sched.new_task(countup(<span class="number">5</span>))</span><br><span class="line">sched.run()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Down 5</span></span><br><span class="line"><span class="string">Up 0</span></span><br><span class="line"><span class="string">Down 4</span></span><br><span class="line"><span class="string">Up 1</span></span><br><span class="line"><span class="string">Down 3</span></span><br><span class="line"><span class="string">Up 2</span></span><br><span class="line"><span class="string">Down 2</span></span><br><span class="line"><span class="string">Up 3</span></span><br><span class="line"><span class="string">Down 1</span></span><br><span class="line"><span class="string">Up 4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，通过简单的调度，我们就实现了两个任务的并发执行。调度器本身的原理非常简单，就是一个循环，不断检查是否有活跃的任务，如果有，就通过 send 执行任务，如果没有异常，就说明任务没有完成，再把任务放回队列。循环。</p>
<p>现在我们还有一个问题，就是sleep的问题，现在sleep还是block的。我们需要在 调度器 中处理这种情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.sleeping = []</span><br><span class="line">        self.current = <span class="literal">None</span>  <span class="comment"># 当前任务的指针</span></span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self, delay</span>):</span></span><br><span class="line">        deadline = time.time() + delay</span><br><span class="line">        self.sequence += <span class="number">1</span>  <span class="comment"># 这个是为了 heap 排序</span></span><br><span class="line">        heapq.heappush(self.sleeping, (deadline, self.sequence, self.current))</span><br><span class="line">        self.current = <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 交出控制权限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span>(<span class="params">self, coro</span>):</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.ready <span class="keyword">or</span> self.sleeping:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.ready:</span><br><span class="line">                deadline, _, coro = heapq.heappop(self.sleeping)</span><br><span class="line">                delta = deadline - time.time()</span><br><span class="line">                <span class="keyword">if</span> delta &gt; <span class="number">0</span>:</span><br><span class="line">                    time.sleep(delta)</span><br><span class="line">                self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">            self.current = self.ready.popleft()</span><br><span class="line">            <span class="comment"># 执行下一步</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current.send(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> self.current:</span><br><span class="line">                    self.ready.append(self.current)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> sched.sleep(<span class="number">1</span>)  <span class="comment"># 注意这里，协程主动把执行权交给 sleep，就是另一个协程</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> sched.sleep(<span class="number">0.2</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Down 5</span></span><br><span class="line"><span class="string">Up 0</span></span><br><span class="line"><span class="string">Down 4</span></span><br><span class="line"><span class="string">Up 1</span></span><br><span class="line"><span class="string">Up 2</span></span><br><span class="line"><span class="string">Up 3</span></span><br><span class="line"><span class="string">Up 4</span></span><br><span class="line"><span class="string">Up 5</span></span><br><span class="line"><span class="string">Down 3</span></span><br><span class="line"><span class="string">Up 6</span></span><br><span class="line"><span class="string">Up 7</span></span><br><span class="line"><span class="string">Up 8</span></span><br><span class="line"><span class="string">Up 9</span></span><br><span class="line"><span class="string">Up 10</span></span><br><span class="line"><span class="string">Down 2</span></span><br><span class="line"><span class="string">Up 11</span></span><br><span class="line"><span class="string">Up 12</span></span><br><span class="line"><span class="string">Up 13</span></span><br><span class="line"><span class="string">Up 14</span></span><br><span class="line"><span class="string">Up 15</span></span><br><span class="line"><span class="string">Down 1</span></span><br><span class="line"><span class="string">Up 16</span></span><br><span class="line"><span class="string">Up 17</span></span><br><span class="line"><span class="string">Up 18</span></span><br><span class="line"><span class="string">Up 19</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，调度器通过一个 sleep 协程实现了非阻塞的睡眠。<code>yield from</code> 可以把执行权交给另一个协程，而不是调度器。</p>
<p>其实，如果你用过 <code>asyncio</code> 库，就会发现这个库的核心就是一个类似的调度器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>这里面的 <code>await</code> 就是 <code>yield from</code> 的功能，即把执行权移交另一个协程。而 <code>async</code> 的主要目的是规范化协程语法，与一般函数进行区别。当然，Python内部有后来慢慢加入了不同的类型。比如 <code>async</code> 定义的协程的类型是： async_generator， 而 yield 定义的类型为： generator。</p>
<h2 id="Python并发还能怎么搞？"><a href="#Python并发还能怎么搞？" class="headerlink" title="Python并发还能怎么搞？"></a>Python并发还能怎么搞？</h2><p>上面提到的都是一些比较常见的方法。当然Python里面还有一些不太常用到的模型。比如</p>
<ul>
<li>Actor Model</li>
<li>CSP</li>
<li>Multiple Interpreters，<a href="https://www.python.org/dev/peps/pep-0554/#id56">https://www.python.org/dev/peps/pep-0554/#id56</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=Y4Gt3Xjd7G8">https://www.youtube.com/watch?v=Y4Gt3Xjd7G8</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Concurrent</tag>
        <tag>Async</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>关于类型系统的一些思考</title>
    <url>/2021/02/20/type_system/</url>
    <content><![CDATA[<h2 id="类型系统是什么"><a href="#类型系统是什么" class="headerlink" title="类型系统是什么"></a>类型系统是什么</h2><blockquote>
<p>类型系统是一个有多个规则组成的逻辑系统，系统内的规则会给程序中的每一个组成部分，包括变量、表达式、函数、甚至模块等等，制定一个 类型 属性。</p>
</blockquote>
<p>通俗的讲，类型系统是为了赋予程序或者数据意义。因为任何值或者一个函数，在内存里面都只是一串bits，而类型就是要给这串bits意义。例如，<code>10</code> 是的类型是一个奇怪的 int 类型，这个int只有两位。类型系统会给你加额外的信息让他变成一个 int，<code>01|10</code>，这里我们假设类型占两位，01就是int的bit表达，| 用来区分类型和值。这是，10就有了意义，而且程序在编译阶段或者运行时就可以通过这个类型标识确保采用合法的操作来操作这个值。</p>
<p>换句话说，类型系统形成了一个除了语法（syntax）和语义（semantic）以外的另一套可以用来分析代码的系统。刚才我们也提到了，类型系统属于逻辑系统，就是通过规则（rule）可以进行推到和证明。所以我们可以肯定的说，好的类型系统可以帮助我们从逻辑角度分析程序，减少bug。因为语法和语义其实并没有办法从逻辑层面表达任何关于程序本身要做的事情。而类型系统可以发现一些逻辑错误，至少在他的rule可以推导的范围内。</p>
<p>有些语言只会给变量制定类型，而表达式、函数则没有类型。比如 Python 中，<code>if a == 1: 1 else: 2</code> 这个表达式是没有类型的概念的。而在 Ocaml 中，<code>if a=1 then 1 else 2</code> 这个表达式有类型 int。事实上一般函数式语言的类型覆盖会更加广泛，而过程式语言覆盖则低很多，比如表达式基本都是没有类型的。显然，类型覆盖约广泛，这个逻辑系统能提供的帮助就越多。</p>
<p>在实际工程中，好的类型系统会提高编译优化能力，甚至对代码重构、测试都有重要的作用。简单来讲，类型系统不但可以减少运行时的bug，还可以协助程序员进行开发。</p>
<p>当然，设计好的类型系统比较复杂，类型系统设计的有问题，反而会增加程序员的负担。</p>
<h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><p>当我们从类型系统的角度讨论计算机语言的时候，可以从如下四个维度看：</p>
<ul>
<li>类型安全(type safe)，分为强和弱</li>
<li>类型表达(type expression), 分为显式和隐式</li>
<li>类型比较(type compatibility)， 一般可以有结构式(structural)和Norminal</li>
<li>类型检查(type checking), 分为静态和动态</li>
</ul>
<p>我举几个例子帮助大家对上面四点有个感性的认知：</p>
<p>语言 | 类型安全 | 类型表达 | 类型比较 | 类型检查 |<br>| ——– | ——– | ——– | ——– | ——- |<br>| C        | 弱       | 显式       | Nominal  | 静态  |<br>| Python   | 强       | 隐式或者显式 | Structural       | 动态  |<br>| Java     | 强       | 显式      | Nominal  | 静态 |<br>| Ocaml    | 强       | 隐式或者显式 | Nominal/Structural | 静态 |</p>
<p>为了进一步理解，我们需要知道这四个维度的定义。</p>
<p><strong>类型安全</strong></p>
<p>一个语言是强类型安全，必须保证代码只能读取自己可以读取的内存区域，并且类型安全的代码不能对一个对象进行不合法的操作。这种保证可以是静态的，即在编译阶段，也可以是动态的，即在运行时。换个说法，类型</p>
<p>C语言的大部分代码是类型安全的，但是C语言的运行时不能保证类型安全，主要是因为可以进行cast操作。比如，要把指针放入array的时候，需要将指针cast成 <code>void*</code>，但是这个操作会丢失所有类型信息，当取回时，有需要 cast 回到原来的类型。由于这些cast的存在，系统运行时可能会出现意想不到的的行为。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = <span class="string">&quot;37&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* z = x + y;</span><br></pre></td></tr></table></figure>

<p>这段c代码中，<code>z</code> 会指向一个内存地址，这个地址是比 <code>y</code> 地址+5 char的一个位置，这个位置可能是任何数据，但是程序本身不会直接崩溃，直到使用z的时候导致更加严重的问题，导致崩溃。而在Java中上述代码会在编译阶段报错。Python属于动态类型，类型安全也只能在运行时抛出异常。</p>
<p>当然这只是很简单的情况，Ocaml其实有用更加的强大的类型系统，能发现比上面这种明显问题更加不显然的逻辑错误。我们后面举例。</p>
<p><strong>类型表达</strong></p>
<p>所谓显示，就是指必须在代码中现实的写出变量的类型，比如C语言中，需要 <code>int a = 1;</code>；而在隐式语言中，比如Python，可以直接写 <code>a = 1</code>。当然对于带有类型推断的语言，比如Ocaml也可以写 <code>let a = 1</code>，不过Ocaml的类型系统已经推断出a的类型是int。Python的情况，只有在运行时才能解释器才能确定a的类型。</p>
<p><strong>类型比较</strong></p>
<p>这里主要在讨论如何说明两个变量的类型是相同的？对于Nominal类型系统，比较非常简单，只要两个类型的名字不一样，他们就是不一样的！无论他们的行为如何。但是对于Structural 类型系统，也叫 property based，只要两个类型的行为一样，他们就是一样的。对于一些存在集成的系统，比较就更加复杂了，需要更多的规则。</p>
<p>结构化类型最好的代表其实Python，在Python的世界里更喜欢被叫做 duck typing。我举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a = <span class="number">1</span>   </span><br><span class="line">        </span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy</span>(<span class="params">o</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(o.a)</span><br><span class="line">    </span><br><span class="line">dummy(a)</span><br><span class="line">dummy(b)</span><br></pre></td></tr></table></figure>

<p>上面的代码运行完全没有问题，但是dummy函数的参数o却支持不同的类型（A和B），这就是所谓的 duck typing。</p>
<p><strong>类型检查</strong></p>
<p>这个很好理解，类型检查就是确保类型安全的过程。如果类型检查发生在编译阶段，那么就是静态类型；反之则是动态类型。</p>
<p>当然，也可以有另一个层面的理解，就是如果类型可以在运行时发生改变，那么就属于动态类型。Python毫无争议属于动态类型，但是Java在引入反射后，反而变得更加动态了。。。另一方面 Ocaml 的类型是完全静态的。</p>
<h2 id="类型系统痛点"><a href="#类型系统痛点" class="headerlink" title="类型系统痛点"></a>类型系统痛点</h2><p>带来了那些痛点？</p>
<ul>
<li>（通常）需要更多的代码</li>
<li>奇葩的编译错误</li>
</ul>
<p><em>举例1：需要更多的代码</em></p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">truncate_reminder</span>(<span class="params">x</span>):</span></span><br><span class="line">    int_part = <span class="built_in">int</span>(x)</span><br><span class="line">    <span class="keyword">return</span> (int_part, x - int_part)</span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 应该感谢Java终于有了泛型。。。不然这段代码的长度会扩大两倍。。。。</span></span><br><span class="line"><span class="comment"> * 泛型算是类型系统一个改善，Java之前的类型系统表达能力真的非常有限 。。。 */</span></span><br><span class="line"><span class="function">Pair&lt;Int, Float&gt; <span class="title">truncateReminder</span><span class="params">(Float x)</span> </span>&#123;</span><br><span class="line">    Int intPart = Int(x);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Pair&lt;Int, Float&gt;(intPart, x - intPart));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ocaml</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> truncate_reminder x = </span><br><span class="line">  <span class="keyword">let</span> int_part = truncate x <span class="keyword">in</span></span><br><span class="line">    (int_part, x -. <span class="built_in">float</span> int_part)</span><br><span class="line">    <span class="comment">(* float 需要显式的写出来，不然编译器也会告诉你这个 *)</span></span><br></pre></td></tr></table></figure>

<p>上面可以发现，Python代码显然是最简洁的，Ocaml其次，Java则多了很多类型标识符+泛型。Ocaml的类型系统可以进行推断，如果推断失败了，它会告诉你它需要哪些提示来完成推断，这样就即有了动态语言的简洁，又可以有用静态类型系统的好处。</p>
<p><em>举例2： 奇葩的错误</em></p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>([<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">len</span>(<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">TypeError                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="string">&lt;ipython-input-2-1cf91bb60cc0&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="string">----&gt; 1 len(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeError: object of type &#x27;int&#x27; has no len()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Ok，Python的类型错误提示还是很友好的。</p>
<p><strong>Ocaml</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>.length([<span class="number">1</span>])</span><br><span class="line"><span class="comment">(* 1 *)</span></span><br><span class="line"><span class="type">List</span>.length(<span class="number">1</span>)</span><br><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">Line 1, characters 11-14:</span></span><br><span class="line"><span class="comment">Error: This expression has type int but an expression was expected of type</span></span><br><span class="line"><span class="comment">         &#x27;a list</span></span><br><span class="line"><span class="comment">*)</span></span><br></pre></td></tr></table></figure>

<p>hmm，看起来更复杂一点了，比如<code>&#39;a list</code>是啥？需要更多关于带参类型的理解，才能读懂这段错误提示。但是起码，你看到表达式的类型是int，然而这个函数需要 类型 <code>a list</code>。（不懂无所谓现在）但是显然，类型系统需要更多的学习。</p>
<p>让我们来看看更加先进的Haskell:</p>
<p><strong>Haskell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :t length</span><br><span class="line">length :: Foldable t &#x3D;&gt; t a -&gt; Int</span><br><span class="line"></span><br><span class="line">-- hmm Foldable 是啥？ lenght这个函数的类型是 Foldable t &#x3D;&gt; t a -&gt; Int。 ok</span><br><span class="line">-- 在看</span><br><span class="line">Prelude&gt; length [1]</span><br><span class="line">1</span><br><span class="line">-- ok 结果正确，但是。。。</span><br><span class="line">Prelude&gt; length 1</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:4:8: error:</span><br><span class="line">    • No instance for (Num [a0]) arising from the literal ‘1’</span><br><span class="line">    • In the first argument of ‘length’, namely ‘1’</span><br><span class="line">      In the expression: length 1</span><br><span class="line">      In an equation for ‘it’: it &#x3D; length 1</span><br></pre></td></tr></table></figure>

<p>看到最后的错误提示，你是什么感觉呢？你只是想求一个int 的长度而已。。。</p>
<h2 id="类型系统好处"><a href="#类型系统好处" class="headerlink" title="类型系统好处"></a>类型系统好处</h2><ul>
<li>提高程序的性能</li>
<li>检测错误</li>
<li>指导代码重构</li>
<li>强迫不变量(Invariants)</li>
<li>让tooling变得更加简单</li>
</ul>
<p>工程经验表明，类型系统带来的好处，远远超过了痛点。特别是对于大型、需要多人合作的项目。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>选择类型安全的语言，除非你知道你面对的是什么</li>
<li>动态类型和静态类型各有利弊</li>
<li>不同的类型系统带来的表达能力和优势完全不一样</li>
<li>类型系统也不是越复杂越高级越好</li>
</ul>
<p>动态语言非常灵活，代码更加简洁，非常适合快速原型或者一些对正确性要求不高的项目。动态语言也更适合开发人员较少的项目。而静态类型语言则更加注重代码的正确性和性能，良好的类型系统对大型项目管理和重构都有很重要的意义，但是类型系统也意味着更多的学习。</p>
<p>我们从举例1可以看到，Ocaml的类型系统显然比Java的类型系统表达能力更强，更加先进。但是相应的也带来了一些学习曲线，比如 <code>&#39;a list</code>。当然，在实际工程中，我们也要取舍选择合适复杂度的类型系统，Haskell的类型系统显然过于先进了，学习成本可能更高。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wanwenli.com/programming/2013/12/27/Type-Systems.html">https://wanwenli.com/programming/2013/12/27/Type-Systems.html</a></li>
<li><a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Type_system#Explicit_or_implicit_declaration_and_inference">https://en.wikipedia.org/wiki/Type_system#Explicit_or_implicit_declaration_and_inference</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ocaml</tag>
        <tag>Python</tag>
        <tag>Java</tag>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（3）GIL</title>
    <url>/2021/02/18/python_gil/</url>
    <content><![CDATA[<h1 id="重新认识Python（3）：GIL，Global-Interpreter-Lock"><a href="#重新认识Python（3）：GIL，Global-Interpreter-Lock" class="headerlink" title="重新认识Python（3）：GIL，Global Interpreter Lock"></a>重新认识Python（3）：GIL，Global Interpreter Lock</h1><p>之前的两个文章主要简述了Python的内存管理模型和对应的GC模型。今天我们来看看Python的另一个“著名”特征：GIL，全局解释器锁。GIL长久以来被各种内行、外行诟病，可是很多人并不清楚GIL究竟是什么？为什么当初要设计GIL？GIL的优势在哪里？</p>
<h2 id="Python-是如何工作的？"><a href="#Python-是如何工作的？" class="headerlink" title="Python 是如何工作的？"></a>Python 是如何工作的？</h2><p>要理解 GIL 需要知道一些Python解释器的运行原理。Python的解释器其实一个循环，循环里是一系列的cases，逐行读取编译后的Opcode进行计算，每一个线程都有独立的这么一个循环。这里插一嘴，其实Python不是解释型语言，起码不是纯粹的解释型，Python源代码会被编译成Python自己的byte code，就是上面循环中的那些opcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    assert(stack_pointer &gt;= f-&gt;f_valuestack); <span class="comment">/* else underflow */</span></span><br><span class="line">    assert(STACK_LEVEL() &lt;= co-&gt;co_stacksize);  <span class="comment">/* else overflow */</span></span><br><span class="line">    assert(!PyErr_Occurred());</span><br><span class="line">    <span class="comment">// 这部分省略的代码就是后面GIL的关键。。我们先来看看解释器的循环</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">/* Extract opcode and argument */</span></span><br><span class="line"></span><br><span class="line">        NEXTOPARG();</span><br><span class="line">    dispatch_opcode:</span><br><span class="line">      <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* BEWARE!</span></span><br><span class="line"><span class="comment">           It is essential that any operation that fails sets either</span></span><br><span class="line"><span class="comment">           x to NULL, err to nonzero, or why to anything but WHY_NOT,</span></span><br><span class="line"><span class="comment">           and that no operation that succeeds does this! */</span></span><br><span class="line"></span><br><span class="line">        TARGET(NOP)</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line"></span><br><span class="line">        TARGET(LOAD_FAST) &#123;</span><br><span class="line">            PyObject *value = GETLOCAL(oparg);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format_exc_check_arg(PyExc_UnboundLocalError,</span><br><span class="line">                                     UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                                     PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PREDICTED(LOAD_CONST);</span><br><span class="line">        TARGET(LOAD_CONST) &#123;</span><br><span class="line">            PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>主要参考的<a href="https://github.com/python/cpython/blob/ef5f4ba96e05f61ad3baca502012085f31e99342/Python/ceval.c#L930-L1064">源代码</a>在这里。</p>
<p>当然，为了支持计算Python的runtime还会准备对应的Frame、全局变量等等。</p>
<h2 id="GIL-是什么？"><a href="#GIL-是什么？" class="headerlink" title="GIL 是什么？"></a>GIL 是什么？</h2><p>上面我们提到，每一个线程都有自己独立的执行循环，但是这些执行循环并不是相互独立的，他们必然会共享一些内存，这里起就是经典的并发问题，比如race condition等等。并发模型的实现由很多方法，我们听到最多、看起来也最简单的方法就是基于锁的方法。Python其实就选择这个方法，GIL也就诞生了。</p>
<p>GIL就是一个锁，每一个线程的执行循环，只有拿到GIL，才可以执行，否则就要等待，而一个Python进程只有一个GIL锁，所以它才叫全局锁。GIL可以保证，在同一时间，只有一个线程可以拿到这个锁。</p>
<p>这里我参考了一个小哥的代码，他简单的实现了Python版本的GIL，方便我们理解GIL。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> SimpleNamespace</span><br><span class="line"></span><br><span class="line">DEFAULT_INTERVAL = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">gil_mutex = threading.RLock()</span><br><span class="line">gil_condition = threading.Condition(lock=gil_mutex)</span><br><span class="line">switch_condition = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># dictionary-like object that supports dot (attribute) syntax</span></span><br><span class="line">gil = SimpleNamespace(</span><br><span class="line">    drop_request=<span class="literal">False</span>,</span><br><span class="line">    locked=<span class="literal">True</span>,</span><br><span class="line">    switch_number=<span class="number">0</span>,</span><br><span class="line">    last_holder=<span class="literal">None</span>,</span><br><span class="line">    eval_breaker=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_gil</span>(<span class="params">thread_id</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gil.locked:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;GIL is not locked&quot;</span>)</span><br><span class="line"></span><br><span class="line">    gil_mutex.acquire()</span><br><span class="line"></span><br><span class="line">    gil.last_holder = thread_id</span><br><span class="line">    gil.locked = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Signals that the GIL is now available for acquiring to the first awaiting thread</span></span><br><span class="line">    gil_condition.notify()</span><br><span class="line"></span><br><span class="line">    gil_mutex.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># force switching</span></span><br><span class="line">    <span class="comment"># Lock current thread so it will not immediately reacquire the GIL</span></span><br><span class="line">    <span class="comment"># this ensures that another GIL-awaiting thread have a chance to get scheduled</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">        switch_condition.acquire()</span><br><span class="line">        <span class="keyword">if</span> gil.last_holder == thread_id:</span><br><span class="line">            gil.drop_request = <span class="literal">False</span></span><br><span class="line">            switch_condition.wait()</span><br><span class="line"></span><br><span class="line">        switch_condition.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take_gil</span>(<span class="params">thread_id</span>):</span></span><br><span class="line">    gil_mutex.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gil.locked:</span><br><span class="line">        saved_switchnum = gil.switch_number</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Release the lock and wait for a signal from a GIL holding thread,</span></span><br><span class="line">        <span class="comment"># set drop_request=True if the wait is timed out</span></span><br><span class="line"></span><br><span class="line">        timed_out = <span class="keyword">not</span> gil_condition.wait(timeout=DEFAULT_INTERVAL)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timed_out <span class="keyword">and</span> gil.locked <span class="keyword">and</span> gil.switch_number == saved_switchnum:</span><br><span class="line">            gil.drop_request = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># lock for force switching</span></span><br><span class="line">    switch_condition.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now we hold the GIL</span></span><br><span class="line">    gil.locked = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.last_holder != thread_id:</span><br><span class="line">        gil.last_holder = thread_id</span><br><span class="line">        gil.switch_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># force switching, send signal to drop_gil</span></span><br><span class="line">    switch_condition.notify()</span><br><span class="line">    switch_condition.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">        gil.drop_request = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    gil_mutex.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execution_loop</span>(<span class="params">target_function, thread_id</span>):</span></span><br><span class="line">    <span class="comment"># Compile Python function down to bytecode and execute it in the while loop</span></span><br><span class="line"></span><br><span class="line">    bytecode = <span class="built_in">compile</span>(target_function)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># drop_request indicates that one or more threads are awaiting for the GIL</span></span><br><span class="line">        <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">            <span class="comment"># release the gil from the current thread</span></span><br><span class="line">            drop_gil(thread_id)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># immediately request the GIL for the current thread</span></span><br><span class="line">            <span class="comment"># at this point the thread will be waiting for GIL and suspended until the function return</span></span><br><span class="line">            take_gil(thread_id)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bytecode execution logic, executes one instruction at a time</span></span><br><span class="line">        instruction = bytecode.next_instruction()</span><br><span class="line">        <span class="keyword">if</span> instruction <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            execute_opcode(instruction)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>看代码我们可以知道：</p>
<ul>
<li>Python创建一个新的thread的时候，会首先call <code>take_gil</code> 尝试得到 GIL，然后才进入执行循环</li>
<li>通过在循环的开始部分检查gil状态，可以确保只有一个线程在执行</li>
</ul>
<p>目前这个版本的GIL其实也实现一些scheduler的功能，比如：</p>
<p><code>gil.drop_request</code> 为True就表明有其他的线程在等待执行，当前进程就会首先尝试放弃gil，给其他线程机会，然后他会立刻尝试夺回gil，以便自己可以继续运行。聪明的你可能想问，马上尝试夺回，那别的进程怎么办啊？</p>
<p>仔细看 <code>drop_gil</code> 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> gil.drop_request:</span><br><span class="line">    switch_condition.acquire()</span><br><span class="line">    <span class="keyword">if</span> gil.last_holder == thread_id:</span><br><span class="line">        gil.drop_request = <span class="literal">False</span></span><br><span class="line">        switch_condition.wait()</span><br><span class="line"></span><br><span class="line">    switch_condition.release()</span><br></pre></td></tr></table></figure>

<p>这段代码确保如果，OS分配的下一个线程还是自己，该线程就会被迫等待，确保其他进程有机会被系统的线程调度器分配。</p>
<p>CPython的源码在<a href="https://github.com/python/cpython/blob/master/Python/ceval_gil.h">这里</a></p>
<h2 id="关于GIL的思考"><a href="#关于GIL的思考" class="headerlink" title="关于GIL的思考"></a>关于GIL的思考</h2><p>GIL从1992年诞生到现在，其实经历一些变化。在GIL被设计的年代，多核CPU基本不存在，当时的线程也主要是用来做IO类型的工作，所以GIL的设计处理多线程IO效率非常高。</p>
<p>GIL的存在也让Python的单核性能大大增加，其实GIL是Python成功的一个重要原因。后来GIL加入了 <code>switch_condition</code>, <code>switch_number</code>, <code>timeout</code> 等参数，很大程度改善了多核处理下GIL线程schedule的问题。Python3以后的GIL仍然无法实现真正的CPU密集并行的多线程。不过这里说的线程都是OS线程，这不妨碍实现软件线程。</p>
<p>GIL难以被完全移除有很多原因，比如</p>
<ul>
<li>移除GIL，就需要修改Python的GC机制，特别是reference counting</li>
<li>GIL移除，会降低单核性能。因为移除全局锁，必然要引入粒度更小的锁</li>
<li>可以考虑其他的同步机制，比如Software transactional memory，那么就要修改整个C API，基本上所有的C-API库都废了。。。。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=7RlqbHCCVyc">https://www.youtube.com/watch?v=7RlqbHCCVyc</a></li>
<li><a href="https://www.youtube.com/watch?v=4zeHStBowEk">https://www.youtube.com/watch?v=4zeHStBowEk</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Python/ceval_gil.h">https://github.com/python/cpython/blob/master/Python/ceval_gil.h</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（2）内存管理</title>
    <url>/2021/02/18/python_memory_mgt/</url>
    <content><![CDATA[<h1 id="重新认识-Python（2）：内存管理"><a href="#重新认识-Python（2）：内存管理" class="headerlink" title="重新认识 Python（2）：内存管理"></a>重新认识 Python（2）：内存管理</h1><p>理解内存管理需要知道通常内存使用的基本规则。一般来说，一个进程的内存会被划分成两个部分，堆（heap）和栈（stack）。栈的结构相对简单，本质上就是一个先进后出队列，所有被分配在栈上的值必须是确定大小的、静态的。栈的功能主要是临时存储函数运行时的参数、临时变量和结果。显然，在程序运行的时候，我们需要产生许多大小不固定且动态的值，比如对象、列表、字典等等，这些数据结构不能直接分配到栈上，因此我们需要堆来存放这些值。相应的，堆的内存空间往往比栈大的多。</p>
<p>而我们通常将的内存管理，本质上是堆管理，不是栈管理。</p>
<h2 id="对象，Object"><a href="#对象，Object" class="headerlink" title="对象，Object"></a>对象，Object</h2><p>Python的内存管理主要是针对“一切皆对象”这个设计理念设计的（这里我们仅针对CPython实现展开说明。）。什么是对象，Object？在Python的世界里对象就是任何分配在堆中的值。</p>
<p>在CPython实现中，对象是struct, <code>PyObject</code>，包含四个部分：</p>
<ul>
<li>指向其他对象的指针(用来找到其他的对象)</li>
<li>对象的引用计数器</li>
<li>类型指针</li>
<li>对象的大小（对于大小可变的对象）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>类型对象也是一个对象，类型对象的类型指针指向他自己。对象一旦分配，他的的类型、size、地址就不能再改变。对于一些size会改变的对象，比如list或者dict，他们实现大小可变的方法是通过指针指向其他对象。</p>
<h2 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h2><p>CPython的内存管理是层状的，主要分成3层：</p>
<ul>
<li>object-specific memory</li>
<li>object memory</li>
<li>raw memory</li>
</ul>
<p>raw memory以下的内存就脱离了Python的控制，移交操作系统控制，如下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Object-specific allocators</span><br><span class="line">    _____   ______   ______       ________</span><br><span class="line">   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |</span><br><span class="line">+3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; |</span><br><span class="line">    _______________________________       |                           |</span><br><span class="line">   [   Python&#39;s object allocator   ]      |                           |</span><br><span class="line">+2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; |</span><br><span class="line">    ______________________________________________________________    |</span><br><span class="line">   [          Python&#39;s raw memory allocator (PyMem_ API)          ]   |</span><br><span class="line">+1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; |   |</span><br><span class="line">    __________________________________________________________________</span><br><span class="line">   [    Underlying general-purpose allocator (ex: C library malloc)   ]</span><br><span class="line"> 0 | &lt;------ Virtual memory allocated for the python process -------&gt; |</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    _______________________________________________________________________</span><br><span class="line">   [                OS-specific Virtual Memory Manager (VMM)               ]</span><br><span class="line">-1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; |</span><br><span class="line">    __________________________________   __________________________________</span><br><span class="line">   [                                  ] [                                  ]</span><br><span class="line">-2 | &lt;-- Physical memory: ROM&#x2F;RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; |</span><br></pre></td></tr></table></figure>

<p>因为Python的runtime会存在成千上万个Object，但是这些对象通常非常的小，比如int object，runtime必须减少小对象的内存分配代价。基本原理就是通过提前申请，且不轻易交回内存，反复利用已经申请到的内存。对于比较大的对象，超过512kb的对象，Python会直接调用C的内存分配器，直接在堆上申请内存。</p>
<p>下面我们主要介小于512kb的对象的内存管理。</p>
<h2 id="小对象的内存管理"><a href="#小对象的内存管理" class="headerlink" title="小对象的内存管理"></a>小对象的内存管理</h2><p>对于小对象内存，Python主要提供了三类对象进行管理：<code>arena</code>, <code>pool</code>, <code>block</code>。</p>
<ul>
<li>block, 最小内存分配单位，每一个block的大小以8byte为单位，划分为64个组。</li>
<li>pool, 是相同大小block的集合</li>
<li>arena, 每一个大小为256kb，包含64个pool</li>
</ul>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>Block是Python对象内存分配的最小单位，从8byte(或者16byte)到512byte不等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Request in bytes     Size of allocated block      Size class idx</span><br><span class="line">* ----------------------------------------------------------------</span><br><span class="line">*        1-8                     8                       0</span><br><span class="line">*        9-16                   16                       1</span><br><span class="line">*       17-24                   24                       2</span><br><span class="line">*       25-32                   32                       3</span><br><span class="line">*       33-40                   40                       4</span><br><span class="line">*       41-48                   48                       5</span><br><span class="line">*       49-56                   56                       6</span><br><span class="line">*       57-64                   64                       7</span><br><span class="line">*       65-72                   72                       8</span><br><span class="line">*        ...                   ...                     ...</span><br><span class="line">*      497-504                 504                      62</span><br><span class="line">*      505-512                 512                      63</span><br></pre></td></tr></table></figure>

<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p><code>pool</code> 是相同分组（大小） <code>block</code> 的集合。一般，pool的大小为4kb（内存分页的大小），这主要是为了方便处理内存的fragmentation。如果一个对象被回收了，内存管理器可以再次利用这部分内存存储其他合适大小的对象。pool的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool&#x27;s free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       &quot;&quot;        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，每一个pool通过双链表连接在一起，<code>szidx</code> 记录了这个pool下面的block的size，<code>ref.count</code> 记录了已经被使用的blocks，<code>arenaindex</code> 则记录了这个pool所属的 <code>arena</code> 地址。<code>freeblock</code> 是当前可用的第一个block的地址。值得注意的是，如果一个block是空的，那么它会存储下一个空block的地址，这样方便寻址。</p>
<p>每一个pool包含三个状态：</p>
<ul>
<li>used，部分被使用</li>
<li>full，全部被使用</li>
<li>empty，空</li>
</ul>
<p>为了提高寻址效率，Python还维护一个array <code>usedpools</code>, 存储不同分组的pool的头地址。如下：</p>
<p><img data-src="https://i.imgur.com/Hg7D3Rl.png" alt=""></p>
<p>另外，block和pool不会直接分配内存，他们只是维护内存的数据结构，内存是由 <code>arena</code> 进行分配的。</p>
<h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p><code>Arena</code> 代表了一片大小为256kb的在堆上的内存空间，每一个 arena 包含 64 个pool。arena的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address;</span><br><span class="line">    block* pool_address;</span><br><span class="line">    uint nfreepools;</span><br><span class="line">    uint ntotalpools;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，arena也是被双链表连接在一起，<code>ntotalpools</code>和<code>nfreepool</code>记录了目前可用的pool的信息。</p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p>Python很少会把已经申请的小内存交还给操作系统，而是反复利用已经拥有的内存，以提高内存管理效率。通常一个 <code>arena</code> 只有在其全部pool均为空的情况下，才会被系统回收。这种情况可能发生，比如当你申请了大量小且短命的对象时候，垃圾回收后可能会出现这种完全空的 <code>arena</code>。</p>
<p>另一个角度说，Python进程可能会长期占有一些它不直接需要的内存。</p>
<p>内存使用状况可以通过：<code>sys._debugmallocstats()</code> 查询。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Small block threshold &#x3D; 512, in 32 size classes.</span><br><span class="line"></span><br><span class="line">class   size   num pools   blocks in use  avail blocks</span><br><span class="line">-----   ----   ---------   -------------  ------------</span><br><span class="line">    0     16           6            1484            34</span><br><span class="line">    1     32          58            7247            61</span><br><span class="line">    2     48         175           14654            46</span><br><span class="line">    3     64        1171           73721            52</span><br><span class="line">    4     80        1542           75259          1841</span><br><span class="line">    5     96         478           19851           225</span><br><span class="line">    6    112         184            6554            70</span><br><span class="line">    7    128         154            4766             8</span><br><span class="line">    8    144         950           26272           328</span><br><span class="line">    9    160          75            1812            63</span><br><span class="line">   10    176         405            9183           132</span><br><span class="line">   11    192          45             916            29</span><br><span class="line">   12    208          35             651            14</span><br><span class="line">   13    224          34             603             9</span><br><span class="line">   14    240         118            1876            12</span><br><span class="line">   15    256          29             402            33</span><br><span class="line">   16    272          26             357             7</span><br><span class="line">   17    288          20             277             3</span><br><span class="line">   18    304         157            2034             7</span><br><span class="line">   19    320          18             211             5</span><br><span class="line">   20    336          22             254            10</span><br><span class="line">   21    352          17             181             6</span><br><span class="line">   22    368          15             157             8</span><br><span class="line">   23    384          15             147             3</span><br><span class="line">   24    400          15             143             7</span><br><span class="line">   25    416          21             185             4</span><br><span class="line">   26    432          38             340             2</span><br><span class="line">   27    448          50             446             4</span><br><span class="line">   28    464          45             354             6</span><br><span class="line">   29    480          35             275             5</span><br><span class="line">   30    496          36             279             9</span><br><span class="line">   31    512          47             324             5</span><br><span class="line"></span><br><span class="line"># arenas allocated total           &#x3D;                  167</span><br><span class="line"># arenas reclaimed                 &#x3D;                   69</span><br><span class="line"># arenas highwater mark            &#x3D;                   98</span><br><span class="line"># arenas allocated current         &#x3D;                   98</span><br><span class="line">98 arenas * 262144 bytes&#x2F;arena     &#x3D;           25,690,112</span><br><span class="line"></span><br><span class="line"># bytes in allocated blocks        &#x3D;           23,843,888</span><br><span class="line"># bytes in available blocks        &#x3D;              323,536</span><br><span class="line">236 unused pools * 4096 bytes      &#x3D;              966,656</span><br><span class="line"># bytes lost to pool headers       &#x3D;              289,728</span><br><span class="line"># bytes lost to quantization       &#x3D;              266,304</span><br><span class="line"># bytes lost to arena alignment    &#x3D;                    0</span><br><span class="line">Total                              &#x3D;           25,690,112</span><br><span class="line"></span><br><span class="line">       3 free PyCFunctionObjects * 48 bytes each &#x3D;                  144</span><br><span class="line">           27 free PyDictObjects * 48 bytes each &#x3D;                1,296</span><br><span class="line">           7 free PyFloatObjects * 24 bytes each &#x3D;                  168</span><br><span class="line">          5 free PyFrameObjects * 368 bytes each &#x3D;                1,840</span><br><span class="line">           72 free PyListObjects * 40 bytes each &#x3D;                2,880</span><br><span class="line">         31 free PyMethodObjects * 40 bytes each &#x3D;                1,240</span><br><span class="line"> 102 free 1-sized PyTupleObjects * 32 bytes each &#x3D;                3,264</span><br><span class="line">1998 free 2-sized PyTupleObjects * 40 bytes each &#x3D;               79,920</span><br><span class="line"> 128 free 3-sized PyTupleObjects * 48 bytes each &#x3D;                6,144</span><br><span class="line">   4 free 4-sized PyTupleObjects * 56 bytes each &#x3D;                  224</span><br><span class="line">  25 free 5-sized PyTupleObjects * 64 bytes each &#x3D;                1,600</span><br><span class="line">  25 free 6-sized PyTupleObjects * 72 bytes each &#x3D;                1,800</span><br><span class="line">   3 free 7-sized PyTupleObjects * 80 bytes each &#x3D;                  240</span><br><span class="line">   1 free 8-sized PyTupleObjects * 88 bytes each &#x3D;                   88</span><br><span class="line">   0 free 9-sized PyTupleObjects * 96 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 10-sized PyTupleObjects * 104 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 11-sized PyTupleObjects * 112 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 12-sized PyTupleObjects * 120 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 13-sized PyTupleObjects * 128 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 14-sized PyTupleObjects * 136 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 15-sized PyTupleObjects * 144 bytes each &#x3D;                    0</span><br><span class="line"> 1 free 16-sized PyTupleObjects * 152 bytes each &#x3D;                  152</span><br><span class="line"> 0 free 17-sized PyTupleObjects * 160 bytes each &#x3D;                    0</span><br><span class="line"> 1 free 18-sized PyTupleObjects * 168 bytes each &#x3D;                  168</span><br><span class="line"> 0 free 19-sized PyTupleObjects * 176 bytes each &#x3D;                    0</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/python/cpython/blob/cc54001c2eb3b14320c1667b22602d69c90d5865/Objects/object.c">https://github.com/python/cpython/blob/cc54001c2eb3b14320c1667b22602d69c90d5865/Objects/object.c</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Include/object.h">https://github.com/python/cpython/blob/master/Include/object.h</a></li>
<li><a href="https://github.com/python/cpython/blob/ad051cbce1360ad3055a048506c09bc2a5442474/Objects/obmalloc.c#L534">https://github.com/python/cpython/blob/ad051cbce1360ad3055a048506c09bc2a5442474/Objects/obmalloc.c#L534</a></li>
<li><a href="https://rushter.com/blog/python-memory-managment/">https://rushter.com/blog/python-memory-managment/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（1）GC，垃圾回收</title>
    <url>/2021/02/16/python_1_gc/</url>
    <content><![CDATA[<h1 id="重新认识-Python（1）：GC，垃圾回收"><a href="#重新认识-Python（1）：GC，垃圾回收" class="headerlink" title="重新认识 Python（1）：GC，垃圾回收"></a>重新认识 Python（1）：GC，垃圾回收</h1><p>Python是目前受众最为广泛的计算机语言之一，涉足的领域包罗万象：Web，机器学习，数据处理，爬虫等等。使用Python的人群也非常多样， 从专业的程序员到数据科学家。这种现状也导致了一个现象：大家对Python存在很多道听途说来的误解。比如，Python是解释型语言（其实python 还真不是，Python是编译型的，只不过他通过解释器执行编译后的代码，其实跟Java一样的，只不过java用虚拟机执行、解释代码），Python非常慢（讲快慢不讲场景都是耍流氓），GIL是垃圾设计（很多人其实不清楚GIL到底是什么？其设计初衷是什么？）， Python的GC很垃圾等等。这些误解通常是因为 Python过于火热，以至于内行、外行都可以随意评论一番，一些误解也就慢慢蔓延开来。我写这个系列的目的就是帮助大家重新认识Python，把 Python当成一个计算机语言，而不是一个工具来认识它。这样不仅会增加对语言本身的理解，也可以提高编写Python代码的质量。</p>
<p>今天我们先来聊一聊Python的GC。(CPython)</p>
<h2 id="Python的内存管理"><a href="#Python的内存管理" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>说GC之前，我们先来看看Python的内存管理。与许多其他语言不同，由于Python中的所有值都是一个对象，object，所以Python程序运行的时候会产生数量众多但是体积很小的对象。因此，Python通常不会把已经申请的内存交还给操作系统，他会为每一个小于512byte的对象分配一个专门的allocator并且不会释放这些内存，方便以后继续使用。Python的很多内存直到进程结束才会释放给系统。</p>
<p>即使我们运行一个简单的包含第三方库的程序，进程中可能存在上百万个对象，但是他们的体积通常都非常小。正是因为这种对象管理模式，才能支持了Python的很多运行时的动态特性，也正是因为这些特征，Python才变得的如此灵活（当然，灵活的代价是牺牲一些性能）。</p>
<p>知道了Python的内存管理特性，我们就可以进一步理解Python的GC设计了。你会发现，很多设计就是为了支持这种内存管理模式而出现的。</p>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>Python的设计其实非常的和谐，一切皆对象。就连一个int也不例外，比如你可以打印整数1的对象id：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 4419605632</span></span><br></pre></td></tr></table></figure>

<p>上面我们提到一个简单的Python进程中可能存在成千上万的大大小小的对象，为他们分配内存通常很简单，但是回收这些内存就需要更多的心思了，因为一旦回收了还在使用的对象的内存就会导致程序崩溃。</p>
<p>Python的 GC 其实包含两个部分：Reference Counting 和 Generational cyclic GC。引用计数高效，但是却存在一个致命的问题：无法检测循环引用。所以必须使用额外的垃圾回收机制，Cpython选择了generational GC。</p>
<p>值得注意的是，引用计数算法是不可以认为干预的，完全由Python的运行时控制，而generational GC可以通过<code>gc module</code>认为控制。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数其实是解决GC超多对象垃圾回收简单且高效的方法！引用计数的原理很简单，python的运行时会追踪每一个object的reference counter，当reference counter 归零的时候，这个对象的内存就会被回收。</p>
<p>Python中所有的变量其实都是一个引用或者说指针，指向对应的对象。比如赋值语句会增加对象的引用，而一个对象可以拥有来自多个变量的引用。</p>
<p>Python中有三种方式可以增加引用：</p>
<ul>
<li>赋值</li>
<li>传参</li>
<li>把对象放入容器，比如list</li>
</ul>
<p>当一个对象的引用归零，如果它包含对其他对象的引用，其他对象的引用也会减少，如果其他对象的引用也因此归零，那么这个对象也会被回收。值得注意的是，被全局变量引用的对象，不会被回收。可以通过 <code>global()</code> 函数查看全局变量。</p>
<p>对于局部变量，即定义在函数内部的变量，当Python的解释器退出函数时，会移除这些变量对对象的引用，但不会删除对象。所以，<strong>Python只有在退出函数或者对一个变量重新赋值的时候，才可能会进行垃圾回收（引用计数GC）！</strong>，换句话说，如果你有一个超长的函数，内部超多产生了超多对象，Python是无法进行GC的，所以，应该尽量写精简的函数。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">foo = []</span><br><span class="line"><span class="comment"># 2 references, 1 from the foo var and 1 from getrefcount</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(foo))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="comment"># 4 references</span></span><br><span class="line">    <span class="comment"># from the foo var, function argument, getrefcount and Python&#x27;s function stack</span></span><br><span class="line">    <span class="built_in">print</span>(sys.getrefcount(a))</span><br><span class="line"></span><br><span class="line">bar(foo)</span><br><span class="line"><span class="comment"># 2 references, the function scope is destroyed</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(foo))</span><br></pre></td></tr></table></figure>

<p>随便说一下，Python （cpython）无法轻易移除 GIL 的一个主要原因也是因为引用计数GC，因为多线程会搞乱引用计数。</p>
<h3 id="Generational-GC，-GGC"><a href="#Generational-GC，-GGC" class="headerlink" title="Generational GC， GGC"></a>Generational GC， GGC</h3><p>那么Python为什么还有第二套GC算法呢？这主要是因为引用计数无法处理循环引用或者自引用的情况。这两种情况都会让对象的引用数量至少维持在1，进而无法被GC。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use ctypes moule  to access our unreachable objects by memory address.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyObject</span>(<span class="params">ctypes.Structure</span>):</span></span><br><span class="line">    _fields_ = [(<span class="string">&quot;refcnt&quot;</span>, ctypes.c_long)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.disable()  <span class="comment"># Disable generational gc</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">lst.append(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store address of the list</span></span><br><span class="line">lst_address = <span class="built_in">id</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Destroy the lst reference</span></span><br><span class="line"><span class="keyword">del</span> lst</span><br><span class="line"></span><br><span class="line">object_1 = &#123;&#125;</span><br><span class="line">object_2 = &#123;&#125;</span><br><span class="line">object_1[<span class="string">&#x27;obj2&#x27;</span>] = object_2</span><br><span class="line">object_2[<span class="string">&#x27;obj1&#x27;</span>] = object_1</span><br><span class="line"></span><br><span class="line">obj_address = <span class="built_in">id</span>(object_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Destroy references</span></span><br><span class="line"><span class="keyword">del</span> object_1, object_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you want to manually run garbage collection process </span></span><br><span class="line"><span class="comment"># gc.collect()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check the reference count</span></span><br><span class="line"><span class="built_in">print</span>(PyObject.from_address(obj_address).refcnt)</span><br><span class="line"><span class="built_in">print</span>(PyObject.from_address(lst_address).refcnt)</span><br></pre></td></tr></table></figure>

<p>上面的例子中， <code>del</code> 会移除变量对对象的引用，执行del以后，这个对象已经无法被系统的其他部分引用，但是，由于存在自引用，该对象无法被回收。为了解决这个问题，Python在1.5以后引入了GGC，专门处理这种情况。值得注意的是，循环引用只会出现在容器变量中，比如list，dict，自定义对象等等，因此GGC不会追踪不可变对象（除了Tuple）。</p>
<p>GGC不是实时进行的，而是周期性的触发。GGC会将所有的容器类型对象分成3代。新建立的对象首先进入第一代，如果它没有被第一次GC回收，这个对象会进入第二代，一次类推。而GGC会优先回收第一代的内存，假设新建的对象会更快的结束自己的生命。通过这种机制，提高GC性能，缩短系统暂停的时间。</p>
<p>那么GGC的触发机制是什么呢？我们提到GC会把对象分为三代，每一代都有自己的计数器和一个阈值。计数器存储自上一次GC以后，新分配的对象数量，减去回收的数量。每次系统分配新的内存时，会检查计数器是否超过阈值，如果是会出发GC。</p>
<p>如果检查时，超过2代达到阈值，GGC会选择更加古老的一代进行回收。因为老一代的对象是从新的一代过度进来的。但是，第三代的内存回收会做特别处理[3]，为了减少性能损失。</p>
<p>默认的设置是700，10，10。可以通过 <code>gc.get_threshold</code>查看每一代的阈值。</p>
<h2 id="如何利用GC？"><a href="#如何利用GC？" class="headerlink" title="如何利用GC？"></a>如何利用GC？</h2><p>了解GC的原理是为了更好的利用GC。比如对于GGC，我们可以根据情况停止gc，以提高性能。</p>
<p>我们可以通过利用 <code>weakref</code> 来引用一些临时且不重要的对象，比如cache，这样GC可以任意回收他们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/3.6/c-api/intro.html#objects-types-and-reference-counts">https://docs.python.org/3.6/c-api/intro.html#objects-types-and-reference-counts</a></li>
<li><a href="https://rushter.com/blog/python-garbage-collector/">https://rushter.com/blog/python-garbage-collector/</a></li>
<li><a href="https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94">https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>雅各书 1\:1-12</title>
    <url>/2021/01/10/%E9%9B%85%E5%90%84%E4%B9%A61/</url>
    <content><![CDATA[<h1 id="雅各书-1：1-12"><a href="#雅各书-1：1-12" class="headerlink" title="雅各书 1：1-12"></a>雅各书 1：1-12</h1><blockquote>
<p>1 神和主耶稣基督的仆人雅各，向散居各地的十二支派问安。 2 我的弟兄们，你们遭遇各种 试炼的时候，都要看为喜乐; 3 因为知道你们的信心经过考验，就产生忍耐。 4 但忍耐要坚持到底(“坚持到底”原文作“有完全的功效”)，使你们可以完全，毫无缺乏。 5 你们中间若有人缺少智慧，就当向那厚赐众人，而且不斥责人的 神祈求，他就必得着。 6 <strong>可是，他应该 凭着信心祈求，不要有疑惑;因为疑惑的人，就像被风吹荡翻腾的海浪。 7 那样的人，不要想 从主得到甚么; 8 因为三心两意的人，在他的一切道路上，都摇摆不定</strong>。</p>
<p>9 卑微的弟兄应当以高升为荣; 10 富足的也不应该以降卑为辱; 因为他如同草上的花，必要过 去。 11 太阳一出，热风一吹，草必枯干，花必凋谢，它的美容就消失了; 富足的人也必在他 的奔波经营中这样衰落。</p>
<p>12 能忍受试炼的人，是有福的;因为他经过考验之后，必得着生命的冠冕，这冠冕是主应许 给爱他的人的。</p>
</blockquote>
<h1 id="我们应当把试炼看作是极大的喜乐"><a href="#我们应当把试炼看作是极大的喜乐" class="headerlink" title="我们应当把试炼看作是极大的喜乐"></a>我们应当把试炼看作是极大的喜乐</h1><p>雅各书的背景：基督徒别破分散各地，经历迫害、贫困。所以，有些基督徒被骗，偏离信仰。</p>
<h2 id="知道神的美意-1-3-4"><a href="#知道神的美意-1-3-4" class="headerlink" title="知道神的美意 1:3-4"></a>知道神的美意 1:3-4</h2><p>神的智慧高过我们，但是神的意图是为了我们的益处。通过合适的试炼，会让我们不断回到神身上，让我们的信心经过考验，以至于产生忍耐。信心经过考验，就像锻炼一样，过程是通过的，结果是好的。经过试炼，信心就会更加刚强，就可以坚持到达新天新地。所以雅各也说：</p>
<blockquote>
<p>12 能忍受试炼的人，是有福的;因为他经过考验之后，必得着生命的冠冕，这冠冕是主应许 给爱他的人的。</p>
</blockquote>
<p>如果我们一直顺利，我们就容易忽略信心，跟随世界，不知不觉的偏离道路。试炼是神的美意，为了锻炼我们的信心，没有经过锻炼的信心是脆弱的。</p>
<p>这样，我们就可以在痛苦中感受神的美意。</p>
<h2 id="求神赐下智慧-1-5-8"><a href="#求神赐下智慧-1-5-8" class="headerlink" title="求神赐下智慧 1:5-8"></a>求神赐下智慧 1:5-8</h2><p>而且，在试炼中神也没有让我们孤身一人，我们可以通过祷告获得从神而来的智慧和能力，应对眼前的试炼。神永远垂听我们的祷告，他甘心情愿的赐下智慧，让我们可以按照神的旨意去生活。所以，在是试炼中，我们应该通过祷告求助神的帮助，应对试炼。这样我们就可以从神的角度去看待眼前的试炼。</p>
<p>但是雅各也提醒：</p>
<blockquote>
<p> 6 <strong>可是，他应该 凭着信心祈求，不要有疑惑;因为疑惑的人，就像被风吹荡翻腾的海浪。 7 那样的人，不要想 从主得到甚么; 8 因为三心两意的人，在他的一切道路上，都摇摆不定</strong>。</p>
</blockquote>
<p>我们一定要凭着信心祷告，但是不要利用神成就自己的私欲。</p>
<h2 id="因将来而欢喜-1-9-11"><a href="#因将来而欢喜-1-9-11" class="headerlink" title="因将来而欢喜 1:9-11"></a>因将来而欢喜 1:9-11</h2><p>在经历试炼的时候也应该经常思考将来的荣耀，就是属天的财富。雅各这里解释到，这个世界的东西终将逝去，只有属灵的财富才是永恒的。而每一个基督徒，已经获得了这永恒的、属灵的财富，我们因此在试炼中欢喜。</p>
<p>雅各甚至警告：</p>
<blockquote>
<p>10 富足的也不应该以降卑为辱; 因为他如同草上的花，必要过去。 11 太阳一出，热风一吹，草必枯干，花必凋谢，它的美容就消失了; 富足的人也必在他 的奔波经营中这样衰落。</p>
</blockquote>
<p>富足的生活，甚至更容易让我们放弃信仰，放弃永恒的财富，被世界吸引。换句话说，富足的人更容易心怀二意。</p>
<h2 id="值得么？"><a href="#值得么？" class="headerlink" title="值得么？"></a>值得么？</h2><p>举个例子，如果一个人继承了1千万英镑，结果他去用1千万买了无数的鲜花。那么他是不是极其愚蠢？同样，用永恒的财富换世界上必将腐败的东西也是愚蠢的。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>雅各书</tag>
      </tags>
  </entry>
  <entry>
    <title>雅各书入门</title>
    <url>/2021/01/04/%E9%9B%85%E5%90%84%E4%B9%A6/</url>
    <content><![CDATA[<p><strong>雅各书“入门”</strong></p>
<blockquote>
<p>24 “所以，凡聽見我這些話又遵行的，就像聰明的人，把自己的房子蓋在磐石上。 25 雨淋、 水沖、風吹，搖撼那房子，房子卻不倒塌，因為建基在磐石上。 26 凡聽見我這些話卻不遵行 的，就像愚蠢的人，把自己的房子蓋在沙土上。 27 雨淋、水沖、風吹，搖撼那房子，房子就 倒塌了，並且倒塌得很厲害。”<br>《马可福音》7：24-27</p>
</blockquote>
<blockquote>
<p>19 我的弟兄們，你們中間若有人被騙離開了真道，如果有人使他回頭， 20 你們應該知道，那 使罪人從歧途上轉回的，就會拯救他的靈魂脫離死亡，也會遮蓋許多罪惡。<br>《雅各书》 5：19-20</p>
</blockquote>
<p>雅各是谁？他是基督的弟弟。耶稣活着的时候，他不相信耶稣是神的儿子，不是一个信徒。但是耶稣基督复活后，他信主了，而且成为了虔诚的基督徒，并带领教会。他于公元62年殉道，所以这本书大概实在公元50年左右写成的。当时，基督徒遭遇迫害。使徒保罗，当时还不是基督徒，而四处迫害基督徒。所以基督徒才会散落各地。也正式因为分散，教会面临了前所未有的挑战，比如贫困，比如出现了很多假教师，诱惑人偏离真道。</p>
<p>雅各为什么要向这些分散在各地的基督徒写信呢？雅各使用了很多黑白分明的例证，就好像当年他的哥哥，耶稣基督，的登山宝训一样。雅各书的中心思想是希望原先读者意识到，心怀二意对基督徒是致命的，信心要有实际行动。</p>
<p><strong>:warning: 不要离开真道!</strong></p>
<p>就是与世俗为伍，随波逐流。基督徒脚踏两只船非常危险，这样不仅要失去救恩，也会在日常生活中变得痛苦，既得不到主内的喜乐，也不能在世俗的生活中获得任何安慰。</p>
<p><strong>:information_source: 使人回转</strong></p>
<p>如果你看到了有人正在走在离开真道的路上，或者你发现自己已经走偏了，一定要激励自己或者别人，回到真道。<br>有信心，没有行为，是死的！</p>
<p>拯救灵魂的主题贯穿着《雅各书》。</p>
<p><strong>:medical_symbol: 遮盖罪</strong> </p>
<p>神与我们同工，救赎灵魂可以遮盖许多罪。神甘心乐意与罪人和好，<code>你们亲近神，神就会接受你。</code>。神会赐给我们一切所需的，让我们可以过讨神喜悦的生活！</p>
<p>2021年的开始，你可以确信，神依然愿意遮盖我们的罪恶。我们应该卸下重担，与神同工，享受与神同在的喜乐，救赎自己、救赎他人的灵魂。</p>
<p>祷告：</p>
<ul>
<li>醒悟过来，彼此鼓励</li>
<li>一心一意，坚持到底</li>
</ul>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>雅各书</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP</title>
    <url>/2020/12/25/sicp_overview/</url>
    <content><![CDATA[<p><strong>SICP quick overview</strong></p>
<h1 id="Building-Abstraction-with-Procedures"><a href="#Building-Abstraction-with-Procedures" class="headerlink" title="Building Abstraction with Procedures"></a>Building Abstraction with Procedures</h1><h2 id="The-Elements-of-Programming"><a href="#The-Elements-of-Programming" class="headerlink" title="The Elements of Programming"></a>The Elements of Programming</h2><p>Three machanisms of powerful language:</p>
<ul>
<li>primitive expression, the simplest entities the language is concerned with</li>
<li>means of combination, compound elements are built from simpler ones</li>
<li>means of abstraction, compound elements can be named and manipulated as units</li>
</ul>
<p>Two elements in programming (maybe just one): data and procedures.</p>
<p><code>define</code> is the simplest means of abstraction. </p>
<p><code>environment</code> the memory to keep track name-value bindings.</p>
<h3 id="Evaluating-Combinations"><a href="#Evaluating-Combinations" class="headerlink" title="Evaluating Combinations"></a>Evaluating Combinations</h3><p>General rule of evaluation of combinations:</p>
<ol>
<li>Evaluate the sub-expression of the combinations</li>
<li>Apply the procedure: value of leftmost sub-expression to the arguments that are the value s of the other sub-expressions</li>
</ol>
<p><code>(define x 3)</code> is not a combination, which is not handled by above.<br>These kind of exceptions are <em>special forms</em>. Special forms have their<br>own evaluation rules.</p>
<h3 id="Compound-Procedures"><a href="#Compound-Procedures" class="headerlink" title="Compound Procedures"></a>Compound Procedures</h3><p><code>(define (square x) (* x x))</code><br>in the form of<br><code>(define (&lt;name&gt; &lt;parameters&gt;) (body))</code></p>
<p>we can now compound to more complex procedures:<br><code>(define (sum-of-square x y) (+ (square x) (square y)))</code>. </p>
<p>From now on, compound procedures are as same as primitive procedures.</p>
<h3 id="Substitution-Model-for-Procedure-Application"><a href="#Substitution-Model-for-Procedure-Application" class="headerlink" title="Substitution Model for Procedure Application"></a>Substitution Model for Procedure Application</h3><p>The application process is:</p>
<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p>
</blockquote>
<p>This is the meaning of procedure application. <strong>But this is not necessarily how the program is executed.</strong></p>
<p>(Applicative-order evaluation) The interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.<br>(Normal-order evaluation) An alternative evaluation model would not evaluate the operands until their values were needed.</p>
<h3 id="Conditional-Expressions"><a href="#Conditional-Expressions" class="headerlink" title="Conditional Expressions"></a>Conditional Expressions</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line"> (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> x <span class="number">0</span>) x)</span><br><span class="line">       ((<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">       ((<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>) (<span class="name"><span class="builtin-name">-</span></span> x)))</span><br></pre></td></tr></table></figure>

<p>More examples:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">a-plus-abs-b</span> a b) ((<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b <span class="number">0</span>) + -) a b))</span><br></pre></td></tr></table></figure>


<h2 id="Procedures-and-the-Processes-generated"><a href="#Procedures-and-the-Processes-generated" class="headerlink" title="Procedures and the Processes generated"></a>Procedures and the Processes generated</h2><blockquote>
<p>The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer</p>
</blockquote>
<blockquote>
<p>A procedure is a pattern for the local evolution of a computational process.</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n) </span><br><span class="line"> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure>

<p>vs </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n) (<span class="name">fact-iter</span> <span class="number">1</span> <span class="number">1</span> n))</span><br><span class="line">(<span class="name">define</span> (<span class="name">fact-iter</span> product counter max-count) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> counter max-count)</span><br><span class="line">product</span><br><span class="line">(<span class="name">fact-iter</span> (<span class="name"><span class="builtin-name">*</span></span> counter product)</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> counter <span class="number">1</span>) max-count)))</span><br></pre></td></tr></table></figure>

<p>Here are some common pattern of computations.</p>
<h3 id="Linear-Recursion-and-Iteration"><a href="#Linear-Recursion-and-Iteration" class="headerlink" title="Linear Recursion and Iteration"></a>Linear Recursion and Iteration</h3><p>The two procedures aim the same goal but the processes they generate<br>have different evaluation shapes. One is a linear recursive process,<br>and one is a linear iterative process.</p>
<blockquote>
<p>The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point.</p>
</blockquote>
<p>Note that, recursive procedure does not mean it will generate a recursive evaluation process (tail recursion for example). </p>
<h3 id="Tree-Recursion"><a href="#Tree-Recursion" class="headerlink" title="Tree Recursion"></a>Tree Recursion</h3><p>Use transform can change a tree recursion to an iterative one.</p>
<h3 id="Order-of-Growth"><a href="#Order-of-Growth" class="headerlink" title="Order of Growth"></a>Order of Growth</h3><p>Orders of growth provide only a crude description of the behavior of a process.</p>
<h3 id="Exponentiation"><a href="#Exponentiation" class="headerlink" title="Exponentiation"></a>Exponentiation</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">expt</span> b n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name">expt</span> b (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">expt1</span> b n)</span><br><span class="line">  (<span class="name">expt-iter</span> b n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">expt-iter</span> b counter product)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> counter <span class="number">0</span>)</span><br><span class="line">      product</span><br><span class="line">      (<span class="name">expt-iter</span> b</span><br><span class="line">                 (<span class="name"><span class="builtin-name">-</span></span> counter <span class="number">1</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">*</span></span> b product))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">fast-expt</span> b n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">even?</span></span> n) (<span class="name">square</span> (<span class="name">fast-expt</span> b (/ n <span class="number">2</span>))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name">fast-expt</span> b (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name"><span class="builtin-name">even?</span></span> n)</span><br><span class="line">(<span class="name"><span class="builtin-name">=</span></span> (<span class="name">remainder</span> n <span class="number">2</span>) <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">square</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> n n))</span><br></pre></td></tr></table></figure>
<h2 id="Formulating-Abstractions-with-Higher-order-Functions"><a href="#Formulating-Abstractions-with-Higher-order-Functions" class="headerlink" title="Formulating Abstractions with Higher-order Functions"></a>Formulating Abstractions with Higher-order Functions</h2><p>Procedures are abstractions that describe compound operations.</p>
<h3 id="Procedures-as-Arguments"><a href="#Procedures-as-Arguments" class="headerlink" title="Procedures as Arguments"></a>Procedures as Arguments</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; Procedures as Arguments</span></span><br><span class="line"><span class="comment">;; (define (inc n) (+ n 1))</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">term</span> a)</span><br><span class="line">         (<span class="name">sum</span> term (<span class="name"><span class="builtin-name">next</span></span> a) next b))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-iter</span> term a next b)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> a result)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        result</span><br><span class="line">        (<span class="name">iter</span> (<span class="name"><span class="builtin-name">next</span></span> a) (<span class="name"><span class="builtin-name">+</span></span> result (<span class="name">term</span> a)))))</span><br><span class="line">  (<span class="name">iter</span> a <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p><code>lambda</code> function is useful. <code>let</code> is useful to create local variables.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((⟨var1⟩ ⟨exp1⟩) (⟨var2⟩ ⟨exp2⟩)</span><br><span class="line">...</span><br><span class="line">(⟨varn⟩ ⟨expn⟩)) ⟨body⟩)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Procedures-as-General-Methods"><a href="#Procedures-as-General-Methods" class="headerlink" title="Procedures as General Methods"></a>Procedures as General Methods</h3><h3 id="Procedures-as-Return-Values"><a href="#Procedures-as-Return-Values" class="headerlink" title="Procedures as Return Values"></a>Procedures as Return Values</h3><p>Elements with the fewest restrictions are said to have first-class status. Some of the “rights and privileges” of first-class elements are:</p>
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to procedures.</li>
<li>They may be returned as the results of procedures.</li>
<li>They may be included in data structures.</li>
</ul>
<h1 id="Building-Abstractions-with-Data"><a href="#Building-Abstractions-with-Data" class="headerlink" title="Building Abstractions with Data"></a>Building Abstractions with Data</h1><p>After compound procedures, we build abstractions by compounding data.</p>
<blockquote>
<p>Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
</blockquote>
<p>The notion of <code>closure</code> is one of the key ideas dealing with compound<br>data. Another idea is <code>conventional interfaces</code> to combine program module in mix-and-match ways. </p>
<p>Data may be represented differently by different parts of program, this leads to <code>generic operations</code>. </p>
<h2 id="Introduction-of-Data-Abstraction"><a href="#Introduction-of-Data-Abstraction" class="headerlink" title="Introduction of Data Abstraction"></a>Introduction of Data Abstraction</h2><p><code>selector</code> and <code>constructor</code> as interface of abstract data.<br>Sometime, we also need <code>predicates</code>.</p>
<p>Example of rational number data abstraction: </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-rat</span> n d) (<span class="name"><span class="builtin-name">cons</span></span> n d))</span><br><span class="line">(<span class="name">define</span> (<span class="name">numer</span> x) (<span class="name">car</span> x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">denom</span> x) (<span class="name">cdr</span> x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">print-tar</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">  (<span class="name">display</span> (<span class="name">numer</span> x))</span><br><span class="line">  (<span class="name">display</span> <span class="string">&quot;/&quot;</span>)</span><br><span class="line">  (<span class="name">display</span> (<span class="name">denom</span> x)))</span><br></pre></td></tr></table></figure>
<p>The horizontal lines represent <code>abstraction barrier</code>.</p>
<p><img data-src="https://i.imgur.com/jBwpFte.png" alt=""></p>
<h3 id="What-is-Meant-by-Data"><a href="#What-is-Meant-by-Data" class="headerlink" title="What is Meant by Data??"></a>What is Meant by Data??</h3><p>In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.</p>
<h2 id="Hierarchical-Data-and-the-Closure-Property"><a href="#Hierarchical-Data-and-the-Closure-Property" class="headerlink" title="Hierarchical Data and the Closure Property"></a>Hierarchical Data and the Closure Property</h2><p>THe ability to create pairs whose elements are pairs is the essence of list structure’s importance as a representational tool. This is called <code>closure property</code>: an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.</p>
<blockquote>
<p> very simplest programs rely on the fact that the elements of a combination can themselves be combinations.</p>
</blockquote>
<p>With pairs we could build a lot of stuff.</p>
<h3 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; Sequences</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">list-ref</span> items n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name">car</span> items)</span><br><span class="line">      (<span class="name">list-ref</span> (<span class="name">cdr</span> items) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name"><span class="builtin-name">map</span></span> proc items)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">null?</span> items)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">proc</span> (<span class="name">car</span> items))</span><br><span class="line">            (<span class="name"><span class="builtin-name">map</span></span> proc (<span class="name">cdr</span> items)))))</span><br></pre></td></tr></table></figure>

<h3 id="Hierarchical-Structures"><a href="#Hierarchical-Structures" class="headerlink" title="Hierarchical Structures"></a>Hierarchical Structures</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">count-leaves</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">null?</span> x) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name">pair?</span> x)) <span class="number">1</span>)</span><br><span class="line">        (<span class="name">else</span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">count-leaves</span> (<span class="name">car</span> x))</span><br><span class="line">                 (<span class="name">count-leaves</span> (<span class="name">cdr</span> x))))))</span><br></pre></td></tr></table></figure>

<h3 id="Sequences-as-Conventional-Interfaces"><a href="#Sequences-as-Conventional-Interfaces" class="headerlink" title="Sequences as Conventional Interfaces"></a>Sequences as Conventional Interfaces</h3><p><code>Conventional Interfaces</code> is anther powerful design tool other than data abstraction. </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> low high)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> low (<span class="name">enumerate-interval</span> (<span class="name"><span class="builtin-name">+</span></span> low <span class="number">1</span>) high))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">enumerate-tree</span> tree)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">null?</span> tree) <span class="literal">nil</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name">pair?</span> tree)) (<span class="name"><span class="builtin-name">list</span></span> tree))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">append</span> (<span class="name">enumerate-tree</span> (<span class="name">car</span> tree))</span><br><span class="line">                      (<span class="name">enumerate-tree</span> (<span class="name">cdr</span> tree))))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">null?</span> sequence)</span><br><span class="line">      initial</span><br><span class="line">      (<span class="name">op</span> (<span class="name">car</span> sequence)</span><br><span class="line">          (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</span><br></pre></td></tr></table></figure>

<h3 id="Example-the-Picture-Language"><a href="#Example-the-Picture-Language" class="headerlink" title="Example: the Picture Language"></a>Example: the Picture Language</h3><p>Good designs:</p>
<ul>
<li>Use data abstractions</li>
<li>The means of combination satisfy the closure property</li>
<li>With above, all the tools for abstracting procedures are available now</li>
<li>complex system should be structured as a sequence of levels.</li>
</ul>
<p>The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail. This is called <code>Stratified design</code>.</p>
<h2 id="Symbolic-Data"><a href="#Symbolic-Data" class="headerlink" title="Symbolic Data"></a>Symbolic Data</h2><p>Another type of data, Symbols, which is not numbers.<br>In order to manipulate symbols we need a new element in our language: the ability to <code>quote</code> a data object.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">list</span></span> &#x27;a &#x27;b &#x27;c)</span><br><span class="line">(<span class="name">cdr</span> &#x27;((<span class="name">x1</span> x2) (<span class="name">y1</span> y2)))</span><br><span class="line">(<span class="name">cadr</span> &#x27;((<span class="name">x1</span> x2) (<span class="name">y1</span> y2)))</span><br><span class="line">(<span class="name">pair?</span> (<span class="name">car</span> &#x27;(<span class="name">a</span> short list)))</span><br></pre></td></tr></table></figure>

<h3 id="Example-Symbolic-Differentiation"><a href="#Example-Symbolic-Differentiation" class="headerlink" title="Example: Symbolic Differentiation"></a>Example: Symbolic Differentiation</h3><p>First, work out the data abstractions needed: <code>constructor</code>, <code>selector</code>, and <code>predicator</code>. </p>
<p>Then define the procedure to do derive on above data abstraction.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">deriv</span> exp var) (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">number?</span></span> exp) <span class="number">0</span>)</span><br><span class="line">((<span class="name">variable?</span> exp) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">same-variable?</span> exp var) <span class="number">1</span> <span class="number">0</span>)) ((<span class="name">sum?</span> exp) (<span class="name">make-sum</span> (<span class="name">deriv</span> (<span class="name">addend</span> exp) var)</span><br><span class="line">                              (<span class="name">deriv</span> (<span class="name">augend</span> exp) var)))</span><br><span class="line">((<span class="name">product?</span> exp) (<span class="name">make-sum</span></span><br><span class="line">(<span class="name">make-product</span> (<span class="name">multiplier</span> exp)</span><br><span class="line">(<span class="name">deriv</span> (<span class="name">multiplicand</span> exp) var))</span><br><span class="line">(<span class="name">make-product</span> (<span class="name">deriv</span> (<span class="name">multiplier</span> exp) var) (<span class="name">multiplicand</span> exp))))</span><br><span class="line">(<span class="name">else</span></span><br><span class="line">(<span class="name">error</span> <span class="string">&quot;unknown expression type: DERIV&quot;</span> exp))))</span><br></pre></td></tr></table></figure>

<h2 id="Multiple-Representations-for-Abstract-Data"><a href="#Multiple-Representations-for-Abstract-Data" class="headerlink" title="Multiple Representations for Abstract Data"></a>Multiple Representations for Abstract Data</h2><p>There might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations. </p>
<p>So in addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program. </p>
<p>In addition, we need to make the system more additive.</p>
<p>To achieve above, we need a new tool <code>generic procedure</code>. Type tags and data-directed style enable this.</p>
<h3 id="Example-Complex-number"><a href="#Example-Complex-number" class="headerlink" title="Example: Complex-number"></a>Example: Complex-number</h3><p><img data-src="https://i.imgur.com/08f8LQm.png" alt=""></p>
<p>But we soon realized that, using type tag make the system not additive!<br>And this kind of system is hard to maintain.</p>
<p>NOT A GOOD DESIGN!</p>
<p>Here is Table of operations for the complex-number system:</p>
<p><img data-src="https://i.imgur.com/1UiVC6S.png" alt=""></p>
<p>Data-directed programming is the technique of designing programs to work with such a table directly. If we do this, then to add a new representation package to the system we need not change any existing procedures; we need only add new entries to the table.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op . args)</span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">type-tags</span> (<span class="name"><span class="builtin-name">map</span></span> type-tag args)))</span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">proc</span> (<span class="name"><span class="builtin-name">get</span></span> op type-tags))) (<span class="name"><span class="builtin-name">if</span></span> proc</span><br><span class="line">          (<span class="name"><span class="builtin-name">apply</span></span> proc (<span class="name"><span class="builtin-name">map</span></span> contents args))</span><br><span class="line">          (<span class="name">error</span> <span class="string">&quot;No method for these types: APPLY-GENERIC&quot;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list</span></span> op type-tags))))))</span><br><span class="line"><span class="comment">;; selectors with generics</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">real-part</span> z) (<span class="name">apply-generic</span> &#x27;real-part z))</span><br><span class="line">(<span class="name">define</span> (<span class="name">imag-part</span> z) (<span class="name">apply-generic</span> &#x27;imag-part z)) </span><br><span class="line">(<span class="name">define</span> (<span class="name">magnitude</span> z) (<span class="name">apply-generic</span> &#x27;magnitude z)) </span><br><span class="line">(<span class="name">define</span> (<span class="name">angle</span> z)     (<span class="name">apply-generic</span> &#x27;angle z))</span><br></pre></td></tr></table></figure>

<p>In effect, this decomposes the operation-and-type table into rows, with each generic operation procedure representing a row of the table.</p>
<p>An alternative implementation strategy is to decompose the table into columns. This style is called <code>message passing</code>.</p>
<h2 id="Systems-with-Generic-Operations"><a href="#Systems-with-Generic-Operations" class="headerlink" title="Systems with Generic Operations"></a>Systems with Generic Operations</h2><h3 id="Generic-Arithmetic-Operations"><a href="#Generic-Arithmetic-Operations" class="headerlink" title="Generic Arithmetic Operations"></a>Generic Arithmetic Operations</h3><p><img data-src="https://i.imgur.com/Yf6vQCg.png" alt=""></p>
<p>The generic arithmetic procedures are defined as</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">add</span> x y) (<span class="name">apply-generic</span> &#x27;add x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">sub</span> x y) (<span class="name">apply-generic</span> &#x27;sub x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">mul</span> x y) (<span class="name">apply-generic</span> &#x27;mul x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">div</span> x y) (<span class="name">apply-generic</span> &#x27;div x y))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">install-scheme-number-package</span>)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">tag</span> x) (<span class="name">attach-tag</span> &#x27;scheme-number x)) </span><br><span class="line">  (<span class="name">put</span> &#x27;add &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">+</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;sub &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">-</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;mul &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">*</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;div &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (/ x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;make &#x27;scheme-number (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">tag</span> x))) &#x27;done)</span><br></pre></td></tr></table></figure>

<p>In the end, we need a two level tag system for complex number.</p>
<h3 id="Combining-Data-of-Different-Types"><a href="#Combining-Data-of-Different-Types" class="headerlink" title="Combining Data of Different Types"></a>Combining Data of Different Types</h3><p>We would like to introduce the cross-type operations in some carefully controlled way, so that we can support them without seriously violating our module boundaries.</p>
<p>One strategy could be making a type transfer of types if possible.</p>
<p>Or we could build a hierachies of type.</p>
<h3 id="Example-Symbolic-Algebra"><a href="#Example-Symbolic-Algebra" class="headerlink" title="Example: Symbolic Algebra"></a>Example: Symbolic Algebra</h3><p>TODO.</p>
<h1 id="Modularity-Objects-and-State"><a href="#Modularity-Objects-and-State" class="headerlink" title="Modularity, Objects, and State"></a>Modularity, Objects, and State</h1><p>Procedure and Data abstractions are powerful tools to deal with complex systems, but not enough. We need organizational principles that can guide us in formulating the overall design of a program.</p>
<p>Two prominent organizational strategies: objects and streams.</p>
<p>With objects, we must be concerned with how a computational object can change and yet maintain its identity. The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation.This essentially a environmental model instead of substitution model.</p>
<p><strong>object</strong>, viewing a large system as a collection of distinct objects whose behaviors may change over time. </p>
<p><strong>stream</strong>, viewing streams of information flow in the system. </p>
<p>While using object to model state come with a price because it couples time and data at the same time. And <code>Stream</code> is a solution.</p>
<h2 id="Assignment-and-Local-State"><a href="#Assignment-and-Local-State" class="headerlink" title="Assignment and Local State"></a>Assignment and Local State</h2><p>Two new operators are needed in order to mantain local state and assignment.<br><code>(set! &lt;name&gt; &lt;new-value&gt;)</code> and <code>(begin &lt;exp1&gt; &lt;exp1&gt; ...)</code>. The value of <code>begin</code> is the value of last expression. The we can use <code>let</code> to create some local variable in the procedure:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> new-withdraw </span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">balance</span> <span class="number">100</span>))</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">        (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount)) balance)</span><br><span class="line">        <span class="string">&quot;Insufficient funds&quot;</span>))))</span><br></pre></td></tr></table></figure>

<p>Then we can have a procedure to create objects:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">      (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount))</span><br><span class="line">             balance)</span><br><span class="line">      <span class="string">&quot;Insufficient funds&quot;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>With these techniques, we can create complex objects with more methods and local variable:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance) </span><br><span class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount) </span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">      (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount)) balance)</span><br><span class="line">      <span class="string">&quot;Insufficient funds&quot;</span>))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">+</span></span> balance amount))</span><br><span class="line">    balance)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">eq?</span> m &#x27;withdraw) withdraw)</span><br><span class="line">          ((<span class="name">eq?</span> m &#x27;deposit) deposit)</span><br><span class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">&quot;Unknown request: MAKE-ACCOUNT&quot;</span></span><br><span class="line">                       m))))</span><br><span class="line">  dispatch)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as functional programming. In contrast to functional programming, programming that makes ex- tensive use of assignment is known as imperative programming. </p>
</blockquote>
<p>As soon as we introduce assignment, a variable can no longer be simply a name. Now a variable somehow refers to a place where a value can be stored, and the value stored at this place can change. And the place is the environment.</p>
<p>A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be referentially transparent. </p>
<h2 id="Environment-Model-of-Evaluation"><a href="#Environment-Model-of-Evaluation" class="headerlink" title="Environment Model of Evaluation"></a>Environment Model of Evaluation</h2><p>An environment is a sequence of frames. Each frame is a table (possibly empty) of bindings, which associate variable names with their corresponding values.</p>
<p>In the environment model of evaluation, a procedure is always a pair consisting of some code and a pointer to an environment.</p>
<p>The environment model of procedure application can be summa- rized by two rules:</p>
<ul>
<li>apply rule,  is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the proce- dure in the context of the new environment constructed</li>
<li>creation rule, created by evaluating a λ-expression relative to a given environment.</li>
</ul>
<h2 id="Modeling-with-Mutable-Data"><a href="#Modeling-with-Mutable-Data" class="headerlink" title="Modeling with Mutable Data"></a>Modeling with Mutable Data</h2><p>To model data that can change, we need not only <code>constructor</code> and <code>selector</code>, but also <code>moutator</code>. Data objects for which mutators are defined are known as mutable data objects.</p>
<p>We introduce two primitives, which are similar to <code>cons</code>, <code>car</code>, and <code>cdr</code>: <code>set-car!</code> and <code>set-cdr!</code>.</p>
<p>Just like pairs can be represented purely by procedures, mutation is just assignment.</p>
<h3 id="Example-Digital-Circuits"><a href="#Example-Digital-Circuits" class="headerlink" title="Example: Digital Circuits"></a>Example: Digital Circuits</h3><p>TODO:</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p>Before we introduced assignment, all our programs were timeless, in the sense that any expression that has a value always has the same value.</p>
<p>So it is often natural to model systems as collections of computational processes that execute concurrently.<br>Just as we can make our programs modular by organizing models in terms of objects with separate local state, it is often appropriate to divide computational models into parts that evolve separately and concurrently.</p>
<p>One possible restriction on concurrency would stipulate that no two operations that change any shared state variables can occur at the same time.<br>A less stringent restriction on concurrency would ensure that a concurrent system produces the same result as if the processes had run sequentially in some order.</p>
<h3 id="Mechanisms-for-Controlling-Concurrency"><a href="#Mechanisms-for-Controlling-Concurrency" class="headerlink" title="Mechanisms for Controlling Concurrency"></a>Mechanisms for Controlling Concurrency</h3><p>We’ve seen that the difficulty in dealing with concurrent processes is rooted in the need to consider the interleaving of the order of events in the different processes. </p>
<p>A more practical approach to the design of concurrent systems is to devise general mechanisms that allow us to constrain the interleaving of concurrent processes.</p>
<p>For example <code>serilizing</code>: Serialization implements the following idea: Processes will execute con- currently, but there will be certain collections of procedures that cannot be executed concurrently. We implement serializers in terms of a more primitive synchronization mechanism called a mutex.</p>
<blockquote>
<p>The complexities we encounter in dealing with time and state in our computational models may in fact mirror a fundamental complexity of the physical universe.</p>
</blockquote>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="Streams-Are-Delayed-Lists"><a href="#Streams-Are-Delayed-Lists" class="headerlink" title="Streams Are Delayed Lists"></a>Streams Are Delayed Lists</h3><p>Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists.<br>The key modularity issue was that we wished to hide the internal state.</p>
<h1 id="Metalinguistic-Abstraction"><a href="#Metalinguistic-Abstraction" class="headerlink" title="Metalinguistic Abstraction"></a>Metalinguistic Abstraction</h1><p>Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that suitable to the problem at hand.</p>
<h2 id="The-Metacircular-Evaluator"><a href="#The-Metacircular-Evaluator" class="headerlink" title="The Metacircular Evaluator"></a>The Metacircular Evaluator</h2><p>An evaluator that is written in the same language that it evaluates is said to be metacircular.</p>
<p>Here we talk about a Scheme formulation of the environment model of evaulation. Recall that the model has two parts:</p>
<ol>
<li>Evulation</li>
<li>Application</li>
</ol>
<p>This is basically <code>eval</code> and <code>apply</code>. </p>
<p>We will use <strong>data abstraction</strong> to make the evaluator independent of the representation of the language.</p>
<h3 id="The-core-of-evaluator"><a href="#The-core-of-evaluator" class="headerlink" title="The core of evaluator"></a>The core of evaluator</h3><p><strong><code>eval</code></strong>: takes an expression and an environment.</p>
<p>Rules:</p>
<ul>
<li>Primitives expression<ul>
<li>self-evaluting expression -&gt; self</li>
<li>lookup value in the environment</li>
</ul>
</li>
<li>Special forms<ul>
<li>quoted expression -&gt; expression that was qouted </li>
<li>assignment</li>
<li>if</li>
<li>lambda</li>
<li>begin</li>
<li>case</li>
</ul>
</li>
<li>Combinations<ul>
<li>procedure application </li>
</ul>
</li>
</ul>
<p><strong><code>apply</code></strong>: takes a procedure and a list of argments.</p>
<ul>
<li>primitive procedures</li>
<li>compound procedures</li>
</ul>
<h3 id="Variations-on-a-Scheme-—-Lazy-Evaluation"><a href="#Variations-on-a-Scheme-—-Lazy-Evaluation" class="headerlink" title="Variations on a Scheme — Lazy Evaluation"></a>Variations on a Scheme — Lazy Evaluation</h3><h4 id="Normal-Order-and-Applicative-Order"><a href="#Normal-Order-and-Applicative-Order" class="headerlink" title="Normal Order and Applicative Order"></a>Normal Order and Applicative Order</h4><h1 id="Computing-with-Register-Machines"><a href="#Computing-with-Register-Machines" class="headerlink" title="Computing with Register Machines"></a>Computing with Register Machines</h1><blockquote>
<p>A more primitive level than Lisp itself.</p>
</blockquote>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020总结</title>
    <url>/2020/12/24/summary_2020/</url>
    <content><![CDATA[<h1 id="2020-年总结"><a href="#2020-年总结" class="headerlink" title="2020 年总结"></a>2020 年总结</h1><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><p>今年对世界很独特。2020年1月，新冠（COVID-19）在武汉首先爆发，3月疫情拓展至美国、英国、欧洲等世界各地。在我写下这篇博客的时候，中国的疫情已经得到了完全控制，而欧洲、美国正处在新兴变种病毒的第三波高峰期。</p>
<p><img data-src="https://i.imgur.com/v3YNSlk.png" alt="日新增病例"></p>
<p>在新冠疫情的影响下，美股出现了前所未有的崩盘运动。2020年2月到3月之间，标普500期货连熔断三次，跌幅高达40%。</p>
<p><img data-src="https://i.imgur.com/HRqM9sy.png" alt="标普500"></p>
<p>连带影响，原油期货价格更是出现了前所未有的负值。</p>
<p><img data-src="https://i.imgur.com/znXcKtx.png" alt="原油期货"></p>
<p>不过，这种独特的情况也成就了某些公司，比如Zoom。Zoom的股票一年翻了8倍！</p>
<p><img data-src="https://i.imgur.com/GDHzSob.png" alt="Zoom股票"></p>
<p>年末另一个引起我注意的是比特币。比特币在18年泡沫破裂后，在2020年12月再创新高，达到了24000美金。。。</p>
<p><img data-src="https://i.imgur.com/M2Fh105.png" alt="比特币"></p>
<p><strong>这些事情基本都在告诉我：黑天鹅事件必然会发生，而且概率远远超过统计数据。</strong><br>这不仅仅针对金融市场，世界的各个领域正在更加紧密的连接，不同领域的黑天鹅很可能对其他领域产生连锁效应。</p>
<p>应对黑天鹅存在的世界，控制风险异常重要，预测异常困难。多样性仍然是在尽可能少的依赖预测前提下最好的风控方式。但是多样性有成本，无限多样得不偿失。</p>
<p>多样性的本质是相关性，也许也有因果关系。</p>
<p>多样性同样体现在多个方面：个人的资产管理、技能管理、人际关系管理等等。</p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>今年还处于我的计算机科学探索期，我对很多计算机科学很多方面进行了非常简略的学习和了解，从硬件层面的ISA到操作系统，简单的探索了编译器，以及各种范式的计算机语言，比如函数式和过程式；探索了不同的编程范式，比如基于Actor的并发编程、分布式编程等等；探索了数据库的设计，实现部分目前还没有涉及。</p>
<p>发现了一个有趣的东西：Live music coding。目前主要用的库是FoxDot和TidalCycles，一个是Python写的，一个是Haskell写的。</p>
<p>研究生课程：</p>
<ul>
<li>Embedded System</li>
<li>Database Design</li>
<li>Concurrent Programming</li>
</ul>
<p>自学课程：</p>
<ul>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2018sp/">Data Structures and Functional Programming</a></li>
<li>[On going] <a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">Operating System</a></li>
<li>[On going] <a href="https://pdos.csail.mit.edu/6.824/schedule.html">Distributed System</a></li>
</ul>
<p>语言表 (按照熟悉程度排序）：</p>
<ul>
<li>Python</li>
<li>Erlang/Elixir</li>
<li>Ocaml</li>
<li>Haskell</li>
<li>Javascript</li>
<li>C</li>
<li>Go</li>
<li>Ruby</li>
</ul>
<p>书籍：</p>
<ul>
<li><a href="https://hackmd.io/Ii5bK9VfSdiUkqKcRjOecg">The C Programming Language</a></li>
<li><a href="https://drive.google.com/drive/folders/1JWyvQk9QWAnce2da2boiiSDh3oK5yFU6">Systematic Trading</a></li>
<li><a href="https://wangzhe3224.github.io/2020/10/03/efficiently_inefficient/">Efficiently Inefficient: How Smart Money Invests and Market Prices Are Determined</a></li>
<li><a href="https://wangzhe3224.github.io/2020/09/20/cs_app/">Computer System: A Programmer’s Perspectives</a></li>
<li><a href="https://wangzhe3224.github.io/2020/05/16/a_new_kind_of_science/">A New Kind of Science</a></li>
<li><a href="https://www.amazon.co.uk/Erlang-OTP-Action-Martin-Logan/dp/1933988789/ref=sr_1_1?adgrpid=52230164094&dchild=1&gclid=Cj0KCQiA5vb-BRCRARIsAJBKc6K6xWXN5HxiyPiartNJjscP2mEpuBZGAr6JrvLZPgUH3ostwAjG3V4aAg5aEALw_wcB&hvadid=259088862228&hvdev=c&hvlocphy=9044953&hvnetw=g&hvqmt=e&hvrand=12324936168106335447&hvtargid=kwd-300183560570&hydadcr=17611_1775466&keywords=erlang+and+otp+in+action&qid=1608382554&sr=8-1&tag=googhydr-21">Erlang and OTP in Action</a></li>
<li><a href="">A Pragmatic Programmer</a></li>
</ul>
<p><strong>多样性思考</strong></p>
<p>在知识领域，多样性的成本主要是时间且成本巨大。但是，由于我是转行学习计算机科学，还处于一个然所学科的阶段。目前多样性体现如下几个大领域：</p>
<ul>
<li>理论层<ul>
<li>离散数学</li>
<li>计算机语言和类型理论</li>
<li>算法理论</li>
<li>数据库理论</li>
<li>并发理论</li>
</ul>
</li>
<li>硬件层<ul>
<li>编译器</li>
<li>虚拟机实现</li>
<li>数据库实现</li>
<li>操作系统</li>
</ul>
</li>
<li>软件层<ul>
<li>各种语言的使用</li>
<li>分布式系统设计</li>
<li>并发系统设计</li>
</ul>
</li>
<li>Domain知识<ul>
<li>量化交易</li>
<li>量化科技</li>
</ul>
</li>
</ul>
<p>探索期过后，需要寻找一个部分深入学习、研究和应用。对于Domain知识也需要进一步加强，今年没有太多关注，主要是完成工作任务，养家糊口。。。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>因为疫情的原因，整整一年都在家里远程工作。因为减少了上下班交通的时间，自己多了很多时间可以支配。也许，等疫情过去，这种远程工作的模式会成为常态。</p>
<p>当然除了工作，教会的活动也都变成了线上。不过线上模式反而增加了很多拓展福音的机会。我们组织了两期线上的圣经课程，讨论福音书。因为是线上，我们可以跟更多不同地方的人交流。</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>6.004 The Digital Abstraction</title>
    <url>/2020/12/19/6004-2/</url>
    <content><![CDATA[<h1 id="The-Digital-Abstraction"><a href="#The-Digital-Abstraction" class="headerlink" title="The Digital Abstraction"></a>The Digital Abstraction</h1><p>Q: the physical representation of bits?</p>
<p>Then ask what is a good bit?</p>
<ul>
<li>small</li>
<li>cheap</li>
<li>stable</li>
<li>easy and fast to manipulate, access/transform/combine/store/transmit</li>
</ul>
<p>Industry selected to use voltage to represent information.<br>But the system need to tolerate errors.</p>
<p>Encode 1 bit with 0 or 1. </p>
<p>Digitalize voltage with buffer.</p>
<h2 id="Combinational-logic"><a href="#Combinational-logic" class="headerlink" title="Combinational logic"></a>Combinational logic</h2><p>Stateless machine</p>
<h2 id="Sequential-logic"><a href="#Sequential-logic" class="headerlink" title="Sequential logic"></a>Sequential logic</h2><p>Circuits that include both combinational logic and memory components are called sequential logic.</p>
<h2 id="Finite-state-machine"><a href="#Finite-state-machine" class="headerlink" title="Finite state machine"></a>Finite state machine</h2><h1 id="Instruction-Set-Architectures"><a href="#Instruction-Set-Architectures" class="headerlink" title="Instruction Set Architectures"></a>Instruction Set Architectures</h1><p>An instruction is the fundamental unit of work, it includes: opcode to be performed and operands, destination for the result.</p>
<p>ISA, is a contract between software and hardware. ISA is the first abstraction layer that describes what CPU can do but hides how CPU do it.</p>
<h2 id="Beta-a-RISC-reduced-instruction-set-computer"><a href="#Beta-a-RISC-reduced-instruction-set-computer" class="headerlink" title="Beta: a RISC, reduced instruction set computer."></a>Beta: a RISC, reduced instruction set computer.</h2><h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2><p>A human readable ISA+ </p>
<h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>High level languages. Two basic execution logic: interpretation and complilation. </p>
<p>Front end + Back end.</p>
<p><img data-src="https://i.imgur.com/yC1UdhA.png" alt=""></p>
<h2 id="Procedures-abstraction-by-high-level-languages"><a href="#Procedures-abstraction-by-high-level-languages" class="headerlink" title="Procedures, abstraction by high level languages"></a>Procedures, abstraction by high level languages</h2><h1 id="Memory-tech"><a href="#Memory-tech" class="headerlink" title="Memory tech"></a>Memory tech</h1><blockquote>
<p>Everything is cache of something else..</p>
</blockquote>
<p><img data-src="https://i.imgur.com/NMkOpar.png" alt=""></p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>6.004</tag>
        <tag>Information</tag>
      </tags>
  </entry>
  <entry>
    <title>6.004 Basic of information</title>
    <url>/2020/12/19/6004_1/</url>
    <content><![CDATA[<h1 id="6-004-Basic-of-information"><a href="#6-004-Basic-of-information" class="headerlink" title="6.004 Basic of information"></a>6.004 Basic of information</h1><p>Q: what is good representation of information?</p>
<p>What is <strong>information</strong>? Information is data that resolves uncertainty about a particular fact.</p>
<p>$X$ is discrete random variable, which has $N$ possible values ($x_i$) and associated probability $p_i$, Information received when learning that choice was $x_i$:</p>
<p>$$I(x_i)=log_2(\frac{1}{p_i})$$</p>
<p>the unit is bits, the number of bits required to encode the choice.</p>
<p>The <strong>entropy</strong>, $H(X)$, of a discrete random variable $X$ is average amount of information received when learning the value of X:</p>
<p>$$H(X)=E(I(X))=\sum_ilog_2(\frac{1}{p_i})$$</p>
<p><strong>encoding</strong> is a unambiguous mapping between bits string to set of possible data.</p>
<p>Encoding as binary tree is a good way to think. </p>
<p>Huffman’s algorithm, given a set of symbols and their probability, constructs an optima variable-length encoding <strong>1 symbol per time</strong>.<br>Build encoding tree bottom up with lower probability.</p>
<p>If we do same algorithm but using multiple symbols, we can do better.</p>
<p><strong>Hamming distance</strong>: same length bits, how many different bits in the same position.</p>
<p><strong>single-bit error</strong> detection and correction by add hamming distance of valid word encoding. </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2017/c1/c1s1/">6.004</a></p>
<h6 id="tags-6-004-Information"><a href="#tags-6-004-Information" class="headerlink" title="tags: 6.004, Information"></a>tags: <code>6.004</code>, <code>Information</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>6.004</tag>
        <tag>Information</tag>
      </tags>
  </entry>
  <entry>
    <title>人们为什么不接受耶稣？</title>
    <url>/2020/12/13/2020_12_13/</url>
    <content><![CDATA[<h1 id="人为什么难以接受耶稣？"><a href="#人为什么难以接受耶稣？" class="headerlink" title="人为什么难以接受耶稣？"></a>人为什么难以接受耶稣？</h1><blockquote>
<p><em>我是光，我到世上来，叫所有信我的不住在黑暗里</em></p>
</blockquote>
<p>人的不信也在神的计划之内，以赛亚先知在公元前700年前后，看到了一个异象：他看到了一个受苦的神的仆人，这个仆人被人藐视，不被人接受。</p>
<p>耶稣在讲道的时候，引用了以赛亚先知的异象：</p>
<blockquote>
<p>耶稣说完了这些话，就离开他们隐藏起来。 37 耶稣在他们面前行了许多神迹，但是他们仍然不信他。 38 这是要应验以赛亚先知所说的话:“主啊，我们所传的，有谁信呢? 主的膀臂向谁显露呢?”。<br>《约翰福音》 12</p>
</blockquote>
<p>以下就是耶稣引用的经文：</p>
<blockquote>
<p>13 看哪!我的仆人必行事亨通，他必受尊崇，被高举，成为至高。 14 许多人怎样因你而惊奇，(因为他的容貌毁损得不像人， 他的形状毁损得不像世人)，15 照样，他也必使多国的人惊异，君王要因他闭口不言， 因为从未向他们述说过的事，他们必看见; 他们从未听过的，他们要明白。53 谁会相信我们所传的?耶和华的膀臂向谁显露呢?<br>《以赛亚书》 52</p>
</blockquote>
<p>人们的不信，是神的审判。当年神正式通过以色列人的不信，完成了他的计划。以色列人把耶稣送上十字架，完成了对世界的救赎。耶稣的死亡和复活正式神一直以来的救赎计划。</p>
<p>然而，如今救赎已经成就了，只要愿意谦卑回转，审判可以避免：</p>
<blockquote>
<p>44 耶稣大声说:“信我的，不单是信我，也是信那差我来的。45 看见我的，就是看见那差我来的。46 我是光，我到世上来，叫所有信我的不住在黑暗里。47 人若听见我 的话却不遵守的，我不审判他，因为我来不是要审判世人，而是要拯救世人。48 弃绝我又不接受我的 话的人，自有审判他的。我所讲的道在末日要定他的罪;<br>《约翰福音》 12</p>
</blockquote>
<p>所以，如今我们要为自己的不信负责。<strong>爱人的荣耀，多过爱神的荣耀，不是真信，乃是假信。</strong></p>
<p>耶稣基督就是黑暗世界的光。如果我们看见了光，却还想留在黑暗里，罪就已经定了。然而，耶稣基督仍然把救赎的大门敞开：</p>
<blockquote>
<p>人若听见我 的话却不遵守的，我不审判他，因为我来不是要审判世人，而是要拯救世人。</p>
</blockquote>
<p>这是耶稣第一次来到世界的目的，但是耶稣也应许，他会第二次来到世界，进行审判，而他现在所讲的道就会给世人定罪，永远的留在黑暗里。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>约翰福音</tag>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>被时间“埋没”的分布式王者：Erlang</title>
    <url>/2020/12/11/erlang/</url>
    <content><![CDATA[<h1 id="被时间“埋没”的高并发王者：Erlang"><a href="#被时间“埋没”的高并发王者：Erlang" class="headerlink" title="被时间“埋没”的高并发王者：Erlang"></a>被时间“埋没”的高并发王者：Erlang</h1><p>分布式、fault-tolerant、高并发等等这些名词变得越来越火爆，一个新的框架、数据库、语言如果不跟这几个名词沾边，都不好意思摆在台面上。可是，早在20-30年前的通信领域已经出现了这样的需求，比如 容错、超高并发、在线代码更新、99.9%在线率等等。而互联网领域直到最近10今年才特别关注这种系统。</p>
<p>大概在90年代初，Erlang诞生了，它的设计者正式为了满足通讯领域系统高并发、高容错、分布式的需求设计Erlang和它的虚拟机，BEAM。（当然BEAM不是第一代虚拟机，而是经过几轮迭代后被大规模投入使用的版本）。</p>
<p>虽然，很多年轻的程序员可能没有通过Erlang，提起分布式、高并发，他们更多想到的可能是 Golang，Scala/Akka等等。可是Erlang系统就在我们身边：Cisco超过90%的交换机仍然在使用Erlang；早在2012年，WhatApp的生产系统就实现了在单个Beam虚拟机节点上同时处理超过2百万个TCP/IP连接；RabbitMQ 服务器端代码是Erlang实现的；电信公司T-Mobile的短信业务也是Erlang实现的；Ericsson用Erlang生态构建新的5G基础设施软件；等等。</p>
<p>可以说，在分布式、高并发、高容错这个领域，Erlang得到了广泛的应用，多年的使用也证明了Erlang生态在这个领域的可靠性。</p>
<p>我有幸和Erlang最初的几个设计者之一Robert Virding 学习过一段时间，了解了一些Erlang背后的故事。</p>
<h1 id="Erlang的设计哲学"><a href="#Erlang的设计哲学" class="headerlink" title="Erlang的设计哲学"></a>Erlang的设计哲学</h1><p>Erlang不是完美的语言，Erlang的设计具有鲜明的目的性：高并发、高容错、分布式。Erlang的虚拟机BEAM也是为了实现相同的目的，可以说，它只围绕这几个设计目的进行优化，比如它对Binary类型计算进行了优化，而浮点计算则非常缓慢。</p>
<p>Erlang本身属于函数式语言，没有变量，循环，一切都是Immutable等等。而 Erlang 的 Pattern Matching 能力非常优秀且高效。代码精简且清晰，同时为信息传递奠定了基础。最近十几年，工业界也开始慢慢接受、甚至推崇函数式编程，但是Erlang已经在30年前把函数式代码部署在了生产环境。</p>
<p>Erlang的并发模型属于Actor Model，它实现高并发的基石在于非常廉价的Process。这个Process不是操作系统中的进程，而是Beam虚拟机内部的一个抽象。Process非常廉价，每个进程只有2-4kb的foot print，一个Beam节点可以毫无压力的同事运行超过2百万个process。这些Process都是相互独立的，他们不共享任何内存，有独立的堆栈，除非建立连接，一个Process的崩溃完全不会影响到系统的其他进程。</p>
<p>更加有意思的是，这200万个虚拟机进程，仅仅需要运行在一个操作系统线程内。换句话说，BEAM把并发模型从操作系统中抽象出来了。这样做的优势显而易见：如果我们有多核处理器，相同的代码可以毫不费力的通过增加节点分布在不同的内核里，增加处理能力。</p>
<p>进程之间是通过传递信息实现互动，注意这些信息都是不可变的（immutable），同时信息的传递可以跨越节点，即可以实现不同内核中节点的通信、不同物理机器节点的通讯。事实上，代码中几乎不需要区分进程是local还是remote。这种跨节点通讯正式分布式系统的基础。</p>
<p>在BEAM进程、进行通讯以及函数式语法的基础上，为了进一步增加容错能力，实现99.9%系统在线率，Erlang也发展出了非常独特的 异常处理 和 代码更新 模式。BEAM虚拟机可以实现系统在线的情况下修复bug，并仅仅重新部署一部分出问题的系统。</p>
<p>大部分编程模式的异常处理都是基于 try-catch，也就是 Defensive Programming，即尽可能的捕捉异常，阻止程序崩溃。以为绝大部分系统不能接受线程异常，一个线程异常有肯能会导致整个系统崩溃。Erlang系统很不一样，因为所有进程都是独立的，一个进程的崩溃完全不会影响系统，甚至，系统中的大部分进程都不会意识到。所以，Erlang的 异常处理 更加专注于如何让仍然工作的进程修复崩溃的进程，也就是自我恢复，Self-healing。当然，Erlang生态并没有这个名词， 在Erlang 的世界里叫做 supervisor-tree。通常编写业务逻辑的时候，仅仅关注正确的情况，而不去主动捕捉异常，以为异常总是多种多样的，而且一定会发生。通常如果出现异常，进程就会终结，而他的supervisor进程会介入进行合理的操作，比如重启它等等。换句话说，把业务逻辑和异常处理逻辑分离。也正式因为这样的 异常处理和自我修复设计，实现了Erlang系统的高容错性能。</p>
<h1 id="Erlang生态"><a href="#Erlang生态" class="headerlink" title="Erlang生态"></a>Erlang生态</h1><p>总结一下 Erlang 实现高并发、高容错、分布式的基石：</p>
<ul>
<li>函数式语言，Immutability</li>
<li>超轻量线程，Process</li>
<li>自愈模式的异常处理，Supervision tree</li>
</ul>
<p>无论是Erlang语言本身，还是他的虚拟机BEAM都是围绕上面那三个特征进行设计的。</p>
<p>其实，很多新的语言和框架都或多或少的在学习上面的特性，比如 go routine 和 channel其实就是轻量级线程和通讯，但却没有Erlang进程那么轻，而且共享内存。Erlang的独特之处在于它的设计目的很单一：高并发。而上面的三个特征是实现可靠的高并发系统必不可少的，Erlang把他们做到了极致，不妥协。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><blockquote>
<p>正确的工具做正确的事情</p>
</blockquote>
<p>Erlang 就是高并发场景的正确工具，他非常不完美，但是他满足了高并发场景所需要的工程特征，而且经历近30年的生产环境考验。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>Distributed System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>我的教会观</title>
    <url>/2020/11/27/church/</url>
    <content><![CDATA[<p>教会对基督徒意味着什么？是一个俱乐部？我们足够重视教会吗？教会是神的计划中最基础的部分，最中心的部分，不是神临时的计划。在旧约中我们就看到了教会的雏形。教会是用基督的血赎回的。</p>
<p>哥林多前书12-14</p>
<h2 id="恩赐的多样性（12）"><a href="#恩赐的多样性（12）" class="headerlink" title="恩赐的多样性（12）"></a>恩赐的多样性（12）</h2><blockquote>
<p>1弟兄们，关于属灵的恩赐，我不愿意你们不明白。2你们知道，你们还是教外人的时候，总是受迷惑被引诱，去拜那不能说话的偶像。3所以我要你们知道，被　神的灵感动而说话的人，没有一个会说“耶稣是可咒诅的”；除非是被圣灵感动，也没有人能说“耶稣是主”。</p>
</blockquote>
<p>属灵的恩赐包含非常多种类，讲道的、方言、预言等等，当然也包括其他看起来“不属灵”的恩赐，比如服侍他人、经济上的资助等等。这些都是恩赐，没有高低贵贱之分。</p>
<p>神让教会个人具有不同的、各种各样的恩赐是为了让我们可以同心合一的成为一个基督的教会。</p>
<h2 id="爱的必要性（13）"><a href="#爱的必要性（13）" class="headerlink" title="爱的必要性（13）"></a>爱的必要性（13）</h2><p>使徒保罗的意图非常重要，不要误解他的意思。这段经文其实是保罗在职责格林多教会。</p>
<p>爱是必不可少的：<code>1我若能说世人和天使的方言，却没有爱，我就成了鸣的锣、响的钹一样。</code>。没有爱，拥有任何属灵的恩赐都是无谓的。<br>每一个教会都会面临这样的问题。</p>
<p>在这一节，有一句非常注明的段落：</p>
<blockquote>
<p>4爱是恒久忍耐，又有恩慈。爱是不嫉妒，不自夸，不张狂；5不作失礼的事，不求自己的益处，不轻易动怒，不计较人的过犯；6不喜欢不义，只喜欢真理。7爱是凡事包容，凡事相信，凡事盼望，凡事忍耐。</p>
</blockquote>
<p>可是保罗在这里说出这些不是为了给爱下定义，而是为了指出格林多教会的问题。比如格林多教会充满了骄傲和嫉妒，他们很爱自己没有彼此相爱。他在这里列举的每一项，都是特别针对格林多教会的问题而来的。</p>
<p>这段其实是一个指责。</p>
<h2 id="造就的优先性（14）"><a href="#造就的优先性（14）" class="headerlink" title="造就的优先性（14）"></a>造就的优先性（14）</h2><blockquote>
<p>5我愿意你们都说方言，但我更愿意你们都讲道；因为那说方言的，如果不翻译出来使教会得着造就，就远不如那讲道的了。</p>
</blockquote>
<p>说方言是恩赐，但不是可以造就所有人，不一定可以造就教会。所以，应该用理智让人理解。</p>
<blockquote>
<p>26弟兄们，那么应该怎么办呢？你们聚集在一起的时候，各人或有诗歌，或有教训，或有启示，或有方言，或有翻译出来的话，一切都应该能造就人。</p>
</blockquote>
<h6 id="tags-教会-哥林多前书"><a href="#tags-教会-哥林多前书" class="headerlink" title="tags: 教会 哥林多前书"></a>tags: <code>教会</code> <code>哥林多前书</code></h6>]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>教会</tag>
        <tag>哥林多前书</tag>
      </tags>
  </entry>
  <entry>
    <title>诗篇2 世界的智慧</title>
    <url>/2020/11/22/shipian_2/</url>
    <content><![CDATA[<h1 id="看破世界的智慧"><a href="#看破世界的智慧" class="headerlink" title="看破世界的智慧"></a>看破世界的智慧</h1><p>你是不是曾经想过这个复杂世界最终会走向哪里？你希望做出绝对正确的决定吗？<br>或者，你已经放弃了思考这样“无关”的问题？</p>
<p>无论怎么样，让我们来看看《诗篇2》是如何看待这样的终极智慧。</p>
<p>世界的真相：</p>
<blockquote>
<p>2 列国为甚么骚动? 万民为甚么空谋妄想? 2 世上的君王起来， 首领聚在一起， 敌对耶和华和他所膏立的，说: 3 “我们来挣断他们给我们的束缚， 摆脱他们的绳索!” 4 那坐在天上的必发笑，主必讥笑他们。</p>
</blockquote>
<p>从古至今，人类无论做什么，都没有改变悖逆神的想法，人们总是在不断挣脱神的掌权，占有神的世界，像<br>神一样生活。尼采这样说过：上帝死了！我们的文化把神从我们的生命中拿走了。</p>
<p>然而，神并没有妥协，也没有必要妥协。他要选立和他心意的君王：</p>
<blockquote>
<p>5 那时，他必在烈怒中对他们讲话，在震怒中使他们惊慌，说: 6 “我已经在锡安我的圣山上，立了我的君王。”</p>
</blockquote>
<p>这个世界最根源的问题都来自与人对神的背叛，人没有能力治理这个世界。人们的作为就好像在一副名画上面<br>加上拙劣的到此一游一样。</p>
<p>神作为创造者拥有至高无上的权利，他审判的权柄来自于他创造者的身份：</p>
<blockquote>
<p>9 你必用铁杖击打他们， 好象打碎陶器一样粉碎他们。’” 10 现在，君王啊!你们要谨慎。 地上的审判官啊!你们应当听劝告。 11 你们要以敬畏的态度事奉耶和华， 又应当存战兢的心而欢呼。</p>
</blockquote>
<p>但是，神充满怜悯，耶稣基督带来的救赎就是避免审判的途径。</p>
<p><strong>诗篇2 就是整个圣经内容的一个缩影，包括人类的堕落、神的愤怒和救赎以及世界最终的审判。</strong></p>
<h2 id="PDF-单张"><a href="#PDF-单张" class="headerlink" title="PDF 单张"></a>PDF 单张</h2><p><a href="https://github.com/wangzhe3224/wangzhe3224.github.io/blob/hexo-source/source/pdfs/%E8%AF%97%E7%AF%872-2020_11_22.pdf">诗篇2</a></p>
<h6 id="tags-诗篇"><a href="#tags-诗篇" class="headerlink" title="tags: 诗篇"></a>tags: <code>诗篇</code></h6>]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>诗篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim增加定制帮助文件</title>
    <url>/2020/11/18/vim_tags/</url>
    <content><![CDATA[<h1 id="Vim增加自定义帮助文件"><a href="#Vim增加自定义帮助文件" class="headerlink" title="Vim增加自定义帮助文件"></a>Vim增加自定义帮助文件</h1><p>首先，准备一份帮助文件，文件名必须是 <code>*.txt</code>，然后该文件必须存放在vim的<code>runtimepath</code>。可以通过 <code>:echo &amp;runtimepath</code> 查看，通常就是在<br><code>~/.vim/doc</code> 或者 如果是 neovim 在 <code>~/.config/nvim/</code>。</p>
<p>帮助文件的首行第一个字符必须是 <code>*</code>，文件的其余部分不限。但是文件中所有<br>包含在<code>**</code>内部的单词，都会被检索。所以应该注意不要与其他部分冲突。</p>
<p>一个帮助文件例子：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">*tidal.txt* Tidal documentation</span><br><span class="line"></span><br><span class="line">this <span class="keyword">file</span> <span class="keyword">is</span> <span class="keyword">a</span> consolidation of the official tidalCycles documentation : http<span class="variable">s:</span>//tidalcycles.org/<span class="built_in">index</span>.php/Userbase</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Time = Rational</span><br><span class="line"></span><br><span class="line">## CORE</span><br><span class="line"></span><br><span class="line">*(&lt;~)*:: Pattern Time -&gt; Pattern <span class="keyword">a</span> -&gt; Pattern <span class="keyword">a</span></span><br><span class="line">&lt;~ <span class="keyword">is</span> <span class="keyword">an</span> operator that shifts <span class="keyword">a</span> pattern backward in time, by the given amount.</span><br><span class="line">For example, <span class="keyword">to</span> shift <span class="keyword">a</span> pattern by <span class="keyword">a</span> quarter of <span class="keyword">a</span> cycle, every fourth cycle:</span><br><span class="line">d1 $ every <span class="number">4</span> (<span class="number">0.25</span> &lt;~) $ sound (<span class="string">&quot;arpy arpy:1 arpy:2 arpy:3&quot;</span>)</span><br><span class="line">Or <span class="keyword">to</span> alternate between different shift<span class="variable">s:</span></span><br><span class="line">d1 $ <span class="string">&quot;&lt;0 0.5 0.125&gt;&quot;</span> &lt;~ sound (<span class="string">&quot;arpy arpy:1 arpy:2 arpy:3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里面的 <code>tidal.txt</code> 和 <code>(&lt;~)</code> 将来都会被检索。</p>
<p>完成上述后，运行 <code>:helptags ~/.vim/doc</code>，这样就会为新的帮助文件生成Tag检索。</p>
<p>检索完成后，就可以运行 <code>:h tidal.txt</code> 来显示对应的帮助文件定位了，同时也支持<br>自动补全，在 intert 模式下， <code>C-N</code> 就可以进行补全。</p>
<p>也可以增加如下段落在 <code>.vimrc</code>里面支持 K 键 阅读文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> K :<span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>show_documentation()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">show_documentation</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">index</span>([<span class="string">&#x27;vim&#x27;</span>,<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;tidal&#x27;</span>], &amp;<span class="keyword">filetype</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">execute</span> <span class="string">&#x27;h &#x27;</span>.<span class="built_in">expand</span>(<span class="string">&#x27;&lt;cword&gt;&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">call</span> CocAction(<span class="string">&#x27;doHover&#x27;</span>)</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>诗篇1 简单的智慧</title>
    <url>/2020/11/15/shipian_1/</url>
    <content><![CDATA[<h1 id="诗篇1：终极智慧-人生二路"><a href="#诗篇1：终极智慧-人生二路" class="headerlink" title="诗篇1：终极智慧 人生二路"></a>诗篇1：终极智慧 人生二路</h1><blockquote>
<p>1 有福的人: 不从恶人的计谋， 不站罪人的道路， 不坐好讥笑的人的座位。 2 他喜爱的是耶和华的律法， 他昼夜默诵的也是耶和华的律法。 3 他像一棵树，栽在溪水旁， 按时结果子， 叶子总不枯干; 他所作的一切，尽都顺利。4 恶人却不是这样， 他们好象糠秕， 被风吹散。 5 因此，在审判的时候，恶人必站立不住; 在义人的团体中，罪人也必这样。 6 因为耶和华看顾义人的道路， 恶人的道路却必灭亡。<br>诗篇 1</p>
</blockquote>
<h2 id="幸福的人是什么样的？"><a href="#幸福的人是什么样的？" class="headerlink" title="幸福的人是什么样的？"></a>幸福的人是什么样的？</h2><p>有祝福的人：</p>
<ul>
<li>不从恶人的计谋</li>
<li>不站罪人的道路</li>
<li>不坐好讥笑的人的座位</li>
</ul>
<p>但是这些人，在诗篇作者的世代，指的是哪些人呢？诗篇是写给以色列人的，就是认识耶和华的人群，所以这里这些人指代的就是不敬畏神的人群。</p>
<p>有福的人：</p>
<ul>
<li>喜爱耶和华的律法</li>
</ul>
<p>有福的人脑海中关注的是神的话语，就是对神的敬畏。所以有福的人不会按照世俗的观念生活，不会依靠这样社会。有福的人，时刻思念神的话语。</p>
<p>有福的人时刻问自己，如何做才是敬畏神的，才是讨神喜悦的？</p>
<h2 id="有福的人是什么结果？"><a href="#有福的人是什么结果？" class="headerlink" title="有福的人是什么结果？"></a>有福的人是什么结果？</h2><blockquote>
<p>3 他像一棵树，栽在溪水旁，按时结果子， 叶子总不枯干; 他所作的一切，尽都顺利。</p>
</blockquote>
<p>他的生命是有意义的，是有果实的，是有源泉的，是充满祝福的。这里的顺利绝不仅仅是世俗的顺利，而是神所关心的事情。而这样的人的幸福，是其他人无法理解的。</p>
<h2 id="人生的另一条路"><a href="#人生的另一条路" class="headerlink" title="人生的另一条路"></a>人生的另一条路</h2><blockquote>
<p> 4 恶人却不是这样， 他们好象糠秕， 被风吹散。 5 因此，在审判的时候，恶人必站立不住; 在义人的团体中，罪人也必这样。 6 因为耶和华看顾义人的道路， 恶人的道路却必灭亡。</p>
</blockquote>
<p>恶人，就是不敬畏神的人，却像糠秕，无意义，没有源泉，必要灭亡。与溪水旁的果树形成了鲜明的对比。</p>
<p>你要如何选择？</p>
<h2 id="可是，世界真的是这样的？"><a href="#可是，世界真的是这样的？" class="headerlink" title="可是，世界真的是这样的？"></a>可是，世界真的是这样的？</h2><p>为什么我们看到这个世界，不敬畏神的人，生活似乎更加美好、富有。反而是很多基督徒受到限制，并没有在这个世界上有任何优势。</p>
<p>原因在于，智慧的定义在圣经中是不一样的。智慧不来自于体验和经验。圣经中的智慧开始于敬畏耶和华，来源于耶和华。很多看似幸福的人，追求的很多东西，到头来都是空虚的，自己终究没有办法掌控自己的生命。因为，人的意义就在于交托于神。</p>
<p>空虚和死亡，是这个世界上没有人可以击败的。只有神可以解决。</p>
<p>世界有很多谎言，把智慧当做愚蠢就是其中一个。魔鬼撒旦，在伊甸园就开始对人类说谎：神不爱你，神不会审判的，你比神更有智慧，你不需要神。。。。这些谎言直到现在仍然以不同的形式出现在我们身边，迷惑我们。</p>
<h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><a href="https://github.com/wangzhe3224/wangzhe3224.github.io/blob/hexo-source/source/pdfs/%E8%AF%97%E7%AF%871.pdf">诗篇1</a></p>
<h6 id="tags-诗篇"><a href="#tags-诗篇" class="headerlink" title="tags: 诗篇"></a>tags: <code>诗篇</code></h6>]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>诗篇</tag>
      </tags>
  </entry>
  <entry>
    <title>CS3110总结</title>
    <url>/2020/11/09/cs3110/</url>
    <content><![CDATA[<h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>总体感觉CS3110这门课程像是一个关于Coding的“大杂烩”，这里完全没有贬义，相反这门课对我这种转行背景的程序员非常有帮助。<br>正如这么课程介绍中说：</p>
<blockquote>
<p>This course is about making you a better programmer. </p>
</blockquote>
<p>为了实现这一目的，这门课程的内容涉及了较多方面的内容，而且每一个部分都有为这个目的贡献了力量：</p>
<ul>
<li>Functional Programming with Ocaml：为了说明如何系统化学习任何一门新的计算机预言</li>
<li>Modular Programming: 为了说明如何构建大型程序</li>
<li>Data Structures: 深度讲解了基本的数据结构,Mutable and Immutable, 比如流、红黑树、哈希表等等</li>
<li>Interpreter: 讲解了计算机预言解释器，即更加了解程序员的工具：计算机语言</li>
<li>Formal Methods: 讲解进行软件Formal verification</li>
</ul>
<p>课程虽然选择Ocaml，但是讲解的内容多数可以应用于任何语言，通过学习背后动机，可以帮助学习和理解其他计算机语言。</p>
<p>同时，这门课的很多主题为深入学习其他领域奠定了基础，比如：</p>
<ul>
<li>CS4110/6110 Programming Languages and Logics，如何设计一门语言</li>
<li>CS4120 Compilers，如何实现一门语言</li>
<li>CS4160 Formal Verification，如何证明程序的正确性 :+1: </li>
</ul>
<h2 id="几个大的主题"><a href="#几个大的主题" class="headerlink" title="几个大的主题"></a>几个大的主题</h2><h3 id="语言可以系统化学习"><a href="#语言可以系统化学习" class="headerlink" title="语言可以系统化学习"></a>语言可以系统化学习</h3><p>计算机语言可以有系统化的学习方法，任何一门计算机语言特性都可有通过如下三个规则进行分析：</p>
<ul>
<li>语法，Syntax</li>
<li>静态语义，static semantic, 即 typing rule</li>
<li>动态语义，dynamic semantic，即 Evaluation rule</li>
</ul>
<p>分治，Divide-and-conquer，无处不在。</p>
<p>计算机语言可以从数学的角度精确定义。</p>
<h3 id="计算机语言不是魔法"><a href="#计算机语言不是魔法" class="headerlink" title="计算机语言不是魔法"></a>计算机语言不是魔法</h3><ul>
<li>编写一个语言的解释器非常简单！</li>
<li>DSL，可能是一个好的选择</li>
</ul>
<h3 id="优雅的抽象确实是魔法"><a href="#优雅的抽象确实是魔法" class="headerlink" title="优雅的抽象确实是魔法"></a>优雅的抽象确实是魔法</h3><ul>
<li>语言特征：product types, union types</li>
<li>Higher order functions: map, fold..</li>
<li>Data structures: lists, tree, dictionary, monad</li>
<li>Module system: abstraction, functors</li>
<li>Use abstraction and decomposition</li>
<li>Think in multiple levels of abstractions</li>
</ul>
<h3 id="编写软件需要系统化的方法"><a href="#编写软件需要系统化的方法" class="headerlink" title="编写软件需要系统化的方法"></a>编写软件需要系统化的方法</h3><ul>
<li>设计：动手编程以前，先想。</li>
<li>同理心：编写可以被人轻易看懂的代码</li>
<li>保证：测试和证明</li>
<li>团队合作</li>
</ul>
<h3 id="这门课教给我的"><a href="#这门课教给我的" class="headerlink" title="这门课教给我的"></a>这门课教给我的</h3><ul>
<li>复杂的系统可以被分解成小的、容易理解的部分</li>
<li>学习小的部分更加容易</li>
<li>学习小的部分如何配合形成复杂系统</li>
</ul>
<h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>模块化编程的核心在于，通过构建抽象以实现局部化。具体实现的工具包括：</p>
<ul>
<li>命名空间，Namespace，把相关的数据结构和函数放在一起</li>
<li>抽象，Abstraction，隐藏具体的数据结构和函数实现，仅保留<strong>接口和文档</strong></li>
<li>代码复用，Code reuse</li>
</ul>
<p>这些概念通常在OO中已经比较常见和熟悉，但是这门课程同时强调了文档和测试的重要性。</p>
<p>好的文档应该区别对待接口和实现，接口文档是写给Client看的，而实现文档是写给内部程序员。</p>
<p>好的接口文档应该包含：</p>
<ul>
<li>Return clause</li>
<li>Requires clause</li>
<li>Raises clause</li>
<li>Example clause</li>
</ul>
<p>好的实现文档应该包含：</p>
<ul>
<li>AF, Abstract Function，实现数据结构到抽象结构的映射关系</li>
<li>RI, Representation Invariant， 那些实现数据结构是合法的抽象结构</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lexing -&gt; (Tokens) -&gt; Parsing -&gt; (AST) -&gt; Semantic Check ...</span><br><span class="line">         -&gt; (Intermediate Representation) -&gt; (Target code)</span><br></pre></td></tr></table></figure>

<h2 id="Lab-解答"><a href="#Lab-解答" class="headerlink" title="Lab 解答"></a>Lab 解答</h2><p><a href="https://github.com/wangzhe3224/cs3110">CS3110 Labs</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook">https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2018sp/">https://www.cs.cornell.edu/courses/cs3110/2018sp/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ocaml</tag>
        <tag>CS3110</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>路加福音 19:1-27</title>
    <url>/2020/11/08/luke_19_1_27/</url>
    <content><![CDATA[<p><strong>十个仆人的比喻</strong></p>
<h2 id="现在我们要充分利用主再来之前的日子"><a href="#现在我们要充分利用主再来之前的日子" class="headerlink" title="现在我们要充分利用主再来之前的日子"></a>现在我们要充分利用主再来之前的日子</h2><p>当时耶稣周围的人认为神的国度当时就要降临，特别的，神国的王会带领他们击败罗马帝国，实现以色列的复国。<br>但是耶稣并不是这样说。</p>
<h3 id="现在为主做工"><a href="#现在为主做工" class="headerlink" title="现在为主做工"></a>现在为主做工</h3><p>比喻中，国王要离开一段时间，他交给仆人一些钱，让们去投资。也就是继续为王做工。<br>为主做工是不是我们生命中最大的荣耀呢？</p>
<p>为主做工是什么意思呢？</p>
<p>只要我们仔细看这段经文的上下文我们就能知道这比喻中，主的工到底是什么？</p>
<blockquote>
<p>人要奉我的名，把神国的福音，从耶路撒冷传到地极。</p>
</blockquote>
<h3 id="只有一个抉择"><a href="#只有一个抉择" class="headerlink" title="只有一个抉择"></a>只有一个抉择</h3><p>耶稣这个比喻的重点，实际上在于是不是顺服主人的吩咐。<br>国王离开的时候，吩咐仆人：拿这些钱就投资。但是，第三个仆人没有顺从去投资，而是把钱财保存起来。</p>
<p>将来，耶稣再来实行审判，结果也取决于是不是顺服耶稣基督的话语和命令。顺服耶稣基督，才是基督徒的首要大事。</p>
<h2 id="将来审判的结果取决于现在让耶稣作王"><a href="#将来审判的结果取决于现在让耶稣作王" class="headerlink" title="将来审判的结果取决于现在让耶稣作王"></a>将来审判的结果取决于现在让耶稣作王</h2><h3 id="做仇敌的危险"><a href="#做仇敌的危险" class="headerlink" title="做仇敌的危险"></a>做仇敌的危险</h3><p>做主的仇敌，就是不承认耶稣基督是王的，就会“死”，永恒的死，永远的离开神。这是将来的审判。<br>这不是神缺乏爱心，而是事实。而且耶稣基督给了世人救赎，拜拜赐给人类的救赎，就是避免审判，<br>与神永恒的同在。</p>
<h3 id="做主工的赏赐"><a href="#做主工的赏赐" class="headerlink" title="做主工的赏赐"></a>做主工的赏赐</h3><p>投入主的工，赏赐是大的：</p>
<blockquote>
<p>17主人说：‘好，良善的仆人，你既然在最小的事上忠心，可以有权管理十座城。</p>
</blockquote>
<p>这也证明我们顺服耶稣基督的吩咐。</p>
<h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p><a href="https://pan.baidu.com/s/13brREFqHnK7CdGbH1QfSOQ">路加福音 19：1-27</a></p>
<p>提取码: i2ds</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>路加福音</tag>
      </tags>
  </entry>
  <entry>
    <title>路加福音 19:1-10</title>
    <url>/2020/11/01/luke_19/</url>
    <content><![CDATA[<blockquote>
<p>耶稣基督，寻找罪人的君王</p>
</blockquote>
<blockquote>
<p>11“‘因为主耶和华这样说:看哪!我必亲自寻觅我的羊，把牠们找出来。12 牧人在他的羊群四散的 时候，怎样寻找他的羊，我也必照样寻找我的羊。这些羊在密云幽暗的日子四散到各处，我要把 牠们从那里救回来。<br>—— 以西结书 34:11-12</p>
</blockquote>
<h2 id="神的国已经在我们中间"><a href="#神的国已经在我们中间" class="headerlink" title="神的国已经在我们中间"></a>神的国已经在我们中间</h2><p>上一章路加让我们发现，耶稣基督让属灵瞎眼的人看见神的国，神的国已经在我们中间。今天这一段更加强化了这一点：</p>
<blockquote>
<p>9 耶稣说:“今天救恩到了这家，他也是亚伯拉罕的子 孙。 10 因为人子来，是要寻找拯救失丧的人。”</p>
</blockquote>
<p>这里面的他，是当时的税吏撒该。在当时的犹太文化背景里面，税吏被认为是有罪的。因为他们替统治者罗马人征收犹太人的关税，他们这个群体也充斥着贪污、腐败，欺压群众。但是，耶稣却说，救恩到了撒该的家里，到了这个罪人的家里。这在当时确实是一件非常奇怪的事情。</p>
<p>撒该，为了看见耶稣，就爬上树。当耶稣看到他的时候，他就欢欢喜喜的接待耶稣。耶稣居然要住在罪人的家里！众人不明白，撒该是税吏长，是坏人头子。</p>
<p>这里出现了两个重要的相联系的概念：接待和救赎。即使是罪人，只要愿意接待神，接受神，神的救赎就会降临。毕竟，“没有一个义人”。这里我们可以联想到之前的高尚的富人，耶稣说这人进神的国，比骆驼穿过针眼还困难，救恩没有降临到那个高尚的富人身上。因为，那人没有接受耶稣，而这个罪人税吏愿意接受耶稣。</p>
<h2 id="神正在寻找拯救罪人"><a href="#神正在寻找拯救罪人" class="headerlink" title="神正在寻找拯救罪人"></a>神正在寻找拯救罪人</h2><p>耶稣首先愿意住在撒该的家里，撒该欢欢喜喜的接待了耶稣。所以他的生活态度发生了巨大的变化：</p>
<blockquote>
<p>8 撒该站着对主说:“主啊，请看，我要把家财的一半分给 穷人，我若敲诈了谁，就还他四倍。”</p>
</blockquote>
<p>救恩的降临并不是因为撒该的改变，而是因为救恩的降临，撒该的生命才发生了巨变。</p>
<p>神拯救的人往往不一定是人们认为的好人，而是愿意悔改顺服的罪人。</p>
<h2 id="与神同工"><a href="#与神同工" class="headerlink" title="与神同工"></a>与神同工</h2><p>因为神的国已经在我们中间，我们有理由充满信心的投入神的工作，就是救赎人类的工作。神正在寻找拯救失散的人。即使在这个世界，神也没有离开我们，神仍然在掌权。神有能力完全颠覆一个人的世界观，神最擅长做不可能的事情。</p>
<p><strong>附件</strong></p>
<p>链接: <a href="https://pan.baidu.com/s/1QMy6ZC3cA2JLgEUe4oB8aw">路加福音19：1-10 PDF</a><br>提取码: gr6f</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>路加福音</tag>
      </tags>
  </entry>
  <entry>
    <title>路加福音 18:31-34</title>
    <url>/2020/10/18/luke_18_31_34/</url>
    <content><![CDATA[<h1 id="耶稣死亡和复活的意义"><a href="#耶稣死亡和复活的意义" class="headerlink" title="耶稣死亡和复活的意义"></a>耶稣死亡和复活的意义</h1><h2 id="关于耶稣死亡和复活的预言"><a href="#关于耶稣死亡和复活的预言" class="headerlink" title="关于耶稣死亡和复活的预言"></a>关于耶稣死亡和复活的预言</h2><blockquote>
<p>31 耶稣把十二门徒带到一边，对他们说:“我们现在上耶路撒冷去，先知所写的一切，都要 成就在人子身上。 32 他要被交给外族人，受戏弄，被凌辱，他们要向他吐唾沫， 33 鞭打他， 杀害他;第三日他要复活。” 34 这些话的含义对门徒是隐藏的。他们听了，一点也不明白， 不知道他说的是甚么。<br>———- 路加福音 18</p>
</blockquote>
<p>这段经文是耶稣当年对门徒说的一段话，预言了他自己的死亡和复活。但是当时的门徒还不明白这些话是什么意思。这里提到的“先知所写的一切”，我们来看看指的是什么？</p>
<p>“人子”是谁？最早这个概念出现在先知但以理的一个异象：</p>
<blockquote>
<p>13“我在夜间的异象中继续观看，看见有一位像人子的，驾着天云而来，到万古常存者那里，被引领到他面前，14得了权柄、尊荣和国度；各国、各族和说各种语言的人都事奉他。 他的权柄是永远的权柄，是不能废去的；他的国度是永不毁灭的。<br>———- 但以理书 7</p>
</blockquote>
<p>人子，就是神的君王。异象中提到人子要掌权，万古长存。可是，耶稣接下来的话却令人诧异，他说他会屈辱被杀，但是三日后复活。其实这提到的是另一位先知以赛亚的预言：</p>
<blockquote>
<p>4 原来他担当了我们的病患，<br>背负了我们的痛苦;<br>我们却以为他受责打， 被 神击打和苦待了。<br>5 然而他是为了我们的过犯被刺透，<br>为了我们的罪孽被压伤; 使我们得平安的惩罚加在他身上，<br>因他受了鞭伤，我们才得医治。<br>———- 以赛亚书 53</p>
</blockquote>
<p>以赛亚也预言了他的复活：</p>
<blockquote>
<p>11 他受了生命之苦以后，必看见光明，并且心满意足; 我的义仆必使许多人 因认识他而得称为义， 他也必背负他们的罪孽。<br>———- 以赛亚书 53</p>
</blockquote>
<p>约拿书 1章17节，约拿在鱼腹中三日三夜复活。</p>
<blockquote>
<p>17耶和华却安排了一条大鱼，把约拿吞下。约拿就在鱼腹中三日三夜。<br>———- 约拿书 1</p>
</blockquote>
<p>所有的预言，人子、受辱、死亡、复活都已经在耶稣基督身上实现了！这是旧约圣经非常常见的手法，就是当时发生的事情，往往不仅仅代表了当时的事件，也预表了将来的事件，圣经整体就是这样渐进性的启示。从创世纪到启示录一向如此。</p>
<p>耶稣的一切经历都不是因为无能为力，而是去救赎我们，也应验了先知预言的一切。他选择经历这些，也证明了他就是人子，神的王。</p>
<h2 id="耶稣为什么被交给外族人杀害？"><a href="#耶稣为什么被交给外族人杀害？" class="headerlink" title="耶稣为什么被交给外族人杀害？"></a>耶稣为什么被交给外族人杀害？</h2><p>在整个圣经中，神围着审判以色列人，把以色列民族交给外族人，四分五裂。所以，交给外邦人通常意味着承受神的审判。那么，耶稣被交给外邦人，就是承受神的审判。可是，耶稣是神的儿子，并没有罪，他是为什么接受审判呢？</p>
<p>让我们再来看看以赛亚先知的预言：</p>
<blockquote>
<p>4 原来他担当了我们的病患，<br>背负了我们的痛苦;<br>我们却以为他受责打， 被 神击打和苦待了。<br>5 然而他是为了我们的过犯被刺透，<br>为了我们的罪孽被压伤; 使我们得平安的惩罚加在他身上，<br>因他受了鞭伤，我们才得医治。<br>———- 以赛亚书 53</p>
</blockquote>
<p>原来，耶稣基督被交给外族人杀害，承受咒诅，乃是为了承担人类的过犯，完成对我们救赎。</p>
<h2 id="复活意味着什么"><a href="#复活意味着什么" class="headerlink" title="复活意味着什么?"></a>复活意味着什么?</h2><p>不知道你有没有注意到：</p>
<blockquote>
<p>34 这些话的含义对门徒是隐藏的。他们听了，一点也不明白， 不知道他说的是甚么。<br>———- 路加福音 18</p>
</blockquote>
<p>福音书说，这些话的意义被隐藏了，也就解释了门徒为什么不理解这么明显的应验。其实，这些都是神对人的审判，让人在属灵上盲目，看不到真相。只有通过耶稣基督的死亡和复活，完成救赎。人属灵的眼睛才可以打开，明白福音。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，耶稣的死亡证明了他的身份：神应许的君王。因为众先知纷纷预言了这些事情。耶稣的死亡，完成了对人类罪的最终救赎。耶稣的复活，将救赎带到了这个堕落的世界。</p>
<p>我们应该记得，耶稣爱我们，所以愿意为我们承受这一切。</p>
<p>天国的门，因着耶稣基督的死亡和复活，大大的敞开了！</p>
<blockquote>
<p>天国近了，你们当悔改，相信福音。</p>
</blockquote>
<p>&lt;完&gt;</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>路加福音</tag>
      </tags>
  </entry>
  <entry>
    <title>Covid-19和基督信仰</title>
    <url>/2020/10/17/covin-19/</url>
    <content><![CDATA[<h1 id="Covid-19是审判吗？"><a href="#Covid-19是审判吗？" class="headerlink" title="Covid-19是审判吗？"></a>Covid-19是审判吗？</h1><p>是审判，但不是惩罚。</p>
<h2 id="疫情是堕落的症状"><a href="#疫情是堕落的症状" class="headerlink" title="疫情是堕落的症状"></a>疫情是堕落的症状</h2><blockquote>
<p>18我看现在的苦难，与将要向我们显出的荣耀，是无法相比的。19被造的万物都热切渴望　神的众子显现出来。20因为被造的万物服在虚空之下，不是自己愿意这样，而是由于使它屈服的那一位；21被造的万物盼望自己得着释放，脱离败坏的奴役，得着　神儿女荣耀的自由。<br>罗马书 8</p>
</blockquote>
<p>疫情，就像这个世界其他的灾难一样，都是人类堕落的审判。这是我们世界的系统性问题，并不是针对个人的。疫情是审判，但是疫情不是惩罚。如果一个人得病，也不意味着这个人比别人更加有罪，因为“没有一个义人，人人都得罪了神”。</p>
<p>同时，疫情也让提醒我们这个世界是有问题的，提醒我们盼望应许的新天地。</p>
<h2 id="疫情是末世的征兆"><a href="#疫情是末世的征兆" class="headerlink" title="疫情是末世的征兆"></a>疫情是末世的征兆</h2><blockquote>
<p>22我们知道被造的万物直到现在都一同在痛苦呻吟。<br>罗马书 8</p>
</blockquote>
<p>疫情，是末世的诸多征兆之一。作为基督徒我们充满盼。这就好像妇人产前的阵痛，新的世界既要降临了。而我们需要做的就是保持信心，热切盼望。</p>
<h1 id="疫情期间如何信靠神？"><a href="#疫情期间如何信靠神？" class="headerlink" title="疫情期间如何信靠神？"></a>疫情期间如何信靠神？</h1><p>显然，再这样一个疫情期间，我们很难对任何事情建立信心。但是更可怕的是，我们容易在错误的事情上建立信心。</p>
<h2 id="信心应该建立在事实基础上"><a href="#信心应该建立在事实基础上" class="headerlink" title="信心应该建立在事实基础上"></a>信心应该建立在事实基础上</h2><blockquote>
<p>“信心是对所盼望的事的把握，是未见之事的证明”<br>希伯来书 11：1</p>
</blockquote>
<p>信心的本质是对未来的事情的确信。对于基督徒来说，信心的对象就是神应许给人的新天地，与神同在的世界。而这些信心的基础就在于神的话语。神的一切应许都来自他的话语。从创世记我们看到，世界的存在也因着神的话语。所以，我们信心的基础就在于神的话语，在于圣经本身。</p>
<p>我们的信心并不依靠我们的自己的感觉，而是依靠神不变的应许。我们的感觉本身也不值得依靠，因为感觉市场变化，不稳定，脆弱。圣经中的信心来自于对话语的确认，并不依靠我们的情感。无论你感觉如何，神的应许不曾改变。</p>
<blockquote>
<p>天地都会废去，但是我的话语不会。</p>
</blockquote>
<h2 id="信心是用事实与感觉征战"><a href="#信心是用事实与感觉征战" class="headerlink" title="信心是用事实与感觉征战"></a>信心是用事实与感觉征战</h2><h3 id="我们可以告诉神自己的感受"><a href="#我们可以告诉神自己的感受" class="headerlink" title="我们可以告诉神自己的感受"></a>我们可以告诉神自己的感受</h3><p>大卫王，在诗篇13中尽情的向神倾诉自己的感受。我们的信心让我们诚实的对神祷告，对神倾诉我们的感受，我们的痛苦、喜悦。</p>
<h3 id="我们可以向神求助"><a href="#我们可以向神求助" class="headerlink" title="我们可以向神求助"></a>我们可以向神求助</h3><p>大卫，同样在他的祷告中向神求助，求神帮助他战胜仇敌。即使，他感觉神抛弃了他。但是因为信心，即使他感觉神离弃了他，他仍然向神呼求！因为，他有信心。</p>
<p>基督徒同样可以这样，因为我们对神的信心。我们祷告不需要华丽的词汇、复杂的句子，我们可以直接向神做简短的呼求。</p>
<h3 id="我们拥有神的话语"><a href="#我们拥有神的话语" class="headerlink" title="我们拥有神的话语"></a>我们拥有神的话语</h3><p>牢记，神爱世人。即使，世界看起来充满痛苦，但是不要让感受影响信心，信心的基础在神的话语、应许，不在于我们的感受。</p>
<p>我们只有不断的通过圣经提醒自己神的属性，我们才能战胜感觉。我们应该知道神是如何拯救以色列人，耶稣基督是如何死在十字架上完成我们的救赎，我们就可以战胜感觉，把信心放在正确的事情上：神的话语。</p>
<h1 id="疫情期间基督徒如何生活？"><a href="#疫情期间基督徒如何生活？" class="headerlink" title="疫情期间基督徒如何生活？"></a>疫情期间基督徒如何生活？</h1><blockquote>
<p>16照样，你们的光也应当照在人前，让他们看见你们的好行为，又颂赞你们在天上的父。<br>马太福音 5</p>
</blockquote>
<ul>
<li>不要作恶</li>
<li>顺服政府</li>
<li>尊敬父母</li>
<li>接纳软弱的弟兄</li>
<li>聚会</li>
<li>祷告</li>
</ul>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>Covid-19</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6828 lab 1</title>
    <url>/2020/10/10/mit6828_lab1/</url>
    <content><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>First thing, what does it mean by saying <code>cs:ip</code>?<br>This is a old but still being used memory addressing method. <code>Segment: Offfset</code>. The absolute memory addres = (Segment * 16) + Offset. For example, <code>F000:FFFD</code> means address <code>FFFFD</code>. This strange way of expressing address is due to the fact that in the old days, CPU’s regeisters are only 16bit, which can only address a memeory address of 2^16 (which is 64KiB memory). This is even too small at that age. So CPU manufacturers combines two regiesters to express larger address, which is this <code>segment: offset</code> thing.<br><code>cs</code> means “code segment” and <code>ip</code> means “instruction pointer”. The combination represents the location where CPU is currently fetching instructions to execute.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)                 [Intel 8088]</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |                                      [Conventional Memory]</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-2-debug-boot"><a href="#Exercise-2-debug-boot" class="headerlink" title="Exercise 2: debug boot"></a>Exercise 2: debug boot</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [CS:IP]    address: command  args</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b   # goto 0xfe05b</span><br><span class="line">[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6c48</span><br><span class="line">[f000:e062]    0xfe062: jne    0xfd2e1</span><br><span class="line">[f000:e066]    0xfe066: xor    %dx,%dx</span><br><span class="line">[f000:e068]    0xfe068: mov    %dx,%ss</span><br><span class="line">[f000:e06a]    0xfe06a: mov    $0x7000,%esp</span><br><span class="line">[f000:e070]    0xfe070: mov    $0xf3691,%edx</span><br><span class="line">[f000:e076]    0xfe076: jmp    0xfd165</span><br><span class="line">[f000:d165]    0xfd165: mov    %eax,%ecx</span><br><span class="line">[f000:d168]    0xfd168: cli</span><br><span class="line">[f000:d169]    0xfd169: cld</span><br><span class="line">[f000:d16a]    0xfd16a: mov    $0x8f,%eax</span><br><span class="line">[f000:d170]    0xfd170: out    %al,$0x70</span><br><span class="line">[f000:d172]    0xfd172: in     $0x71,%al</span><br><span class="line">[f000:d174]    0xfd174: in     $0x92,%al</span><br><span class="line">[f000:d176]    0xfd176: or     $0x2,%al</span><br><span class="line">[f000:d178]    0xfd178: out    %al,$0x92</span><br><span class="line">[f000:d17a]    0xfd17a: lidtw  %cs:0x6c38</span><br><span class="line">[f000:d180]    0xfd180: lgdtw  %cs:0x6bf4</span><br><span class="line">[f000:d186]    0xfd186: mov    %cr0,%eax</span><br><span class="line">[f000:d189]    0xfd189: or     $0x1,%eax</span><br><span class="line">[f000:d18d]    0xfd18d: mov    %eax,%cr0</span><br><span class="line">[f000:d190]    0xfd190: ljmpl  $0x8,$0xfd198</span><br><span class="line">&#x3D;&gt; 0xfd198:     mov    $0x10,%eax</span><br><span class="line">&#x3D;&gt; 0xfd19d:     mov    %eax,%ds</span><br><span class="line">&#x3D;&gt; 0xfd19f:     mov    %eax,%es</span><br><span class="line">&#x3D;&gt; 0xfd1a1:     mov    %eax,%ss</span><br></pre></td></tr></table></figure>

<h2 id="Part-2-Boot-Loader"><a href="#Part-2-Boot-Loader" class="headerlink" title="Part 2 Boot Loader"></a>Part 2 Boot Loader</h2><p>BIOS handle control to boot loader by loading boot loader into memory and jump instruction pointer to <code>0x7C00</code>, where boot<br> loader code started.</p>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><ul>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
</ul>
<p><code>[   0:7c1e] =&gt; 0x7c1e:  lgdtw  0x7c64</code>. Here starting using GDT, Global Descriptor Table.<br>Then mark control regesiter, <code>cr0</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   0:7c23] &#x3D;&gt; 0x7c23:  mov    %cr0,%eax</span><br><span class="line">[   0:7c26] &#x3D;&gt; 0x7c26:  or     $0x1,%eax</span><br><span class="line">[   0:7c2a] &#x3D;&gt; 0x7c2a:  mov    %eax,%cr0</span><br><span class="line">[   0:7c2d] &#x3D;&gt; 0x7c2d:  ljmp   $0x8,$0x7c32   # &lt;-- Jump to next instruction, which in 32-bit code segment.</span><br><span class="line">&#x3D;&gt; 0x7c32:      mov    $0x10,%ax   # notice that the address format changed.</span><br></pre></td></tr></table></figure>

<p>In <code>boot.S</code> source code, one can see <code>.code16</code> as a sign of 16-bit mode, and <code>.code32</code> as 32-bit mode.</p>
<ul>
<li><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&gt; 0x7c40:      mov    $0x7c00,%esp # setup stack pointer to call boot&#x2F;main.c</span><br><span class="line">&#x3D;&gt; 0x7c45:      call   0x7d15</span><br><span class="line">&#x3D;&gt; 0x7d15:      push   %ebp # here we move to &#96;main.c&#96;. boot.S hands over control to main.c </span><br><span class="line">&#x3D;&gt; 0x7d6b:      call   *0x10018       # this is the last instruction from boot loader</span><br><span class="line">&#x3D;&gt; 0x10000c:    movw   $0x1234,0x472  # this is the first instruction from the kernel.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Where is the first instruction of the kernel? <code>0x10000c</code></p>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?  The boot loader find sector number from </p>
</li>
</ul>
<p>Notes:<br><code>x/i $pc</code>: show current instruction (content that program counter, <code>pc</code>, pointed to)<br><code>si</code>: execute current instruction<br><code>c</code>: execute until next break point<br><code>b *address</code>: set a break point at address</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><ul>
<li>Understand <code>pointer.c</code>. Read K&amp;R Ch5.1 - 5.5.</li>
</ul>
<p>Note:</p>
<ul>
<li>Unary operators like * and ++ associate right to left. <code>++*p</code> and <code>(*p)++</code> and <code>*p++</code>.</li>
<li>(int *) ((char *) c) makes the trick, char is 1 byte long whereas int is 4 bytes.</li>
</ul>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>The first instruction that would break will be <code>ljmp $PORT_MODE_CSEG, $protcseg</code>, <code>$protcseg</code> is part of<br>.text segment, and the segement is assumed to be loaded at <code>0x7c00</code>. </p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>Breakpoint 0x7c00</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   0:7c00] &#x3D;&gt; 0x7c00:  cli</span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x100010:       0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">&#x3D;&gt; 0x10000c:    movw   $0x1234,0x472</span><br><span class="line">Breakpoint 2, 0x0010000c in ?? ()</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x0000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure>

<h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>this bit code activate page:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Turn on paging.</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Set the breakpoint at 0x00100025 (this is the pysical address of movl %eax, %cr0). We can see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb) x&#x2F;8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p>After execute this line, we can see that both 100000 and f0100000 hold same content.<br> Memory is mapped.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb) x&#x2F;8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure>

<p>The next instruction need the virtual memeory setup, otherwise it cannot find the right memory address.<br> 0xf010002f.</p>
<p><code>f0100028:   b8 2f 00 10 f0          mov    $0xf010002f,%eax</code></p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>The code is similar to unsigned int, just change base to 8:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; getuint(&amp;ap, lflag);</span><br><span class="line">base &#x3D; 8;</span><br><span class="line">goto number;</span><br></pre></td></tr></table></figure>

<p><strong>Explain the interface between printf.c and console.c. Specifically, what function does console.c export?</strong><br><strong>How is this function used by printf.c?</strong></p>
<p><code>putch()</code> function in printf.c calls <code>cputchar()</code> in console.c to show chars in concole.</p>
<p>the following code will give a new page when screen is full.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (crt_pos &gt;&#x3D; CRT_SIZE) &#123;</span><br><span class="line">    int i;</span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">            for (i &#x3D; CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                    crt_buf[i] &#x3D; 0x0700 | &#39; &#39;;</span><br><span class="line">                        crt_pos -&#x3D; CRT_COLS;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercies-9-The-Stack"><a href="#Exercies-9-The-Stack" class="headerlink" title="Exercies 9: The Stack"></a>Exercies 9: The Stack</h3><blockquote>
<p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p>
</blockquote>
<p>The kernel initialized stack pointer in line 76 of <code>kern/entry.S</code> with <code>movl $(bootstacktop), %esp</code>.<br>By looking at <code>obj/kern/kernel.asm</code> line 57, we know that stack pointer is pointing to <code>0xf0110000</code><br> which is right after the 1MB kernel space.</p>
<p><code>f0100034:   bc 00 00 11 f0          mov    $0xf0110000,%esp</code></p>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ebp != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> eip = ebp[<span class="number">1</span>];</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (debuginfo_eip(eip, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        ebp = (<span class="keyword">uint32_t</span> *)(*ebp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://qiita.com/kagurazakakotori/items/b092fc0dbe3c3ec09e8e">Solution</a></li>
<li><a href="https://www.youtube.com/watch?v=Q2sFmqvpBe0">Call stack video</a></li>
<li><a href="https://www.youtube.com/watch?v=XbZQ-EonR_I">Details in stack and register</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>神的国属于什么样的人？</title>
    <url>/2020/10/04/luke_18/</url>
    <content><![CDATA[<h1 id="神的国属于什么样的人？"><a href="#神的国属于什么样的人？" class="headerlink" title="神的国属于什么样的人？"></a>神的国属于什么样的人？</h1><p>路加福音 18：15，1：46</p>
<p>我们是两手空空人吗？我们是像小孩子一样的，单单接受的人么？</p>
<p>其实，扪心自问，我时刻带着自己的骄傲。</p>
<blockquote>
<p>16耶稣却叫他们过来，说：“让小孩子到我这里来，不要禁止他们，因为　神的国正属于这样的人。17我实在告诉你们，凡不像小孩子一样接受　神的国的，决不能进去。”</p>
</blockquote>
<p>放下自己的骄傲，承认自己的无能为力，才是进入神的国的唯一方法。没有一个义人，如不是神的怜悯，没有人可以进如神的话。而耶稣这里要求我们做的也就是放下自己，两手空空的接受救恩，接受自己的失败。</p>
<p>也正是因此，我们的教会里，也不会有高低贵贱之分。我们都一样，都是接受者。都是白白接受救恩得人。穷人、富人、当官的、老百姓等等，在神那里没有任何分别。在神看来，只有接受救恩的人和持续悖逆神的人。</p>
<h1 id="神的国属于两手空空的人"><a href="#神的国属于两手空空的人" class="headerlink" title="神的国属于两手空空的人"></a>神的国属于两手空空的人</h1><blockquote>
<p>18 有一个官长问耶稣:“良善的老师，我当作甚么，才可以承受永生?” 19 耶稣对他说:“你为甚么称我是良善的呢?除了 神一位以外，没有良善的。 20 诫命你是知道的:不可奸淫，不可杀人，不可偷盗，不可作假见证，当孝敬父母。” 21 他说:“这一切我从小都遵守了。” 22 耶稣听了，就告诉他:“你还缺少一件，应当变卖你一切所有的，分给穷人，你就必定有财宝在天上， 而且你还要来跟从我。” 23 他听见这话，非常忧愁，因为他十分富有。24 耶稣见他这样，就说:“富有的人要进 神的国，是多么难哪! 25 骆驼穿过针眼，比有钱的人 进 神的国还容易呢。” 26 听见的人说:“这样，谁可以得救呢?” 27 耶稣说:“人所不能的， 在 神却是可能的。” 28 彼得说:“你看，我们已舍弃自己所有的，跟从你了!” 29 耶稣说: “我实在告诉你们，人为 神的国撇下房屋、妻子、弟兄、父母或儿女， 30 没有不在今世得许多 倍，来世得永生的。”</p>
</blockquote>
<p>耶稣，只列出了10条诫命中的6个，因为耶稣知道富人忽略了第一条诫命：除我以外，你不可以有别的神。富人把财富放在首位，财富已经变成了他的神。</p>
<p>耶稣解释道，进入神的国，必须要两手空空，靠自己是万万不可的！！因为：但人所不能的，在神却是可能 18:27-30。</p>
<h1 id="神的国不仅仅在将来，神的国已经在基督徒中间"><a href="#神的国不仅仅在将来，神的国已经在基督徒中间" class="headerlink" title="神的国不仅仅在将来，神的国已经在基督徒中间"></a>神的国不仅仅在将来，神的国已经在基督徒中间</h1><blockquote>
<p>29 耶稣说: “我实在告诉你们，人为 神的国撇下房屋、妻子、弟兄、父母或儿女， 30 没有不在今世得许多 倍，来世得永生的。”</p>
</blockquote>
<p>认识神，在这个世界已经得到了真正的满足感、安全感。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>路加福音</tag>
      </tags>
  </entry>
  <entry>
    <title>Efficiently Inefficient Market</title>
    <url>/2020/10/03/efficiently_inefficient/</url>
    <content><![CDATA[<h1 id="Efficiently-Inefficient-Market"><a href="#Efficiently-Inefficient-Market" class="headerlink" title="Efficiently Inefficient Market"></a>Efficiently Inefficient Market</h1><p><a href="https://hackmd.io/DEJL1LPVSd6-XRKV85iEeg"><img data-src="https://hackmd.io/DEJL1LPVSd6-XRKV85iEeg/badge" alt="hackmd-github-sync-badge"></a></p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>作者认为，市场足够的有效，但是不是完全有效，也正式基金经理的主动挖掘无效性，才进一步促进了市场的有效。只不过，主动投资是有花销的，比如人力、技能、电脑、场地等等，这些都会为主动管理资金设立门槛，导致超过容量有限。</p>
<p>作者在AQR从事量化投资相关研究，具有很好的学术和工业背景，所以他的见解更加贴合真是市场，但是又包含严谨的说明，没有任何玄学。比如，他就明确的说出：想要盈利就必须要预测，而且要做好的预测。</p>
<p>这一点我很认同，母我看到太多所谓的“交易”达人胡扯：不预测，只是跟随市场。&lt;—- <strong>扯淡</strong>。</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul>
<li>价值</li>
<li>趋势</li>
<li>流动性</li>
<li>Carry</li>
<li>质量</li>
</ul>
<h1 id="1、主动投资活动"><a href="#1、主动投资活动" class="headerlink" title="1、主动投资活动"></a>1、主动投资活动</h1><h2 id="评价策略表现"><a href="#评价策略表现" class="headerlink" title="评价策略表现"></a>评价策略表现</h2><p>Alpha, t-statics, sharpe ratio, information ratio, alpha-to-margin ratio, sortino ratio</p>
<h2 id="寻找、回测策略"><a href="#寻找、回测策略" class="headerlink" title="寻找、回测策略"></a>寻找、回测策略</h2><p>每一个策略背后都应该有合理的盈利逻辑，因为你的每一笔交易都会存在对手方，如果你的策略真的有效，那么对手会亏损，问题在于他有什么理由一直亏损？</p>
<p>所以超额利润，alpha，一般来源有两个：流动性的补偿和信息的补偿。</p>
<p><img data-src="https://i.imgur.com/FRHkc6g.png" alt="Alpha的来源"></p>
<p><strong>信息</strong></p>
<p>市场价格如果可以反映该产品的一切信息，那么这个过程不是自动完成的，也不是瞬间完成的，需要有人去交易这些信息，把这些信息反映到市场价格中去。反过来说，如果市场自动、瞬间反映了所有信息，那么不会有人去收集并交易任何信息，因为没有意义。可以，如果是这样的话，市场优又如何可以反映新出现的信息？所以，对冲基金等主动管理者就通过收集和交易信息成全了市场的有效性。</p>
<p>对冲基金往往也充当了信息的生产者，比如他们会对公司进行深入系统的研究，然后做出对应的交易，从而将这些信息反映到价格中。对冲基金也会高价购买信息，然后通过交易行为，将这些信息反映到价格中，并且从中盈利。同时，对冲基金也会交易一些非理性行为，比如</p>
<blockquote>
<p>there is a general tendency of initial underreaction and delayed overreaction that creates trends and momentum.</p>
</blockquote>
<p>所以，当一个新的策略形成的时候，问问自己受益从何而来？</p>
<ul>
<li>这些信息被大部分人忽略了吗？</li>
<li>通过整个多种不同的信息，得到了新的信息吗？</li>
<li>我比其他人更快的获得了这个信息吗？</li>
<li>这些信息还没有完全反映到市场价格吗？</li>
</ul>
<p><strong>风险</strong></p>
<p>获得超额回报的另一个途径就是承担风险。市场风险不计入。通常对冲基金会通过承担流动性风险获得市场收益意外的超额回报。</p>
<p>流动性风险会直接影响资产的价格。</p>
<p><em>市场流动性风险</em>，是指需要花费巨额的费用才能退出某个资产。最常见的情况就是在崩盘的情况下，bid-ask差价非常大，甚至出现没有bid的情况，无人接盘。因此，流动性差的资产通常具有较高的回报率或者比较便宜，这就是市场流动性风险补偿。</p>
<p><em>资本流动性风险</em>，是指被margin call的风险。换句话说，持有高Margin的资产应该得到相应的回报，因为承担了资本流动性风险。</p>
<p><em>需求压力</em>，Demand pressure，并购套利就是一个典型的需求压力策略。当一些机构进行风险对冲的时候，也会出现需求压力。在比如需要roll future contract的时候，债券降级的时候，都会产生一些需求压力，通常都是卖出压力。</p>
<p><strong>回测</strong></p>
<p>回测的基本组成部分：</p>
<ul>
<li>交易池，定义可以交易的资产</li>
<li>信号，信息输入</li>
<li>交易规则，包括调仓规则，交易规则等等</li>
<li>时间延迟，Point-in-time 信息</li>
<li>交易费用</li>
</ul>
<h2 id="回归分析的等效性"><a href="#回归分析的等效性" class="headerlink" title="回归分析的等效性"></a>回归分析的等效性</h2><p>投资组合资产的选择和比较几乎等效于线性回归系数的分析：</p>
<blockquote>
<p>任何预测性质的回归分析都可以等效成资产组合选择，任何资产组合选择都可以等效成为预测回归分析。</p>
</blockquote>
<ul>
<li>时间序列回归分析，与择时策略相关</li>
<li>Corss-sectional回归分析与则产选择策略相关</li>
<li>单因子回归分析与根据一个信号排序资产相关；而多因子回归则与多因子排序相关</li>
</ul>
<h3 id="时间序列回归"><a href="#时间序列回归" class="headerlink" title="时间序列回归"></a>时间序列回归</h3><p>$$R_{t+1}^e = a + bF_t + e_{t+1}$$</p>
<p><strong>而 $b$ 的最小二乘估计值就可以被看成一个long-short择时策略的累计回报率</strong>：</p>
<p>$$\hat{b}=\frac{\sum_t(F_t - \bar{F})R_{t+1}}{\sum_t(F_t-\bar{F})^2} = \sum_{t=1}^{T}x_tR_{t+1}$$</p>
<p>其中，$x_t = k(F_t - \bar{F})$，而$k = 1/\sum(F_t-\bar{F})^2$ 不影响策略的夏普值。</p>
<p>$x_t$就是实际的交易仓位，当信号$F_t$超过其均值时，x为正，即买入。反之，则卖出。</p>
<h3 id="Corss-sectional回归与选股"><a href="#Corss-sectional回归与选股" class="headerlink" title="Corss-sectional回归与选股"></a><em>Corss-sectional回归与选股</em></h3><p>$$R_{t+1}^i= a + bF_t^i + e_{t+1}^i$$</p>
<p>其中，i代表一个资产，F同样代表信号。针对投资组合中的所有资产进行上述回归分析，得到回归系数矩阵：</p>
<p>$$\hat{b}<em>t=\frac{\sum_i(F_t^i - \bar{F_t})R^i</em>{t+1}}{\sum_i(F_t^i - \bar{F_t})^2} = \sum_{i}x_t^iR_{t+1}^i$$</p>
<p><strong>这个回归系数 $\hat{b}$ 就代表了一个long-short策略在t和t-1获得的收益</strong>。而资产的权重就是：</p>
<p>$$x_t^i=k_t(F_t^i-\bar{F_t})$$</p>
<p>这个回归系数$\hat{b_t}$的平均值，其实就是Fama–MacBeth模型中的系数$\hat{b}$。</p>
<p>$$\hat{b} = 1/T\sum_{t=1}^T\hat{b}_t$$</p>
<p>进而，我们可以求出策略的波动率：</p>
<p>$$\hat{\sigma} = \sqrt{\frac{1}{T-1}\sum_{t=1}^T(\hat{b_t}-\hat{b})^2}$$</p>
<p>这里如果看一下t-static会发现，其实t-statistics就是高夏普比例的表现。</p>
<p>$$tstatistics = \sqrt{T}\frac{\hat{b}}{\hat{\sigma}}$$</p>
<h3 id="多因子回归"><a href="#多因子回归" class="headerlink" title="多因子回归"></a>多因子回归</h3><p>$$R_{t+1}^i= a + b^FF_t^i + b^GG_t^i + e_{t+1}^i$$</p>
<p>在这种情况下，$b^F$ 代表了同时交易信号F和信号G的时候，信号F的收益。</p>
<blockquote>
<p>值得注意的是，时间序列线性回归更加可以，因为用到了信号均值进行计算。而信号均值从回测的角度，属于未来信息。</p>
</blockquote>
<h2 id="构建投资组合以及风险管理"><a href="#构建投资组合以及风险管理" class="headerlink" title="构建投资组合以及风险管理"></a>构建投资组合以及风险管理</h2><p>当我们识别出若干可用的信号以后，就需要组合这些信号形成投资组合进行交易。具体方法多种多样，但是总体原则是：</p>
<ul>
<li>多样性</li>
<li>头寸限制</li>
<li>对信心更强的信号，下注更多</li>
<li>根据风险指标调整投资组合</li>
<li>关注相关性</li>
</ul>
<h2 id="交易的花费"><a href="#交易的花费" class="headerlink" title="交易的花费"></a>交易的花费</h2><ul>
<li>交易花费</li>
<li>funding cost<ul>
<li>总杠杆</li>
<li>净杠杆</li>
</ul>
</li>
<li>Margin</li>
</ul>
<h1 id="2-股票类策略"><a href="#2-股票类策略" class="headerlink" title="2. 股票类策略"></a>2. 股票类策略</h1><p>主要分为三类：discretionary equity, dedicated short bias, and quantitative equities.</p>
<blockquote>
<p>Intrinsic value: It is the discounted value of the cash that can be taken out of a business during its remaining life.</p>
</blockquote>
<p>交易股票的基础在于股票估值，即固有价值。估值的核心在于未来现金流的现今折扣价值：</p>
<p>$$V_t = E_t(\frac{D_{t+1}+V_{t+1}}{1+k_t})$$</p>
<p>其中，k 即使股票的回报率，D 是股票的分红。</p>
<p>不过，分红并不容易预测，特别对于有些成长型的公司，股票并没有分红，所以需要Earning和Book value进行替代计算。</p>
<p>当然，除了上述绝对估值，也可以对股票进行相对估值。</p>
<h2 id="Discretionary-equity"><a href="#Discretionary-equity" class="headerlink" title="Discretionary equity"></a>Discretionary equity</h2><ul>
<li>Value</li>
<li>Growth</li>
<li>Quality</li>
</ul>
<h2 id="Dedicated-short-bias"><a href="#Dedicated-short-bias" class="headerlink" title="Dedicated short bias"></a>Dedicated short bias</h2><h2 id="Quant-equity"><a href="#Quant-equity" class="headerlink" title="Quant equity"></a>Quant equity</h2><ul>
<li>Fundamental quant<ul>
<li>value</li>
<li>quality</li>
<li>bet against beta</li>
</ul>
</li>
<li>Statistic Arb</li>
<li>HFT</li>
</ul>
<h1 id="3、资产配置和宏观策略"><a href="#3、资产配置和宏观策略" class="headerlink" title="3、资产配置和宏观策略"></a>3、资产配置和宏观策略</h1><p>宏观策略的逻辑是自顶向下的，而股票策略则通常是自底向上的。宏观策略的主要受益来源是各种Risk Premiums，比如股票风险回报、时间结构回报（国债）、信誉风险回报（公司债）、流动性风险回报（房地产等）、其他（比如价值引子、趋势、carry等等）。</p>
<p><strong>市场择时</strong></p>
<p>市场择时策略可以通过回归和回测进行分析。</p>
<p><strong>回报率的来源</strong></p>
<h2 id="全球资产配置"><a href="#全球资产配置" class="headerlink" title="全球资产配置"></a>全球资产配置</h2><blockquote>
<p>The whole world is simply nothing more than a flow chart for capital.</p>
</blockquote>
<ul>
<li>Carry</li>
<li>Central banks</li>
</ul>
<h2 id="CTA"><a href="#CTA" class="headerlink" title="CTA"></a>CTA</h2><p>趋势策略，不同时间周期、不同产品的多样性效应。</p>
<h1 id="4、套利策略"><a href="#4、套利策略" class="headerlink" title="4、套利策略"></a>4、套利策略</h1>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>Hedge Fund</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer System</title>
    <url>/2020/09/20/cs_app/</url>
    <content><![CDATA[<h1 id="Computer-System-A-Programmer’s-Perspectives"><a href="#Computer-System-A-Programmer’s-Perspectives" class="headerlink" title="Computer System: A Programmer’s Perspectives"></a>Computer System: A Programmer’s Perspectives</h1><p><a href="https://hackmd.io/fzzDuqP9TO2f8MOsqmOxUQ"><img data-src="https://hackmd.io/fzzDuqP9TO2f8MOsqmOxUQ/badge" alt="hackmd-github-sync-badge"></a></p>
<p>一个读书笔记。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书首先自底向上介绍现代计算机的基本工作原理，论述了计算软件和硬件如何协调工作。在此基础上，介绍了一个程序是如何从源代码，被编译，然后被执行的。然后，详细展开说明一个应用程序在硬件和操作系统层面是如何被执行的。 最后，介绍了多个程序之间是如何互动，比如IO、网络、以及并发。</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>这本书的角度很独特，作者从一个开发应用程序的程序员角度切入，而不是从操作系统开发人员的角度切入。刚开始读这本书的时候，原本的目的是学习操作系统，但是却意外发现这本书的角度其实非常适合非操作系统开发程序员阅读。因为他深入浅出的解释了很多幕后的事情，读后感觉对整个计算机工作原理有了更加深入的理解，同时也有助于写出更加高效的程序。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>Information is Bits + Context</p>
</blockquote>
<p>源代码的编译过程：</p>
<p><img data-src="https://i.imgur.com/RBffpof.png" alt="源代码编译"></p>
<p>编译过程主要包含：预处理，编译，汇编，连接等四个过程。预处理主要是扩充源代码的语法糖，比如宏，导入等等；编译器输出汇编版本的程序；汇编器会形成二进制的目标文件；最终，连接器会把各个目标文件组合在一起形成最终的可执行二进制文件。整个过程就是一个把高级语言翻译成二进制指令的过程。</p>
<p>计算机只能执行二进制指令，这些指令通常涉及：读入、存储、计算和跳转。当我们执行一个程序的时候，就是执行编译产生的二进制文件的时候，所有指令和数据会被读入内存，然后CPU通过读取指令和数据完成计算。</p>
<p><img data-src="https://i.imgur.com/ggjMHJJ.png" alt=""></p>
<p>操作系统的主要功能就是提供一个硬件和一般引用程序之间的抽象，为每一个应用程序提供一个进程，也就是一个相对独立的CPU和内存环境。</p>
<p><img data-src="https://i.imgur.com/79exfiM.png" alt=""></p>
<p>计算机的各个部分通过总线连接：</p>
<p><img data-src="https://i.imgur.com/b9gUgiO.png" alt=""></p>
<h2 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h2><h3 id="信息的表达与操作"><a href="#信息的表达与操作" class="headerlink" title="信息的表达与操作"></a>信息的表达与操作</h3><p>word size: 寻址极限，指针的范围。因为1 byte = 8 bit. 所以在64位寻址系统中，一个指针类型由8 byte表达，即64bits。</p>
<p>fix point fraction and floating point fraction。 这里有个不错的参考：<br><a href="https://ryanstutorials.net/binary-tutorial/binary-floating-point.php">https://ryanstutorials.net/binary-tutorial/binary-floating-point.php</a></p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>bit wise 运算。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>转化小数到二进制的小数的一种方法：不断给小数部分乘2，取结果整数部分（1或者0）作为该位置的bit，持续进行。</p>
<p>一些“奇怪”的问题，浮点数的代数性质并不能跟真正的小数一致，比如</p>
<ul>
<li>(3.14+1e10) - 1e10 = 0</li>
<li>(1e20<em>1e10)*1e-20 = 无穷，1e20</em>(1e20*1e-20) = 1e20</li>
</ul>
<p>为了避免这些，尽量考虑计算过程中的数值的极值范围，合理处理上面的极端情况。减少两个数量级相差很多的量进行计算， 通常先进行规范化处理后进行计算。</p>
<h3 id="代码的机器层面表达"><a href="#代码的机器层面表达" class="headerlink" title="代码的机器层面表达"></a>代码的机器层面表达</h3><p>源代码经过编译，会形成汇编文件，这个文件其实就是通过简单的指令按顺序排列。只不过在这个阶段，指令使用人类可以理解的单词表达，比如<code>pushl</code>等等。汇编文件经过汇编，就形成了二进制文件，也就是把汇编指令一一对应的翻译成二进制（一般采用16进制表达），如下图所示：</p>
<p><img data-src="https://i.imgur.com/LkwkUrY.png" alt=""></p>
<h3 id="提高速度的一些小技巧"><a href="#提高速度的一些小技巧" class="headerlink" title="提高速度的一些小技巧"></a>提高速度的一些小技巧</h3><ol>
<li>减少循环</li>
<li>循环中减少函数调用</li>
<li>使用局部变量</li>
</ol>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>这里的异常处理指的是硬件或者操作系统层面的异常，不是高级语言中的异常处理。</p>
<p>在硬件层面，异常主要分成四种：</p>
<ul>
<li>Interrupt，异步，通常由IO造成</li>
<li>Trap,同步，一般是操作系统内核制造</li>
<li>Fault，同步，可恢复的错误产生</li>
<li>Abort，同步，不可恢复的错误产生</li>
</ul>
<p>其中，只有Interrupt是异步的，因为它是由CPU外部的设备产生的，而其他异常都是CPU执行指令的结果。</p>
<h3 id="进程，Processes"><a href="#进程，Processes" class="headerlink" title="进程，Processes"></a>进程，Processes</h3><p>异常处理是系统实现进程抽象的基本方法，每一个运行在操作系统上的程序都有自己的进程，进程中包含了程序的代码、数据、盏、寄存器状态等等。进程提供了两个基本的抽象：</p>
<ul>
<li>独立的逻辑控制流程</li>
<li>独立的私有内存空间</li>
</ul>
<p>有了这个两个抽象，每一个程序就好像独占整个电脑一样。每一个进程都至少有一个进程ID，PID，如果是子进程，还会有对应的子进程pid。从程序员的角度看，一个进程有三种状态：running, stopped, terminated。</p>
<p><code>fork</code>可以用来创建进程或者子进程。<code>execve</code> 可以用来执行一段程序。程序与进程是不同的，程序通常只是一段代码加数据，而进程则是一系列的计算资源、内存、IO等等。通常一个程序需要在进程中运行。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存，Virtual Memory，是另一个非常重要的抽象。VM主要有三个功能：</p>
<ul>
<li>物理内存成为虚拟内存地址的高速缓存</li>
<li>实现了每一个进程独立的虚拟内存空间</li>
<li>确保不同进程的内存空间不发生冲突</li>
</ul>
<p>Memory management unit, MMU, is the hardware that translate virtual addresses to physical addresses. </p>
<p>虚拟内存的基本思想就是区分数据本身和数据属性，比如地址并不是数据本身，而是数据的一个属性，因此，同一个数据可以具有不同的地址属性。因此，每一个字节（Byte）的内存空间都有一个物理地址和一个虚拟地址。</p>
<blockquote>
<p>任何计算机问题都可以通过增加重新定向解决，Mapping。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><img data-src="https://i.imgur.com/PPKEmBj.png" alt=""></p>
<h2 id="程序的互动"><a href="#程序的互动" class="headerlink" title="程序的互动"></a>程序的互动</h2><h3 id="系统IO"><a href="#系统IO" class="headerlink" title="系统IO"></a>系统IO</h3><p>Input/Output，IO，指的是内存和其他外设之间的数据传输过程。Input，从外部设备拷贝数据进入内存；Output，从内存传输数据进入外部设备。外部设备可以是硬盘、终端、网络等等。</p>
<p>系统内核，Kernel，提供了基本的IO操作。在Unix类系统中，所有的I/O设备，例如网络、硬盘、终端等，都用文件表达，所有的输入、输出都已读写对应的文件完成。文件，就是一些列的字节。</p>
<p>注意到，这里出现了另一个重新定向，Mapping：I/O设备到文件。通过文件映射，统一了各类外设的操作方法。跟虚拟内存异曲同工。</p>
<p><img data-src="https://i.imgur.com/vPBnwkw.png" alt=""></p>
<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>Socket Interface.</p>
<p><img data-src="https://i.imgur.com/QcA0tVp.png" alt=""></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>这里是应用层面的并发。操作系统提供了三种并发方法：</p>
<ul>
<li>Process,进程</li>
<li>I/O multiplexing</li>
<li>Thread，线程</li>
</ul>
<p>线程实现可以看成是Process和Multiplexing的结合，多个线程在同一个进程中，因此共享内存，但是程序执行的schedule是由系统内核完成的。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning 4 Dynamic Programming</title>
    <url>/2020/08/01/rl4/</url>
    <content><![CDATA[<p>In previous chapter, value functions are defined. Dynamic Programming method is used here to use value functions to organize and structure the search for agent best policy.</p>
<p><img data-src="https://i.imgur.com/26qVDFu.png" alt=""></p>
<p><img data-src="https://i.imgur.com/YFH5OcT.png" alt=""></p>
<p>In other words, DP algorithms are obtained by turning Bellman equations such as these into assignments, that is, into update rules for improving approximations of the desired value functions.</p>
<h2 id="Policy-Evaluation"><a href="#Policy-Evaluation" class="headerlink" title="Policy Evaluation"></a>Policy Evaluation</h2><p>First thing, how can we compute value function $v_{\pi}$ given a policy? This is also known as <em>prediction problem</em> or <em>policy evaluation</em>. </p>
<p><img data-src="https://i.imgur.com/GBtvnIv.png" alt=""></p>
<p>As above, there is a iterative method that we can solve this recursive problem.</p>
<p><img data-src="https://i.imgur.com/qwEAxdf.png" alt=""></p>
<p>TODO: code to simulate Grid world value functions</p>
<h2 id="Policy-Improvement"><a href="#Policy-Improvement" class="headerlink" title="Policy Improvement"></a>Policy Improvement</h2><p>The theory is simple. If $q_{\pi}(s,\pi’(s)) \gt v_{\pi}(s)$, then $\pi’$ must be as good as, or better than, $\pi$ . Hence $v_{\pi’}(s) \gt v_{\pi}(s)$</p>
<p><img data-src="https://i.imgur.com/Yrw6w2t.png" alt=""></p>
<p>Or in another equation:</p>
<p><img data-src="https://i.imgur.com/NMnxuE7.png" alt=""></p>
<p>TODO：code</p>
<h2 id="Policy-Iteration"><a href="#Policy-Iteration" class="headerlink" title="Policy Iteration"></a>Policy Iteration</h2><p>Once we know how to compute value function and how to improve a policy using value function, we can iterate the process to get a optimal policy.</p>
<p><img data-src="https://i.imgur.com/39yUEIw.png" alt=""></p>
<h2 id="Value-Iteration"><a href="#Value-Iteration" class="headerlink" title="Value Iteration"></a>Value Iteration</h2><p><img data-src="https://i.imgur.com/kfwyLJf.png" alt=""></p>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning 3 Markov Decision Process</title>
    <url>/2020/07/31/rl2/</url>
    <content><![CDATA[<h1 id="Markov-Decision-Process-MDP"><a href="#Markov-Decision-Process-MDP" class="headerlink" title="Markov Decision Process, MDP"></a>Markov Decision Process, MDP</h1><p><a href="https://hackmd.io/BGkR2gTjTLy6oHBfkQ2EAQ"><img data-src="https://hackmd.io/BGkR2gTjTLy6oHBfkQ2EAQ/badge" alt="hackmd-github-sync-badge"></a></p>
<h2 id="High-level-overview-of-RL"><a href="#High-level-overview-of-RL" class="headerlink" title="High level overview of RL"></a>High level overview of RL</h2><p>At the heart of RL theory, it is Markov Decision Process.</p>
<p>The general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment.</p>
<p>High level description of RL problem: three signals.</p>
<p>The <strong>representation</strong> of the signals (actions and states) is art! Reword, on the other hand, is always real numbers. (why?? this does not sound good!!! Not consistent with actions and states which have complex representation!!)</p>
<p>Two types of RL tasks: episodic task and continuing task.</p>
<p>The reward for both cases: </p>
<p>$$G_t = \sum_{k=0}^{T-t-1}\gamma^k R_{t+k+1}$$</p>
<p>where, $T$ can be infinite and $\gamma$ can be 1.</p>
<h2 id="The-Markov-Property"><a href="#The-Markov-Property" class="headerlink" title="The Markov Property"></a>The Markov Property</h2><p>Here we don’t discuss the design of state signal, because I focus on form the RL problem framework. However, the design of the states representation is very important in terms of make a good RL model.</p>
<p>State representation can be very complicated and not expected to inform the agent everything about the environment. </p>
<p>A state signal that succeeds in retaining all relevant information is said to be Markov, or to have the <strong>Markov property</strong>.</p>
<p>The dynamic of environment is a joint distribution of states and rewards:</p>
<p>$$Pr{R_{t+1}=r, S_{t+1}=s’|S_0,A_0,R_1,…,S_t, A_t}$$</p>
<p>If state signal has the Markov property, we have</p>
<p>$$p(s’,r|s,a) = Pr{R_{t+1}=r, S_{t+1}=s’|S_t, A_t}$$</p>
<p>In order for these to be effective and informative, the state representation must be informative.</p>
<h2 id="Markov-Decision-Process"><a href="#Markov-Decision-Process" class="headerlink" title="Markov Decision Process"></a>Markov Decision Process</h2><p>Expected rewords for state-action pairs:</p>
<p><img data-src="https://i.imgur.com/64vtOf2.png" alt=""></p>
<p>The state-transition probability:</p>
<p><img data-src="https://i.imgur.com/eqZhGEy.png" alt=""></p>
<p>The expected rewards for state-action-next-state triples:</p>
<p><img data-src="https://i.imgur.com/7xgrcZX.png" alt=""></p>
<h2 id="Value-functions"><a href="#Value-functions" class="headerlink" title="Value functions"></a>Value functions</h2><p>Value functions estimation how good is a state in terms of the goal. Accordingly, value functions are defined with respect to particular policies.</p>
<p>For MDPs, we can define $v_{\pi}(s)$ formally as</p>
<p>$$v_{\pi}(s)=\mathbb{E}_{\pi}[G_t|S_t=s]$$</p>
<p>where, $G_t = \sum_{k=0}^{\infty}\gamma^kR_{t+k+1}$.</p>
<p>Similarly, we can define the value of taking action a in state s under a policy:</p>
<p>$$q_{\pi}(s, a) = \mathbb{E}_{\pi}[G_t | S_t=s, A_t=a]$$</p>
<p>A fundamental property of value function is that they satisfy particular recursive relationships.</p>
<p>$$v_{\pi} = \sum_{a}\pi(a|s)\sum_{s’,r}p(s’,r|s,a)[r+\gamma v_{\pi}(s’)]$$</p>
<p>This is <strong>Bellman equation</strong>.</p>
<h2 id="Optimal-Value-Functions"><a href="#Optimal-Value-Functions" class="headerlink" title="Optimal Value Functions"></a>Optimal Value Functions</h2><p>Solving a reinforcement learning task means, roughly, finding a policy that achieves a lot of reward over the long run. </p>
<p>$$q_{<em>}=\mathbb{E}[R_{t+1}+\gamma v_{</em>}(S_{t+1})|S_t=s,A_t=a]$$</p>
<p>We have</p>
<p>$$v_{<em>}=max\sum_{s’,r}p(s’,r|s,a)[r+\gamma v_{</em>}(s’)], for all A(s)$$</p>
<p>$$q_{<em>}(s,a) = \sum_{s’,r}p(s’,r|s,a)[r + \gamma max q_{</em>}(s’,a’)]$$</p>
<p>These are Bellman optimality equation.</p>
<h2 id="Bellman-Equations"><a href="#Bellman-Equations" class="headerlink" title="Bellman Equations"></a>Bellman Equations</h2><p><img data-src="https://i.imgur.com/Ln7PnVy.png" alt=""></p>
<p>The are relationships between value function and q-function:</p>
<p><img data-src="https://i.imgur.com/YEGGt2x.png" alt=""></p>
<p>Our goal in RL is to solve Bellman Optimality Equation. There are two ways of solving this non-linear problem:</p>
<ul>
<li>Dynamic Programming, this when you have a model of the MDP.<ul>
<li>Value iteration</li>
<li>Policy iteration</li>
</ul>
</li>
<li>Sampling <ul>
<li>Monte Carlo</li>
<li>Q-learning</li>
<li>Sarsa</li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Reinforcement learning is about learning from interaction how to behave in order to achieve a goal.</li>
<li>the actions are the choices made by the agent; the states are the basis for making the choices; and the rewards are the basis for evaluating the choices.</li>
<li>A policy is a stochastic rule by which the agent selects actions as a function of states. The agent’s objective is to maximize the amount of reward it receives over time.</li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>MDP</tag>
      </tags>
  </entry>
  <entry>
    <title>接受来自造物主的邀请 - 以赛亚书 55</title>
    <url>/2020/07/26/yisaiya55/</url>
    <content><![CDATA[<h1 id="接受来自造物主的邀请-以赛亚书-55"><a href="#接受来自造物主的邀请-以赛亚书-55" class="headerlink" title="接受来自造物主的邀请 - 以赛亚书 55"></a>接受来自造物主的邀请 - 以赛亚书 55</h1><h2 id="难以拒绝的邀请-1-5-incoming-envelope"><a href="#难以拒绝的邀请-1-5-incoming-envelope" class="headerlink" title="难以拒绝的邀请 1-5 :incoming_envelope:"></a>难以拒绝的邀请 1-5 :incoming_envelope:</h2><blockquote>
<p>看哪!你要召聚你不认识的国; 那些素来不认识你的国也必奔向你， 都因耶和华你的 神、以色列的圣者的缘故， 因为他已经荣耀了你。</p>
</blockquote>
<p>神通过自己的仆人，耶稣基督，承受罪的后果，已经把救赎带给了全世界。值得注意的是，先知以赛亚的世代，耶稣基督来没有降临，以色列作为神当时的仆人，并没有看到基督的降临。但是，先知在这里把时间推移到了未来，真正的仆人已经到来，救赎已经到来。(￣▽￣)</p>
<blockquote>
<p>你们为甚么用银子去买那不是食物的呢? 为甚么用你们劳碌得来的去买那不能使人饱足的呢? 你们要留心听我的话，就可以吃美物， 使你们的心灵享受肥甘。</p>
</blockquote>
<p>先知用免费的宴会的比喻，来说明神救赎的邀请。但是他说道，被邀请的人都是“穷人”，因为神的救赎只能来自神的怜悯，并不是我们可以用自己的努力换取的。这个救赎的邀请，是给所有谦卑的人的，所有愿意承认自己无能为力得到救赎的人的。</p>
<h2 id="尽快的回应-6-7-information-source"><a href="#尽快的回应-6-7-information-source" class="headerlink" title="尽快的回应 6-7 :information_source:"></a>尽快的回应 6-7 :information_source:</h2><blockquote>
<p>6 你们要趁着耶和华可以寻找的时候，寻找他，趁着他靠近的时候，呼求他。7 恶人要离弃自己的道路， 不义的人当除去自己的意念， 回转过来归向耶和华， 耶和华就必怜悯他。你们当回转过来归向我们的 神， 因为他大大赦免人的罪。</p>
</blockquote>
<p>当然，这个邀请不是无限期的，先知这里强调，你们要寻找他、靠近他、呼求他。就好像迷路的人，应该大声呼救。而且，他也提醒人们，快速的离开错误的道路，认罪，回到神的道路上。</p>
<p>先知提到，你要趁着耶和华还在寻找的时候，归向他。因为救赎的大门不会永远开放，要在大门关闭前会转相信。</p>
<h2 id="万无一失的救赎-8-13-information-source"><a href="#万无一失的救赎-8-13-information-source" class="headerlink" title="万无一失的救赎 8-13 :information_source:"></a>万无一失的救赎 8-13 :information_source:</h2><p>这救赎是来自造物主的，这救赎的完美超过我们的理智所能推测的，我们必须紧紧依靠神的话语，依靠着完备的救赎。</p>
<blockquote>
<p>8 耶和华说:“我的意念不是你们的意念， 你们的道路也不是我的道路。<br>9 天怎样高过地， 我的道路也怎样高过你们的道路， 我的意念也怎样高过你们的意念。<br>11 从我的口所出的话也必这样， 必不徒然返回我这里， 却要作成我所喜悦的， 使它在我差遣它去作的事上必然亨通。</p>
</blockquote>
<p>我们有理由信靠这个邀请，因为这个邀请来自宇宙的造物主 神。当然，这意味着，我们只能通过相信来接受救赎，而不是完全依靠理智，因为我们没有能力完全理解神的心思意念。</p>
<p>造物主 神，也保证：“从我的口所出的话也必这样， 必不徒然返回我这里”。神，从不食言。神，通过话语实现创造，也通过话语实现救赎。</p>
<h2 id="基督徒-latin-cross"><a href="#基督徒-latin-cross" class="headerlink" title="基督徒 :latin_cross:"></a>基督徒 :latin_cross:</h2><p>当我们困倦的时候，应该时常思考神的话语，因为他的话语绝不落空。虽然，可能我们可能不理解为什么许多坏事情发生在自己身上、发生在世界上，但是我们应该记得，神的话语、心思都高于人的理解。</p>
<p>新天地降临后，你绝对不会后悔经历的一切忍耐。救恩，已经成就了。</p>
<p>:latin_cross: </p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning Introduction 1 - 2</title>
    <url>/2020/07/25/rl1/</url>
    <content><![CDATA[<p><a href="https://hackmd.io/EF3LjEjfQtCa-yEZlFNCmQ"><img data-src="https://hackmd.io/EF3LjEjfQtCa-yEZlFNCmQ/badge" alt="hackmd-github-sync-badge"></a></p>
<p>Reinforcement learning, RL is a framework that let an agent to make suitable  decisions to achieve best goal. Underneath math problem to solve is a  Markov Decision Process, MDP.  RL is different from both supervised and unsupervised learning. </p>
<h1 id="Elements-of-RL"><a href="#Elements-of-RL" class="headerlink" title="Elements of RL"></a>Elements of RL</h1><p>Apart from Agent and Environment, following elements also play central<br>roles: Policy, Reward Signal, Value Function, and Model of environment. </p>
<p>Policy, is a map from current states to actions to take. It might be<br>deterministic or stochastic.</p>
<p>Reword signal, defines the goal of RL. At each step, environment will<br>give agent a single number, a reward.</p>
<p>Value function, specifies what is good in the long run. The estimation<br>of value is in the central part of RL.</p>
<p>Model, is what the agent think the environment will behave. Basically by<br>building a model of env, the agent can do planning better. But model env<br>sometime is very hard.</p>
<p>Not all RL model need full set of above. But a good value function does<br>help to make a better decision.In the end, evolutionary and value function methods both search the space of policies, but learning a value function takes advantage of information available during the course of play.</p>
<h1 id="A-bit-history"><a href="#A-bit-history" class="headerlink" title="A bit history"></a>A bit history</h1><p>There are two threads of RL histories. One thread concerns learning by trial and error that started in the psychology of animal learning. The other thread concerns the problem of optimal control and its solution using value functions and dynamic programming. </p>
<p>Although the two threads have been largely independent, the exceptions revolve around a third, less distinct thread concerning temporal-difference methods</p>
<h1 id="Simplest-problem-Multi-arm-Bandits"><a href="#Simplest-problem-Multi-arm-Bandits" class="headerlink" title="Simplest problem: Multi-arm Bandits"></a>Simplest problem: Multi-arm Bandits</h1><p>The most important feature distinguishing reinforcement learning from other types of learning is that it uses training information that evaluates the actions taken rather than instructs by giving correct actions.</p>
<p>Consider the following learning problem. You are faced repeatedly with a choice among n different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period, for example, over 1000 action selections, or time steps.</p>
<h2 id="Action-Value-method"><a href="#Action-Value-method" class="headerlink" title="Action Value method"></a>Action Value method</h2><p>Assume $q(a)$ is the true value of action a, and the estimation on t step is $Q_t(a)$. Then the simplest idea is average: </p>
<p>$$Q_t(a) = \frac {R_1+ R_2 + … + R_{N_t(a)}}{N_t(a)}$$</p>
<p>Once we have $Q_t(a)$, we can then select the action with highest estimated action value. The <em>greedy</em> action selection method can be written as</p>
<p>$$A_t = argmax Q_t(a)$$</p>
<p>Greedy means that action selection always <strong>exploits</strong> currently knowledge to max immediate reward. A simple alternative is to behave greedily most of the time, but, <strong>explore</strong> new actions sometimes.</p>
<h2 id="Incremental-Implementation"><a href="#Incremental-Implementation" class="headerlink" title="Incremental Implementation"></a>Incremental Implementation</h2><p>$$Q_{k+1} = Q_k + \frac {1}{k}[R_k - Q_k]$$</p>
<p>So esentially, update previous estimation with adjustment of new update.</p>
<p>$$NewEstimate \leftarrow OldEstimate + StepSize * [Target - OldEstimate]$$</p>
<h2 id="Nonstationary-Problem"><a href="#Nonstationary-Problem" class="headerlink" title="Nonstationary Problem"></a>Nonstationary Problem</h2><p>For non-stationary problem, it makes more sense to has more weights on recent result.</p>
<p>$$Q_{k+1} = Q_k + \alpha [R_k - Q_k]$$</p>
<p>$$Q_{k+1} = (1-\alpha)^kQ_1 + \sum_{i=1}^k\alpha(1-\alpha)^{k-i}R_i$$</p>
<h2 id="Upper-Confidence-Bound-Action-Selection"><a href="#Upper-Confidence-Bound-Action-Selection" class="headerlink" title="Upper-Confidence-Bound Action Selection"></a>Upper-Confidence-Bound Action Selection</h2><p>$$A_t = argmax_a\Big[Q_t(a) + c\sqrt{\frac{ln t}{N_t(a)}}\Big]$$</p>
<p>The idea here is to add exploration more wisely. So if an action is not selected for a long time, it is more likely to be selected, and if an action has been selected a lot of time, it is more likely to be selected (stick with optimal action, i.e. exploiate. )</p>
<h2 id="Gradient-Bandits"><a href="#Gradient-Bandits" class="headerlink" title="Gradient Bandits"></a>Gradient Bandits</h2><p>we can also learn a preference of each action, $H_t(a)$. The more preference, the more change to take that action. But preference is a relative value.</p>
<p>$$\pi_{t}(a) = P{A_t=a} = \frac {e^{H_t(a)}}{\sum_{b=1}^{n}e^{H_t(b)}}$$</p>
<p>So action is a softmax of preferences. We want to learn the preference of each actions.</p>
<p>Initially, all preference is 0.</p>
<p>So the learning/updating process is:</p>
<p>$$H_{t+1}(A_t) = H_t(A_t) + \alpha(R_t - \bar{R_t})(1 - \pi_{t}(A_t))$$</p>
<p>$$H_{t+1}(a) = H_t(a) - \alpha(R_t - \bar{R_t}\pi_t(a), \forall{a} \ne A_t$$</p>
<p>Above is a stochastic approximation to gradient ascent:</p>
<p>$$H_{t+1}(a) = H_t(a) + \alpha \frac {\partial {E[R_t]}} {\partial {H_t(a)}}$$</p>
<p>where, $E[R_t] = \sum_{b}\pi_t(b)q(b)$</p>
<h1 id="Different-Agents-of-Mult-arm-Bandits"><a href="#Different-Agents-of-Mult-arm-Bandits" class="headerlink" title="Different Agents of Mult-arm Bandits"></a>Different Agents of Mult-arm Bandits</h1><h2 id="Random-Agent"><a href="#Random-Agent" class="headerlink" title="Random Agent"></a>Random Agent</h2><p>The agent pick action randomly from action space, <code>number_of_arms</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Random</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;A random agent.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  This agent returns an action between 0 and &#x27;number_of_arms&#x27;, </span></span><br><span class="line"><span class="string">  uniformly at random. The &#x27;previous_action&#x27; argument of &#x27;step&#x27;</span></span><br><span class="line"><span class="string">  is ignored.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;random&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="Greedy-Agent"><a href="#Greedy-Agent" class="headerlink" title="Greedy Agent"></a>Greedy Agent</h2><p>The agent pick action that has most big expected value.</p>
<p>So pick action as following:</p>
<p>$$A_t = argmax Q_t(a)$$</p>
<p>Every step, update Q value of previous actions and counter of actions:</p>
<p>$$N(A_{t-1}) = N(A_{t-1}) + 1$$<br>$$Q(A_{t-1}) = Q(A_{t-1}) + \alpha(R_t - Q(A_{t-1}))$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greedy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;greedy&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="keyword">return</span> np.argmax(self.Q)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="epsilon-Greedy-Agent"><a href="#epsilon-Greedy-Agent" class="headerlink" title="$\epsilon$-Greedy Agent"></a>$\epsilon$-Greedy Agent</h2><p>The issue of pure greedy agent is that it may stuck in some false action and never explore. So we add a small change to select action which does not have best q value, but just to explore to gather more information.</p>
<p>The update process is as same as Greedy agent. But the way we choose actions changed:</p>
<p>$$A_t = argmax Q, rand &gt; \epsilon$$<br>$$A_t = random action, rand &lt;= \epsilon$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EpsilonGreedy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms, epsilon=<span class="number">0.1</span></span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self._epsilon = epsilon</span><br><span class="line">    self.name = <span class="string">&#x27;epsilon-greedy epsilon:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epsilon)</span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line"></span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      ra = <span class="built_in">bool</span>( np.random.random() &lt; self._epsilon )</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">not</span> ra) * np.argmax(self.Q) + (ra) * np.random.randint(self._number_of_arms)</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">## UCB Agent</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCB</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;ucb&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.t += <span class="number">1</span></span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># here is the extra bit</span></span><br><span class="line">      U = np.sqrt(np.log(self.t)/<span class="number">1.</span>/(self.N+<span class="number">1.</span>))</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="keyword">return</span> np.argmax(self.Q+U)</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.t = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Reinforce-Agent"><a href="#Reinforce-Agent" class="headerlink" title="Reinforce Agent"></a>Reinforce Agent</h2><p>Base line will not affect mean, but will change the variance of the estimation. </p>
<p>After we have the policy, we can sample an action from the policy.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reinforce</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms, step_size=<span class="number">0.1</span>, baseline=<span class="literal">False</span></span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self._lr = step_size</span><br><span class="line">    self.name = <span class="string">&#x27;reinforce, baseline: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(baseline)</span><br><span class="line">    self._baseline = baseline</span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.t += <span class="number">1</span></span><br><span class="line">      self.all_reward += reward</span><br><span class="line">      <span class="keyword">if</span> self._baseline:</span><br><span class="line">        base = self.all_reward / (self.t * <span class="number">1.</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        base = <span class="number">0</span></span><br><span class="line">      <span class="comment"># update preferences</span></span><br><span class="line">      <span class="comment"># this is H_a, reduce others preference</span></span><br><span class="line">      self.prob -= self._lr * (reward-base) * self.policy</span><br><span class="line">      <span class="comment"># this is H_A, increase current action preference</span></span><br><span class="line">      self.prob[previous_action] += self._lr * (reward-base)</span><br><span class="line">      x = self.prob</span><br><span class="line">      y = np.exp(x - np.<span class="built_in">max</span>(x))</span><br><span class="line">      self.policy = y / np.<span class="built_in">sum</span>(y)</span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="comment"># here we sample an action from the updated policy</span></span><br><span class="line">      <span class="keyword">import</span> bisect</span><br><span class="line">      acc = np.cumsum(self.policy)</span><br><span class="line">      <span class="keyword">return</span> bisect.bisect(acc, np.random.random())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.policy = np.ones((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)/self._number_of_arms</span><br><span class="line">    self.prob = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.t = <span class="number">0</span></span><br><span class="line">    self.all_reward = <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<h1 id="Full-RL-Problem"><a href="#Full-RL-Problem" class="headerlink" title="Full RL Problem"></a>Full RL Problem</h1><p>Above problem is not a full RL problem, because there is no association between action and different situations. Full RL problem needs to learn a policy that maps situations to actions.</p>
<h1 id="Bandit-Env-Code-Attached"><a href="#Bandit-Env-Code-Attached" class="headerlink" title="Bandit Env Code Attached"></a>Bandit Env Code Attached</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BernoulliBandit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;A stationary multi-armed Bernoulli bandit.&quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, success_probabilities, success_reward=<span class="number">1.</span>, fail_reward=<span class="number">0.</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Constructor of a stationary Bernoulli bandit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      success_probabilities: A list or numpy array containing the probabilities,</span></span><br><span class="line"><span class="string">          for each of the arms, of providing a success reward.</span></span><br><span class="line"><span class="string">      success_reward: The reward on success (default: 1.)</span></span><br><span class="line"><span class="string">      fail_reward: The reward on failure (default: 0.)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._probs = success_probabilities</span><br><span class="line">    self._number_of_arms = <span class="built_in">len</span>(self._probs)</span><br><span class="line">    self._s = success_reward</span><br><span class="line">    self._f = fail_reward</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, action</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The step function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      action: An integer or tf.int32 that specifies which arm to pull.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      A sampled reward according to the success probability of the selected arm.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">      ValueError: when the provided action is out of bounds.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> action &lt; <span class="number">0</span> <span class="keyword">or</span> action &gt;= self._number_of_arms:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Action &#123;&#125; is out of bounds for a &#x27;</span></span><br><span class="line">                       <span class="string">&#x27;&#123;&#125;-armed bandit&#x27;</span>.<span class="built_in">format</span>(action, self._number_of_arms))</span><br><span class="line"></span><br><span class="line">    success = <span class="built_in">bool</span>(np.random.random() &lt; self._probs[action])</span><br><span class="line">    reward = success * self._s + (<span class="keyword">not</span> success) * self._f</span><br><span class="line">    <span class="keyword">return</span> reward</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>n-arm bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>神的仆人成就的救恩 - 以赛亚书54</title>
    <url>/2020/07/19/yisaiya5/</url>
    <content><![CDATA[<p>以赛亚书54章有两个主题，其一，神承诺与他的子民和好；其二，神的城市一定会被重新建立。</p>
<blockquote>
<p>9 这事对我就好象挪亚时代的洪水一般; 我怎样起誓不再使挪亚时代的洪水漫过大地， 我也照样起誓不向你发怒，也不斥责你。10 虽然大山可以挪开，小山可以迁移，但我的慈爱必不从你身上挪开， 我和平的约也必不迁移; 这是怜悯你的耶和华说的。 《以赛亚书 54》</p>
</blockquote>
<p>神应许会收回怒气，把慈爱加给世界。</p>
<blockquote>
<p>11 受困苦、被风飘荡、不得安慰的啊! 你看，我要用彩色的石头安置你的基石，以蓝宝石奠定你的根基。 12 又用红宝石做你的城楼，用红玉做你的城门，用各种宝石做你四周的围墙。13 你所有的儿女都必受耶和华的教导，14 耶和华这样说: 你的儿女必大享平安。<br>《以赛亚书 54》</p>
</blockquote>
<p>这里以赛亚预言了未来完美的城池，而且所有神的儿女都可以得到神的教导。就是我们的圣经。当今世界，我们已经可以轻松的得到耶和华的教导。</p>
<p>这些都是靠着以赛亚口中那个受苦的仆人，就是耶稣基督，成就的事情。</p>
<p>这经文也会影响我们如何看待目前世界的种种问题，比如新冠疫情、战争、饥饿等等，这些都不是神审判，因为审判已经加给耶稣基督。我们需要持续的信靠，知道主再来。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>神的创造与律法 诗篇19</title>
    <url>/2020/07/08/shipian/</url>
    <content><![CDATA[<blockquote>
<p>1诸天述说　神的荣耀，穹苍传扬他的作为。 2天天发出言语，夜夜传出知识。</p>
</blockquote>
<p>大卫，写了一首歌来称赞神的伟大。神的创造和神的律法都在反映神的荣耀。</p>
<h2 id="宇宙"><a href="#宇宙" class="headerlink" title="宇宙"></a>宇宙</h2><p>宇宙万物都在彰显神的存在和伟大。宇宙就好像在用口述说神的荣耀。</p>
<p>大卫的时代，人们通常愿意崇拜宇宙中的事物，比如太阳、月亮和星辰。但是，人们却忽略了一个事实：神是宇宙的创造者。他才是唯一值得崇拜的。</p>
<p>我们的时代，人们不再崇拜太阳和星辰，人们崇拜科学，这些科学让然在是解释宇宙万物。同样的，人们仍然忽略了同一个事实：神是宇宙的创造者。</p>
<p>宇宙，确实是伟大的；但是，他的创造者才是一切的来源，宇宙的存在就是为了彰显他的荣耀。</p>
<p>任何时代，我们都不应该弄错主次。</p>
<h2 id="律法"><a href="#律法" class="headerlink" title="律法"></a>律法</h2><blockquote>
<p>7耶和华的律法是完全的，能使人心苏醒；耶和华的法度是坚定的，能使愚人有智慧。</p>
</blockquote>
<p>神的律法让人充满智慧，智慧始于认识耶和华。神的话语是完备的，拥有无比的价值。</p>
<p>神的话语让人充满喜乐。</p>
<p>我们的时代，有太多的话语、声音，我们应该听从哪一个？答案很明显：神的话语。</p>
<p>在漫长的人类历史中，我们发展出来很多理论和哲学，但是一个不争的事实是：所以的哲学和理论都不是完整的，都不能经过时间的考验。但是神的话语拥有完全不用的属性。</p>
<blockquote>
<p>8耶和华的训词是正直的，能使人心快乐；耶和华的命令是清洁的，能使人的眼睛明亮。9耶和华的话语“耶和华的话语”原文作“耶和华的敬畏”是洁净的，能坚立到永远；耶和华的典章是真实的，完全公义；10都比金子宝贵，比大量的精金更宝贵；比蜜甘甜，比蜂房滴下来的蜜更甘甜；11并且你的仆人也借着这些得到警戒，谨守这些就得着大赏赐。</p>
</blockquote>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>大卫，在诗歌的结尾讲了这样一段话：</p>
<blockquote>
<p>12谁能知道自己的错误呢？ 求你赦免我隐而未现的过失。 13求你拦阻你仆人，不犯任意妄为的罪， 不许它们辖制我；我才可以完全，不犯大过。<br>14耶和华我的盘石、我的救赎主啊！愿我口中的言语、心里的意念，都在你面前蒙悦纳。</p>
</blockquote>
<p>大卫，请求神原谅他所犯的罪，甚至是那些他自己没有意识到的罪恶。更进一步，他请求神可以帮助他不再犯罪。因为，当他意识到宇宙万物的精妙和神的话语的以后，他理所当然的选择了谦卑的求神能够悦纳他的心思意念，做他的磐石和救赎者。</p>
<p>多么美好啊？宇宙的创造者，做你我的磐石，你我的救赎者。</p>
<h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><p>我们应该如何做？</p>
<p>谦卑</p>
<p>思考</p>
<p>敬畏</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>诗篇</tag>
      </tags>
  </entry>
  <entry>
    <title>醒来吧！神的子民 51:9-52</title>
    <url>/2020/07/05/yisaiya4/</url>
    <content><![CDATA[<h1 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h1><p>当我们即将踏上一段新的旅程，我们会准备行囊，心情激动。但是，如果旅程迟迟推迟，我们很可能就会渐渐失去激动的心情，然后把行囊中的种种拿出来。我们可能重新整理床铺，渐渐忘记即将发生的旅程。</p>
<h1 id="基督徒的旅程"><a href="#基督徒的旅程" class="headerlink" title="基督徒的旅程"></a>基督徒的旅程</h1><h2 id="醒来吧，耶和华的臂膀-51-9-16"><a href="#醒来吧，耶和华的臂膀-51-9-16" class="headerlink" title="醒来吧，耶和华的臂膀!(51:9-16)"></a>醒来吧，耶和华的臂膀!(51:9-16)</h2><blockquote>
<p>耶和华的膀臂啊，醒来吧!醒来吧!穿上能力吧!像古时的日子，像上古的世代一样醒来吧! 从前砍碎了拉哈伯， 刺透了海龙的，不是你吗?</p>
</blockquote>
<p>以色列人终于开始重新呼唤神的帮助，就像当年带以色列出埃及一样，拯救他们。以色列人终于意识到神的能力。</p>
<p>可是</p>
<p>该清醒的不是神，而是以色列人。</p>
<h2 id="醒来吧，耶路撒冷，从醉-罪-中醒来-51-17-23"><a href="#醒来吧，耶路撒冷，从醉-罪-中醒来-51-17-23" class="headerlink" title="醒来吧，耶路撒冷，从醉(罪)中醒来!(51:17-23)"></a>醒来吧，耶路撒冷，从醉(罪)中醒来!(51:17-23)</h2><blockquote>
<p>17耶路撒冷啊，醒来!醒来!站起来吧! 你从耶和华的手中喝了他烈怒的杯， 喝尽了那使人摇摇摆摆的爵。</p>
</blockquote>
<p>以色列人才是应该从醉酒中醒来。他们面临的痛苦都是因为他们喝了耶和华愤怒的杯。正是因为以色列人犯罪，才收到神公义的审判。</p>
<p>但是，神，决定拿走那愤怒的杯，救赎以色列。（为什么呢？）</p>
<p>以色列的仇敌将会承担愤怒的杯。（为什么呢？）</p>
<h2 id="醒来吧，锡安，换衣服准备离开-52-1-12"><a href="#醒来吧，锡安，换衣服准备离开-52-1-12" class="headerlink" title="醒来吧，锡安，换衣服准备离开!(52:1-12)"></a>醒来吧，锡安，换衣服准备离开!(52:1-12)</h2><blockquote>
<p>1 锡安哪!你要醒来; 醒来，披上你的力量。 圣城耶路撒冷啊! 要穿上你华美的衣服。 因为未受割礼的和不洁净的人， 都再不得进到你那里去。2 耶路撒冷啊!抖下尘土， 起来，坐在位上吧! 锡安被掳的居民哪! 解开你颈项上的锁炼。</p>
</blockquote>
<p>耶和华与神的子民住在一起了，耶路撒冷将会成为真正的圣城。这也正是福音的预言。</p>
<p>要离开，不要触摸不洁净的东西。不要留恋即将毁灭的世界了，因为我们将要去的是圣洁的地方。而且，神会保守：</p>
<blockquote>
<p>11 你们要离开，要离开，要从那里出来， 我没有对雅各的后裔说过: 不要触摸不洁净的东西。扛抬耶和华器皿的啊! 我耶和华讲说公义， 你们要从巴比伦城中出来，要自洁。 12 你们出来，不必着急; 以色列的 神必作你们的后盾。向不能拯救人的神祈求的，</p>
</blockquote>
<p>基督徒处在同样的世代，救赎的世代，离开巴比伦的世代，我们应该做好准备离开的世代。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>传道人的传承：提摩太后书</title>
    <url>/2020/06/28/timotai2/</url>
    <content><![CDATA[<h1 id="传道人的传承"><a href="#传道人的传承" class="headerlink" title="传道人的传承"></a>传道人的传承</h1><blockquote>
<p>我在上帝面前，并在将来审判活人死人的基督耶稣面前，凭着他的显现和他的国度郑重地劝戒你：<br>2务要传道；无论得时不得时总要专心，并以百般的忍耐和各样的教导责备人，警戒人，劝勉人。<br>3因为时候将到，那时人会厌烦健全的教导，耳朵发痒，就随心所欲地增添好些教师，<br>4并且掩耳不听真理，偏向无稽的传说。<br>5至于你，凡事要谨慎，忍受苦难，做传福音的工作，尽你的职分。<br>6至于我，我已经被浇献，离世的时候到了。<br>7那美好的仗我已经打过了，当跑的路我已经跑尽了，该信的道我已经守住了。<br>8从此以后，有公义的冠冕为我存留，就是按着公义审判的主到了那日要赐给我的；不但赐给我，也赐给凡爱慕他显现的人。<br>《提摩太后书》4</p>
</blockquote>
<p>这封书信是身在牢狱中的保罗写给新一代传道人提摩太的，从信中我们也可以看到，保罗已经走到了生命的尽头。他留下了那句经典的经文，每一个传道人都铭记在心：</p>
<blockquote>
<p>7那美好的仗我已经打过了，当跑的路我已经跑尽了，该信的道我已经守住了。<br>8从此以后，有公义的冠冕为我存留，就是按着公义审判的主到了那日要赐给我的；不但赐给我，也赐给凡爱慕他显现的人。</p>
</blockquote>
<p>保罗当时身陷囹圄，教会内部开始出现离弃真道的人，背弃信仰，否认复活的事情。更加可怕的是，教会出现了很多假教师，他们不讲真理，却说虚妄的话，教导别人离弃信仰。他心急如焚。</p>
<p>而提摩太一直都是保罗信任的同工，他从小从祖母哪里接受了旧约圣经的教导，作为教会新一代的代领人，他面临很多挑战：人们背弃信仰，教会中假教师横行。</p>
<p>正是再这样的情况下，第一代传道人代表：保罗，写信给新一代传道人：提摩太，提醒他一定要持守真理，传讲福音。保罗为提摩太指明了道路：</p>
<blockquote>
<p>16 圣经都是上帝所默示的“圣经都是上帝所默示的”或译“凡上帝所默示的圣经”。于教训、督责、使人归正、教导人学义都是有益的，<br>17 叫属上帝的人得以完全，预备行各样的善事。</p>
</blockquote>
<p>他希望提摩太可以持守这圣经完备的教导，即使面对苦难，也可以坚持下去，并且将耶稣基督的福音传讲出去。</p>
<p>这就是一个老传道人对新传道人最后的叮嘱。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>提摩太后书</tag>
      </tags>
  </entry>
  <entry>
    <title>Python无成本加速技巧</title>
    <url>/2020/06/14/python_speedup/</url>
    <content><![CDATA[<p>Python是个很精巧的语言，但是常见的Cython解释器生成的代码相对来说还是比较慢的，这里主要是跟动态语言的一些特性有关系。但是，我会介绍一下非常常见的手段，可以通过简单的变化提升代码速度：无成本的加速技巧。</p>
<h1 id="palm-tree-Python到底慢在哪里？"><a href="#palm-tree-Python到底慢在哪里？" class="headerlink" title=":palm_tree: Python到底慢在哪里？"></a>:palm_tree: Python到底慢在哪里？</h1><p>其实，巨大部分的场景我们觉得Python慢是在循环的时候。那么<strong>在循环里，我们可以注意如下</strong>：</p>
<h2 id="1、避免使用-操作"><a href="#1、避免使用-操作" class="headerlink" title="1、避免使用 . 操作"></a>1、避免使用 <code>.</code> 操作</h2><p>比如如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        z = math.sqrt(x) + math.sqrt(y)  <span class="comment"># 这里的 . 操作很慢</span></span><br><span class="line">        demo.something()   <span class="comment"># 这里的 . 操作很慢</span></span><br></pre></td></tr></table></figure>

<p><code>.</code> 会访问类的内部字典找到合适的方法或者属性，这些操作放在循环中就会拖慢速度。所以，应该尽量把这个操作从循环中去除。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt   <span class="comment"># &lt;==== </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line">sth = demo.something()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        z = sqrt(x) + sqrt(y)  <span class="comment"># &lt;----</span></span><br><span class="line">        sth()   <span class="comment"># &lt;----</span></span><br></pre></td></tr></table></figure>

<h2 id="2、避免循环临时变量"><a href="#2、避免循环临时变量" class="headerlink" title="2、避免循环临时变量"></a>2、避免循环临时变量</h2><p>比如使用 <code>a, b = b, a</code> 来交换变量，而不是使用临时变量</p>
<h2 id="3、字符串使用join-而不是"><a href="#3、字符串使用join-而不是" class="headerlink" title="3、字符串使用join 而不是 +"></a>3、字符串使用<code>join</code> 而不是 +</h2><p>比如 <code>&#39;_&#39;.join([&quot;a&quot;, &quot;b&quot;])</code>而不是 <code>&quot;a&quot;+&quot;_&quot;+&quot;b&quot;</code>。</p>
<p>使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。</p>
<h2 id="4、使用隐式循环"><a href="#4、使用隐式循环" class="headerlink" title="4、使用隐式循环"></a>4、使用隐式循环</h2><p>比如 <code>sum(range(10)</code> 速度比for 循环更快。但是for循环比while循环更快！</p>
<h2 id="5、大杀器：numba-jit"><a href="#5、大杀器：numba-jit" class="headerlink" title="5、大杀器：numba.jit"></a>5、大杀器：<code>numba.jit</code></h2><p>比如同样的代码，下面的循环一个在1s内完成，而普通版本需要4s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numba</span><br><span class="line"></span><br><span class="line"><span class="meta">@numba.jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeSum</span>(<span class="params">size: <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="built_in">sum</span> = computeSum(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总之，最低成本加速的方法就是尽量减少循环中的无意义操作，或者进行jit编译（其实也是减少Head的重量）。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>看哪!万众期待的仆人 - 以赛亚书49</title>
    <url>/2020/06/14/yisaiya3/</url>
    <content><![CDATA[<h1 id="预言中新的仆人"><a href="#预言中新的仆人" class="headerlink" title="预言中新的仆人"></a>预言中新的仆人</h1><blockquote>
<p>1 众海岛啊!你们要听我的话。 远方的万族啊!你们要留心听。</p>
</blockquote>
<p>先知以赛亚在开头就说明他要说明一个重大的消息，有一个预言中的仆人会降临。</p>
<blockquote>
<p>3 他对我说:“你是我的仆人以色列， 我要借着你得荣耀。”<br>4 但我说:“我劳碌是徒然的; 我用尽气力，是虚无虚空的; 然而我当得的公理是在耶和华那里， 我的赏赐是在我的 神那里。”</p>
</blockquote>
<p>这位仆人原本是以色列民族，但是以色列失败了。这里神预言的仆人，不是以色列民族。</p>
<p>其实，先知这里就是在预言耶稣基督的到来。还记得吗？再上一个章节，以赛亚预言了波斯的古列王，“恰巧”会让我以色列回到故乡。但是今天这一位仆人，区有不同的特点。这位仆人，被藏在阴影之下，但是他口里说出的话，却如快刀。</p>
<p>虽然，仆人最终用尽力气，却得到虚空，但是仆人的赏赐在神那里！</p>
<h1 id="仆人的使命"><a href="#仆人的使命" class="headerlink" title="仆人的使命"></a>仆人的使命</h1><blockquote>
<p>5 现在，耶和华说:<br>6 “你作我的仆人， 使雅各众支派复兴，使以色列中得保全的归回，只是小事，我还要使你作列国的光，使我的救恩传到地极。”</p>
</blockquote>
<p>救恩要通过这位仆人，把救恩传到地极，而不仅仅是赐给犹太人。先知以赛亚就是犹太人，但是他说救恩是赐给万国的。这仆人，就像一束光一样把救恩带给万国，放弃人手所造的毫无能力的偶像，而去认识创造者、满有能力的神。万国就在黑暗之中，看不到世界的真相。</p>
<p>这位仆人不仅仅让失败的以色列重新认识神，更让万国看到世界的光。</p>
<h1 id="仆人的“命运”"><a href="#仆人的“命运”" class="headerlink" title="仆人的“命运”"></a>仆人的“命运”</h1><blockquote>
<p>7 以色列的救赎主，以色列的圣者耶和华，对那被人藐视的、 被本国憎恶的、<br>被统治者奴役的，这样说:<br>“君王看见了，就必起立，<br>领袖看见了，也要下拜，<br>都因信实的耶和华，就是拣选了你的、以色列的圣者的缘故。” 8 耶和华这样说:“在悦纳的时候，我应允了你，在拯救的日子，我帮助了你;我要保护你，使你作人民的中保，复兴那地，使人承受荒凉之地作产业</p>
</blockquote>
<p>这位仆人本是犹太人的后裔，却被犹太人憎恨。但是他是属神的，最终君王、领袖都要向他下拜。</p>
<p>这里提到，仆人会成为人的中保。这里中保在原文中有”约”的意思，就是人与神的约。“约”是一个旧约中重要的概念。神是通过跟人立约实现他的救赎。现在，这位仆人就是新约的本身！这位仆人带来的就像是出埃及一样的拯救。</p>
<blockquote>
<p>9 对那些被囚的说:‘你们出来吧!’对那些在黑暗中的人说:‘你们现身吧!’<br>他们沿途必得喂养，耶和华这样说: 一切光秃的高处必成为他们的草场。“埃及劳碌得来的和古实所得之利，<br>10 他们必不饥饿，也不口渴，<br>以及身量高大的西巴人，<br>炎热和太阳必不伤害他们，<br>都必过来归你，也要属你;<br>因为那怜悯他们的，要引领他们，<br>他们必带着锁炼过来随从你，<br>带领他们到水泉的旁边。<br>11 我必使我的众山成为道路， 向你恳求，说:<br>我的大道都必被修高。‘ 神真的在你们中间，此外，再没有别的神， 12 看哪!有些人从远方而来;<br>没有别的真神。’” 看哪!有些从北方，从西方而来，拯救者以色列的 神啊! 还有些从色尼姆地而来。”</p>
</blockquote>
<p>神的仆人会持续的带领人们走向神的国度。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>关于波斯王古烈的预言 - 以赛亚书45</title>
    <url>/2020/06/07/yisaiya_46/</url>
    <content><![CDATA[<p>我们每天要听见很多的声音，来自社会的、新闻的、亲人朋友的、父母的、公司同事老板的、网络上的等等。我们应该挺创造天地的耶和华的声音。神通过先知以赛亚证明他是独一的神，他把还未发生的事情指示给以赛亚。以赛亚在100多年前预言了古列王会让以色列人从重建圣殿。</p>
<p>他不仅说出了他的名字，也说出了将要做的事情。</p>
<blockquote>
<p>28 我对古列说:‘我的牧人; 他必成就我所喜悦的一切。’ 他要对耶路撒冷说:‘你必被重建起来!’ 他必对圣殿说:‘你的根基要奠定!’” 45 1“我耶和华所膏立的古列， 我紧握着他的右手， 使列国降服在他面前; 我也松开列王的腰带; 我使门户在他面前敞开，使城门不得关闭; 耶和华对古列这样说: 2 我必亲自领导你，把高低不平的路修平; 铜门，我必打破;铁门，我必砍断。</p>
<blockquote>
<p>以赛亚书44</p>
</blockquote>
</blockquote>
<ul>
<li>744-686年 以赛亚事奉的时间(以赛亚 1:1)</li>
<li>586 年 巴比伦掳走犹太人</li>
<li>538 年 古列成为波斯的君王，在接下来 20 年间征服了周围所有国家 </li>
<li>538 年 古列征服了巴比伦之后，吩咐了犹太人回去耶路撒冷重建圣殿</li>
</ul>
<p>很明显，正如耶和华自己的宣称，他是掌控历史的神，我们当然要耶和华的声音。</p>
<p>在这个预言之后，神又说出了另一个预言，一个关于全世界的预言：</p>
<blockquote>
<p>22 全地的人哪!你们都要归向我，都要得救。 因为我是 神，再没有别的 神。 23 我指着自己起誓， 我的口凭着公义说出的话， 决不改变: ‘万膝都必向我跪拜，万口都要指着我起誓。’ 24 人论到我必说: ‘只有在耶和华里面才有公义和能力’; 向他发怒的，都必来到他面前，并且要蒙羞。 25 以色列所有的后裔， 都必靠耶和华得称为义，并要夸胜。”</p>
<blockquote>
<p>以赛亚书45</p>
</blockquote>
</blockquote>
<p>耶和华是这样介绍他自己的：</p>
<blockquote>
<p>我从起初就宣告末后的事，从古时就述说还未作成的事，说:‘我的计划必定成功，<br>我所喜悦的，我都必作成。</p>
<blockquote>
<p>以赛亚书46</p>
</blockquote>
<p>17 唯有以色列必靠着耶和华得救， 得着永远的拯救;你们必不蒙羞，也不受辱，直到永远。18 因为创造诸天的耶和华，他是 神， 塑造大地，把大地造成;他坚立大地; 他创造大地，不是荒凉的; 他塑造大地，是要给人居住;他这样说: “我是耶和华，再没有别的 神。</p>
<blockquote>
<p>以赛亚书45</p>
</blockquote>
<p>11 以色列的圣者，造以色列的主耶和华这样说: “你们可以问我将要来的事， 关于我的众子和我手所作的， 你们也可以吩咐我回答。 12 我造了地，又造了人在地上; 我亲手展开了诸天， 又命定了天上的万象。</p>
<blockquote>
<p>以赛亚书44</p>
</blockquote>
</blockquote>
<h2 id="要听耶和华的声音，免得失去救恩"><a href="#要听耶和华的声音，免得失去救恩" class="headerlink" title="要听耶和华的声音，免得失去救恩"></a>要听耶和华的声音，免得失去救恩</h2><p>因为他是独一真神，在没有别的神。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>圣经的结构</title>
    <url>/2020/05/17/bible_structure/</url>
    <content><![CDATA[<h1 id="book-基本信息"><a href="#book-基本信息" class="headerlink" title=":book:基本信息"></a>:book:基本信息</h1><p>圣经（Bible）是一系列不同文学体裁的书组成，分为新约和旧约两个部分。圣经总共包含了66卷书，成书时间跨越2千余年，由40位作者完成。最初版本的圣经主要由两种语言写成：希伯来语和希腊语。</p>
<p>旧约圣经包含39卷书，排列顺序在主前300年左右确定：</p>
<table>
<thead>
<tr>
<th>历史书</th>
<th>诗歌</th>
<th>先知书</th>
</tr>
</thead>
<tbody><tr>
<td>创世纪到以斯帖书</td>
<td>约伯记到雅歌</td>
<td>以赛亚书到玛拉基书</td>
</tr>
</tbody></table>
<p>在希伯来原文圣经中，排序略有不同：</p>
<table>
<thead>
<tr>
<th>律法书</th>
<th>先知书</th>
<th align="left">圣卷</th>
</tr>
</thead>
<tbody><tr>
<td>创世纪到申命记</td>
<td>大先知、小先知书</td>
<td align="left">诗篇、智慧书</td>
</tr>
</tbody></table>
<p>新约圣经包含27卷，其中福音书主要记叙耶稣基督的出生、讲道、神迹、受难以及复活的见证。使徒行传是路加接着路加福音之后，记叙耶稣基督升天后福音如何被传开的经过。使徒书信主要是使徒写给各个初代教会的书信，在圣灵的工作下启示关于耶稣基督的真理。启示录是约翰所写，记叙了他所见到的异象，其中的属灵事实隐藏在可见的现实世界。</p>
<table>
<thead>
<tr>
<th>福音书</th>
<th align="left">马太福音、马可福音、路加福音、约翰福音</th>
</tr>
</thead>
<tbody><tr>
<td>使徒行传</td>
<td align="left">路加关于初代使徒传道的历史</td>
</tr>
<tr>
<td>使徒书信</td>
<td align="left">罗马书到犹大书</td>
</tr>
<tr>
<td>启示录</td>
<td align="left">约翰关于审判的异象</td>
</tr>
</tbody></table>
<h2 id="writing-hand-圣经只有一个“作者”"><a href="#writing-hand-圣经只有一个“作者”" class="headerlink" title=":writing_hand: 圣经只有一个“作者”"></a>:writing_hand: 圣经只有一个“作者”</h2><p>圣经的神奇之处在于，它虽然包含了各种不同的资料，并且由40位人类作者经过2000年的时间完成，但是它作为一个整体，却体现了惊人的一致性。</p>
<p>根据使徒的讲述这本书的作者其实是神，这本书其实只有一个主题，后面我们会展开这个主题。</p>
<p>使徒保罗说：圣经都是神所默示的。（提后3：16）</p>
<h2 id="page-facing-up-圣经的同一个主题"><a href="#page-facing-up-圣经的同一个主题" class="headerlink" title=":page_facing_up: 圣经的同一个主题"></a>:page_facing_up: 圣经的同一个主题</h2><p>圣经66卷书涉及到的领域非常广泛，但是有一个重要的主题将它们连接起来：耶稣基督以及神通过他实现的救赎计划。这不仅仅是在旧约中成立，在新约也是一样的主题。耶稣本人在提到旧约的时候说：给我作见证的就是这经。（约5：39）他从死里复活后，曾经对信徒说：“于是从摩西和众先知起，凡经上所指着自己的话都给你们讲解明白了。”（路24：27）“这就是我从前与你们同在的时候告诉你的话：摩西、律法、先知书和诗篇上所记，凡指着我的话都必须应验。”（路24：44）</p>
<p>旧约和新约并不是神的两个不同的计划，而是同一个计划的两个阶段。在旧约中，神透过给以色列人的应许预言了将来对人类的救赎，而新约耶稣基督的降临这是应许的实现。</p>
<h2 id="notebook-圣经是一本书"><a href="#notebook-圣经是一本书" class="headerlink" title=":notebook: 圣经是一本书"></a>:notebook: 圣经是一本书</h2><p>了解圣经是一本书，圣经有一个主题，对我们如何阅读圣经有着重要的影响。首先一个原则是，圣经绝大部分的内容是不能脱离上下文来阅读的。如果脱离上下文阅读很可能会曲解经文的原本意思。第二个原则是，阅读不同的文学体裁应该采用不同的阅读方法。比如阅读启示录这种体裁，就不能用度历史书的方法来阅读。</p>
<h1 id="incoming-envelope-圣经概览"><a href="#incoming-envelope-圣经概览" class="headerlink" title=":incoming_envelope: 圣经概览"></a>:incoming_envelope: 圣经概览</h1><h2 id="神的国度"><a href="#神的国度" class="headerlink" title="神的国度"></a>神的国度</h2><p>为了阅读圣经，我们首先需要确定一个贯穿始终的主题。这样我们才能把圣经的各个部分组织起来。这个主题必须出自圣经本身，但是又能把圣经每个部分贯穿起来，而这个主题就是：神的国度。</p>
<p>耶稣在他的第一次讲道中这样说：“日期满了，神的国近了”（可1：15）。可见神的国度在他的讲道中具有及其重要的意义。在旧约中，神的国度这个主题也是应许的重要部分：神的子民在神的地方接受神的掌管和祝福。</p>
<h2 id="圣经概览"><a href="#圣经概览" class="headerlink" title="圣经概览"></a>圣经概览</h2><p>那么根据神的国度这个主题，我们可以把圣经分解成以下几个部分看：</p>
<ul>
<li>旧约<ul>
<li>雏形的国度</li>
<li>失落的国度</li>
<li>应许的国度</li>
<li>局部的国度</li>
<li>预言的国度</li>
</ul>
</li>
<li>新约<ul>
<li>当下的国度</li>
<li>宣告的国度</li>
<li>完美的国度</li>
</ul>
</li>
</ul>
<p>雏形的国度，就是伊甸园的世代，人类和神共同在一起，人类在神的掌管下接受神的祝福。神也说，这是好的。</p>
<p>失落的国度，就是亚当和夏娃多落后被赶出伊甸园的世代，他们失去了神的祝福。但是神依然希望带他们回到自己的身边。</p>
<p>应许的国度，神拣选了亚伯拉罕，并给了他应许：万国将通过他得到祝福。</p>
<p>局部的国度，主要是以色列从出埃及以后的历史。</p>
<p>预言的国度，以色列灭国，神预言弥撒亚的降临和神国度的降临。</p>
<p>当下的国度，耶稣基督降世，通过自己的死亡和复活完成了对人类的救赎</p>
<p>宣告的国度，耶稣升天后，福音在万国被传开。** （这就是我们的世代！）**</p>
<p>完美的国度，启示录中预言的基督再临，审判完成，神的国度彻底降临。我们的世代终结。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《上帝的蓝图》，Vaughan Roberts</li>
</ul>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>“你不要惧怕，我是你的神” - 以赛亚书41</title>
    <url>/2020/05/17/yisaiya2/</url>
    <content><![CDATA[<p>在新冠肺炎这个特殊的时期，来自先知以赛亚的预言对我们是极大的鼓励。我们在这种时期是最缺乏安全感的时候，面对危机，我们从哪里得到力量？</p>
<p>在这种时期，我们也应该更加谨慎，力量应该来自耶和华，不应该来自各式各样的偶像！</p>
<h1 id="我们从哪里获得力量？"><a href="#我们从哪里获得力量？" class="headerlink" title="我们从哪里获得力量？"></a>我们从哪里获得力量？</h1><p>“手”的概念不断在这段经文中出现，神是个灵，但是经文用比喻告诉我们神是我们的依靠。</p>
<p><strong>以赛亚书41：10 不要惧怕，因为我与你同在;不要四处张望，因为我是你的 神，<br>我必坚固你，我必帮助你;我必用公义的右手扶持你。</strong></p>
<p><strong>以赛亚书41：13  因为我，耶和华你们的神，紧握着你的右手，对你说：“不要惧怕，我必帮助你。”</strong></p>
<p>耶和华是信实不变的神，他说的话依然生效。这就是我们在面对危险和不确定性的时候，获得力量的地方。握住耶和华全能的手。</p>
<h1 id="偶像的软弱"><a href="#偶像的软弱" class="headerlink" title="偶像的软弱"></a>偶像的软弱</h1><p>面对不确定性，去选择依靠偶像，只会带来更多的恐惧。为什么呢？因为偶像都是人手所造的，注定会朽坏的、及其不稳定的东西。当你选择依靠他们的同时，你已经开始恐惧偶像有一天离开你。</p>
<p>先知以赛亚是这样说的：</p>
<p><strong>41：28 看哪!他们都是无有，他们所作的都是虚无; 他们所铸的偶像都是风，都是虚空。</strong></p>
<h1 id="我们为什么惧怕？"><a href="#我们为什么惧怕？" class="headerlink" title="我们为什么惧怕？"></a>我们为什么惧怕？</h1><p>我们担心失去我们关心的东西：生命、爱情、金钱、健康、权利、地位、亲密关系等等。</p>
<p>我们认为我们只能自己面对一切。</p>
<p>我们害怕自己不能掌控的事情。</p>
<p>但是，</p>
<p>神，掌管一切。</p>
<h1 id="一首诗歌"><a href="#一首诗歌" class="headerlink" title="一首诗歌"></a>一首诗歌</h1><p>我的诗歌 我的拯救<br>祢是我患难中随时的帮助<br>众山怎样围绕耶路撒冷<br>祢必围绕我到永远  </p>
<p>主祢是我力量 主祢是我高台<br>坚固盘石我信靠祢必不动摇<br>主祢是我力量 主祢是避难所<br>我的盼望只在乎祢  </p>
<p><a href="https://www.youtube.com/watch?v=izOAxx2bRIc">https://www.youtube.com/watch?v=izOAxx2bRIc</a></p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新科学</title>
    <url>/2020/05/16/a_new_kind_of_science/</url>
    <content><![CDATA[<blockquote>
<p>一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
</blockquote>
<h1 id="1、新科学的基础"><a href="#1、新科学的基础" class="headerlink" title="1、新科学的基础"></a>1、新科学的基础</h1><p>简单的规则，可以形成复杂的行为。</p>
<p>如果人也是规则计算的一部分，自由意志又是如何与之协调的？</p>
<p>数学、物理、生物学、社会学、哲学、计算机科学、艺术的关系。这个系统真的解决了这些领域的基本问题吗？？</p>
<h1 id="2、关键性的实验"><a href="#2、关键性的实验" class="headerlink" title="2、关键性的实验"></a>2、关键性的实验</h1><p>每一个新的科学产生都起始于某一个现象或者观察。这本书的起点是程序和计算。日常生活中程序通常是为了某些特殊的目的编写的，那么问题来了，如果我们随便选一些程序，而没有明确的目的，这些程序的运行结果会是什么呢？</p>
<p>上面这个问题，数学很难解决，而最简单的办法就是用计算机进行试验。</p>
<p>程序从抽象的角度可以理解成为：包含一些规则（Rules），这些会规定每一步做什么。设定规则的方式有很多。比如cellular automata，元细胞自动机。</p>
<p>重要的发现是：简单的规则，可以产生复杂的模式。这也是本书的所谓新科学的核心思想。</p>
<p>Rule30，是一个简单的规则，但是产生了随机数。</p>
<p>问题是当我们观察到非常复杂的行为时，产生这种行为的规则（如果是有规则产生的话）可能非常简单。</p>
<h1 id="3、简单程序的世界！"><a href="#3、简单程序的世界！" class="headerlink" title="3、简单程序的世界！"></a>3、简单程序的世界！</h1><p>问题：简单程序的一般行为是什么样的？</p>
<p>作者发现的规律：</p>
<ul>
<li>Cellular automata, 不仅可以产生重复的模式，还可以产生随机性</li>
<li>Substitute system，似乎只能产生重复的模式，而不能产生随机性</li>
<li>Sequence Substitute system，也可以产生随机性</li>
<li>Tag system</li>
<li>Cyclic Tag system</li>
<li>Symbolic system</li>
</ul>
<p>（是吗？）</p>
<p>作者发现，在很多迥异的系统中，简单的规则总是能够产生复杂的行为，甚至随机性。所以这种简单导致的复杂性普遍存在。下一个问题是：什么时候会出现复杂性？通过目前的实验，如果规则很简单，会出现重复的行为；规则稍微复杂，会出现嵌套类型的现象；当规则进一步复杂，就会出现更加复杂的行为，比如混合和随机性。</p>
<p>作者发现，出现复杂行为的阈值通常很低。但是，一旦超过阈值，提高规则的复杂度，并不能显著提高系统的复杂性。复杂的系统行为与规则的复杂度并没有显著的关联，也就是说，行为异常复杂的系统，其控制规则可能非常简单。</p>
<p>据此，作者推断应该存在一般性的原则控制这些系统的复杂度。</p>
<p>（如何定义复杂度？随机性？熵？）</p>
<p>这章最后作者提到了一些对传统数学和物理研究方法的看法：<br>他的研究方法在传统领域可能会被认为是不精确的，但是传统方法是从现象出发的，可能不能发现上文的复杂度。作者采用了实验的途径。</p>
<h1 id="4、基于数字的系统"><a href="#4、基于数字的系统" class="headerlink" title="4、基于数字的系统"></a>4、基于数字的系统</h1><p>基于数字的系统在传统科学和数学领域非常普遍。那么，基于数字的系统是不是能够产生复杂度？作者给出的答案是肯定的。</p>
<p>（这类系统与细胞自动机系统有什么区别和联系？）</p>
<p>数学系统的基础是数字系统，而计算系统（比如细胞自动机）的基础是通过一个序列的代码。这种代码的表达方式在自然界非常常见，比如DNA。</p>
<h2 id="基础代数"><a href="#基础代数" class="headerlink" title="基础代数"></a>基础代数</h2><p>基础代数的操作（operation，也可以看做规则的一种吧）非常简单，但是作者发现即使这种规则也可以产生复杂系统行为，就像上一章的细胞自动机。</p>
<p>比如，以1作为基，持续加1，就像1，2，3，….从数学的角度看这是一个再简单不过的操作，但是如果我们看这个操作以二进制的形式就会呈现一定的复杂度。</p>
<p><img data-src="https://i.imgur.com/7yhmZHN.png" alt="简单加法的二进制模式"></p>
<p>有人可能提出疑问，就是这种复杂度仅仅是看起来而已，并没有本质的复杂度。但是作者提出了新的例子：除法。</p>
<p>(其实无理数对于数字来说已经非常奇葩了。。。随机性还记得吗？)</p>
<p><img data-src="https://i.imgur.com/yNSwlnU.png" alt="这个看起来就好像股票价格"></p>
<p>这些系统与细胞自动机不同，细胞自动机的变化通常是局部的，而数字系统则没有这个限制。</p>
<h2 id="递归序列"><a href="#递归序列" class="headerlink" title="递归序列"></a>递归序列</h2><p>比如，$f[n] = f[n-1] + f[n-2]$。简单的规则可以发现：</p>
<p><img data-src="https://i.imgur.com/WCTTJpN.png" alt=""></p>
<p>但是，如果稍微增加复杂度，我们就会发现复杂系统行为：</p>
<p><img data-src="https://i.imgur.com/kBF0hMf.png" alt=""></p>
<h2 id="数学常数"><a href="#数学常数" class="headerlink" title="数学常数"></a>数学常数</h2><p>常数比如$\pi$, $e$，无理数等等。</p>
<p><img data-src="https://i.imgur.com/GxEXKZd.png" alt=""></p>
<p>作者表明，不论采用哪种形式表达，数学常数也表现了高的复杂度。</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>一个自然的推广就是函数。简单函数只要稍微叠加，就会出现复杂现象。</p>
<p><img data-src="https://i.imgur.com/X5ANIxW.png" alt=""></p>
<h2 id="连续细胞自动机"><a href="#连续细胞自动机" class="headerlink" title="连续细胞自动机"></a>连续细胞自动机</h2><p>目前为止作者讨论的系统全部都是离散系统。</p>
<p><img data-src="https://i.imgur.com/Wgjq8VT.png" alt=""></p>
<h2 id="连续系统和离散系统"><a href="#连续系统和离散系统" class="headerlink" title="连续系统和离散系统"></a>连续系统和离散系统</h2><p>区别在哪里呢？</p>
<h1 id="5、二维和更高维度"><a href="#5、二维和更高维度" class="headerlink" title="5、二维和更高维度"></a>5、二维和更高维度</h1><p>结论是，维度的增加并没有改变复杂度的基本特征。</p>
<h2 id="高纬度细胞自动机"><a href="#高纬度细胞自动机" class="headerlink" title="高纬度细胞自动机"></a>高纬度细胞自动机</h2><p><img data-src="https://i.imgur.com/wKcVljW.png" alt=""></p>
<p>这个像不像雪花？自然界的现象。</p>
<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><h2 id="Substitute系统和分型"><a href="#Substitute系统和分型" class="headerlink" title="Substitute系统和分型"></a>Substitute系统和分型</h2><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><p>这个其实已经看到了现在火爆的作者的物理学项目的影子了。</p>
<h1 id="6、从随机性说起"><a href="#6、从随机性说起" class="headerlink" title="6、从随机性说起"></a>6、从随机性说起</h1><p>作者综合分析了细胞自动机的四类行为，并且认为这些行为具有通用价值。</p>
<h1 id="7、程序和自然界的机理"><a href="#7、程序和自然界的机理" class="headerlink" title="7、程序和自然界的机理"></a>7、程序和自然界的机理</h1><p>作者让我们看到自然界的很多现象都与之前的介绍的内容非常相似。</p>
<p><em>随机性</em></p>
<ul>
<li>外界注入随机性，通过与系统外界的通讯</li>
<li>初始条件随机性</li>
<li>自身演化产生随机性，无外界通讯</li>
</ul>
<p>作者认为第三种是控制自然界随机性的主要形式。</p>
<p>（是否有可能是三者的共同作用呢？）</p>
<p>（预定论和随机性并不冲突。）</p>
<p>作者认为随机性是让离散系统看起来像连续系统的原因。（实际上我觉得这个世界本身就是离散的，现代物理学似乎也支持这个观点）</p>
<h1 id="8、对日常系统的分析"><a href="#8、对日常系统的分析" class="headerlink" title="8、对日常系统的分析"></a>8、对日常系统的分析</h1><h2 id="8-1-建模的问题"><a href="#8-1-建模的问题" class="headerlink" title="8.1 建模的问题"></a>8.1 建模的问题</h2><p>从简单规则演化的角度思考很多系统的现象，似乎可以解释一些基础的问题。</p>
<h1 id="9、物理学的基础"><a href="#9、物理学的基础" class="headerlink" title="9、物理学的基础"></a>9、物理学的基础</h1><p>我们的宇宙看起来异常复杂，那么，我们的宇宙可能是由简单规则经过迭代产生吗？这本书的一个重要发现就是：复杂现象的成因不一定是复杂的。</p>
<p>值得注意的是，作者指出即使上面这个假设成立，这个系统并不具有可逆性，我们无法通过反向工程我们的宇宙找到对应的法则。</p>
<p>好，如果我们假设宇宙的演化可以由简单规则表达，那么我们如何找到这些规则？这些规则有什么特征？</p>
<p>细胞自动机可能不是一个好的选择，因为它的演化被限制在了一些格子里。。（也许这只是编码结构的不同而已，最终他们代表了相同的意义？）</p>
<p>作者对传统物理提出了挑战，他认为目前的物理定律并没有解释基础问题，而仅仅是规则在大尺度下的一些特征。换句话说，目前的物理定律，对解释基础物理毫无作用！</p>
<h2 id="空间的本质"><a href="#空间的本质" class="headerlink" title="空间的本质"></a>空间的本质</h2><p>物理学普遍认为空间是连续的，但是对于细胞自动机而言，他们的空间显然是离散的。</p>
<p>那么问题是：如何对这样的宇宙建模？</p>
<p>作者选择了用网络的形式表达空间。每一个节点具有三个连接。</p>
<h2 id="时间和空间的联系"><a href="#时间和空间的联系" class="headerlink" title="时间和空间的联系"></a>时间和空间的联系</h2><p>作者相信时间也是离散的。同样采用网络进行建模：因果网络。</p>
<h1 id="10、认知与分析"><a href="#10、认知与分析" class="headerlink" title="10、认知与分析"></a>10、认知与分析</h1><p>解释人类感知和分析能力。</p>
<h1 id="11、计算的语言"><a href="#11、计算的语言" class="headerlink" title="11、计算的语言"></a>11、计算的语言</h1><p>泛化的原细胞自动机。</p>
<h1 id="12、计算等价原则"><a href="#12、计算等价原则" class="headerlink" title="12、计算等价原则"></a>12、计算等价原则</h1><p>假设: 一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
<p>自从计算机诞生，计算的对象已经从抽象的数字发展到图像、声音等等。</p>
<p>从计算的角度看，即使具有截然不同的内部结构的系统仍然具有一定的等价性。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Computation</tag>
      </tags>
  </entry>
  <entry>
    <title>依靠耶和华的人必重新得力</title>
    <url>/2020/05/10/bible2/</url>
    <content><![CDATA[<h1 id="神的伟大"><a href="#神的伟大" class="headerlink" title="神的伟大"></a>神的伟大</h1><p>先知以赛亚在40章向以色列人描述了神的伟大。他用了一系列惊人的反问句，向人们展示了神的伟大。</p>
<p>首先是神的伟大自然力量：谁曾用掌心量过海水？用手掌测过苍天？用升斗量过大地？用秤称量过山岭？答案显然是没有人。物质世界在神的眼中不过是举手之间就能掌控的事情。</p>
<p>然后是神的奇妙智慧：谁曾测度耶和华的灵？谁做过他的谋士？谁使神有聪明？谁又曾经教导神明智的路？答案显然是没有人。神的拥有终极的智慧。</p>
<p>最后是神的伟大和人的渺小的对比：万国就像水桶中的一滴，就像天平上面的尘埃，万国在他眼中好像不存在，在他看来，只有乌有和虚空。</p>
<h1 id="偶像的懦弱"><a href="#偶像的懦弱" class="headerlink" title="偶像的懦弱"></a>偶像的懦弱</h1><p>你们把谁来跟神相比呢？你们用什么形象跟神并列呢？</p>
<p>你们铸造偶像来敬拜，可是这些偶像居然都不能自立，而需要人的维护才能得以站立。这也是必然的，因为所有被造之物都是必然会朽坏的，为有神的道是永恒长存的。“花必凋谢，草必枯干，唯有神的道永远长存！”</p>
<p>所以，我们为什么还是要依靠必然朽坏的东西呢？权利、金钱、地位、一份体面的工作，这些东西终究都是靠不住的，如果我们依靠这些东西，就是我们依靠必然朽坏的偶像，最终我们什么也得不到。</p>
<h1 id="神才是人唯一的依靠"><a href="#神才是人唯一的依靠" class="headerlink" title="神才是人唯一的依靠"></a>神才是人唯一的依靠</h1><p>只有神才是“靠得住”的，以为他的伟大和全能。更加令人兴奋的是，神虽然伟大，但是他在乎我们这些“草芥”一般的人，他珍惜我们这些人类，以为我们是按照神的形象所造的。</p>
<p>28你不知道吗？你没有听过吗？<br>永在的　神、耶和华、地极的创造主既不疲乏，也不困倦；<br>他的知识无法测度。<br>29疲乏的，他赐气力，<br>无力的，他加力量。<br>30就是年轻人也会疲乏困倦，<br>强壮的人也会全然跌倒。<br>31但那些仰望耶和华的人，<br>必重新得力；<br>他们必像鹰一样展翅上腾；<br>他们奔跑，也不困倦，<br>他们行走，也不疲乏。</p>
<h1 id="诗篇121的鼓励"><a href="#诗篇121的鼓励" class="headerlink" title="诗篇121的鼓励"></a>诗篇121的鼓励</h1><p>最后，我附上来自诗篇的鼓励，耶和华 神是我们唯一的依靠。</p>
<p>朝圣之歌<br>1我要向群山举目，<br>我的帮助从哪里来呢？<br>2我的帮助是从<br>造天地的耶和华而来。<br>3他必不使你的脚滑倒；<br>保护你的必不打盹。<br>4看哪！保护以色列的，<br>必不打盹，也不睡觉。<br>5保护你的是耶和华，<br>耶和华在你的右边荫庇你。<br>6白天太阳必不伤你，<br>夜里月亮必不害你。<br>7耶和华要保护你脱离一切灾祸，<br>他要保护你的性命。<br>8你出你入，耶和华要保护你，<br>从现在直到永远。</p>
<p>平安。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
        <tag>诗篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph - DiGraph</title>
    <url>/2020/05/09/graph3_digraph/</url>
    <content><![CDATA[<h1 id="1-Concepts"><a href="#1-Concepts" class="headerlink" title="1. Concepts"></a>1. Concepts</h1><p><strong>Definition.</strong> A <code>directed graph</code> or <code>digraph</code> is a set of nodes and a<br>collection of <code>directed edges</code>. Each directed edge connects an ordered<br>pair of nodes.</p>
<p><strong>Definition.</strong> A <code>directed path</code> is a path in a digraph is a sequence of nodes in which there is a directed edge pointing from each node in the sequence to its successor in the sequence. A <code>directed cycle</code> is a directed path with at least one edge whose first and last nodes are the same. A <code>simple cycle</code> is a cycle with no repeated edges or nodes. The <code>length</code> of a path is its number of edges.</p>
<p>With above, we can define that a node a is reachable from node b if there is a directed path from a to b. </p>
<h1 id="2-Data-Structure"><a href="#2-Data-Structure" class="headerlink" title="2. Data Structure"></a>2. Data Structure</h1><p>Again, before we go to the algorithms of DiGraph, let’s define our data structure representation of digraph. Full code can be found here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py</a>.</p>
<p>Here I list the important part. DiGraph is a bit different from Undirected graph in terms of its internal data containers. DiGraph has not only <code>_adj</code> for adjacent list, but also has <code>_succ</code> and <code>_pred</code> which is used to represent the direction of edges. What’s more, there is a <code>reverse</code> function to reverse the direction of the edges in the graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Hashable</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygraph.entities.graph <span class="keyword">import</span> GraphBase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span>(<span class="params">GraphBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dict_dict_dict = <span class="built_in">dict</span></span><br><span class="line">    dict_dict = <span class="built_in">dict</span></span><br><span class="line">    node_factory = <span class="built_in">dict</span></span><br><span class="line">    edge_factory = <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(kwargs)</span><br><span class="line">        self._succ = self._adj</span><br><span class="line">        self._pred = self.dict_dict_dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node: Hashable, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Add node to graph,</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :param kwargs: node&#x27;s meta data</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node] = self.dict_dict()</span><br><span class="line">            self._pred[node] = self.dict_dict()</span><br><span class="line">            attr_dict = self._nodes[node] = self.node_factory()</span><br><span class="line">            attr_dict.update(kwargs)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># already existed</span></span><br><span class="line">            self._nodes[node].update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span>(<span class="params">self, node_a: Hashable, node_b: Hashable, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; add edge to graph</span></span><br><span class="line"><span class="string">        :param node_a:</span></span><br><span class="line"><span class="string">        :param node_b:</span></span><br><span class="line"><span class="string">        :param kwargs: meta data for edge, weights can go here!</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node_a <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_a] = self.dict_dict()</span><br><span class="line">            self._pred[node_a] = self.dict_dict()</span><br><span class="line">            self._nodes[node_a] = self.node_factory()</span><br><span class="line">        <span class="keyword">if</span> node_b <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_b] = self.dict_dict()</span><br><span class="line">            self._pred[node_b] = self.dict_dict()</span><br><span class="line">            self._nodes[node_b] = self.node_factory()</span><br><span class="line"></span><br><span class="line">        data = self._adj[node_a].get(node_b, self.edge_factory())</span><br><span class="line">        data.update(kwargs)</span><br><span class="line">        self._succ[node_a][node_b] = data</span><br><span class="line">        self._pred[node_b][node_a] = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj_nodes</span>(<span class="params">self, node: Hashable</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; find adj nodes view</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._succ[node]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self</span>) -&gt; GraphBase:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; reverse the graph &quot;&quot;&quot;</span></span><br><span class="line">    gp = self.__class__()</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> self.nodes:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> self._adj[a]:</span><br><span class="line">            gp.add_edge(b, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gp</span><br></pre></td></tr></table></figure>

<h1 id="3-Problems"><a href="#3-Problems" class="headerlink" title="3. Problems"></a>3. Problems</h1><p>Ok, let’s visit some of the problems around DiGraph:</p>
<ul>
<li>Single-source reachability</li>
<li>Topological sort</li>
<li>Strong connectivity</li>
</ul>
<p>These problem is similar to what we have in <a href="https://wangzhe3224.github.io/2020/05/02/graph2_search/">undirected graph</a>. </p>
<h2 id="3-1-Single-source-reachability"><a href="#3-1-Single-source-reachability" class="headerlink" title="3.1 Single-source reachability"></a>3.1 Single-source reachability</h2><blockquote>
<p>Given a digraph and a source node <em>a</em>, support query of the form: Is there a directed path from <em>a</em> to a given node <em>x</em>?</p>
</blockquote>
<p>This problem is solved using the same function as in undirected graph. Both single-source directed path(DFS) and shortest directed path (BFS).</p>
<p>Related code: <a href="https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos">https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos</a></p>
<h2 id="3-2-Topological-sort"><a href="#3-2-Topological-sort" class="headerlink" title="3.2 Topological sort"></a>3.2 Topological sort</h2><p>This is a scheduling problem. Defines:</p>
<blockquote>
<p>Given a digraph, put the nodes in order such that all its directed edges point from a node earlier in the order to a node later in the order. Or does not exist. </p>
</blockquote>
<p>In order to solve this, we first need to make sure, there is no cyclic in the graph. or make sure the graph a DAG, directed acyclic graph. <strong>So first we need a algorithm to detect cyclic in a graph.</strong></p>
<p>The solution is leverage DFS’s stack, one fact is that all the node in current stack is in the same path, of we find a node that appear twice in the stack, we know there is a cyclic, hence graph is not a DAG.</p>
<p>Once we know we have a DAG, the next job is to find the order. It turns out that it is another application of DFS.</p>
<h2 id="3-3-Strong-connection"><a href="#3-3-Strong-connection" class="headerlink" title="3.3 Strong connection"></a>3.3 Strong connection</h2><p>Strong connection between a and b is that they are mutually reachable. </p>
<p>The solution is similar to cyclic detection in undriected graph, but we need loop through reverse post order in previous section. </p>
<p>Check code here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28</a></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Python</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph Algorithms - Search</title>
    <url>/2020/05/02/graph2_search/</url>
    <content><![CDATA[<p>When working with graph, search is an important topic. For example, search for connectivity, search for shortest path. There are two basic strategies to do search in graph: Depth-first(DFS) and Breadth-first(BFS). <strong>Note that in this blog, all the discussions are based on undirected graph</strong>. But the strategy can be used to all kind of graphs given they share similar data structures.</p>
<h1 id="What-kind-of-problems-we-are-solving"><a href="#What-kind-of-problems-we-are-solving" class="headerlink" title="What kind of problems we are solving?"></a>What kind of problems we are solving?</h1><p>The basic idea of search in general is to walk through the data structure and collection information we need. In terms of Graph, only two elements matters: nodes (vertices) and edges. Walking through a graph, really means iterating the nodes in a way.</p>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>The next questions to ask is that how can I solve a question by looping through the least nodes? Well to answer this question, we need to decide a data structure to represent graph. </p>
<p>Here we select a straight forward way: adjacent list. Completed code can be found <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/graph.py">here</a></p>
<p>Essentially, we use dict of dict to represent nodes, and dict of dict of dict to represent adjacent list. I know.. it is not a list at all. But the idea is the same, the benefit of using a dict is that it is very easy to embed meta data to either nodes or edges. And it is an easy way to extend this data structure to other types of graph, say weighted graph. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span>(<span class="params">Graph</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    dict_dict_dict = <span class="built_in">dict</span></span><br><span class="line">    dict_dict = <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">        self.__adj = self.dict_dict_dict()  <span class="comment"># dict of dict of dict</span></span><br><span class="line">        self.__nodes = self.dict_dict()  <span class="comment"># dict of dict</span></span><br></pre></td></tr></table></figure>

<p>And.. in the end, dict (hash map) is just a list with hashable index instead of int as index. Or in another words, dict is just a generalized list… alright.. too far away. :smirk: </p>
<p>For example, we can represent graph: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 2 - 3</span><br><span class="line">    |</span><br><span class="line">    4</span><br></pre></td></tr></table></figure>

<p>with following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__adj &#x3D; &#123;1: &#123;2: &#123;&#125;&#125;, 2:&#123;3:&#123;&#125;, 4:&#123;&#125;&#125;, 3:&#123;2:&#123;&#125;&#125;, 4:&#123;2:&#123;&#125;&#125;&#125;</span><br><span class="line">__nodes &#x3D; &#123;1:&#123;&#125;, 2:&#123;&#125;, 3:&#123;&#125;, 4:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Search-strategy"><a href="#Search-strategy" class="headerlink" title="Search strategy"></a>Search strategy</h1><p>Ok, we got our little dict(s), the next question is how can we search or walk through this structure? Well when we meet the first node, there are two obvious ways: 1. go to one of its adjacent node and go even deeper via that node. 2. go to all of its adjacent nodes and do the same for other nodes. </p>
<p>The first way is called depth-first, the second is called breadth-first.</p>
<p>Apperently they have different properties.</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><p>For detailed code, please go <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py</a></p>
<p>We can prove that DFS marks all the nodes connected to a given node in time proportional to the sum of their degrees.</p>
<p>Recall <code>degree of a node</code> is the number of nodes connected to it directly. </p>
<p>This strategy is efficient in may problems:</p>
<ul>
<li>Given a graph, are two given nodes are connected? This question, is equivalent to ask, given two nodes, is there a path from node a to b? if so, find me the path (in terms of sequence of nodes of course)!</li>
<li>How many connected components does the graph have?</li>
</ul>
<p>All right, let’s try to solve a find path problem using DFS.</p>
<p>Here is one question: given a graph, node a, calculate <em>one</em> path between a and the rest of the nodes, if no path, return None.</p>
<p>So let’s start with a recursive way, which is the nature of DFS. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_view</span>(<span class="params">nodes, edge_to: <span class="built_in">dict</span>, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; convert edge_to to path view &quot;&quot;&quot;</span></span><br><span class="line">    _paths = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> edge_to:  <span class="comment"># has a path</span></span><br><span class="line">            path = []</span><br><span class="line">            _<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">while</span> _<span class="built_in">next</span> != source:</span><br><span class="line">                path.append(_<span class="built_in">next</span>)</span><br><span class="line">                _<span class="built_in">next</span> = edge_to[_<span class="built_in">next</span>]</span><br><span class="line">            path.append(source)</span><br><span class="line">            _paths[node] = path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _paths[node] = <span class="literal">None</span>   <span class="comment"># no path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _path</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_path</span>(<span class="params">graph, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; get paths from source to other nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string">    Note: not all the path, but one of the path if exist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param graph: Graph</span></span><br><span class="line"><span class="string">    :param source: the source node</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#123;target: [source, x, x, node2]&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    edge_to = &#123;&#125;  <span class="comment"># magic path..</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs_path</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">        <span class="keyword">for</span> _node <span class="keyword">in</span> graph[start]:  <span class="comment"># all its neighbour</span></span><br><span class="line">            <span class="keyword">if</span> _node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(_node)</span><br><span class="line">            edge_to[_node] = start</span><br><span class="line">            _dfs_path(graph, _node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    _dfs_path(graph, source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, edge_to, source)</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><p>Breadth-first search use a different strategy from depth-first search. It will search all the connected nodes and do the same process to sub-nodes. While depth search will go down a path to the end.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_path</span>(<span class="params">graph, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; a breadth first search for paths. These suppose to be the shortest paths.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reference</span></span><br><span class="line"><span class="string">    ---------</span></span><br><span class="line"><span class="string">    &lt;Algorithms 4th edition&gt; by Robert Sedgewick. P540</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param source: a source node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _queue = deque([])</span><br><span class="line">    _visited = <span class="built_in">set</span>()</span><br><span class="line">    _queue.append(source)</span><br><span class="line">    _edge_to = &#123;source: source&#125;</span><br><span class="line">    <span class="keyword">while</span> _queue:</span><br><span class="line">        cur_node = _queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[cur_node]:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> _visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            _visited.add(cur_node)</span><br><span class="line">            _edge_to[child] = cur_node</span><br><span class="line">            _queue.append(child)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, _edge_to, source</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Python</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph basics - 1 Concepts</title>
    <url>/2020/04/25/graph1/</url>
    <content><![CDATA[<p>Graph is a mathematical object to model pairwise connections between objects. There are a lot of applications:</p>
<p><img data-src="https://i.imgur.com/aDYbUMC.png" alt="Typical graph applications"></p>
<span id="more"></span>

<h1 id="1-Definitions"><a href="#1-Definitions" class="headerlink" title="1. Definitions"></a>1. Definitions</h1><p>Definition: </p>
<ul>
<li>A <code>graph</code> is a set of vertices and a collection of edges that each connect a pair of vertices.</li>
<li>A <code>Bipartite graph</code> is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set.</li>
</ul>
<p>Definition: </p>
<ul>
<li>A <code>path</code> in a graph is a sequence of vertices connected by edges. </li>
<li>A <code>simple path</code> is one with no repeated vertices. </li>
<li>A <code>cycle</code> is a path with at least one edge whose first and last vertices are the same.</li>
<li>A <code>simple cycle</code> is a cycle with no repeated edges or vertices.</li>
<li><em>length</em> of a path or cycle is its number of edges.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A graph is <code>connected</code> if there is a path from every vertex to every other vertex in the graph.</li>
<li>A graph is <code>not connected</code> consists of a set of connected <code>components</code>, which are maximal connected subgraphs. </li>
<li>An <code>acyclic</code> graph is graph without cycles.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A <code>tree</code> is an <code>acyclic connected</code> graph.</li>
<li>A disjoint set of trees is called a <code>forest</code>.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>The <code>density</code> of a graph is the proportion of possible pairs of vertices that are connected by edges.</li>
</ul>
<p><img data-src="https://i.imgur.com/goP5flX.png" alt="Anatomy of a graph"></p>
<p><img data-src="https://i.imgur.com/RHAkNfF.png" alt="A tree"></p>
<p><img data-src="https://i.imgur.com/zRy67JE.png" alt="A forest"></p>
<h1 id="2-Graph-Interface"><a href="#2-Graph-Interface" class="headerlink" title="2. Graph Interface"></a>2. Graph Interface</h1><p>We now need to define fundamental graph operation interface and find a data structure to represent undirected graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Vertex &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Edge &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphOperation</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Graph operation interface &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span>(<span class="params">v: Vertex, m: Vertex</span>)-&gt;<span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj</span>(<span class="params">v: Vertex</span>) -&gt; []:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; find adjacent to v &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">degree</span>(<span class="params">v: Vertex</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; get degree of &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_self_loops</span>() -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; number of self loops &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>In the end, most of the operations can be done via <code>adj</code> method. We could add more operations for graph, but it will depends on the application’s use case. </p>
<h1 id="3-Data-Structures"><a href="#3-Data-Structures" class="headerlink" title="3. Data Structures"></a>3. Data Structures</h1><p>There are several ways to represent graph, such as adjacent matrix, array of edges, and adjacent list. Here we select adjacent list because it makes <code>adj</code> method very simple and it will also be able to represent parallel edges whereas adjacent matrix cannot do.</p>
<p><code>adjacent list</code> representation has following characteristics:</p>
<ul>
<li>space usage is proportional to V + E</li>
<li>constant time to add an edge</li>
<li>constant time per adjacent vertex processed</li>
</ul>
<p>However, the order of adjacent vertex is random for now. We could add order for it (but add some time complex).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span>(<span class="params">GraphOperation</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;  &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>():</span></span><br><span class="line">        self.__adj_list = []  <span class="comment"># type: <span class="type">List</span>[Vertex]</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.imgur.com/G0aulAp.png" alt="Adjacent list representation"></p>
<h1 id="4-Design-Pattern-of-graph-processing"><a href="#4-Design-Pattern-of-graph-processing" class="headerlink" title="4. Design Pattern of graph processing"></a>4. Design Pattern of graph processing</h1><p>The idea here is to delegate more complex operations from Graph interface, such as search connected vertex, find path or find shortest path.</p>
<p>Common algorithms:</p>
<ul>
<li>search connected vertex</li>
<li>find paths</li>
<li>find shortest path</li>
<li>is connected components?</li>
<li>is a acylic graph?</li>
<li>is graph bipartite?</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Risk Is Right</title>
    <url>/2020/04/22/risk_is_right/</url>
    <content><![CDATA[<h1 id="Risk-is-right"><a href="#Risk-is-right" class="headerlink" title="Risk is right"></a>Risk is right</h1><p>Author: John Piper<br>Subtitle: Better to Lose Your Life Than to Waste It</p>
<h2 id="0-Preface"><a href="#0-Preface" class="headerlink" title="0 Preface"></a>0 Preface</h2><p>In Matthew 13:44 Jesus tells his disciples, “The kingdom of heaven is like treasure hidden in a field, which a man found and covered up. Then in his joy he goes and sells all that he has and buys that field.”</p>
<h2 id="1-The-ultimate-meaning-of-life"><a href="#1-The-ultimate-meaning-of-life" class="headerlink" title="1 The ultimate meaning of life"></a>1 The ultimate meaning of life</h2><blockquote>
<p>It is my eager expectation and hope that I will not be at all ashamed, but that with full courage now as always Christ will be honored in my body, whether by life or by death. For to me to live is Christ, and to die is gain. (Phil. 1:20–21)</p>
</blockquote>
<p>The universe was created for this—making much of Christ. Paul says as much in Colossians 1:16: “All things were created through him and for him.” <strong>For him</strong>.</p>
<p>So make much of Christ is our meaning as well, the same as the universe. </p>
<span id="more"></span>

<h2 id="2-What-is-risk"><a href="#2-What-is-risk" class="headerlink" title="2 What is risk?"></a>2 What is risk?</h2><blockquote>
<p>If our single, all-embracing passion is to make much of Christ in life and death, and if the life that magnifies him most is the life of costly love, then life is risk, and risk is right. To run from it is to waste your life.</p>
</blockquote>
<blockquote>
<p>This means that God can take no risks. He knows the outcome of all his choices before they happen. This is what it means to be God over against all the gods of the nations (Isa. 41:23; 42:8–9; 44:6–8; 45:21; 46:8–11; 48:3).</p>
</blockquote>
<p>There is noting in this world we really have. If you think our life is full of uncertainty (Risk). But God take NO risk! He is the safest place for us.</p>
<p>There is no one in this world, can gurantee us anything for sure. But God do.</p>
<h2 id="3-Stories-of-risk-in-the-old-testament"><a href="#3-Stories-of-risk-in-the-old-testament" class="headerlink" title="3. Stories of risk in the old testament"></a>3. Stories of risk in the old testament</h2><blockquote>
<p>May the lord do what seems good to him</p>
</blockquote>
<p>2 Samuel 10.</p>
<blockquote>
<p>If I perish, I perish</p>
</blockquote>
<p>Esther. 4:15-16</p>
<blockquote>
<p>We will not serve your Gods</p>
</blockquote>
<p>Dan. 3:16–18</p>
<h2 id="4-The-great-risk-taker-in-the-new-testament"><a href="#4-The-great-risk-taker-in-the-new-testament" class="headerlink" title="4. The great risk taker in the new testament"></a>4. The great risk taker in the new testament</h2><p>Paul. </p>
<p>为神做功是跟神同工的荣耀。</p>
<h2 id="6-Right-and-wrong-reason-to-risk"><a href="#6-Right-and-wrong-reason-to-risk" class="headerlink" title="6. Right and wrong reason to risk"></a>6. Right and wrong reason to risk</h2><p>Risk not for Christ is simply wrong.. and expect short term success is wrong reasong as well. </p>
<h2 id="7-The-foundation-of-risk"><a href="#7-The-foundation-of-risk" class="headerlink" title="7. The foundation of risk"></a>7. The foundation of risk</h2><blockquote>
<p><strong>Who shall separate us from the love of Christ?</strong> Shall tribulation, or distress, or persecution, or famine, or nakedness, or danger, or sword? As it is written, “For your sake we are being killed all the day long; we are regarded as sheep to be slaughtered.” No, in all these things we are more than con- querors through him who loved us. For I am sure that nei- ther death nor life, nor angels nor rulers, nor things present nor things to come, nor powers, nor height nor depth, nor anything else in all creation, will be able to separate us from the love of God in Christ Jesus our Lord.</p>
</blockquote>
<p>Does God give us what we need? Well yes, but we must be very clear on what we really need. It is love from God.</p>
<h2 id="8-The-far-end-of-risk"><a href="#8-The-far-end-of-risk" class="headerlink" title="8. The far end of risk."></a>8. The far end of risk.</h2><p>The bottom-line comfort and assurance in all our risk taking<br>for Christ is that nothing will ever separate us from the love<br>of Christ.</p>
<p>Even we think the worst case of a risk: death.. God has defeat it… So… </p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Bible</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Systematic Trading</title>
    <url>/2020/04/21/systematic_trading/</url>
    <content><![CDATA[<h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><h3 id="Layer-1-Read"><a href="#Layer-1-Read" class="headerlink" title="Layer 1 Read"></a>Layer 1 Read</h3><p>作者退休前是AHL的基金经理，经历过2008年的股灾。</p>
<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
<h3 id="Layer-2-Read"><a href="#Layer-2-Read" class="headerlink" title="Layer 2 Read"></a>Layer 2 Read</h3><ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
<h3 id="Layer-3-read-精读感兴趣的地方，甚至动手操作。"><a href="#Layer-3-read-精读感兴趣的地方，甚至动手操作。" class="headerlink" title="Layer 3 read: 精读感兴趣的地方，甚至动手操作。"></a>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</h3><span id="more"></span>

<h2 id="Part-I-theory"><a href="#Part-I-theory" class="headerlink" title="Part I: theory"></a>Part I: theory</h2><h3 id="Cognitive-bias"><a href="#Cognitive-bias" class="headerlink" title="Cognitive bias"></a>Cognitive bias</h3><ol>
<li>hard to admit failure</li>
<li>happy to be confirmed</li>
<li>overconfident</li>
</ol>
<blockquote>
<p>what makes an addictive game:</p>
<ol>
<li>an illusion of control</li>
<li>frequent changes of <em>Almost</em> win big</li>
<li>rapid and continous to give a constant flow of stimulation</li>
</ol>
</blockquote>
<p>if we know most of player has these bias, we can leverage them by apply trading rules to remove our own bias.</p>
<h3 id="Good-system-design"><a href="#Good-system-design" class="headerlink" title="Good system design"></a>Good system design</h3><ul>
<li>objective</li>
<li>easiy to explain/understand</li>
<li>avoid over-fitting</li>
<li>avoid over-trading</li>
<li>avoid over-betting</li>
</ul>
<h3 id="What-makes-good-trading-rule"><a href="#What-makes-good-trading-rule" class="headerlink" title="What makes good trading rule"></a>What makes good trading rule</h3><ul>
<li>Risk prem</li>
<li>Skew trading</li>
<li>Leverage</li>
<li>Liquidity</li>
<li>Correlation</li>
</ul>
<blockquote>
<p>I also believe finding the best trading rules is less important than designing your trading system in the correct way.</p>
</blockquote>
<h2 id="Part-II-toolbox"><a href="#Part-II-toolbox" class="headerlink" title="Part II: toolbox"></a>Part II: toolbox</h2><h3 id="Fitting"><a href="#Fitting" class="headerlink" title="Fitting"></a>Fitting</h3><ol>
<li>Come up with a small number of trading rules to exploit each idea I have about how the market behaves.</li>
<li>For each rule select a few variations. At this stage I am not looking at performance, but at behaviour such as trading speed and correlation with other variations.</li>
<li>Allocate forecast weights to each variation, taking uncertainty about Sharpe ratios into account. Poor rules will have lower weight, but are rarely entirely excluded.</li>
</ol>
<p><strong>Select rules from different themes</strong></p>
<ul>
<li>trend following</li>
<li>carry </li>
</ul>
<p>Some points:</p>
<ul>
<li>So diversification amongst instruments is preferable to rule diversification, Adding new instruments is a tiresome task of uploading and checking data which is less fun than coming up with more trading rules, but in my experience is of far more benefit.</li>
</ul>
<h3 id="Portfolio-Allocation"><a href="#Portfolio-Allocation" class="headerlink" title="Portfolio Allocation"></a>Portfolio Allocation</h3><ul>
<li>Forecast weights</li>
<li>Instrument weights</li>
</ul>
<p>The goal here is given some constrains to produce allocation weights on underlyings (instruments or trading rules).</p>
<p>Portfolio allocation should be tool to control risk, leverage divercification. Optimizaion is good but only when result is still reasonable in terms of diversification. </p>
<p><strong>question:</strong> how can we quantify diversification?</p>
<h2 id="Part-III-framework"><a href="#Part-III-framework" class="headerlink" title="Part III: framework"></a>Part III: framework</h2><h3 id="Framework-overview"><a href="#Framework-overview" class="headerlink" title="Framework overview"></a>Framework overview</h3><p>Components:</p>
<ul>
<li>Instruments to trade</li>
<li>Forecasts</li>
<li>Combine forecast</li>
<li>Volatility targeting</li>
<li>Portfolio</li>
<li>Speed and Size for all</li>
</ul>
<h3 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h3><p><img data-src="https://i.imgur.com/v9TZ5ds.png" alt=""></p>
<h3 id="Forecasts"><a href="#Forecasts" class="headerlink" title="Forecasts"></a>Forecasts</h3><ul>
<li>Forecast should be a scale not binary</li>
<li>Should be vol adjusted</li>
<li>Should be consisten in scale</li>
<li>Forecast should be capped</li>
</ul>
<p><img data-src="https://i.imgur.com/aTjsVtr.png" alt=""></p>
<p>The process works as following:</p>
<p>$$<br>signal = cap({raw} / vol * scalar, up_limit, floor_limit)<br>$$</p>
<p>where,<br>$raw$ is raw signal,<br>$vol$ is volatility estimation of underly asset(s),<br>$scalar$ is an enstimation number to scale the signal to a range, say -20~+20<br>$cap(.)$ is a function that cap the signal to $up_limit, floor_limit$ </p>
<h3 id="Combined-Forecasts"><a href="#Combined-Forecasts" class="headerlink" title="Combined Forecasts"></a>Combined Forecasts</h3><p>The purpose is that given more than 1 signals for 1 instrument (can be extented to multiple instruments), we need a function to aggregate thme. $fweight$ or forecast weights estimation is at the core of this stage. And they should all be positive and<br>add up to 100%.</p>
<p><strong>Next question is how to choose an fweights given several signals?</strong></p>
<p>To answer this, portfolio construction method is useful, although the underlyings here is signals not assets. And correlation of signal return (NOTE: not performance) are needed in order to come up with weights. Several level (say, 2 levels) of grouping is useful, if you have several types of signals, and each of them has several variances. </p>
<p>$$raw_combined = f(corr, raw_signals)$$</p>
<p>There is another concept is needed: forcast diversification multiplier, FDM. The reason is that we want to maintian the scale level of combined signal as same as scale level as individiual signals. When the signals are not perfectly correlated, the raw weighted combination will always results in a lower scale level. So we need a multiplier to scale it back.</p>
<p>Agian, correlation is important here:</p>
<p>$$FDM = target_vol / portfolio_vol$$</p>
<p>NOTE: it is better to cap this formula as well to avoid large multiplier. </p>
<p>Again, after FDM, the signal level should be capped to 20, as we always do. (20 is just standard we selected, it needs to be consistent.)</p>
<p>So in the end:</p>
<p>$$<br>combined_signal = cap(raw_combined * FDM, -20, 20)$$</p>
<p><img data-src="https://i.imgur.com/xMt7Oll.png" alt=""></p>
<h3 id="Vol-targeting"><a href="#Vol-targeting" class="headerlink" title="Vol targeting"></a>Vol targeting</h3><p>The end result of this is just float, which is a overall volatility target you want to achieve. In another word, a parameter in the system, that will be used across the system. </p>
<p>There are two ways:</p>
<ul>
<li>vol in pct</li>
<li>vol in cash value</li>
</ul>
<h3 id="Position-sizing"><a href="#Position-sizing" class="headerlink" title="Position sizing"></a>Position sizing</h3><p>In this stage, the task is to work out how scaled position, like how may shares (no rounding yet),given vol target and combined signal for one instrument. Note that, here we assumed that all the capital will be allocated to one instrument.</p>
<p>To achieve this, the first quesitons: if I am holding 1 share/unit of this instrument, how much rish am I exposed to in terms of cash?</p>
<p>To answer that question, we define <strong>block value</strong> as: when holding 1 unit of instrument, the cash value movement when the price of the instrument moves 1%. In this way, a connection between cash value movement and price quote movement is built. Then we just need to figure out the prive volatility. </p>
<p>Bad news, estimation of volatility is not that easy.. </p>
<p>What’more, if you are holding multiple currency, it is better to convert cash value movement into base currency.</p>
<p>Now, without considering forecast, assume we put all the capital into one instrument, and want to achieve a cash volatility, we need a <strong>volatility scalar</strong>.</p>
<p>$$vol_scalar = tartet_cash_risk / block_value$$</p>
<p>Above vol scalar is associated to a average signal level 10, so the final position will be:</p>
<p>$$pos_sub = signal_level * vol_scalar<br>$$</p>
<h3 id="Portfolio"><a href="#Portfolio" class="headerlink" title="Portfolio"></a>Portfolio</h3><p>Finally, it is time to put all sub system above into a portfolio. Out of this, we will work out exactly how much units of each instruments we need to fill. In other words, generate a target position in terms of units (rounded).</p>
<p>The concept here is as same as in Combine Forecasts, except that the underlyings are now correlation between sub systems, instead of instruments.</p>
<blockquote>
<p>A good approximation is that the correlation between subsystem returns will be 0.70 of the correlation of instrument returns. So if two assets have a correlation of 0.5 between their instrument returns in appendix C, then their subsystems will have a correlation of 0.7 × 0.5 = 0.35.</p>
</blockquote>
<p>Note that, similar to FDM, an Instrument diversification multiplier, IDM, is needed here to avoid low resulting vol.</p>
<p>By this step, the positions are still fractional. Before we decide how much to trade, we need a buffer (position inertia) to avoid back forward small trade because of rounding. For the sake of reducing trading cost.</p>
<h3 id="Speed-and-size"><a href="#Speed-and-size" class="headerlink" title="Speed and size"></a>Speed and size</h3><p>Now, we have system to trade, the next question is that how to config the system? For example, what kind of predicor should I used? what kind of instrument should I trade? What target vol should I select?</p>
<h4 id="Caluclate-cost-of-trading"><a href="#Caluclate-cost-of-trading" class="headerlink" title="Caluclate cost of trading"></a>Caluclate cost of trading</h4><p>Types of cost:</p>
<ul>
<li>execution cost</li>
<li>mamangement fee for ETFs</li>
</ul>
<p>Agian, the costs of different instruments should be normalized to be compared. </p>
<p>$$ norm_cost = (2*C) / (16 * ICV)<br>$$</p>
<p>where,<br>$C$ is cost to trade 1 unit in currency C,<br>$ICV$ is daily instrument currency volatility.  </p>
<p>Note that 16 is for tha annulized vol. $norm_cost$ has the same unit as Sharpe ratio. So it is easy to compare the cost effect with the strategy sharpe ratio.</p>
<p>Some experience value of costs:</p>
<ul>
<li>Futures: 0.001</li>
<li>Spread betting: 0.01</li>
<li>ETF: 0.08</li>
</ul>
<h3 id="Turnover"><a href="#Turnover" class="headerlink" title="Turnover"></a>Turnover</h3><p>Now we need to measure how qucikly you trade. The number of round trips per year is the turnover. </p>
<p>A norm cost times turnover inshares, it is the final cost, in the same unit as sharpe ratio.</p>
<h3 id="Determine-portfolio-size"><a href="#Determine-portfolio-size" class="headerlink" title="Determine portfolio size"></a>Determine portfolio size</h3><p>2 × volatility scalar × instrument weight × instrument diversification multiplier</p>
<h2 id="Part-IV-Practice"><a href="#Part-IV-Practice" class="headerlink" title="Part IV Practice"></a>Part IV Practice</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Systematic Trading: A unique new method for designing trading and investing systems</li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>很潮的属11和弦</title>
    <url>/2020/04/13/chord_2/</url>
    <content><![CDATA[<p>在我们想要结束一段的时候，通常会用V -&gt; I的方式结束。以下我们用C调说明。</p>
<p>比如，<code>G7 -&gt; C</code>:</p>
<p><img data-src="https://i.imgur.com/9DPfaZS.png" alt=""></p>
<span id="more"></span>
<p>但是，这种进行显得非常古典。我们可以通过采用属11和弦让进行听起来更加流行。比如<code>F/G</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;:[GFAc]</span><br></pre></td></tr></table></figure>

<p>这样我们的和声进行可以变成：</p>
<p><img data-src="https://i.imgur.com/JqqVIIH.png" alt=""></p>
<p>这个<code>F/G</code> 也可以理解成G11但是去掉3和5音，也就是缩减版本的属11和弦。</p>
<p><img data-src="https://i.imgur.com/pp6Q65K.png" alt=""></p>
<p>吉他版本的 <code>F/G</code> and <code>Cadd2</code>:</p>
<p><img data-src="https://i.imgur.com/vWQGych.png" alt=""> <img data-src="https://i.imgur.com/r4rnaoa.png" alt=""></p>
<p>也可以记成<code>G9sus</code></p>
<p><img data-src="https://i.imgur.com/dqPj7q1.png" alt=""></p>
<p>吉他版本的 <code>G9sus4</code> 和 <code>Cmaj9</code> : </p>
<p><img data-src="https://i.imgur.com/hGKcbVN.png" alt=""> <img data-src="https://i.imgur.com/kxEC3F9.png" alt=""></p>
<p>所以，总结一下：</p>
<p><img data-src="https://i.imgur.com/NCmERJy.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=EdT1xi4qtT4">https://www.youtube.com/watch?v=EdT1xi4qtT4</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Chord</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo拓展功能</title>
    <url>/2020/04/13/chord_3/</url>
    <content><![CDATA[<p>目前，<code>abcjs</code> 还不支持非浏览器环境的使用，所以，目前似乎没办法变成 Hexo Tag。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://dustinpfister.github.io/2018/01/03/hexo-plugins/">https://dustinpfister.github.io/2018/01/03/hexo-plugins/</a></li>
<li><a href="https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html">https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html</a></li>
<li><a href="https://hexo.io/api/">https://hexo.io/api/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>时间的开始：创世纪</title>
    <url>/2020/04/12/genesis_1/</url>
    <content><![CDATA[<h2 id="时间的开始"><a href="#时间的开始" class="headerlink" title="时间的开始"></a>时间的开始</h2><blockquote>
<p><strong>起初，神创造天地。</strong></p>
</blockquote>
<p>这就是创世纪的开始，也是时间的开始，我们的世界的开始。这句话的希伯来原文只有7个词，如下图（从右向左读）：</p>
<p><img data-src="https://i.imgur.com/ArszXVF.png" alt="1.1"></p>
<span id="more"></span>

<p>其中，第四个词是助词，没有实际含义。</p>
<p>第一个词，起初。意思就是时间的开始，在那之前没有时间。在那之后，时间有了意义，开始流淌。</p>
<p>第二个词，创造。这个词是单数动词，也就是说主语是单数。这个词在旧约圣经中出现过54词，其主语只有神，没有其他被造之物。而且，从未出现用某物创造另一物的说法，只有：神创造xxx，这一种用法。侧面说明，这是一种只有神才能做的、从无到有的过程。而非制造，既用一个东西创造另一个东西。</p>
<p>第三个词，神。这个词的是<code>Elohim</code>，是一个复数形式，代表神。不过，这个词的动词，创造，却是一个单数形式。说明，神是唯一的，但是神不是单数。这个概念是三位一体的体现，即神、灵和话语。我在后面进一步解释。</p>
<p>第五-七个词，天和地。其中，天是复数。在希伯来文化中，这种两极化的修辞方式很常见，天地既代表宇宙。比如，善和恶用来指代世界一切的事情。</p>
<blockquote>
<p><strong>地是空虚混沌，渊面黑暗；神的灵运行在水面上。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/svE2eaz.png" alt="1.2"></p>
<p>空虚混沌。空虚和混沌这两个次总是连在一起使用的，指荒凉的、不毛之地。但是，不是不存在或者无的状态。这也解释的通，因为神已经创造了天和地（即宇宙），物质已经被创造了。</p>
<p>渊，这个词是很多水或者海洋的意思。渊面黑暗，就是说黑暗笼罩在水上。但是，这是光和暗并没有分开，这里的黑暗，可能就是在光以前的状态。</p>
<p>灵，这个词有好多意思：风、心、灵、气息等。但是，这里就出现了神的第二个位格：灵。经文说，神的灵。</p>
<p>运行，是动词。但是，这个词的直接意思是，庇护、抚育。也就是说，神的灵运行在这水上，主观上乃是为了呵护这个创造。</p>
<p>或者说，神尤其爱护这个创造。而这句话显然已经从对宇宙的创造转到对某颗星球的关注，神特别关注这颗星球（就是地球）。</p>
<blockquote>
<p><strong>神说：『要有光』，就有了光。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/kCFamMh.png" alt="1.3"></p>
<p>说，是动词。神通过“说话”，继续他的创造。神的话语，有创造的能力。这是神的第三个位格，即道。至此，神的三个位格：神、灵、道都出现了。</p>
<blockquote>
<p><strong>神看光是好的，就把光暗分开了。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/H9B6Qza.png" alt="1.4"></p>
<p>神看光是好的，他就“分开”光和黑暗。这种分别，就是秩序的表现，神通过分别把秩序带入宇宙。</p>
<blockquote>
<p><strong>神称光为『昼』，称暗为『夜』。有晚上，有早晨，这是头一日。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/QfudTNp.png" alt=""></p>
<p>称，就是命名。在希伯来文化中，命名就象征这对该物的主权。</p>
<p>接下来，神继续通过话语进行他的创造，直到：</p>
<blockquote>
<p><strong>神就照着自己的形象造人，乃是照着祂的形象造男造女。</strong></p>
</blockquote>
<p>神的创造达到了高峰，人。神说：</p>
<blockquote>
<p><strong>神看着一切所造的都甚好。有晚上，有早晨，是第六日。</strong></p>
</blockquote>
<p>他认为人的出现，才让他的创造达到了更好！</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>创世纪用2节经文描述了宇宙的诞生，看起来轻描淡写，却道出了真谛：</p>
<ol>
<li>物质世界是被创造的，有开始</li>
<li>神用话语创造，用圣灵陪伴世界</li>
</ol>
<p>我认为神用这样的方式启示世界的开始充满智慧，没有很多细节，因为那些细节可能远远超过当代科学的认知，更何况是千年以前的人类？</p>
<p>换一个角度，神这么轻描淡写宇宙的创造，却花了很多时间在地球的创造，他用了整本圣经描述地球上神和人的关系。这难道不是说明神更加在乎人吗？就像刚才的经文提到，神经历了“6天”的创造，直到人的出现，他才说极好！而且，他就进入了第七日，就是安息，也就是停止了他的创造！</p>
<p>人，就是神创造的最高峰，乃至整个宇宙的创造跟这个相比都不值一提。甚至，宇宙的出现就是为了人的出现。神是多么的重视人类，多么的爱这人类，他精心设计宇宙让人可以生存，可以跟他同在。</p>
<p>然而，人，还是选择了堕落，离开爱人的神，选择犯罪，自己做神。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>但是神对人的爱没有改变，即使是犯罪的人类，他也要带回他们。而代价是：从创世之初与他同在的话语，道成肉身，受死救赎。正是耶稣的死而复活，重新打开了人与神的通路。</p>
<p>关于人类的未来，已经记录在圣经的最后一本书中《启示录》。</p>
<p>创世记前三章起头的每一件事情，到了《启示录》最后三章，都有了最终的结局：</p>
<ol>
<li>创世记：神创造天地（创一1-31）；启示录：神结束旧造，重造新天新地（启二十11；二十一1、5）。</li>
<li>创世记：神按自己的形象造人（创一26-27）；启示录：人被恢复成神的儿子（启二十一4）。</li>
<li>创世记：神所造的是有灵的活人（创二7）；启示录：人在神面前可以活到永永远远（启二十二5）。</li>
<li>创世记：神设立伊甸园（创二8）；启示录：神建造新耶路撒冷（启二十一2）。</li>
<li>创世记：伊甸园里有一条河分为四道，滋润园子（创二10）；启示录：新耶路撒冷有一道生命水的河，供应生命（启二十二1）。</li>
<li>创世记：伊甸园里有一棵生命树（创二9）；启示录：生命树遍布生命水的河两岸（启二十二2）。</li>
<li>创世记：人在伊甸园有一份很有前途的工作（创二15）；启示录：人在新耶路撒冷重新找到了一份更有前途的工作（启二十二3、5）。</li>
<li>创世记：头一个亚当的婚姻（创二22-25）；启示录：末后的亚当的婚姻（启二十一2）。</li>
<li>创世记：撒但诱惑人（创三1-5）；启示录：撒但被扔在火湖里（启二十10）。</li>
<li>创世记：罪进入世界（创三6-7）；启示录：罪从世界被消除（启二十一27）。</li>
<li>创世记：人躲避神的面（创三8）；启示录：人要见神的面（启二十二4）。</li>
<li>创世记：神呼喊、寻找失落的人（创三9）；启示录：神找回了失丧的人，亲自与人同住（启二十一3）。</li>
<li>创世记：咒诅临到受造之物（创三14-19）；启示录：以后再没有咒诅（启二十二3）。</li>
<li>创世记：死亡、悲哀进入世界（创三16、19）；启示录：不再有死亡、悲哀（启二十一4）。</li>
<li>创世记：人被逐出伊甸园，失去了产业（创三23）；启示录：人重返新耶路撒冷，承受这些为业（启二十一7；二十二3-5）。</li>
<li>创世记：人失去了生命树的分（创三24）；启示录：人重享生命树的分（启二十二2、14）。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://cmcbiblereading.com/2015/01/26/%e5%88%9b%e4%b8%96%e8%ae%b0%e7%ac%ac1%e7%ab%a0%e9%80%90%e8%8a%82%e6%b3%a8%e8%a7%a3%e3%80%81%e7%a5%b7%e8%af%bb/">圣经综合解读</a></li>
<li><a href="http://hebrew.fhl.net/genesis/gen1.html">http://hebrew.fhl.net/genesis/gen1.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>创世纪</tag>
      </tags>
  </entry>
  <entry>
    <title>如何“冥想”圣经</title>
    <url>/2020/04/08/think/</url>
    <content><![CDATA[<h1 id="如何“冥想”圣经？"><a href="#如何“冥想”圣经？" class="headerlink" title="如何“冥想”圣经？"></a>如何“冥想”圣经？</h1><p>冥想的目的并不是放空自己，而是充实自己的头脑。特别在针对圣经的冥想时候，因该让神的话语充满自己。冥想最核心的要点在于：慢。</p>
<p>慢慢地读圣经，慢慢的想圣经。如何帮助我们慢慢的读，慢慢的想呢？推荐尝试如下方法：</p>
<ul>
<li>写写画画</li>
<li>背诵</li>
<li>反复</li>
<li>持之以恒</li>
<li>用自己的话复述经文的内容</li>
<li>总结</li>
</ul>
<p>书写、记笔记、画画等等都是很好方法，这可以让我们的阅读进度慢下来，进而增加对读过内容的理解时间。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Bible</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Z-backtest</title>
    <url>/2020/04/07/z_backtesting/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Why? bother to create another backtest framework, if we already have plenty of them?</p>
<ul>
<li>I can not find even one backtest framework to backtest option (or deriveritive) based strategy properly. (Mix of option and delta one product is a Bigger NO!)</li>
<li>Debug/Reconcile backtest is painful, because of bad state management</li>
<li>Logic components are hard to re-use</li>
<li>And thanks to point 3, strategy code to strategy logic is not easy</li>
<li>Not easy to do strategy of strategies</li>
</ul>
<p>How? to solve above problems?</p>
<ol>
<li>Use unified interface for derivertive and delta-one Node (And Event a Strategy!)</li>
<li>Use explicit state management, things like Redux</li>
<li>Use Algo stacks to express logics</li>
<li>Thanks to point 3, this is solved</li>
<li>Use Tree structure to describe strategy (Check point 1)</li>
</ol>
<p>What? we will achieve in this framework?</p>
<ol>
<li>Derivertive/Delta-one/Strategy can be backtested together</li>
<li>Strategy data will be presented as a tree structure</li>
<li>Common logic can be tested and re-used easily</li>
<li>Compose common logics creats new strategy easily</li>
<li>Strategy logic will be explicitly expressed as Algo stucks</li>
<li>State evolution during backtesting is trasnprent </li>
</ol>
<p>What are not our goals (at least for now):</p>
<ol>
<li>Spead (If you are simple enough, you should be fast as well)</li>
<li>Live trading (state =&gt; order =&gt; trade =&gt; state)</li>
<li>Intraday strategy</li>
<li>A lot of built in batteries (common logics, or complex derivative Node)</li>
</ol>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2>]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Backtest</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio Signal Processing for Music Applications</title>
    <url>/2020/04/06/Audio_Signal_Processing_for_Music_Applications/</url>
    <content><![CDATA[<h1 id="Audio-Signal-Processing-for-Music-Applications"><a href="#Audio-Signal-Processing-for-Music-Applications" class="headerlink" title="Audio Signal Processing for Music Applications"></a>Audio Signal Processing for Music Applications</h1><p><a href="https://www.coursera.org/lecture/audio-signal-processing/dft-1-EZRXC">Course Link</a></p>
<blockquote>
<p>Perhaps most importantly, from the point of view of computer music research, is that the human ear is a kind of spectrum analyzer. That is, the cochlea of the inner ear physically splits sound into its (quasi) sinusoidal components. This is accomplished by the basilar membrane in the inner ear: a sound wave injected at the oval window (which is connected via the bones of the middle ear to the ear drum), travels along the basilar membrane inside the coiled cochlea. The membrane starts out thick and stiff, and gradually becomes thinner and more compliant toward its apex (the helicotrema). A stiff membrane has a high resonance frequency while a thin, compliant membrane has a low resonance frequency (assuming comparable mass per unit length, or at least less of a difference in mass than in compliance). Thus, as the sound wave travels, each frequency in the sound resonates at a particular place along the basilar membrane. The highest audible frequencies resonate right at the entrance, while the lowest frequencies travel the farthest and resonate near the helicotrema. The membrane resonance effectively <code>shorts out&#39;&#39; the signal energy at the resonant frequency, and it travels no further. Along the basilar membrane there are hair cells which</code>feel’’ the resonant vibration and transmit an increased firing rate along the auditory nerve to the brain. Thus, the ear is very literally a Fourier analyzer for sound, albeit nonlinear and using ``analysis’’ parameters that are difficult to match exactly. Nevertheless, by looking at spectra (which display the amount of each sinusoidal frequency present in a sound), we are looking at a representation much more like what the brain receives when we hear.</p>
</blockquote>
<span id="more"></span>

<p>Discrete Fourier Transform:</p>
<p>$$X[k]=\sum_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$$</p>
<p>Where,<br>$n$: discrete time index(normalized time, T = 1)<br>$k$: discrete frequency index<br>$w_k=2\pi k/N$: frequency in radians per seconds<br>$f_k=f_s k/N$: frequency in Hz ($f_s$ is sampling rate)</p>
<p>Complex exponentials:</p>
<p>$$s_k^* = e^{-j2\pi kn/N}$$</p>
<p>Scalar product:</p>
<p>$$&lt;x, s_k&gt; = \sum_{n=0}^{N-1}x[n]s_k^*[n]$$</p>
<p>Real sinusoid:</p>
<p>$$x[n] = Acos(2\pi fnT + \psi)$$</p>
<p>where,</p>
<p>$x$ is the array of real values of the sinusoid<br>$n$ is an integer value expressing the time index<br>$A$ is the amplitude vaclue of the sinusoid<br>$f$ is frequency in Hz<br>$T$ is sampling period, $1/f_s$, $f_s$ is the sampling frequency in Hz<br>$\psi$ is the initial phase in radians</p>
<p>Complex sinusiod:</p>
<p>$$x[n]=Ae^{j(wnT+\psi)} = Acos(wnT+\psi) + jAsin(wnT+\psi)$$</p>
<p>Inverse DFT:</p>
<p>$$x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]s_k[n]$$<br>where, $s$ is the conjugate of $s^*$.</p>
<p>The bridge between analog and digial signal.</p>
<p>$$f = \frac{F_s}{M}$$<br>where, M is period of digital signal, F_s is the sampling frequency in Hz, f is the frequency in analog signal in Hz.</p>
<p>The discrete-time oscillatory heartbeat:</p>
<p>$$x[n] = Ae^{j(wn+\psi)} = A[cos(wn+\psi)+jsin(wn+\psi)]$$</p>
<p>where, $A$ is amplitude, $w$ is frequency in radians, and $\psi$ is initial phase in radians.</p>
<p>The concept here is that a circular movement, the e part, can always be described as a sin and cos function for two dementions movements.</p>
<p>Multiple e part will rotate the point. hence:</p>
<p>$x[n]=e^{jwn}; x[n+1]=e^{jw}x[n]$</p>
<p>:::warning<br>Not every sinusoid is periodic in discrete time! $e^{jwn}$ is periodic in n, only when $w=\frac{M}{N}2\pi$<br>:::</p>
<p>If $w &gt; 2\pi$, we have issues.</p>
<h2 id="Vector-space-in-DSP"><a href="#Vector-space-in-DSP" class="headerlink" title="Vector space in DSP"></a>Vector space in DSP</h2><p>Once we model something in vector space, all the tools in vectors space is open to us!</p>
<p>:::info<br>The item in vectors, can be any thing! such as functions!<br>:::</p>
<p>Some examples of vector spaces:</p>
<ul>
<li>$\mathbb{R}^2: x=[x_0, x_1]^T$</li>
<li>$\mathbb{R}^3: x=[x_0, x_1, x_2]^T$</li>
<li>$L_2(-1, 1): x=x(t), t\in[-1, 1]$</li>
<li>$\mathbb{R}^N$</li>
</ul>
<p>The ingredients of vector space (Data Structure):</p>
<ul>
<li>the set of vectors, V</li>
<li>a set of scalars, say $\mathbb{C}$</li>
</ul>
<p>At least to some methods to apply to these Data:</p>
<ul>
<li>resize vectors</li>
<li>combine vectors</li>
</ul>
<p>So formal properties of a vector space:</p>
<ul>
<li>x + y = y + x</li>
<li>(x+y)+z = x+(y+z)</li>
<li>a(x+y)= ax + ay</li>
<li>inner product, $&lt;.,.&gt;: V*V \to \mathbb{C}$<ul>
<li>&lt;x+y, z&gt; = &lt;x, y+z&gt;</li>
<li>….</li>
</ul>
</li>
<li>…</li>
</ul>
<p>Inner product reflect the similarity of two vectors! If 0, means orgthogno, or no simalarity! We have <code>norm</code> and <code>distance</code> of two vectors. The <code>distance</code> in $L_2$ function vector space, also called mean square error!</p>
<h2 id="Signal-Space"><a href="#Signal-Space" class="headerlink" title="Signal Space"></a>Signal Space</h2><p>Finite-length and periodic signals live in $\mathbb{C}^N$. </p>
<p>The inner product operation is defined:</p>
<p>$$&lt;x, y&gt; = \sum_{n=0}^{N-1}x^{*}[n]y[n]$$</p>
<p>By finite, it requires the sequences to be square-summable: $\sum |x[n]|^2&lt;\infty$. This is energy of signal, so finite energy!</p>
<p>:::info<br>Hilbert Space: $H(V, \mathbb{C})$:</p>
<ul>
<li>an inner product is defined</li>
<li>completeness on all required vector operation<br>:::</li>
</ul>
<h2 id="Bases"><a href="#Bases" class="headerlink" title="Bases"></a>Bases</h2><p>Linear combination is the basic operation in vector spaces. How can we find a set of building blocks, vectors, to express all the other vectors in the space??</p>
<p>Formal definition of bases:</p>
<p>Given: </p>
<ul>
<li>a vector space, H</li>
<li>a set of K vectors from $W= {w^{(k)}}_{k=0,1,…,K-1}$</li>
</ul>
<p>W is a basis for H if:</p>
<ol>
<li>we can write all $x\in H$:<br>$$x = \sum_{k=0}^{K-1}\alpha w^, \alpha_k\in\mathbb{C}$$</li>
<li>$\alpha_k$ are unique</li>
</ol>
<p>Orthogonal basis</p>
<p>Orthonormal basis</p>
<p>By orthonormal basis, </p>
<p>$$\alpha_k=&lt;w, x&gt;$$</p>
<p>Change basis:</p>
<p><img data-src="https://i.imgur.com/9SdEpoD.png" alt="Change Basis"></p>
<h2 id="Subspace-bases-approximations"><a href="#Subspace-bases-approximations" class="headerlink" title="Subspace bases approximations"></a>Subspace bases approximations</h2><p>Approximate using sub-space.</p>
<h3 id="Least-square-approximation"><a href="#Least-square-approximation" class="headerlink" title="Least square approximation"></a>Least square approximation</h3><p>Given $s^{(k)}<em>{k=0,1,…,K-1}$ are orthonormal basis for S,<br>the orthogonal projection:<br>$$\hat{x}=\sum</em>{}^{}&lt;s^{(k)}, x&gt;s^{(k)}$$</p>
<p>is the best approximation of over S. It has minimum norm error, the error is also orthogonal to approximation, which means this sub space cannot get more information any more.</p>
<p>Gram-Schmidt orthonormlization procedure.</p>
<h2 id="Fouries-Analysis"><a href="#Fouries-Analysis" class="headerlink" title="Fouries Analysis"></a>Fouries Analysis</h2><p>Osillations are everywhere. And system does not move in circles, can’t last long.</p>
<p>Fouries analysis is simply a base change in vector space $\mathbb{C}^N$.</p>
<p>$$w_k[n]=e^{j\frac{2\pi}{N}nk}$$</p>
<p>where $n, k = 0,1,…,N-1$.</p>
<p>Above is an orthogonal basis in $\mathbb{C}$</p>
<h2 id="DFT-Discrete-Fouries-Transformaion"><a href="#DFT-Discrete-Fouries-Transformaion" class="headerlink" title="DFT, Discrete Fouries Transformaion"></a>DFT, Discrete Fouries Transformaion</h2><p>The analysis formular:</p>
<p>$$X_k = &lt;w_k, x&gt;$$</p>
<p>The synthesis formula:</p>
<p>$$x = \frac{1}{N}\sum_{k=0}^{N-1}X_kw^{(k)}$$</p>
<h2 id="Interpreting-DFT"><a href="#Interpreting-DFT" class="headerlink" title="Interpreting DFT"></a>Interpreting DFT</h2><p><img data-src="https://i.imgur.com/z5XIDHQ.png" alt=""></p>
<p><img data-src="https://i.imgur.com/aT146UI.png" alt=""></p>
<h3 id="How-to-label-DFT-result"><a href="#How-to-label-DFT-result" class="headerlink" title="How to label DFT result?"></a>How to label DFT result?</h3><p>Given sample number is N, sample frequency is $f_s$, if we find a peak in DFT at k = 500, what is the corresponding frequency in Hz? </p>
<p>The highest freqency in the system is $f_s/2$.</p>
<p>$f = kf_s/N$</p>
<h2 id="DFT-in-Music"><a href="#DFT-in-Music" class="headerlink" title="DFT in Music"></a>DFT in Music</h2><p>Frequency, harmonics. timbre is different because of the harmonics. But the pitch is just the first frequency component. </p>
<p><img data-src="https://i.imgur.com/UnhGofZ.png" alt=""></p>
<h2 id="DFT-synthesis"><a href="#DFT-synthesis" class="headerlink" title="DFT synthesis"></a>DFT synthesis</h2><p><img data-src="https://i.imgur.com/KfWDMkE.png" alt=""></p>
<p>Frequency in Hz and in radians:</p>
<p>$$f = \frac{wf_s}{2\pi}$$</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><h2 id="STFT-short-term-fouries-transform"><a href="#STFT-short-term-fouries-transform" class="headerlink" title="STFT, short term fouries transform"></a>STFT, short term fouries transform</h2><p>Spectrogram is a way to show STFT. There are two variables: window and frequency. $X[m;k]$, where m is the window, k is frequency index.</p>
<p>Spectrogram show time, frequency at the same time. Once we know the sample frequency, we can label the spectrogram.</p>
<p>$T_s = 1/F_s$, the frequency resolution is $f_s/L Hz$, and the width of time slices is $LT_s$.</p>
<p>Question to ask:</p>
<ul>
<li>width of window?</li>
<li>position of the window?</li>
<li>shape of the window?</li>
</ul>
<p><img data-src="https://i.imgur.com/A5PBgce.png" alt=""></p>
<p>Short window gives better time precision, while long window give better frequency precision.</p>
<p><img data-src="https://i.imgur.com/L2UAe8g.png" alt=""></p>
<p>STFT leads to wavelet transform.</p>
<h1 id="The-DFT-Numerical-Aspects"><a href="#The-DFT-Numerical-Aspects" class="headerlink" title="The DFT: Numerical Aspects"></a>The DFT: Numerical Aspects</h1><p>As a quick reminder, the definitions of the direct and inverse DFT for a length-$N$ signal are:</p>
<p>\begin{align<em>}<br>    X[k] &amp;= \sum_{n=0}^{N-1} x[n], e^{-j\frac{2\pi}{N}nk}, \quad k=0, \ldots, N-1 \<br>    x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1} X[k], e^{j\frac{2\pi}{N}nk}, \quad n=0, \ldots, N-1<br>\end{align</em>}</p>
<p>The DFT produces a complex-valued vector that we can represent either via its real and imaginary parts or via its magnitude $|X[k]|$ and phase $\angle X[k] = \arctan \frac{\text{Im}{X[k]}}{\text{Re}{X[k]}}$.</p>
<h3 id="Numerical-errors-in-real-and-imaginary-parts"><a href="#Numerical-errors-in-real-and-imaginary-parts" class="headerlink" title="Numerical errors in real and imaginary parts"></a>Numerical errors in real and imaginary parts</h3><p>The DFT can be easily implemented using the change of basis matrix ${W}_N$. This is an $N\times N$ complex-valued matrix whose elements are </p>
<p>$$<br>    {W}_N(n,k)=e^{-j\frac{2\pi}{N}nk}<br>$$</p>
<p>so that the DFT of a vector $\mathbf{x}$ is simply $\mathbf{X} = W_N\mathbf{x}$. Note that the inverse DFT can be obtained by simply conjugating ${W}_N$ so that $\mathbf{x} = W_N^*\mathbf{X}$.</p>
<p>We can easily generate the matrix ${W}_N$ in Python like so:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft_matrix</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># create a 1xN matrix containing indices 0 to N-1</span></span><br><span class="line">    a = np.expand_dims(np.arange(N), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># take advantage of numpy broadcasting to create the matrix</span></span><br><span class="line">    W = np.exp(-<span class="number">2j</span> * (np.pi / N) * (a.T * a))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> W</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT matrix</span></span><br><span class="line">N = <span class="built_in">len</span>(x)</span><br><span class="line">W = dft_matrix(N);</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT</span></span><br><span class="line">X = np.dot(W, x)</span><br><span class="line"><span class="comment"># inverse DFT</span></span><br><span class="line">x_hat = np.dot(W.T.conjugate(), X) / N</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x-x_hat)</span><br></pre></td></tr></table></figure>

<h2 id="Fouries-representation-for-signal-class"><a href="#Fouries-representation-for-signal-class" class="headerlink" title="Fouries representation for signal class"></a>Fouries representation for signal class</h2><ul>
<li>N-point finite-length: DFT</li>
<li>N-point periodic: DFS</li>
<li>infinite length: DTFT</li>
</ul>
<p><img data-src="https://i.imgur.com/ZnK3RgD.png" alt=""></p>
<p><img data-src="https://i.imgur.com/uzP9LOM.png" alt=""></p>
<p><img data-src="https://i.imgur.com/AUUxJbD.png" alt=""></p>
<h2 id="Sinusoidal-modulation"><a href="#Sinusoidal-modulation" class="headerlink" title="Sinusoidal modulation"></a>Sinusoidal modulation</h2><p>Based on where most frequencies are located.</p>
<ul>
<li>lowpass signal</li>
<li>highpass signal</li>
<li>bandpass signal</li>
</ul>
<p>How?</p>
<p><img data-src="https://i.imgur.com/4VwKahL.png" alt=""></p>
<p>Why?</p>
<p><img data-src="https://i.imgur.com/JZGmVkB.png" alt=""></p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p><img data-src="" alt="Uploading file..._kr65l8uvc"></p>
<h3 id="Linear-time-invariant-filters"><a href="#Linear-time-invariant-filters" class="headerlink" title="Linear time-invariant filters"></a>Linear time-invariant filters</h3><p>Linearity</p>
<p><img data-src="https://i.imgur.com/3qUraJ1.png" alt=""></p>
<p>Time-invariant</p>
<p><img data-src="https://i.imgur.com/8nz362v.png" alt=""></p>
<p>Add them we have</p>
<p><img data-src="https://i.imgur.com/HgmAN8f.png" alt=""></p>
<p>In formalar:</p>
<p><img data-src="https://i.imgur.com/htfvgNy.png" alt=""></p>
<h3 id="Convolution-1"><a href="#Convolution-1" class="headerlink" title="Convolution"></a>Convolution</h3><p>LTI filters are entirely characterized by their impulse reponse, i.e., their response to the impulse delta function $\delta[n]$, the output of an LTI filter y[n]  y[n] can be computed by convolving the input x[n]  x[n] with the impulse response,</p>
<p>$$<br>\delta[n]=\sum_{k=-\inf}^{inf}x[k]h[n-k]<br>$$</p>
<h3 id="Filter-by-examples"><a href="#Filter-by-examples" class="headerlink" title="Filter by examples"></a>Filter by examples</h3><p>Moving average: </p>
<p><img data-src="https://i.imgur.com/C8gsV6B.png" alt=""></p>
<p>Leaky integrator: </p>
<p><img data-src="https://i.imgur.com/5UgmloR.png" alt=""></p>
<h3 id="Filter-types"><a href="#Filter-types" class="headerlink" title="Filter types"></a>Filter types</h3><ul>
<li>lowpass, MA, leaky</li>
<li>highpass</li>
<li>bandpass</li>
<li>allpass</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul>
<li><a href="https://ccrma.stanford.edu/~jos/mdft/">https://ccrma.stanford.edu/~jos/mdft/</a></li>
<li><a href="https://www.youtube.com/watch?v=MBnnXbOM5S4">The more general uncertainty principle, beyond quantum</a></li>
<li><a href="youtube.com/watch?v=spUNpyF58BY">But what is the Fourier Transform? A visual introduction</a></li>
<li><a href="https://www.youtube.com/watch?v=r6sGWTCMz2k">But what is a Fourier series? From heat flow to circle drawings</a></li>
<li><a href="http://www.jezzamon.com/fourier/index.html">An Interactive Introduction to Fourier Transforms</a></li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Signal Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>配和弦的方法</title>
    <url>/2020/04/05/how-to-chords/</url>
    <content><![CDATA[<h2 id="配和弦的基本规则"><a href="#配和弦的基本规则" class="headerlink" title="配和弦的基本规则"></a>配和弦的基本规则</h2><ol>
<li>选择含有旋律音的调内和弦</li>
<li>多种选择的时候，考虑上下文以及和弦功能<ol>
<li>下一个和弦用什么？增加一些变化</li>
<li>功能和弦：比如G7是属和弦，会制造紧张，回归C</li>
<li>其他附属和弦，比如Dm，F等等</li>
</ol>
</li>
<li>多久换一个和弦？</li>
<li>递归上面的过程</li>
</ol>
<h2 id="和弦有什么功能"><a href="#和弦有什么功能" class="headerlink" title="和弦有什么功能"></a>和弦有什么功能</h2><p>分类1：</p>
<ul>
<li>主和弦，Tonic，I</li>
<li>属和弦，dominant, V。G7，<strong>三全音</strong>产生更加不稳定的感觉</li>
<li>下属和弦，桥梁，去G 或者 G7</li>
<li>附属和弦，你要接的下一个和弦的上面5度音的属7和弦，比如下一个是Em，可以用B7过度到他</li>
</ul>
<p>分类2：</p>
<ul>
<li>家：C, I</li>
<li>外面：G7,Bdim. V,vii</li>
<li>桥：Dm，F，他们很喜欢去外面。ii, iv</li>
<li>暂时的家，或者家的延伸：Em，Am. iii, vi</li>
</ul>
<p><img data-src="https://i.imgur.com/EFZjJPV.png" alt="功能"></p>
<span id="more"></span>

<h2 id="递归上面的规则！"><a href="#递归上面的规则！" class="headerlink" title="递归上面的规则！"></a>递归上面的规则！</h2><p>可以选定目标和弦作为暂时的１级和弦，然后在前面添加该调的常见回家进行，比如ii -&gt; V -&gt; I.</p>
<p><img data-src="https://i.imgur.com/n1bl3Ou.png" alt=""><br><img data-src="https://i.imgur.com/oAuXgIT.png" alt=""><br><img data-src="https://i.imgur.com/6buXmP8.png" alt=""></p>
<p>当然，使用上面的方法是，临时的V可以被另外一个包含相同三全音的和弦代替，比如比目标I和弦，高半个音的属和弦。比如下面这个例子：</p>
<p><img data-src="https://i.imgur.com/3EzZzZ8.png" alt=""></p>
<p>还可以通过从平行调中，借用和弦。比如在Ｃ调中，可以借用Ｃｍ中的Ｆｍ和弦，回到Ｃ和弦。</p>
<p><img data-src="https://i.imgur.com/ymKfpIv.png" alt=""></p>
<h2 id="认识和弦"><a href="#认识和弦" class="headerlink" title="认识和弦"></a>认识和弦</h2><ul>
<li>Major</li>
<li>Minor</li>
<li>Dominant</li>
</ul>
<p><img data-src="https://i.imgur.com/iJQPvFb.png" alt=""><br><img data-src="https://i.imgur.com/w4ttqAC.png" alt=""><br><img data-src="https://i.imgur.com/s2deAcz.png" alt=""><br><img data-src="https://i.imgur.com/0VhtLrr.png" alt=""></p>
<h3 id="和弦变化"><a href="#和弦变化" class="headerlink" title="和弦变化"></a>和弦变化</h3><ul>
<li>add</li>
<li>sus</li>
<li>omit</li>
<li>()</li>
<li>转位</li>
<li>其他家族</li>
</ul>
<p><img data-src="https://i.imgur.com/z8ax5Da.png" alt=""><br><img data-src="https://i.imgur.com/Bg4L8JM.png" alt=""><br><img data-src="https://i.imgur.com/7lDnl3B.png" alt=""><br><img data-src="https://i.imgur.com/sokdbbh.png" alt=""><br><img data-src="https://i.imgur.com/rvK0h7b.png" alt=""><br><img data-src="https://i.imgur.com/FKhpfiE.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.musictheory.net/products/lessons">Musictheory</a></li>
<li><a href="https://www.youtube.com/channel/UCVXstWyJeO6No3jYELxYrjg">好和弦</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Chord</tag>
      </tags>
  </entry>
  <entry>
    <title>Major Update</title>
    <url>/2020/03/29/major-update/</url>
    <content><![CDATA[<p>I updated my blog. Not sure I will move old posts here. But I put them here: <a href="https://github.com/wangzhe3224/wangzhe3224.github.io.backup/tree/master/_posts">Old post</a>.<br>Just in case. </p>
<p>Zhe</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
  </entry>
  <entry>
    <title>Road Map for Investment Tool Box</title>
    <url>/2020/01/01/road_map/</url>
    <content><![CDATA[<h2 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h2><p>Create series of tools to for my investment. Open to public use. </p>
<h2 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h2><p>Build simple and small components, if I cannot see the whole picture. Even I am smart enough to see whole picture, I will do the same.</p>
<h2 id="Software-Engineering"><a href="#Software-Engineering" class="headerlink" title="Software Engineering"></a>Software Engineering</h2><ol>
<li>Composition: Design simple tools in a way that we can chain different tool together.</li>
<li>Test-Driven: Test creats sense of accomplishmen and modularity.</li>
<li>Cloud-Based Deployment: leverage AWS service.<span id="more"></span>

</li>
</ol>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Follow the philosoph, tools</p>
<ul>
<li><input disabled="" type="checkbox"> Data tools</li>
<li><input disabled="" type="checkbox"> VIX term structures</li>
<li><input disabled="" type="checkbox"> Yield curve</li>
<li><input disabled="" type="checkbox"> Time series statistics</li>
<li><input disabled="" type="checkbox"> Correlation tools</li>
<li><input disabled="" type="checkbox"> MOV tools</li>
<li><input disabled="" type="checkbox"> Option tools</li>
<li><input disabled="" type="checkbox"> Backtesting tools</li>
<li><input disabled="" type="checkbox"> Time series generate tools</li>
</ul>
<h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><ul>
<li>Date/Time</li>
<li>Time series</li>
<li>Term structure</li>
<li>Matrix</li>
</ul>
<h2 id="Presentations"><a href="#Presentations" class="headerlink" title="Presentations"></a>Presentations</h2><ul>
<li>Graph</li>
<li>Table</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/robertmartin8/PyPortfolioOpt">PyPortfolioOpt</a></li>
<li><a href="https://github.com/lballabio/QuantLib-SWIG/tree/master/Python">QuantLib</a></li>
<li><a href="https://www.backtrader.com/">Backtrader</a></li>
<li><a href="https://github.com/pmorissette/bt">Bt</a></li>
<li><a href="http://qoppac.blogspot.com/">Systematic Trading</a></li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2019/12/31/how_to_read/</url>
    <content><![CDATA[<h1 id="如何阅读一本书"><a href="#如何阅读一本书" class="headerlink" title="如何阅读一本书"></a>如何阅读一本书</h1><p>具体的阅读方法：</p>
<ul>
<li>Layer 1 read: 提出一些原认知问题，一边读书，一边补充完善<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是什么</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
</li>
<li>Layer 2 read: 稍微具体阅读每一个章节，但不会为了不懂得内容停留过长时间，主要在于总结作者每一个章节都在讲什么？<ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
</li>
<li>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</li>
</ul>
<span id="more"></span>

<h2 id="如何主动的阅读"><a href="#如何主动的阅读" class="headerlink" title="如何主动的阅读"></a>如何主动的阅读</h2><p>主动阅读涉及到的问题可以在不同的层次被反复提出，比如最高的层次应该针对这一类书提出，然后针对这一本书提出，然后针对每一个章节提出。</p>
<p>问自己如下几个问题：</p>
<ol>
<li>整体来说，这本书在说什么？这本书的主题是什么？作者是如何一步一步阐述这个主题的？</li>
<li>作者细节上都说了什么？他主要的观点、声明是什么？</li>
<li>这本书说的有道理吗？部分有道理？还是全部有道理？</li>
<li>这本书跟我有什么关系？书上的信息对我有什么意义？跟我已有的知识有什么关系？</li>
</ol>
<p>仅仅提出问题还不够，还需要有效的回答问题。</p>
<ol>
<li>在书上做笔记，标注</li>
<li>记录相关的页码</li>
</ol>
<p>在不同的阅读阶段，所提出和记录的问题是不同的。笔记主要可以分成三种：</p>
<ol>
<li>结构笔记：这是什么样的书？结构如何？如何展开陈述？</li>
<li>概念笔记：可以引用别的书籍的解释</li>
<li>辩证笔记：？？？？？？</li>
</ol>
<h2 id="阅读的四个层次"><a href="#阅读的四个层次" class="headerlink" title="阅读的四个层次"></a>阅读的四个层次</h2><ol>
<li>基础阅读：这个句子在说什么？</li>
<li>检视阅读：这本书属于什么分类？是什么架构？包含那些主要部分？</li>
<li>分析阅读：大量的时间，对书中内容进行系统性的提问，以获得深刻的理解</li>
<li>主题阅读：同一类主题的众多书籍之间的联系？那些内容是新的？那些存在矛盾？</li>
</ol>
<p>这四个层次的阅读存在上一级别包含下一级别的关系。</p>
<h3 id="1、基础阅读"><a href="#1、基础阅读" class="headerlink" title="1、基础阅读"></a>1、基础阅读</h3><p>基本相当于美国9年级的阅读水平。可以认识绝大部分的单词，能够无障碍的理解句子的意思</p>
<h3 id="2、检视阅读"><a href="#2、检视阅读" class="headerlink" title="2、检视阅读"></a>2、检视阅读</h3><p>包含两个部分：系统的略读和？？？？</p>
<p><strong>略读</strong></p>
<p>目的是发现这本书是不是我需要的？这个过程最多不会超过1小时，具体操作如下：</p>
<ul>
<li>书名，副标题。为后续的归类做准备</li>
<li>目录，了解书籍的总体架构</li>
<li>索引，了解书籍涵盖的概念范围，寻找那些主题出现频率最高</li>
<li>前言和作者介绍，一般会向读者说明如何阅读本书或者很多写作的上下文，帮助理解</li>
<li>从目录中挑选几段自己觉得感兴趣的快速的读一下</li>
<li>书的结尾，了解主要的结论，一般作者会在最后对全书进行总结</li>
</ul>
<p><strong>粗浅的阅读</strong></p>
<p>由于检视阅读的最终目的是为了从总体上了解书籍的主题和脉络，因此在这个阶段，先要从头到尾的第一遍，即使遇到了不懂的地方，也<strong>不要</strong>停下来查询或者思索。</p>
<h3 id="3、分析阅读"><a href="#3、分析阅读" class="headerlink" title="3、分析阅读"></a>3、分析阅读</h3><p>能够提供读者对一本书架构的认识。总结如下：</p>
<ol>
<li>依照本书的种类与主题，对书籍进行分类</li>
<li>用最短的句子概括本书的主要内容</li>
<li>按照顺序与关系，列出全书的重要部分，总结各部分提纲。</li>
<li>找出作者希望通过本书解决的问题</li>
<li>诠释作者使用的关键字，与作者首先达成共识；</li>
<li>找到重点句子，并且用自己的方式概括主旨；</li>
<li>找出作者的论述段落，重新架构作者的前因后果，以明白作者的主张；</li>
<li>确定作者解决的了那些问题，那些还没有解决；在没有解决的问题中，那些是作者认为无法解决的？</li>
</ol>
<h3 id="一本书的分类"><a href="#一本书的分类" class="headerlink" title="一本书的分类"></a>一本书的分类</h3><p><strong>第一个原则是知道书籍的分类</strong>，根据不同的分类存在不同的阅读分析方法。应该逐渐建立自己的书籍分类标准，比如小说和论述。论述中又包含科学、人文和哲学。</p>
<p>一般来说，书籍可以分成<strong>实用性</strong>和<strong>理论性</strong>。理论性作品会教你这是什么，而实用性作品会叫你如何做想要做的事情或者你认为应该做的事情。<br>实用性的书籍会经常出现，应该、好坏、结果和意义之类的词语。</p>
<p>人文历史类的书籍，关心时间问题；科学书籍不关心时间；哲学比较像科学，也是追求一般真理，但是哲学往往依托的是主观，而科学依靠事实。（那么数学呢？）</p>
<h3 id="透视一本书"><a href="#透视一本书" class="headerlink" title="透视一本书"></a>透视一本书</h3><p><strong>分析阅读的第二个原则是：使用一个简单的句子或者几句话来叙述整本书的内容。</strong>　也就是发现一本书的作者准备做什么。</p>
<p>将总结落实到文字，记录下来。模糊的印象往往没有效果。</p>
<p><strong>分析阅读的第三个原则是：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。</strong> 一本书的各个部分只有有逻辑的链接在一起才会变的对我有意义。</p>
<p>在完成了原则2的任务后，按照如下方法总结书籍整体架构：</p>
<ol>
<li>作者将全书分为x个部分，第一部分谈。。。第二部分谈。。。</li>
<li>第一个部分可以分成y个段落</li>
<li>第一个段落有z个重点问题</li>
</ol>
<p>:::info<br>读者需要在书籍中发现隐藏的骨架，而作者则是先构建了骨架，确用更加丰富的材料隐藏骨架。这一点跟音乐、美术等等很多东西都一样。<br>:::</p>
<p><strong>分析阅读第四个原则：找出作者想要问的问题</strong>。一本书的作者开始写作时通常有一个或者多个问题，全书的推进就是在试图解决这些问题。</p>
<p>找到与作者共通的词义,或者反复出现的词？</p>
<p><strong>第五个原则（部分1）</strong>：抓住书中的单字，搞清楚作者是如何使用这个单字的。一般就是那些最让我头疼的词。或者理解问书中的反复出现的基础概念。这些基础概念往往会在不同的语境下产生不同的意义。</p>
<p>比如，财富，在国富论中就是专门用于，而物种在进化论中才是专门用语。</p>
<p><strong>第五个原则（部分2）</strong>：判断重要的词汇是不是在各种语境下是不是有专门的含义？</p>
<p><strong>第六个原则</strong>：圈出重要的句子，找出其中的主旨。找出主旨的好办法是，用自己的话重写作者的意思。</p>
<p><strong>第七个原则</strong>：从相关文句的关联中，设法架构出一个本书的基本论述。找到文中的论述段落。</p>
<p><strong>第八个原则</strong>：找出作者对于论述问题的解答。</p>
<p>上述的四个原则，能够提供读者对一本书架构的认识。总结如下：</p>
<h3 id="分析阅读的第三阶段"><a href="#分析阅读的第三阶段" class="headerlink" title="分析阅读的第三阶段"></a>分析阅读的第三阶段</h3><p>:::info<br>必须能评论，提出批评，才算真正完成这件事（主动阅读一本书这件事情）。受教是一种美德，但是受教不是盲目服从。<br>:::</p>
<p>这部分主要涉及读者对书籍的评论。但是在对书籍进行评论前，应该先去报自己已经理解作者想要表达的意义了。</p>
<p>批评观点的几个标准：</p>
<ol>
<li>证明作者的知识不足；</li>
<li>证明作者的知识错误；</li>
<li>证明作者不合逻辑；</li>
<li>证明作者分析和理由是不完整的。</li>
</ol>
<h3 id="不同书籍的阅读方法"><a href="#不同书籍的阅读方法" class="headerlink" title="不同书籍的阅读方法"></a>不同书籍的阅读方法</h3><h4 id="实用性的书"><a href="#实用性的书" class="headerlink" title="实用性的书"></a>实用性的书</h4><p>一般就是讲述规则的书，谈论的主题是关于如何做的更好或者如何避免更糟。这种书籍最主要的任务自然是寻找规则。</p>
<p>另一类实用的书籍，主要谈论规则后面的原理，但是它不是纯理论的书籍。其主旨实在说明某件事情的状态，论述就是强调真的如此。 </p>
<p>阅读实用性书籍的两个主要问题：</p>
<ol>
<li>作者的目的是什么？</li>
<li>他建议用什么方法达到这个目的？</li>
</ol>
<h4 id="科学与数学书籍"><a href="#科学与数学书籍" class="headerlink" title="科学与数学书籍"></a>科学与数学书籍</h4><p>数学其实一种语言，学习语言要学习两次，第一次学习如何说话，第二次学习如何阅读。</p>
<p>首先学习语法，然后才是表达理解。</p>
<h4 id="哲学书"><a href="#哲学书" class="headerlink" title="哲学书"></a>哲学书</h4><h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><h2 id="4、主题阅读"><a href="#4、主题阅读" class="headerlink" title="4、主题阅读"></a>4、主题阅读</h2><p>主题阅读的五个步骤：</p>
<ol>
<li>找到相关章节</li>
<li>用自己的语言表达作者的想法，这样才可以联系不同的作者</li>
<li>厘清问题</li>
<li>界定议题</li>
<li>分析讨论</li>
</ol>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
