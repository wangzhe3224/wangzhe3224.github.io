<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>醒来吧！神的子民 51:9-52</title>
    <url>/2020/07/05/yisaiya4/</url>
    <content><![CDATA[<h1 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h1><p>当我们即将踏上一段新的旅程，我们会准备行囊，心情激动。但是，如果旅程迟迟推迟，我们很可能就会渐渐失去激动的心情，然后把行囊中的种种拿出来。我们可能重新整理床铺，渐渐忘记即将发生的旅程。</p>
<h1 id="基督徒的旅程"><a href="#基督徒的旅程" class="headerlink" title="基督徒的旅程"></a>基督徒的旅程</h1><h2 id="醒来吧，耶和华的臂膀-51-9-16"><a href="#醒来吧，耶和华的臂膀-51-9-16" class="headerlink" title="醒来吧，耶和华的臂膀!(51:9-16)"></a>醒来吧，耶和华的臂膀!(51:9-16)</h2><blockquote>
<p>耶和华的膀臂啊，醒来吧!醒来吧!穿上能力吧!像古时的日子，像上古的世代一样醒来吧! 从前砍碎了拉哈伯， 刺透了海龙的，不是你吗?</p>
</blockquote>
<p>以色列人终于开始重新呼唤神的帮助，就像当年带以色列出埃及一样，拯救他们。以色列人终于意识到神的能力。</p>
<p>可是</p>
<p>该清醒的不是神，而是以色列人。</p>
<h2 id="醒来吧，耶路撒冷，从醉-罪-中醒来-51-17-23"><a href="#醒来吧，耶路撒冷，从醉-罪-中醒来-51-17-23" class="headerlink" title="醒来吧，耶路撒冷，从醉(罪)中醒来!(51:17-23)"></a>醒来吧，耶路撒冷，从醉(罪)中醒来!(51:17-23)</h2><blockquote>
<p>17耶路撒冷啊，醒来!醒来!站起来吧! 你从耶和华的手中喝了他烈怒的杯， 喝尽了那使人摇摇摆摆的爵。</p>
</blockquote>
<p>以色列人才是应该从醉酒中醒来。他们面临的痛苦都是因为他们喝了耶和华愤怒的杯。正是因为以色列人犯罪，才收到神公义的审判。</p>
<p>但是，神，决定拿走那愤怒的杯，救赎以色列。（为什么呢？）</p>
<p>以色列的仇敌将会承担愤怒的杯。（为什么呢？）</p>
<h2 id="醒来吧，锡安，换衣服准备离开-52-1-12"><a href="#醒来吧，锡安，换衣服准备离开-52-1-12" class="headerlink" title="醒来吧，锡安，换衣服准备离开!(52:1-12)"></a>醒来吧，锡安，换衣服准备离开!(52:1-12)</h2><blockquote>
<p>1 锡安哪!你要醒来; 醒来，披上你的力量。 圣城耶路撒冷啊! 要穿上你华美的衣服。 因为未受割礼的和不洁净的人， 都再不得进到你那里去。2 耶路撒冷啊!抖下尘土， 起来，坐在位上吧! 锡安被掳的居民哪! 解开你颈项上的锁炼。</p>
</blockquote>
<p>耶和华与神的子民住在一起了，耶路撒冷将会成为真正的圣城。这也正是福音的预言。</p>
<p>要离开，不要触摸不洁净的东西。不要留恋即将毁灭的世界了，因为我们将要去的是圣洁的地方。而且，神会保守：</p>
<blockquote>
<p>11 你们要离开，要离开，要从那里出来， 我没有对雅各的后裔说过: 不要触摸不洁净的东西。扛抬耶和华器皿的啊! 我耶和华讲说公义， 你们要从巴比伦城中出来，要自洁。 12 你们出来，不必着急; 以色列的 神必作你们的后盾。向不能拯救人的神祈求的，</p>
</blockquote>
<p>基督徒处在同样的世代，救赎的世代，离开巴比伦的世代，我们应该做好准备离开的世代。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>传道人的传承：提摩太后书</title>
    <url>/2020/06/28/timotai2/</url>
    <content><![CDATA[<h1 id="传道人的传承"><a href="#传道人的传承" class="headerlink" title="传道人的传承"></a>传道人的传承</h1><blockquote>
<p>我在上帝面前，并在将来审判活人死人的基督耶稣面前，凭着他的显现和他的国度郑重地劝戒你：<br>2务要传道；无论得时不得时总要专心，并以百般的忍耐和各样的教导责备人，警戒人，劝勉人。<br>3因为时候将到，那时人会厌烦健全的教导，耳朵发痒，就随心所欲地增添好些教师，<br>4并且掩耳不听真理，偏向无稽的传说。<br>5至于你，凡事要谨慎，忍受苦难，做传福音的工作，尽你的职分。<br>6至于我，我已经被浇献，离世的时候到了。<br>7那美好的仗我已经打过了，当跑的路我已经跑尽了，该信的道我已经守住了。<br>8从此以后，有公义的冠冕为我存留，就是按着公义审判的主到了那日要赐给我的；不但赐给我，也赐给凡爱慕他显现的人。<br>《提摩太后书》4</p>
</blockquote>
<p>这封书信是身在牢狱中的保罗写给新一代传道人提摩太的，从信中我们也可以看到，保罗已经走到了生命的尽头。他留下了那句经典的经文，每一个传道人都铭记在心：</p>
<blockquote>
<p>7那美好的仗我已经打过了，当跑的路我已经跑尽了，该信的道我已经守住了。<br>8从此以后，有公义的冠冕为我存留，就是按着公义审判的主到了那日要赐给我的；不但赐给我，也赐给凡爱慕他显现的人。</p>
</blockquote>
<p>保罗当时身陷囹圄，教会内部开始出现离弃真道的人，背弃信仰，否认复活的事情。更加可怕的是，教会出现了很多假教师，他们不讲真理，却说虚妄的话，教导别人离弃信仰。他心急如焚。</p>
<p>而提摩太一直都是保罗信任的同工，他从小从祖母哪里接受了旧约圣经的教导，作为教会新一代的代领人，他面临很多挑战：人们背弃信仰，教会中假教师横行。</p>
<p>正是再这样的情况下，第一代传道人代表：保罗，写信给新一代传道人：提摩太，提醒他一定要持守真理，传讲福音。保罗为提摩太指明了道路：</p>
<blockquote>
<p>16 圣经都是上帝所默示的“圣经都是上帝所默示的”或译“凡上帝所默示的圣经”。于教训、督责、使人归正、教导人学义都是有益的，<br>17 叫属上帝的人得以完全，预备行各样的善事。</p>
</blockquote>
<p>他希望提摩太可以持守这圣经完备的教导，即使面对苦难，也可以坚持下去，并且将耶稣基督的福音传讲出去。</p>
<p>这就是一个老传道人对新传道人最后的叮嘱。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>提摩太后书</tag>
      </tags>
  </entry>
  <entry>
    <title>Python无成本加速技巧</title>
    <url>/2020/06/14/python_speedup/</url>
    <content><![CDATA[<p>Python是个很精巧的语言，但是常见的Cython解释器生成的代码相对来说还是比较慢的，这里主要是跟动态语言的一些特性有关系。但是，我会介绍一下非常常见的手段，可以通过简单的变化提升代码速度：无成本的加速技巧。</p>
<h1 id="x1f334-Python到底慢在哪里？"><a href="#x1f334-Python到底慢在哪里？" class="headerlink" title="&#x1f334; Python到底慢在哪里？"></a><span class="github-emoji" alias="palm_tree" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f334.png?v8">&#x1f334;</span> Python到底慢在哪里？</h1><p>其实，巨大部分的场景我们觉得Python慢是在循环的时候。那么<strong>在循环里，我们可以注意如下</strong>：</p>
<h2 id="1、避免使用-操作"><a href="#1、避免使用-操作" class="headerlink" title="1、避免使用 . 操作"></a>1、避免使用 <code>.</code> 操作</h2><p>比如如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(size):</span><br><span class="line">        z = math.sqrt(x) + math.sqrt(y)  <span class="comment"># 这里的 . 操作很慢</span></span><br><span class="line">        demo.something()   <span class="comment"># 这里的 . 操作很慢</span></span><br></pre></td></tr></table></figure>

<p><code>.</code> 会访问类的内部字典找到合适的方法或者属性，这些操作放在循环中就会拖慢速度。所以，应该尽量把这个操作从循环中去除。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt   <span class="comment"># &lt;==== </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line">sth = demo.something()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(size):</span><br><span class="line">        z = sqrt(x) + sqrt(y)  <span class="comment"># &lt;----</span></span><br><span class="line">        sth()   <span class="comment"># &lt;----</span></span><br></pre></td></tr></table></figure>

<h2 id="2、避免循环临时变量"><a href="#2、避免循环临时变量" class="headerlink" title="2、避免循环临时变量"></a>2、避免循环临时变量</h2><p>比如使用 <code>a, b = b, a</code> 来交换变量，而不是使用临时变量</p>
<h2 id="3、字符串使用join-而不是"><a href="#3、字符串使用join-而不是" class="headerlink" title="3、字符串使用join 而不是 +"></a>3、字符串使用<code>join</code> 而不是 +</h2><p>比如 <code>&#39;_&#39;.join([&quot;a&quot;, &quot;b&quot;])</code>而不是 <code>&quot;a&quot;+&quot;_&quot;+&quot;b&quot;</code>。</p>
<p>使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。</p>
<h2 id="4、使用隐式循环"><a href="#4、使用隐式循环" class="headerlink" title="4、使用隐式循环"></a>4、使用隐式循环</h2><p>比如 <code>sum(range(10)</code> 速度比for 循环更快。但是for循环比while循环更快！</p>
<h2 id="5、大杀器：numba-jit"><a href="#5、大杀器：numba-jit" class="headerlink" title="5、大杀器：numba.jit"></a>5、大杀器：<code>numba.jit</code></h2><p>比如同样的代码，下面的循环一个在1s内完成，而普通版本需要4s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numba</span><br><span class="line"></span><br><span class="line"><span class="meta">@numba.jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeSum</span><span class="params">(size: float)</span> -&gt; int:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        sum += i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">        sum = computeSum(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总之，最低成本加速的方法就是尽量减少循环中的无意义操作，或者进行jit编译（其实也是减少Head的重量）。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>看哪!万众期待的仆人 - 以赛亚书49</title>
    <url>/2020/06/14/yisaiya3/</url>
    <content><![CDATA[<h1 id="预言中新的仆人"><a href="#预言中新的仆人" class="headerlink" title="预言中新的仆人"></a>预言中新的仆人</h1><blockquote>
<p>1 众海岛啊!你们要听我的话。 远方的万族啊!你们要留心听。</p>
</blockquote>
<p>先知以赛亚在开头就说明他要说明一个重大的消息，有一个预言中的仆人会降临。</p>
<blockquote>
<p>3 他对我说:“你是我的仆人以色列， 我要借着你得荣耀。”<br>4 但我说:“我劳碌是徒然的; 我用尽气力，是虚无虚空的; 然而我当得的公理是在耶和华那里， 我的赏赐是在我的 神那里。”</p>
</blockquote>
<p>这位仆人原本是以色列民族，但是以色列失败了。这里神预言的仆人，不是以色列民族。</p>
<p>其实，先知这里就是在预言耶稣基督的到来。还记得吗？再上一个章节，以赛亚预言了波斯的古列王，“恰巧”会让我以色列回到故乡。但是今天这一位仆人，区有不同的特点。这位仆人，被藏在阴影之下，但是他口里说出的话，却如快刀。</p>
<p>虽然，仆人最终用尽力气，却得到虚空，但是仆人的赏赐在神那里！</p>
<h1 id="仆人的使命"><a href="#仆人的使命" class="headerlink" title="仆人的使命"></a>仆人的使命</h1><blockquote>
<p>5 现在，耶和华说:<br>6 “你作我的仆人， 使雅各众支派复兴，使以色列中得保全的归回，只是小事，我还要使你作列国的光，使我的救恩传到地极。”</p>
</blockquote>
<p>救恩要通过这位仆人，把救恩传到地极，而不仅仅是赐给犹太人。先知以赛亚就是犹太人，但是他说救恩是赐给万国的。这仆人，就像一束光一样把救恩带给万国，放弃人手所造的毫无能力的偶像，而去认识创造者、满有能力的神。万国就在黑暗之中，看不到世界的真相。</p>
<p>这位仆人不仅仅让失败的以色列重新认识神，更让万国看到世界的光。</p>
<h1 id="仆人的“命运”"><a href="#仆人的“命运”" class="headerlink" title="仆人的“命运”"></a>仆人的“命运”</h1><blockquote>
<p>7 以色列的救赎主，以色列的圣者耶和华，对那被人藐视的、 被本国憎恶的、<br>被统治者奴役的，这样说:<br>“君王看见了，就必起立，<br>领袖看见了，也要下拜，<br>都因信实的耶和华，就是拣选了你的、以色列的圣者的缘故。” 8 耶和华这样说:“在悦纳的时候，我应允了你，在拯救的日子，我帮助了你;我要保护你，使你作人民的中保，复兴那地，使人承受荒凉之地作产业</p>
</blockquote>
<p>这位仆人本是犹太人的后裔，却被犹太人憎恨。但是他是属神的，最终君王、领袖都要向他下拜。</p>
<p>这里提到，仆人会成为人的中保。这里中保在原文中有”约”的意思，就是人与神的约。“约”是一个旧约中重要的概念。神是通过跟人立约实现他的救赎。现在，这位仆人就是新约的本身！这位仆人带来的就像是出埃及一样的拯救。</p>
<blockquote>
<p>9 对那些被囚的说:‘你们出来吧!’对那些在黑暗中的人说:‘你们现身吧!’<br>他们沿途必得喂养，耶和华这样说: 一切光秃的高处必成为他们的草场。“埃及劳碌得来的和古实所得之利，<br>10 他们必不饥饿，也不口渴，<br>以及身量高大的西巴人，<br>炎热和太阳必不伤害他们，<br>都必过来归你，也要属你;<br>因为那怜悯他们的，要引领他们，<br>他们必带着锁炼过来随从你，<br>带领他们到水泉的旁边。<br>11 我必使我的众山成为道路， 向你恳求，说:<br>我的大道都必被修高。‘ 神真的在你们中间，此外，再没有别的神， 12 看哪!有些人从远方而来;<br>没有别的真神。’” 看哪!有些从北方，从西方而来，拯救者以色列的 神啊! 还有些从色尼姆地而来。”</p>
</blockquote>
<p>神的仆人会持续的带领人们走向神的国度。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>关于波斯王古烈的预言 - 以赛亚书45</title>
    <url>/2020/06/07/yisaiya_46/</url>
    <content><![CDATA[<p>我们每天要听见很多的声音，来自社会的、新闻的、亲人朋友的、父母的、公司同事老板的、网络上的等等。我们应该挺创造天地的耶和华的声音。神通过先知以赛亚证明他是独一的神，他把还未发生的事情指示给以赛亚。以赛亚在100多年前预言了古列王会让以色列人从重建圣殿。</p>
<p>他不仅说出了他的名字，也说出了将要做的事情。</p>
<blockquote>
<p>28 我对古列说:‘我的牧人; 他必成就我所喜悦的一切。’ 他要对耶路撒冷说:‘你必被重建起来!’ 他必对圣殿说:‘你的根基要奠定!’” 45 1“我耶和华所膏立的古列， 我紧握着他的右手， 使列国降服在他面前; 我也松开列王的腰带; 我使门户在他面前敞开，使城门不得关闭; 耶和华对古列这样说: 2 我必亲自领导你，把高低不平的路修平; 铜门，我必打破;铁门，我必砍断。</p>
<blockquote>
<p>以赛亚书44</p>
</blockquote>
</blockquote>
<ul>
<li>744-686年 以赛亚事奉的时间(以赛亚 1:1)</li>
<li>586 年 巴比伦掳走犹太人</li>
<li>538 年 古列成为波斯的君王，在接下来 20 年间征服了周围所有国家 </li>
<li>538 年 古列征服了巴比伦之后，吩咐了犹太人回去耶路撒冷重建圣殿</li>
</ul>
<p>很明显，正如耶和华自己的宣称，他是掌控历史的神，我们当然要耶和华的声音。</p>
<p>在这个预言之后，神又说出了另一个预言，一个关于全世界的预言：</p>
<blockquote>
<p>22 全地的人哪!你们都要归向我，都要得救。 因为我是 神，再没有别的 神。 23 我指着自己起誓， 我的口凭着公义说出的话， 决不改变: ‘万膝都必向我跪拜，万口都要指着我起誓。’ 24 人论到我必说: ‘只有在耶和华里面才有公义和能力’; 向他发怒的，都必来到他面前，并且要蒙羞。 25 以色列所有的后裔， 都必靠耶和华得称为义，并要夸胜。”</p>
<blockquote>
<p>以赛亚书45</p>
</blockquote>
</blockquote>
<p>耶和华是这样介绍他自己的：</p>
<blockquote>
<p>我从起初就宣告末后的事，从古时就述说还未作成的事，说:‘我的计划必定成功，<br>我所喜悦的，我都必作成。</p>
<blockquote>
<p>以赛亚书46</p>
</blockquote>
<p>17 唯有以色列必靠着耶和华得救， 得着永远的拯救;你们必不蒙羞，也不受辱，直到永远。18 因为创造诸天的耶和华，他是 神， 塑造大地，把大地造成;他坚立大地; 他创造大地，不是荒凉的; 他塑造大地，是要给人居住;他这样说: “我是耶和华，再没有别的 神。</p>
<blockquote>
<p>以赛亚书45</p>
</blockquote>
<p>11 以色列的圣者，造以色列的主耶和华这样说: “你们可以问我将要来的事， 关于我的众子和我手所作的， 你们也可以吩咐我回答。 12 我造了地，又造了人在地上; 我亲手展开了诸天， 又命定了天上的万象。</p>
<blockquote>
<p>以赛亚书44</p>
</blockquote>
</blockquote>
<h2 id="要听耶和华的声音，免得失去救恩"><a href="#要听耶和华的声音，免得失去救恩" class="headerlink" title="要听耶和华的声音，免得失去救恩"></a>要听耶和华的声音，免得失去救恩</h2><p>因为他是独一真神，在没有别的神。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>圣经的结构</title>
    <url>/2020/05/17/bible_structure/</url>
    <content><![CDATA[<h1 id="x1f4d6-基本信息"><a href="#x1f4d6-基本信息" class="headerlink" title="&#x1f4d6;基本信息"></a><span class="github-emoji" alias="book" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png?v8">&#x1f4d6;</span>基本信息</h1><p>圣经（Bible）是一系列不同文学体裁的书组成，分为新约和旧约两个部分。圣经总共包含了66卷书，成书时间跨越2千余年，由40位作者完成。最初版本的圣经主要由两种语言写成：希伯来语和希腊语。</p>
<p>旧约圣经包含39卷书，排列顺序在主前300年左右确定：</p>
<table>
<thead>
<tr>
<th>历史书</th>
<th>诗歌</th>
<th>先知书</th>
</tr>
</thead>
<tbody><tr>
<td>创世纪到以斯帖书</td>
<td>约伯记到雅歌</td>
<td>以赛亚书到玛拉基书</td>
</tr>
</tbody></table>
<p>在希伯来原文圣经中，排序略有不同：</p>
<table>
<thead>
<tr>
<th>律法书</th>
<th>先知书</th>
<th align="left">圣卷</th>
</tr>
</thead>
<tbody><tr>
<td>创世纪到申命记</td>
<td>大先知、小先知书</td>
<td align="left">诗篇、智慧书</td>
</tr>
</tbody></table>
<p>新约圣经包含27卷，其中福音书主要记叙耶稣基督的出生、讲道、神迹、受难以及复活的见证。使徒行传是路加接着路加福音之后，记叙耶稣基督升天后福音如何被传开的经过。使徒书信主要是使徒写给各个初代教会的书信，在圣灵的工作下启示关于耶稣基督的真理。启示录是约翰所写，记叙了他所见到的异象，其中的属灵事实隐藏在可见的现实世界。</p>
<table>
<thead>
<tr>
<th>福音书</th>
<th align="left">马太福音、马可福音、路加福音、约翰福音</th>
</tr>
</thead>
<tbody><tr>
<td>使徒行传</td>
<td align="left">路加关于初代使徒传道的历史</td>
</tr>
<tr>
<td>使徒书信</td>
<td align="left">罗马书到犹大书</td>
</tr>
<tr>
<td>启示录</td>
<td align="left">约翰关于审判的异象</td>
</tr>
</tbody></table>
<h2 id="x270d-圣经只有一个“作者”"><a href="#x270d-圣经只有一个“作者”" class="headerlink" title="&#x270d; 圣经只有一个“作者”"></a><span class="github-emoji" alias="writing_hand" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png?v8">&#x270d;</span> 圣经只有一个“作者”</h2><p>圣经的神奇之处在于，它虽然包含了各种不同的资料，并且由40位人类作者经过2000年的时间完成，但是它作为一个整体，却体现了惊人的一致性。</p>
<p>根据使徒的讲述这本书的作者其实是神，这本书其实只有一个主题，后面我们会展开这个主题。</p>
<p>使徒保罗说：圣经都是神所默示的。（提后3：16）</p>
<h2 id="x1f4c4-圣经的同一个主题"><a href="#x1f4c4-圣经的同一个主题" class="headerlink" title="&#x1f4c4; 圣经的同一个主题"></a><span class="github-emoji" alias="page_facing_up" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4c4.png?v8">&#x1f4c4;</span> 圣经的同一个主题</h2><p>圣经66卷书涉及到的领域非常广泛，但是有一个重要的主题将它们连接起来：耶稣基督以及神通过他实现的救赎计划。这不仅仅是在旧约中成立，在新约也是一样的主题。耶稣本人在提到旧约的时候说：给我作见证的就是这经。（约5：39）他从死里复活后，曾经对信徒说：“于是从摩西和众先知起，凡经上所指着自己的话都给你们讲解明白了。”（路24：27）“这就是我从前与你们同在的时候告诉你的话：摩西、律法、先知书和诗篇上所记，凡指着我的话都必须应验。”（路24：44）</p>
<p>旧约和新约并不是神的两个不同的计划，而是同一个计划的两个阶段。在旧约中，神透过给以色列人的应许预言了将来对人类的救赎，而新约耶稣基督的降临这是应许的实现。</p>
<h2 id="x1f4d3-圣经是一本书"><a href="#x1f4d3-圣经是一本书" class="headerlink" title="&#x1f4d3; 圣经是一本书"></a><span class="github-emoji" alias="notebook" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8">&#x1f4d3;</span> 圣经是一本书</h2><p>了解圣经是一本书，圣经有一个主题，对我们如何阅读圣经有着重要的影响。首先一个原则是，圣经绝大部分的内容是不能脱离上下文来阅读的。如果脱离上下文阅读很可能会曲解经文的原本意思。第二个原则是，阅读不同的文学体裁应该采用不同的阅读方法。比如阅读启示录这种体裁，就不能用度历史书的方法来阅读。</p>
<h1 id="x1f4e8-圣经概览"><a href="#x1f4e8-圣经概览" class="headerlink" title="&#x1f4e8; 圣经概览"></a><span class="github-emoji" alias="incoming_envelope" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4e8.png?v8">&#x1f4e8;</span> 圣经概览</h1><h2 id="神的国度"><a href="#神的国度" class="headerlink" title="神的国度"></a>神的国度</h2><p>为了阅读圣经，我们首先需要确定一个贯穿始终的主题。这样我们才能把圣经的各个部分组织起来。这个主题必须出自圣经本身，但是又能把圣经每个部分贯穿起来，而这个主题就是：神的国度。</p>
<p>耶稣在他的第一次讲道中这样说：“日期满了，神的国近了”（可1：15）。可见神的国度在他的讲道中具有及其重要的意义。在旧约中，神的国度这个主题也是应许的重要部分：神的子民在神的地方接受神的掌管和祝福。</p>
<h2 id="圣经概览"><a href="#圣经概览" class="headerlink" title="圣经概览"></a>圣经概览</h2><p>那么根据神的国度这个主题，我们可以把圣经分解成以下几个部分看：</p>
<ul>
<li>旧约<ul>
<li>雏形的国度</li>
<li>失落的国度</li>
<li>应许的国度</li>
<li>局部的国度</li>
<li>预言的国度</li>
</ul>
</li>
<li>新约<ul>
<li>当下的国度</li>
<li>宣告的国度</li>
<li>完美的国度</li>
</ul>
</li>
</ul>
<p>雏形的国度，就是伊甸园的世代，人类和神共同在一起，人类在神的掌管下接受神的祝福。神也说，这是好的。</p>
<p>失落的国度，就是亚当和夏娃多落后被赶出伊甸园的世代，他们失去了神的祝福。但是神依然希望带他们回到自己的身边。</p>
<p>应许的国度，神拣选了亚伯拉罕，并给了他应许：万国将通过他得到祝福。</p>
<p>局部的国度，主要是以色列从出埃及以后的历史。</p>
<p>预言的国度，以色列灭国，神预言弥撒亚的降临和神国度的降临。</p>
<p>当下的国度，耶稣基督降世，通过自己的死亡和复活完成了对人类的救赎</p>
<p>宣告的国度，耶稣升天后，福音在万国被传开。** （这就是我们的世代！）**</p>
<p>完美的国度，启示录中预言的基督再临，审判完成，神的国度彻底降临。我们的世代终结。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《上帝的蓝图》，Vaughan Roberts</li>
</ul>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>Bible</tag>
      </tags>
  </entry>
  <entry>
    <title>“你不要惧怕，我是你的神” - 以赛亚书41</title>
    <url>/2020/05/17/yisaiya2/</url>
    <content><![CDATA[<p>在新冠肺炎这个特殊的时期，来自先知以赛亚的预言对我们是极大的鼓励。我们在这种时期是最缺乏安全感的时候，面对危机，我们从哪里得到力量？</p>
<p>在这种时期，我们也应该更加谨慎，力量应该来自耶和华，不应该来自各式各样的偶像！</p>
<h1 id="我们从哪里获得力量？"><a href="#我们从哪里获得力量？" class="headerlink" title="我们从哪里获得力量？"></a>我们从哪里获得力量？</h1><p>“手”的概念不断在这段经文中出现，神是个灵，但是经文用比喻告诉我们神是我们的依靠。</p>
<p><strong>以赛亚书41：10 不要惧怕，因为我与你同在;不要四处张望，因为我是你的 神，<br>我必坚固你，我必帮助你;我必用公义的右手扶持你。</strong></p>
<p><strong>以赛亚书41：13  因为我，耶和华你们的神，紧握着你的右手，对你说：“不要惧怕，我必帮助你。”</strong></p>
<p>耶和华是信实不变的神，他说的话依然生效。这就是我们在面对危险和不确定性的时候，获得力量的地方。握住耶和华全能的手。</p>
<h1 id="偶像的软弱"><a href="#偶像的软弱" class="headerlink" title="偶像的软弱"></a>偶像的软弱</h1><p>面对不确定性，去选择依靠偶像，只会带来更多的恐惧。为什么呢？因为偶像都是人手所造的，注定会朽坏的、及其不稳定的东西。当你选择依靠他们的同时，你已经开始恐惧偶像有一天离开你。</p>
<p>先知以赛亚是这样说的：</p>
<p><strong>41：28 看哪!他们都是无有，他们所作的都是虚无; 他们所铸的偶像都是风，都是虚空。</strong></p>
<h1 id="我们为什么惧怕？"><a href="#我们为什么惧怕？" class="headerlink" title="我们为什么惧怕？"></a>我们为什么惧怕？</h1><p>我们担心失去我们关心的东西：生命、爱情、金钱、健康、权利、地位、亲密关系等等。</p>
<p>我们认为我们只能自己面对一切。</p>
<p>我们害怕自己不能掌控的事情。</p>
<p>但是，</p>
<p>神，掌管一切。</p>
<h1 id="一首诗歌"><a href="#一首诗歌" class="headerlink" title="一首诗歌"></a>一首诗歌</h1><p>我的诗歌 我的拯救<br>祢是我患难中随时的帮助<br>众山怎样围绕耶路撒冷<br>祢必围绕我到永远  </p>
<p>主祢是我力量 主祢是我高台<br>坚固盘石我信靠祢必不动摇<br>主祢是我力量 主祢是避难所<br>我的盼望只在乎祢  </p>
<p><a href="https://www.youtube.com/watch?v=izOAxx2bRIc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=izOAxx2bRIc</a></p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新科学</title>
    <url>/2020/05/16/a_new_kind_of_science/</url>
    <content><![CDATA[<blockquote>
<p>一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
</blockquote>
<h1 id="1、新科学的基础"><a href="#1、新科学的基础" class="headerlink" title="1、新科学的基础"></a>1、新科学的基础</h1><p>简单的规则，可以形成复杂的行为。</p>
<p>如果人也是规则计算的一部分，自由意志又是如何与之协调的？</p>
<p>数学、物理、生物学、社会学、哲学、计算机科学、艺术的关系。这个系统真的解决了这些领域的基本问题吗？？</p>
<h1 id="2、关键性的实验"><a href="#2、关键性的实验" class="headerlink" title="2、关键性的实验"></a>2、关键性的实验</h1><p>每一个新的科学产生都起始于某一个现象或者观察。这本书的起点是程序和计算。日常生活中程序通常是为了某些特殊的目的编写的，那么问题来了，如果我们随便选一些程序，而没有明确的目的，这些程序的运行结果会是什么呢？</p>
<p>上面这个问题，数学很难解决，而最简单的办法就是用计算机进行试验。</p>
<p>程序从抽象的角度可以理解成为：包含一些规则（Rules），这些会规定每一步做什么。设定规则的方式有很多。比如cellular automata，元细胞自动机。</p>
<p>重要的发现是：简单的规则，可以产生复杂的模式。这也是本书的所谓新科学的核心思想。</p>
<p>Rule30，是一个简单的规则，但是产生了随机数。</p>
<p>问题是当我们观察到非常复杂的行为时，产生这种行为的规则（如果是有规则产生的话）可能非常简单。</p>
<h1 id="3、简单程序的世界！"><a href="#3、简单程序的世界！" class="headerlink" title="3、简单程序的世界！"></a>3、简单程序的世界！</h1><p>问题：简单程序的一般行为是什么样的？</p>
<p>作者发现的规律：</p>
<ul>
<li>Cellular automata, 不仅可以产生重复的模式，还可以产生随机性</li>
<li>Substitute system，似乎只能产生重复的模式，而不能产生随机性</li>
<li>Sequence Substitute system，也可以产生随机性</li>
<li>Tag system</li>
<li>Cyclic Tag system</li>
<li>Symbolic system</li>
</ul>
<p>（是吗？）</p>
<p>作者发现，在很多迥异的系统中，简单的规则总是能够产生复杂的行为，甚至随机性。所以这种简单导致的复杂性普遍存在。下一个问题是：什么时候会出现复杂性？通过目前的实验，如果规则很简单，会出现重复的行为；规则稍微复杂，会出现嵌套类型的现象；当规则进一步复杂，就会出现更加复杂的行为，比如混合和随机性。</p>
<p>作者发现，出现复杂行为的阈值通常很低。但是，一旦超过阈值，提高规则的复杂度，并不能显著提高系统的复杂性。复杂的系统行为与规则的复杂度并没有显著的关联，也就是说，行为异常复杂的系统，其控制规则可能非常简单。</p>
<p>据此，作者推断应该存在一般性的原则控制这些系统的复杂度。</p>
<p>（如何定义复杂度？随机性？熵？）</p>
<p>这章最后作者提到了一些对传统数学和物理研究方法的看法：<br>他的研究方法在传统领域可能会被认为是不精确的，但是传统方法是从现象出发的，可能不能发现上文的复杂度。作者采用了实验的途径。</p>
<h1 id="4、基于数字的系统"><a href="#4、基于数字的系统" class="headerlink" title="4、基于数字的系统"></a>4、基于数字的系统</h1><p>基于数字的系统在传统科学和数学领域非常普遍。那么，基于数字的系统是不是能够产生复杂度？作者给出的答案是肯定的。</p>
<p>（这类系统与细胞自动机系统有什么区别和联系？）</p>
<p>数学系统的基础是数字系统，而计算系统（比如细胞自动机）的基础是通过一个序列的代码。这种代码的表达方式在自然界非常常见，比如DNA。</p>
<h2 id="基础代数"><a href="#基础代数" class="headerlink" title="基础代数"></a>基础代数</h2><p>基础代数的操作（operation，也可以看做规则的一种吧）非常简单，但是作者发现即使这种规则也可以产生复杂系统行为，就像上一章的细胞自动机。</p>
<p>比如，以1作为基，持续加1，就像1，2，3，….从数学的角度看这是一个再简单不过的操作，但是如果我们看这个操作以二进制的形式就会呈现一定的复杂度。</p>
<p><img data-src="https://i.imgur.com/7yhmZHN.png" alt="简单加法的二进制模式"></p>
<p>有人可能提出疑问，就是这种复杂度仅仅是看起来而已，并没有本质的复杂度。但是作者提出了新的例子：除法。</p>
<p>(其实无理数对于数字来说已经非常奇葩了。。。随机性还记得吗？)</p>
<p><img data-src="https://i.imgur.com/yNSwlnU.png" alt="这个看起来就好像股票价格"></p>
<p>这些系统与细胞自动机不同，细胞自动机的变化通常是局部的，而数字系统则没有这个限制。</p>
<h2 id="递归序列"><a href="#递归序列" class="headerlink" title="递归序列"></a>递归序列</h2><p>比如，$f[n] = f[n-1] + f[n-2]$。简单的规则可以发现：</p>
<p><img data-src="https://i.imgur.com/WCTTJpN.png" alt=""></p>
<p>但是，如果稍微增加复杂度，我们就会发现复杂系统行为：</p>
<p><img data-src="https://i.imgur.com/kBF0hMf.png" alt=""></p>
<h2 id="数学常数"><a href="#数学常数" class="headerlink" title="数学常数"></a>数学常数</h2><p>常数比如$\pi$, $e$，无理数等等。</p>
<p><img data-src="https://i.imgur.com/GxEXKZd.png" alt=""></p>
<p>作者表明，不论采用哪种形式表达，数学常数也表现了高的复杂度。</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>一个自然的推广就是函数。简单函数只要稍微叠加，就会出现复杂现象。</p>
<p><img data-src="https://i.imgur.com/X5ANIxW.png" alt=""></p>
<h2 id="连续细胞自动机"><a href="#连续细胞自动机" class="headerlink" title="连续细胞自动机"></a>连续细胞自动机</h2><p>目前为止作者讨论的系统全部都是离散系统。</p>
<p><img data-src="https://i.imgur.com/Wgjq8VT.png" alt=""></p>
<h2 id="连续系统和离散系统"><a href="#连续系统和离散系统" class="headerlink" title="连续系统和离散系统"></a>连续系统和离散系统</h2><p>区别在哪里呢？</p>
<h1 id="5、二维和更高维度"><a href="#5、二维和更高维度" class="headerlink" title="5、二维和更高维度"></a>5、二维和更高维度</h1><p>结论是，维度的增加并没有改变复杂度的基本特征。</p>
<h2 id="高纬度细胞自动机"><a href="#高纬度细胞自动机" class="headerlink" title="高纬度细胞自动机"></a>高纬度细胞自动机</h2><p><img data-src="https://i.imgur.com/wKcVljW.png" alt=""></p>
<p>这个像不像雪花？自然界的现象。</p>
<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><h2 id="Substitute系统和分型"><a href="#Substitute系统和分型" class="headerlink" title="Substitute系统和分型"></a>Substitute系统和分型</h2><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><p>这个其实已经看到了现在火爆的作者的物理学项目的影子了。</p>
<h1 id="6、从随机性说起"><a href="#6、从随机性说起" class="headerlink" title="6、从随机性说起"></a>6、从随机性说起</h1><p>作者综合分析了细胞自动机的四类行为，并且认为这些行为具有通用价值。</p>
<h1 id="7、程序和自然界的机理"><a href="#7、程序和自然界的机理" class="headerlink" title="7、程序和自然界的机理"></a>7、程序和自然界的机理</h1><p>作者让我们看到自然界的很多现象都与之前的介绍的内容非常相似。</p>
<p><em>随机性</em></p>
<ul>
<li>外界注入随机性，通过与系统外界的通讯</li>
<li>初始条件随机性</li>
<li>自身演化产生随机性，无外界通讯</li>
</ul>
<p>作者认为第三种是控制自然界随机性的主要形式。</p>
<p>（是否有可能是三者的共同作用呢？）</p>
<p>（预定论和随机性并不冲突。）</p>
<p>作者认为随机性是让离散系统看起来像连续系统的原因。（实际上我觉得这个世界本身就是离散的，现代物理学似乎也支持这个观点）</p>
<h1 id="8、对日常系统的分析"><a href="#8、对日常系统的分析" class="headerlink" title="8、对日常系统的分析"></a>8、对日常系统的分析</h1><h2 id="8-1-建模的问题"><a href="#8-1-建模的问题" class="headerlink" title="8.1 建模的问题"></a>8.1 建模的问题</h2><p>从简单规则演化的角度思考很多系统的现象，似乎可以解释一些基础的问题。</p>
<h1 id="9、物理学的基础"><a href="#9、物理学的基础" class="headerlink" title="9、物理学的基础"></a>9、物理学的基础</h1><p>我们的宇宙看起来异常复杂，那么，我们的宇宙可能是由简单规则经过迭代产生吗？这本书的一个重要发现就是：复杂现象的成因不一定是复杂的。</p>
<p>值得注意的是，作者指出即使上面这个假设成立，这个系统并不具有可逆性，我们无法通过反向工程我们的宇宙找到对应的法则。</p>
<p>好，如果我们假设宇宙的演化可以由简单规则表达，那么我们如何找到这些规则？这些规则有什么特征？</p>
<p>细胞自动机可能不是一个好的选择，因为它的演化被限制在了一些格子里。。（也许这只是编码结构的不同而已，最终他们代表了相同的意义？）</p>
<p>作者对传统物理提出了挑战，他认为目前的物理定律并没有解释基础问题，而仅仅是规则在大尺度下的一些特征。换句话说，目前的物理定律，对解释基础物理毫无作用！</p>
<h2 id="空间的本质"><a href="#空间的本质" class="headerlink" title="空间的本质"></a>空间的本质</h2><p>物理学普遍认为空间是连续的，但是对于细胞自动机而言，他们的空间显然是离散的。</p>
<p>那么问题是：如何对这样的宇宙建模？</p>
<p>作者选择了用网络的形式表达空间。每一个节点具有三个连接。</p>
<h2 id="时间和空间的联系"><a href="#时间和空间的联系" class="headerlink" title="时间和空间的联系"></a>时间和空间的联系</h2><p>作者相信时间也是离散的。同样采用网络进行建模：因果网络。</p>
<h1 id="10、认知与分析"><a href="#10、认知与分析" class="headerlink" title="10、认知与分析"></a>10、认知与分析</h1><p>解释人类感知和分析能力。</p>
<h1 id="11、计算的语言"><a href="#11、计算的语言" class="headerlink" title="11、计算的语言"></a>11、计算的语言</h1><p>泛化的原细胞自动机。</p>
<h1 id="12、计算等价原则"><a href="#12、计算等价原则" class="headerlink" title="12、计算等价原则"></a>12、计算等价原则</h1><p>假设: 一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
<p>自从计算机诞生，计算的对象已经从抽象的数字发展到图像、声音等等。</p>
<p>从计算的角度看，即使具有截然不同的内部结构的系统仍然具有一定的等价性。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Computation</tag>
      </tags>
  </entry>
  <entry>
    <title>依靠耶和华的人必重新得力</title>
    <url>/2020/05/10/bible2/</url>
    <content><![CDATA[<h1 id="神的伟大"><a href="#神的伟大" class="headerlink" title="神的伟大"></a>神的伟大</h1><p>先知以赛亚在40章向以色列人描述了神的伟大。他用了一系列惊人的反问句，向人们展示了神的伟大。</p>
<p>首先是神的伟大自然力量：谁曾用掌心量过海水？用手掌测过苍天？用升斗量过大地？用秤称量过山岭？答案显然是没有人。物质世界在神的眼中不过是举手之间就能掌控的事情。</p>
<p>然后是神的奇妙智慧：谁曾测度耶和华的灵？谁做过他的谋士？谁使神有聪明？谁又曾经教导神明智的路？答案显然是没有人。神的拥有终极的智慧。</p>
<p>最后是神的伟大和人的渺小的对比：万国就像水桶中的一滴，就像天平上面的尘埃，万国在他眼中好像不存在，在他看来，只有乌有和虚空。</p>
<h1 id="偶像的懦弱"><a href="#偶像的懦弱" class="headerlink" title="偶像的懦弱"></a>偶像的懦弱</h1><p>你们把谁来跟神相比呢？你们用什么形象跟神并列呢？</p>
<p>你们铸造偶像来敬拜，可是这些偶像居然都不能自立，而需要人的维护才能得以站立。这也是必然的，因为所有被造之物都是必然会朽坏的，为有神的道是永恒长存的。“花必凋谢，草必枯干，唯有神的道永远长存！”</p>
<p>所以，我们为什么还是要依靠必然朽坏的东西呢？权利、金钱、地位、一份体面的工作，这些东西终究都是靠不住的，如果我们依靠这些东西，就是我们依靠必然朽坏的偶像，最终我们什么也得不到。</p>
<h1 id="神才是人唯一的依靠"><a href="#神才是人唯一的依靠" class="headerlink" title="神才是人唯一的依靠"></a>神才是人唯一的依靠</h1><p>只有神才是“靠得住”的，以为他的伟大和全能。更加令人兴奋的是，神虽然伟大，但是他在乎我们这些“草芥”一般的人，他珍惜我们这些人类，以为我们是按照神的形象所造的。</p>
<p>28你不知道吗？你没有听过吗？<br>永在的　神、耶和华、地极的创造主既不疲乏，也不困倦；<br>他的知识无法测度。<br>29疲乏的，他赐气力，<br>无力的，他加力量。<br>30就是年轻人也会疲乏困倦，<br>强壮的人也会全然跌倒。<br>31但那些仰望耶和华的人，<br>必重新得力；<br>他们必像鹰一样展翅上腾；<br>他们奔跑，也不困倦，<br>他们行走，也不疲乏。</p>
<h1 id="诗篇121的鼓励"><a href="#诗篇121的鼓励" class="headerlink" title="诗篇121的鼓励"></a>诗篇121的鼓励</h1><p>最后，我附上来自诗篇的鼓励，耶和华 神是我们唯一的依靠。</p>
<p>朝圣之歌<br>1我要向群山举目，<br>我的帮助从哪里来呢？<br>2我的帮助是从<br>造天地的耶和华而来。<br>3他必不使你的脚滑倒；<br>保护你的必不打盹。<br>4看哪！保护以色列的，<br>必不打盹，也不睡觉。<br>5保护你的是耶和华，<br>耶和华在你的右边荫庇你。<br>6白天太阳必不伤你，<br>夜里月亮必不害你。<br>7耶和华要保护你脱离一切灾祸，<br>他要保护你的性命。<br>8你出你入，耶和华要保护你，<br>从现在直到永远。</p>
<p>平安。</p>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>以赛亚书</tag>
        <tag>诗篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph - DiGraph</title>
    <url>/2020/05/09/graph3_digraph/</url>
    <content><![CDATA[<h1 id="1-Concepts"><a href="#1-Concepts" class="headerlink" title="1. Concepts"></a>1. Concepts</h1><p><strong>Definition.</strong> A <code>directed graph</code> or <code>digraph</code> is a set of nodes and a<br>collection of <code>directed edges</code>. Each directed edge connects an ordered<br>pair of nodes.</p>
<p><strong>Definition.</strong> A <code>directed path</code> is a path in a digraph is a sequence of nodes in which there is a directed edge pointing from each node in the sequence to its successor in the sequence. A <code>directed cycle</code> is a directed path with at least one edge whose first and last nodes are the same. A <code>simple cycle</code> is a cycle with no repeated edges or nodes. The <code>length</code> of a path is its number of edges.</p>
<p>With above, we can define that a node a is reachable from node b if there is a directed path from a to b. </p>
<h1 id="2-Data-Structure"><a href="#2-Data-Structure" class="headerlink" title="2. Data Structure"></a>2. Data Structure</h1><p>Again, before we go to the algorithms of DiGraph, let’s define our data structure representation of digraph. Full code can be found here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py" target="_blank" rel="noopener">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py</a>.</p>
<p>Here I list the important part. DiGraph is a bit different from Undirected graph in terms of its internal data containers. DiGraph has not only <code>_adj</code> for adjacent list, but also has <code>_succ</code> and <code>_pred</code> which is used to represent the direction of edges. What’s more, there is a <code>reverse</code> function to reverse the direction of the edges in the graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Hashable</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygraph.entities.graph <span class="keyword">import</span> GraphBase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span><span class="params">(GraphBase)</span>:</span></span><br><span class="line">    <span class="string">""""""</span></span><br><span class="line"></span><br><span class="line">    dict_dict_dict = dict</span><br><span class="line">    dict_dict = dict</span><br><span class="line">    node_factory = dict</span><br><span class="line">    edge_factory = dict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">""""""</span></span><br><span class="line">        super().__init__(kwargs)</span><br><span class="line">        self._succ = self._adj</span><br><span class="line">        self._pred = self.dict_dict_dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span><span class="params">(self, node: Hashable, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">""" Add node to graph,</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :param kwargs: node's meta data</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node] = self.dict_dict()</span><br><span class="line">            self._pred[node] = self.dict_dict()</span><br><span class="line">            attr_dict = self._nodes[node] = self.node_factory()</span><br><span class="line">            attr_dict.update(kwargs)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># already existed</span></span><br><span class="line">            self._nodes[node].update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(self, node_a: Hashable, node_b: Hashable, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">""" add edge to graph</span></span><br><span class="line"><span class="string">        :param node_a:</span></span><br><span class="line"><span class="string">        :param node_b:</span></span><br><span class="line"><span class="string">        :param kwargs: meta data for edge, weights can go here!</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node_a <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_a] = self.dict_dict()</span><br><span class="line">            self._pred[node_a] = self.dict_dict()</span><br><span class="line">            self._nodes[node_a] = self.node_factory()</span><br><span class="line">        <span class="keyword">if</span> node_b <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_b] = self.dict_dict()</span><br><span class="line">            self._pred[node_b] = self.dict_dict()</span><br><span class="line">            self._nodes[node_b] = self.node_factory()</span><br><span class="line"></span><br><span class="line">        data = self._adj[node_a].get(node_b, self.edge_factory())</span><br><span class="line">        data.update(kwargs)</span><br><span class="line">        self._succ[node_a][node_b] = data</span><br><span class="line">        self._pred[node_b][node_a] = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj_nodes</span><span class="params">(self, node: Hashable)</span>:</span></span><br><span class="line">        <span class="string">""" find adj nodes view</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._succ[node]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span> -&gt; GraphBase:</span></span><br><span class="line">    <span class="string">""" reverse the graph """</span></span><br><span class="line">    gp = self.__class__()</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> self.nodes:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> self._adj[a]:</span><br><span class="line">            gp.add_edge(b, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gp</span><br></pre></td></tr></table></figure>

<h1 id="3-Problems"><a href="#3-Problems" class="headerlink" title="3. Problems"></a>3. Problems</h1><p>Ok, let’s visit some of the problems around DiGraph:</p>
<ul>
<li>Single-source reachability</li>
<li>Topological sort</li>
<li>Strong connectivity</li>
</ul>
<p>These problem is similar to what we have in <a href="https://wangzhe3224.github.io/2020/05/02/graph2_search/" target="_blank" rel="noopener">undirected graph</a>. </p>
<h2 id="3-1-Single-source-reachability"><a href="#3-1-Single-source-reachability" class="headerlink" title="3.1 Single-source reachability"></a>3.1 Single-source reachability</h2><blockquote>
<p>Given a digraph and a source node <em>a</em>, support query of the form: Is there a directed path from <em>a</em> to a given node <em>x</em>?</p>
</blockquote>
<p>This problem is solved using the same function as in undirected graph. Both single-source directed path(DFS) and shortest directed path (BFS).</p>
<p>Related code: <a href="https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos" target="_blank" rel="noopener">https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos</a></p>
<h2 id="3-2-Topological-sort"><a href="#3-2-Topological-sort" class="headerlink" title="3.2 Topological sort"></a>3.2 Topological sort</h2><p>This is a scheduling problem. Defines:</p>
<blockquote>
<p>Given a digraph, put the nodes in order such that all its directed edges point from a node earlier in the order to a node later in the order. Or does not exist. </p>
</blockquote>
<p>In order to solve this, we first need to make sure, there is no cyclic in the graph. or make sure the graph a DAG, directed acyclic graph. <strong>So first we need a algorithm to detect cyclic in a graph.</strong></p>
<p>The solution is leverage DFS’s stack, one fact is that all the node in current stack is in the same path, of we find a node that appear twice in the stack, we know there is a cyclic, hence graph is not a DAG.</p>
<p>Once we know we have a DAG, the next job is to find the order. It turns out that it is another application of DFS.</p>
<h2 id="3-3-Strong-connection"><a href="#3-3-Strong-connection" class="headerlink" title="3.3 Strong connection"></a>3.3 Strong connection</h2><p>Strong connection between a and b is that they are mutually reachable. </p>
<p>The solution is similar to cyclic detection in undriected graph, but we need loop through reverse post order in previous section. </p>
<p>Check code here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28" target="_blank" rel="noopener">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28</a></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph Algorithms - Search</title>
    <url>/2020/05/02/graph2_search/</url>
    <content><![CDATA[<p>When working with graph, search is an important topic. For example, search for connectivity, search for shortest path. There are two basic strategies to do search in graph: Depth-first(DFS) and Breadth-first(BFS). <strong>Note that in this blog, all the discussions are based on undirected graph</strong>. But the strategy can be used to all kind of graphs given they share similar data structures.</p>
<h1 id="What-kind-of-problems-we-are-solving"><a href="#What-kind-of-problems-we-are-solving" class="headerlink" title="What kind of problems we are solving?"></a>What kind of problems we are solving?</h1><p>The basic idea of search in general is to walk through the data structure and collection information we need. In terms of Graph, only two elements matters: nodes (vertices) and edges. Walking through a graph, really means iterating the nodes in a way.</p>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>The next questions to ask is that how can I solve a question by looping through the least nodes? Well to answer this question, we need to decide a data structure to represent graph. </p>
<p>Here we select a straight forward way: adjacent list. Completed code can be found <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/graph.py" target="_blank" rel="noopener">here</a></p>
<p>Essentially, we use dict of dict to represent nodes, and dict of dict of dict to represent adjacent list. I know.. it is not a list at all. But the idea is the same, the benefit of using a dict is that it is very easy to embed meta data to either nodes or edges. And it is an easy way to extend this data structure to other types of graph, say weighted graph. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span><span class="params">(Graph)</span>:</span></span><br><span class="line">    <span class="string">""""""</span></span><br><span class="line">    dict_dict_dict = dict</span><br><span class="line">    dict_dict = dict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""""""</span></span><br><span class="line">        self.__adj = self.dict_dict_dict()  <span class="comment"># dict of dict of dict</span></span><br><span class="line">        self.__nodes = self.dict_dict()  <span class="comment"># dict of dict</span></span><br></pre></td></tr></table></figure>

<p>And.. in the end, dict (hash map) is just a list with hashable index instead of int as index. Or in another words, dict is just a generalized list… alright.. too far away. <span class="github-emoji" alias="smirk" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">&#x1f60f;</span> </p>
<p>For example, we can represent graph: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 2 - 3</span><br><span class="line">    |</span><br><span class="line">    4</span><br></pre></td></tr></table></figure>

<p>with following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__adj &#x3D; &#123;1: &#123;2: &#123;&#125;&#125;, 2:&#123;3:&#123;&#125;, 4:&#123;&#125;&#125;, 3:&#123;2:&#123;&#125;&#125;, 4:&#123;2:&#123;&#125;&#125;&#125;</span><br><span class="line">__nodes &#x3D; &#123;1:&#123;&#125;, 2:&#123;&#125;, 3:&#123;&#125;, 4:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Search-strategy"><a href="#Search-strategy" class="headerlink" title="Search strategy"></a>Search strategy</h1><p>Ok, we got our little dict(s), the next question is how can we search or walk through this structure? Well when we meet the first node, there are two obvious ways: 1. go to one of its adjacent node and go even deeper via that node. 2. go to all of its adjacent nodes and do the same for other nodes. </p>
<p>The first way is called depth-first, the second is called breadth-first.</p>
<p>Apperently they have different properties.</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><p>For detailed code, please go <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py" target="_blank" rel="noopener">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py</a></p>
<p>We can prove that DFS marks all the nodes connected to a given node in time proportional to the sum of their degrees.</p>
<p>Recall <code>degree of a node</code> is the number of nodes connected to it directly. </p>
<p>This strategy is efficient in may problems:</p>
<ul>
<li>Given a graph, are two given nodes are connected? This question, is equivalent to ask, given two nodes, is there a path from node a to b? if so, find me the path (in terms of sequence of nodes of course)!</li>
<li>How many connected components does the graph have?</li>
</ul>
<p>All right, let’s try to solve a find path problem using DFS.</p>
<p>Here is one question: given a graph, node a, calculate <em>one</em> path between a and the rest of the nodes, if no path, return None.</p>
<p>So let’s start with a recursive way, which is the nature of DFS. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_view</span><span class="params">(nodes, edge_to: dict, source)</span>:</span></span><br><span class="line">    <span class="string">""" convert edge_to to path view """</span></span><br><span class="line">    _paths = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> edge_to:  <span class="comment"># has a path</span></span><br><span class="line">            path = []</span><br><span class="line">            _next = node</span><br><span class="line">            <span class="keyword">while</span> _next != source:</span><br><span class="line">                path.append(_next)</span><br><span class="line">                _next = edge_to[_next]</span><br><span class="line">            path.append(source)</span><br><span class="line">            _paths[node] = path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _paths[node] = <span class="literal">None</span>   <span class="comment"># no path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _path</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_path</span><span class="params">(graph, source)</span>:</span></span><br><span class="line">    <span class="string">""" get paths from source to other nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string">    Note: not all the path, but one of the path if exist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param graph: Graph</span></span><br><span class="line"><span class="string">    :param source: the source node</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#123;target: [source, x, x, node2]&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    visited = set()</span><br><span class="line">    edge_to = &#123;&#125;  <span class="comment"># magic path..</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs_path</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _node <span class="keyword">in</span> graph[start]:  <span class="comment"># all its neighbour</span></span><br><span class="line">            <span class="keyword">if</span> _node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(_node)</span><br><span class="line">            edge_to[_node] = start</span><br><span class="line">            _dfs_path(graph, _node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    _dfs_path(graph, source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, edge_to, source)</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><p>Breadth-first search use a different strategy from depth-first search. It will search all the connected nodes and do the same process to sub-nodes. While depth search will go down a path to the end.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_path</span><span class="params">(graph, source)</span>:</span></span><br><span class="line">    <span class="string">""" a breadth first search for paths. These suppose to be the shortest paths.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reference</span></span><br><span class="line"><span class="string">    ---------</span></span><br><span class="line"><span class="string">    &lt;Algorithms 4th edition&gt; by Robert Sedgewick. P540</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param source: a source node</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    _queue = deque([])</span><br><span class="line">    _visited = set()</span><br><span class="line">    _queue.append(source)</span><br><span class="line">    _edge_to = &#123;source: source&#125;</span><br><span class="line">    <span class="keyword">while</span> _queue:</span><br><span class="line">        cur_node = _queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[cur_node]:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> _visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            _visited.add(cur_node)</span><br><span class="line">            _edge_to[child] = cur_node</span><br><span class="line">            _queue.append(child)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, _edge_to, source</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph basics - 1 Concepts</title>
    <url>/2020/04/25/graph1/</url>
    <content><![CDATA[<p>Graph is a mathematical object to model pairwise connections between objects. There are a lot of applications:</p>
<p><img data-src="https://i.imgur.com/aDYbUMC.png" alt="Typical graph applications"></p>
<a id="more"></a>

<h1 id="1-Definitions"><a href="#1-Definitions" class="headerlink" title="1. Definitions"></a>1. Definitions</h1><p>Definition: </p>
<ul>
<li>A <code>graph</code> is a set of vertices and a collection of edges that each connect a pair of vertices.</li>
<li>A <code>Bipartite graph</code> is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set.</li>
</ul>
<p>Definition: </p>
<ul>
<li>A <code>path</code> in a graph is a sequence of vertices connected by edges. </li>
<li>A <code>simple path</code> is one with no repeated vertices. </li>
<li>A <code>cycle</code> is a path with at least one edge whose first and last vertices are the same.</li>
<li>A <code>simple cycle</code> is a cycle with no repeated edges or vertices.</li>
<li><em>length</em> of a path or cycle is its number of edges.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A graph is <code>connected</code> if there is a path from every vertex to every other vertex in the graph.</li>
<li>A graph is <code>not connected</code> consists of a set of connected <code>components</code>, which are maximal connected subgraphs. </li>
<li>An <code>acyclic</code> graph is graph without cycles.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A <code>tree</code> is an <code>acyclic connected</code> graph.</li>
<li>A disjoint set of trees is called a <code>forest</code>.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>The <code>density</code> of a graph is the proportion of possible pairs of vertices that are connected by edges.</li>
</ul>
<p><img data-src="https://i.imgur.com/goP5flX.png" alt="Anatomy of a graph"></p>
<p><img data-src="https://i.imgur.com/RHAkNfF.png" alt="A tree"></p>
<p><img data-src="https://i.imgur.com/zRy67JE.png" alt="A forest"></p>
<h1 id="2-Graph-Interface"><a href="#2-Graph-Interface" class="headerlink" title="2. Graph Interface"></a>2. Graph Interface</h1><p>We now need to define fundamental graph operation interface and find a data structure to represent undirected graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span></span><br><span class="line">    <span class="string">""" Vertex """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="string">""" Edge """</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphOperation</span>:</span></span><br><span class="line">    <span class="string">""" Graph operation interface """</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(v: Vertex, m: Vertex)</span>-&gt;<span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">""""""</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj</span><span class="params">(v: Vertex)</span> -&gt; []:</span></span><br><span class="line">        <span class="string">""" find adjacent to v """</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">degree</span><span class="params">(v: Vertex)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">""" get degree of """</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_self_loops</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">        <span class="string">""" number of self loops """</span></span><br></pre></td></tr></table></figure>

<p>In the end, most of the operations can be done via <code>adj</code> method. We could add more operations for graph, but it will depends on the application’s use case. </p>
<h1 id="3-Data-Structures"><a href="#3-Data-Structures" class="headerlink" title="3. Data Structures"></a>3. Data Structures</h1><p>There are several ways to represent graph, such as adjacent matrix, array of edges, and adjacent list. Here we select adjacent list because it makes <code>adj</code> method very simple and it will also be able to represent parallel edges whereas adjacent matrix cannot do.</p>
<p><code>adjacent list</code> representation has following characteristics:</p>
<ul>
<li>space usage is proportional to V + E</li>
<li>constant time to add an edge</li>
<li>constant time per adjacent vertex processed</li>
</ul>
<p>However, the order of adjacent vertex is random for now. We could add order for it (but add some time complex).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span><span class="params">(GraphOperation)</span>:</span></span><br><span class="line">    <span class="string">"""  """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">        self.__adj_list = []  <span class="comment"># type: List[Vertex]</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.imgur.com/G0aulAp.png" alt="Adjacent list representation"></p>
<h1 id="4-Design-Pattern-of-graph-processing"><a href="#4-Design-Pattern-of-graph-processing" class="headerlink" title="4. Design Pattern of graph processing"></a>4. Design Pattern of graph processing</h1><p>The idea here is to delegate more complex operations from Graph interface, such as search connected vertex, find path or find shortest path.</p>
<p>Common algorithms:</p>
<ul>
<li>search connected vertex</li>
<li>find paths</li>
<li>find shortest path</li>
<li>is connected components?</li>
<li>is a acylic graph?</li>
<li>is graph bipartite?</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Risk Is Right</title>
    <url>/2020/04/22/risk_is_right/</url>
    <content><![CDATA[<h1 id="Risk-is-right"><a href="#Risk-is-right" class="headerlink" title="Risk is right"></a>Risk is right</h1><p>Author: John Piper<br>Subtitle: Better to Lose Your Life Than to Waste It</p>
<h2 id="0-Preface"><a href="#0-Preface" class="headerlink" title="0 Preface"></a>0 Preface</h2><p>In Matthew 13:44 Jesus tells his disciples, “The kingdom of heaven is like treasure hidden in a field, which a man found and covered up. Then in his joy he goes and sells all that he has and buys that field.”</p>
<h2 id="1-The-ultimate-meaning-of-life"><a href="#1-The-ultimate-meaning-of-life" class="headerlink" title="1 The ultimate meaning of life"></a>1 The ultimate meaning of life</h2><blockquote>
<p>It is my eager expectation and hope that I will not be at all ashamed, but that with full courage now as always Christ will be honored in my body, whether by life or by death. For to me to live is Christ, and to die is gain. (Phil. 1:20–21)</p>
</blockquote>
<p>The universe was created for this—making much of Christ. Paul says as much in Colossians 1:16: “All things were created through him and for him.” <strong>For him</strong>.</p>
<p>So make much of Christ is our meaning as well, the same as the universe. </p>
<a id="more"></a>

<h2 id="2-What-is-risk"><a href="#2-What-is-risk" class="headerlink" title="2 What is risk?"></a>2 What is risk?</h2><blockquote>
<p>If our single, all-embracing passion is to make much of Christ in life and death, and if the life that magnifies him most is the life of costly love, then life is risk, and risk is right. To run from it is to waste your life.</p>
</blockquote>
<blockquote>
<p>This means that God can take no risks. He knows the outcome of all his choices before they happen. This is what it means to be God over against all the gods of the nations (Isa. 41:23; 42:8–9; 44:6–8; 45:21; 46:8–11; 48:3).</p>
</blockquote>
<p>There is noting in this world we really have. If you think our life is full of uncertainty (Risk). But God take NO risk! He is the safest place for us.</p>
<p>There is no one in this world, can gurantee us anything for sure. But God do.</p>
<h2 id="3-Stories-of-risk-in-the-old-testament"><a href="#3-Stories-of-risk-in-the-old-testament" class="headerlink" title="3. Stories of risk in the old testament"></a>3. Stories of risk in the old testament</h2><blockquote>
<p>May the lord do what seems good to him</p>
</blockquote>
<p>2 Samuel 10.</p>
<blockquote>
<p>If I perish, I perish</p>
</blockquote>
<p>Esther. 4:15-16</p>
<blockquote>
<p>We will not serve your Gods</p>
</blockquote>
<p>Dan. 3:16–18</p>
<h2 id="4-The-great-risk-taker-in-the-new-testament"><a href="#4-The-great-risk-taker-in-the-new-testament" class="headerlink" title="4. The great risk taker in the new testament"></a>4. The great risk taker in the new testament</h2><p>Paul. </p>
<p>为神做功是跟神同工的荣耀。</p>
<h2 id="6-Right-and-wrong-reason-to-risk"><a href="#6-Right-and-wrong-reason-to-risk" class="headerlink" title="6. Right and wrong reason to risk"></a>6. Right and wrong reason to risk</h2><p>Risk not for Christ is simply wrong.. and expect short term success is wrong reasong as well. </p>
<h2 id="7-The-foundation-of-risk"><a href="#7-The-foundation-of-risk" class="headerlink" title="7. The foundation of risk"></a>7. The foundation of risk</h2><blockquote>
<p><strong>Who shall separate us from the love of Christ?</strong> Shall tribulation, or distress, or persecution, or famine, or nakedness, or danger, or sword? As it is written, “For your sake we are being killed all the day long; we are regarded as sheep to be slaughtered.” No, in all these things we are more than con- querors through him who loved us. For I am sure that nei- ther death nor life, nor angels nor rulers, nor things present nor things to come, nor powers, nor height nor depth, nor anything else in all creation, will be able to separate us from the love of God in Christ Jesus our Lord.</p>
</blockquote>
<p>Does God give us what we need? Well yes, but we must be very clear on what we really need. It is love from God.</p>
<h2 id="8-The-far-end-of-risk"><a href="#8-The-far-end-of-risk" class="headerlink" title="8. The far end of risk."></a>8. The far end of risk.</h2><p>The bottom-line comfort and assurance in all our risk taking<br>for Christ is that nothing will ever separate us from the love<br>of Christ.</p>
<p>Even we think the worst case of a risk: death.. God has defeat it… So… </p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Bible</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Systematic Trading</title>
    <url>/2020/04/21/systematic_trading/</url>
    <content><![CDATA[<h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><h3 id="Layer-1-Read"><a href="#Layer-1-Read" class="headerlink" title="Layer 1 Read"></a>Layer 1 Read</h3><p>作者退休前是AHL的基金经理，经历过2008年的股灾。</p>
<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
<h3 id="Layer-2-Read"><a href="#Layer-2-Read" class="headerlink" title="Layer 2 Read"></a>Layer 2 Read</h3><ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
<h3 id="Layer-3-read-精读感兴趣的地方，甚至动手操作。"><a href="#Layer-3-read-精读感兴趣的地方，甚至动手操作。" class="headerlink" title="Layer 3 read: 精读感兴趣的地方，甚至动手操作。"></a>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</h3><a id="more"></a>

<h2 id="Part-I-theory"><a href="#Part-I-theory" class="headerlink" title="Part I: theory"></a>Part I: theory</h2><h3 id="Cognitive-bias"><a href="#Cognitive-bias" class="headerlink" title="Cognitive bias"></a>Cognitive bias</h3><ol>
<li>hard to admit failure</li>
<li>happy to be confirmed</li>
<li>overconfident</li>
</ol>
<blockquote>
<p>what makes an addictive game:</p>
<ol>
<li>an illusion of control</li>
<li>frequent changes of <em>Almost</em> win big</li>
<li>rapid and continous to give a constant flow of stimulation</li>
</ol>
</blockquote>
<p>if we know most of player has these bias, we can leverage them by apply trading rules to remove our own bias.</p>
<h3 id="Good-system-design"><a href="#Good-system-design" class="headerlink" title="Good system design"></a>Good system design</h3><ul>
<li>objective</li>
<li>easiy to explain/understand</li>
<li>avoid over-fitting</li>
<li>avoid over-trading</li>
<li>avoid over-betting</li>
</ul>
<h3 id="What-makes-good-trading-rule"><a href="#What-makes-good-trading-rule" class="headerlink" title="What makes good trading rule"></a>What makes good trading rule</h3><ul>
<li>Risk prem</li>
<li>Skew trading</li>
<li>Leverage</li>
<li>Liquidity</li>
<li>Correlation</li>
</ul>
<blockquote>
<p>I also believe finding the best trading rules is less important than designing your trading system in the correct way.</p>
</blockquote>
<h2 id="Part-II-toolbox"><a href="#Part-II-toolbox" class="headerlink" title="Part II: toolbox"></a>Part II: toolbox</h2><h3 id="Fitting"><a href="#Fitting" class="headerlink" title="Fitting"></a>Fitting</h3><ol>
<li>Come up with a small number of trading rules to exploit each idea I have about how the market behaves.</li>
<li>For each rule select a few variations. At this stage I am not looking at performance, but at behaviour such as trading speed and correlation with other variations.</li>
<li>Allocate forecast weights to each variation, taking uncertainty about Sharpe ratios into account. Poor rules will have lower weight, but are rarely entirely excluded.</li>
</ol>
<p><strong>Select rules from different themes</strong></p>
<ul>
<li>trend following</li>
<li>carry </li>
</ul>
<p>Some points:</p>
<ul>
<li>So diversification amongst instruments is preferable to rule diversification, Adding new instruments is a tiresome task of uploading and checking data which is less fun than coming up with more trading rules, but in my experience is of far more benefit.</li>
</ul>
<h3 id="Portfolio-Allocation"><a href="#Portfolio-Allocation" class="headerlink" title="Portfolio Allocation"></a>Portfolio Allocation</h3><ul>
<li>Forecast weights</li>
<li>Instrument weights</li>
</ul>
<p>The goal here is given some constrains to produce allocation weights on underlyings (instruments or trading rules).</p>
<p>Portfolio allocation should be tool to control risk, leverage divercification. Optimizaion is good but only when result is still reasonable in terms of diversification. </p>
<p><strong>question:</strong> how can we quantify diversification?</p>
<h2 id="Part-III-framework"><a href="#Part-III-framework" class="headerlink" title="Part III: framework"></a>Part III: framework</h2><h3 id="Framework-overview"><a href="#Framework-overview" class="headerlink" title="Framework overview"></a>Framework overview</h3><p>Components:</p>
<ul>
<li>Instruments to trade</li>
<li>Forecasts</li>
<li>Combine forecast</li>
<li>Volatility targeting</li>
<li>Portfolio</li>
<li>Speed and Size for all</li>
</ul>
<h3 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h3><p><img data-src="https://i.imgur.com/v9TZ5ds.png" alt=""></p>
<h3 id="Forecasts"><a href="#Forecasts" class="headerlink" title="Forecasts"></a>Forecasts</h3><ul>
<li>Forecast should be a scale not binary</li>
<li>Should be vol adjusted</li>
<li>Should be consisten in scale</li>
<li>Forecast should be capped</li>
</ul>
<p><img data-src="https://i.imgur.com/aTjsVtr.png" alt=""></p>
<p>The process works as following:</p>
<p>$$<br>signal = cap({raw} / vol * scalar, up_limit, floor_limit)<br>$$</p>
<p>where,<br>$raw$ is raw signal,<br>$vol$ is volatility estimation of underly asset(s),<br>$scalar$ is an enstimation number to scale the signal to a range, say -20~+20<br>$cap(.)$ is a function that cap the signal to $up_limit, floor_limit$ </p>
<h3 id="Combined-Forecasts"><a href="#Combined-Forecasts" class="headerlink" title="Combined Forecasts"></a>Combined Forecasts</h3><p>The purpose is that given more than 1 signals for 1 instrument (can be extented to multiple instruments), we need a function to aggregate thme. $fweight$ or forecast weights estimation is at the core of this stage. And they should all be positive and<br>add up to 100%.</p>
<p><strong>Next question is how to choose an fweights given several signals?</strong></p>
<p>To answer this, portfolio construction method is useful, although the underlyings here is signals not assets. And correlation of signal return (NOTE: not performance) are needed in order to come up with weights. Several level (say, 2 levels) of grouping is useful, if you have several types of signals, and each of them has several variances. </p>
<p>$$raw_combined = f(corr, raw_signals)$$</p>
<p>There is another concept is needed: forcast diversification multiplier, FDM. The reason is that we want to maintian the scale level of combined signal as same as scale level as individiual signals. When the signals are not perfectly correlated, the raw weighted combination will always results in a lower scale level. So we need a multiplier to scale it back.</p>
<p>Agian, correlation is important here:</p>
<p>$$FDM = target_vol / portfolio_vol$$</p>
<p>NOTE: it is better to cap this formula as well to avoid large multiplier. </p>
<p>Again, after FDM, the signal level should be capped to 20, as we always do. (20 is just standard we selected, it needs to be consistent.)</p>
<p>So in the end:</p>
<p>$$<br>combined_signal = cap(raw_combined * FDM, -20, 20)$$</p>
<p><img data-src="https://i.imgur.com/xMt7Oll.png" alt=""></p>
<h3 id="Vol-targeting"><a href="#Vol-targeting" class="headerlink" title="Vol targeting"></a>Vol targeting</h3><p>The end result of this is just float, which is a overall volatility target you want to achieve. In another word, a parameter in the system, that will be used across the system. </p>
<p>There are two ways:</p>
<ul>
<li>vol in pct</li>
<li>vol in cash value</li>
</ul>
<h3 id="Position-sizing"><a href="#Position-sizing" class="headerlink" title="Position sizing"></a>Position sizing</h3><p>In this stage, the task is to work out how scaled position, like how may shares (no rounding yet),given vol target and combined signal for one instrument. Note that, here we assumed that all the capital will be allocated to one instrument.</p>
<p>To achieve this, the first quesitons: if I am holding 1 share/unit of this instrument, how much rish am I exposed to in terms of cash?</p>
<p>To answer that question, we define <strong>block value</strong> as: when holding 1 unit of instrument, the cash value movement when the price of the instrument moves 1%. In this way, a connection between cash value movement and price quote movement is built. Then we just need to figure out the prive volatility. </p>
<p>Bad news, estimation of volatility is not that easy.. </p>
<p>What’more, if you are holding multiple currency, it is better to convert cash value movement into base currency.</p>
<p>Now, without considering forecast, assume we put all the capital into one instrument, and want to achieve a cash volatility, we need a <strong>volatility scalar</strong>.</p>
<p>$$vol_scalar = tartet_cash_risk / block_value$$</p>
<p>Above vol scalar is associated to a average signal level 10, so the final position will be:</p>
<p>$$pos_sub = signal_level * vol_scalar<br>$$</p>
<h3 id="Portfolio"><a href="#Portfolio" class="headerlink" title="Portfolio"></a>Portfolio</h3><p>Finally, it is time to put all sub system above into a portfolio. Out of this, we will work out exactly how much units of each instruments we need to fill. In other words, generate a target position in terms of units (rounded).</p>
<p>The concept here is as same as in Combine Forecasts, except that the underlyings are now correlation between sub systems, instead of instruments.</p>
<blockquote>
<p>A good approximation is that the correlation between subsystem returns will be 0.70 of the correlation of instrument returns. So if two assets have a correlation of 0.5 between their instrument returns in appendix C, then their subsystems will have a correlation of 0.7 × 0.5 = 0.35.</p>
</blockquote>
<p>Note that, similar to FDM, an Instrument diversification multiplier, IDM, is needed here to avoid low resulting vol.</p>
<p>By this step, the positions are still fractional. Before we decide how much to trade, we need a buffer (position inertia) to avoid back forward small trade because of rounding. For the sake of reducing trading cost.</p>
<h3 id="Speed-and-size"><a href="#Speed-and-size" class="headerlink" title="Speed and size"></a>Speed and size</h3><p>Now, we have system to trade, the next question is that how to config the system? For example, what kind of predicor should I used? what kind of instrument should I trade? What target vol should I select?</p>
<h4 id="Caluclate-cost-of-trading"><a href="#Caluclate-cost-of-trading" class="headerlink" title="Caluclate cost of trading"></a>Caluclate cost of trading</h4><p>Types of cost:</p>
<ul>
<li>execution cost</li>
<li>mamangement fee for ETFs</li>
</ul>
<p>Agian, the costs of different instruments should be normalized to be compared. </p>
<p>$$ norm_cost = (2*C) / (16 * ICV)<br>$$</p>
<p>where,<br>$C$ is cost to trade 1 unit in currency C,<br>$ICV$ is daily instrument currency volatility.  </p>
<p>Note that 16 is for tha annulized vol. $norm_cost$ has the same unit as Sharpe ratio. So it is easy to compare the cost effect with the strategy sharpe ratio.</p>
<p>Some experience value of costs:</p>
<ul>
<li>Futures: 0.001</li>
<li>Spread betting: 0.01</li>
<li>ETF: 0.08</li>
</ul>
<h3 id="Turnover"><a href="#Turnover" class="headerlink" title="Turnover"></a>Turnover</h3><p>Now we need to measure how qucikly you trade. The number of round trips per year is the turnover. </p>
<p>A norm cost times turnover inshares, it is the final cost, in the same unit as sharpe ratio.</p>
<h3 id="Determine-portfolio-size"><a href="#Determine-portfolio-size" class="headerlink" title="Determine portfolio size"></a>Determine portfolio size</h3><p>2 × volatility scalar × instrument weight × instrument diversification multiplier</p>
<h2 id="Part-IV-Practice"><a href="#Part-IV-Practice" class="headerlink" title="Part IV Practice"></a>Part IV Practice</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Systematic Trading: A unique new method for designing trading and investing systems</li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Investing</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo拓展功能</title>
    <url>/2020/04/13/chord_3/</url>
    <content><![CDATA[<p>目前，<code>abcjs</code> 还不支持非浏览器环境的使用，所以，目前似乎没办法变成 Hexo Tag。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://dustinpfister.github.io/2018/01/03/hexo-plugins/" target="_blank" rel="noopener">https://dustinpfister.github.io/2018/01/03/hexo-plugins/</a></li>
<li><a href="https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html" target="_blank" rel="noopener">https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html</a></li>
<li><a href="https://hexo.io/api/" target="_blank" rel="noopener">https://hexo.io/api/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>很潮的属11和弦</title>
    <url>/2020/04/13/chord_2/</url>
    <content><![CDATA[<p>在我们想要结束一段的时候，通常会用V -&gt; I的方式结束。以下我们用C调说明。</p>
<p>比如，<code>G7 -&gt; C</code>:</p>
<p><img data-src="https://i.imgur.com/9DPfaZS.png" alt=""></p>
<a id="more"></a>
<p>但是，这种进行显得非常古典。我们可以通过采用属11和弦让进行听起来更加流行。比如<code>F/G</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;:[GFAc]</span><br></pre></td></tr></table></figure>

<p>这样我们的和声进行可以变成：</p>
<p><img data-src="https://i.imgur.com/JqqVIIH.png" alt=""></p>
<p>这个<code>F/G</code> 也可以理解成G11但是去掉3和5音，也就是缩减版本的属11和弦。</p>
<p><img data-src="https://i.imgur.com/pp6Q65K.png" alt=""></p>
<p>吉他版本的 <code>F/G</code> and <code>Cadd2</code>:</p>
<p><img data-src="https://i.imgur.com/vWQGych.png" alt=""> <img data-src="https://i.imgur.com/r4rnaoa.png" alt=""></p>
<p>也可以记成<code>G9sus</code></p>
<p><img data-src="https://i.imgur.com/dqPj7q1.png" alt=""></p>
<p>吉他版本的 <code>G9sus4</code> 和 <code>Cmaj9</code> : </p>
<p><img data-src="https://i.imgur.com/hGKcbVN.png" alt=""> <img data-src="https://i.imgur.com/kxEC3F9.png" alt=""></p>
<p>所以，总结一下：</p>
<p><img data-src="https://i.imgur.com/NCmERJy.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=EdT1xi4qtT4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EdT1xi4qtT4</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Chord</tag>
      </tags>
  </entry>
  <entry>
    <title>时间的开始：创世纪</title>
    <url>/2020/04/12/genesis_1/</url>
    <content><![CDATA[<h2 id="时间的开始"><a href="#时间的开始" class="headerlink" title="时间的开始"></a>时间的开始</h2><blockquote>
<p><strong>起初，神创造天地。</strong></p>
</blockquote>
<p>这就是创世纪的开始，也是时间的开始，我们的世界的开始。这句话的希伯来原文只有7个词，如下图（从右向左读）：</p>
<p><img data-src="https://i.imgur.com/ArszXVF.png" alt="1.1"></p>
<a id="more"></a>

<p>其中，第四个词是助词，没有实际含义。</p>
<p>第一个词，起初。意思就是时间的开始，在那之前没有时间。在那之后，时间有了意义，开始流淌。</p>
<p>第二个词，创造。这个词是单数动词，也就是说主语是单数。这个词在旧约圣经中出现过54词，其主语只有神，没有其他被造之物。而且，从未出现用某物创造另一物的说法，只有：神创造xxx，这一种用法。侧面说明，这是一种只有神才能做的、从无到有的过程。而非制造，既用一个东西创造另一个东西。</p>
<p>第三个词，神。这个词的是<code>Elohim</code>，是一个复数形式，代表神。不过，这个词的动词，创造，却是一个单数形式。说明，神是唯一的，但是神不是单数。这个概念是三位一体的体现，即神、灵和话语。我在后面进一步解释。</p>
<p>第五-七个词，天和地。其中，天是复数。在希伯来文化中，这种两极化的修辞方式很常见，天地既代表宇宙。比如，善和恶用来指代世界一切的事情。</p>
<blockquote>
<p><strong>地是空虚混沌，渊面黑暗；神的灵运行在水面上。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/svE2eaz.png" alt="1.2"></p>
<p>空虚混沌。空虚和混沌这两个次总是连在一起使用的，指荒凉的、不毛之地。但是，不是不存在或者无的状态。这也解释的通，因为神已经创造了天和地（即宇宙），物质已经被创造了。</p>
<p>渊，这个词是很多水或者海洋的意思。渊面黑暗，就是说黑暗笼罩在水上。但是，这是光和暗并没有分开，这里的黑暗，可能就是在光以前的状态。</p>
<p>灵，这个词有好多意思：风、心、灵、气息等。但是，这里就出现了神的第二个位格：灵。经文说，神的灵。</p>
<p>运行，是动词。但是，这个词的直接意思是，庇护、抚育。也就是说，神的灵运行在这水上，主观上乃是为了呵护这个创造。</p>
<p>或者说，神尤其爱护这个创造。而这句话显然已经从对宇宙的创造转到对某颗星球的关注，神特别关注这颗星球（就是地球）。</p>
<blockquote>
<p><strong>神说：『要有光』，就有了光。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/kCFamMh.png" alt="1.3"></p>
<p>说，是动词。神通过“说话”，继续他的创造。神的话语，有创造的能力。这是神的第三个位格，即道。至此，神的三个位格：神、灵、道都出现了。</p>
<blockquote>
<p><strong>神看光是好的，就把光暗分开了。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/H9B6Qza.png" alt="1.4"></p>
<p>神看光是好的，他就“分开”光和黑暗。这种分别，就是秩序的表现，神通过分别把秩序带入宇宙。</p>
<blockquote>
<p><strong>神称光为『昼』，称暗为『夜』。有晚上，有早晨，这是头一日。</strong></p>
</blockquote>
<p><img data-src="https://i.imgur.com/QfudTNp.png" alt=""></p>
<p>称，就是命名。在希伯来文化中，命名就象征这对该物的主权。</p>
<p>接下来，神继续通过话语进行他的创造，直到：</p>
<blockquote>
<p><strong>神就照着自己的形象造人，乃是照着祂的形象造男造女。</strong></p>
</blockquote>
<p>神的创造达到了高峰，人。神说：</p>
<blockquote>
<p><strong>神看着一切所造的都甚好。有晚上，有早晨，是第六日。</strong></p>
</blockquote>
<p>他认为人的出现，才让他的创造达到了更好！</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>创世纪用2节经文描述了宇宙的诞生，看起来轻描淡写，却道出了真谛：</p>
<ol>
<li>物质世界是被创造的，有开始</li>
<li>神用话语创造，用圣灵陪伴世界</li>
</ol>
<p>我认为神用这样的方式启示世界的开始充满智慧，没有很多细节，因为那些细节可能远远超过当代科学的认知，更何况是千年以前的人类？</p>
<p>换一个角度，神这么轻描淡写宇宙的创造，却花了很多时间在地球的创造，他用了整本圣经描述地球上神和人的关系。这难道不是说明神更加在乎人吗？就像刚才的经文提到，神经历了“6天”的创造，直到人的出现，他才说极好！而且，他就进入了第七日，就是安息，也就是停止了他的创造！</p>
<p>人，就是神创造的最高峰，乃至整个宇宙的创造跟这个相比都不值一提。甚至，宇宙的出现就是为了人的出现。神是多么的重视人类，多么的爱这人类，他精心设计宇宙让人可以生存，可以跟他同在。</p>
<p>然而，人，还是选择了堕落，离开爱人的神，选择犯罪，自己做神。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>但是神对人的爱没有改变，即使是犯罪的人类，他也要带回他们。而代价是：从创世之初与他同在的话语，道成肉身，受死救赎。正是耶稣的死而复活，重新打开了人与神的通路。</p>
<p>关于人类的未来，已经记录在圣经的最后一本书中《启示录》。</p>
<p>创世记前三章起头的每一件事情，到了《启示录》最后三章，都有了最终的结局：</p>
<ol>
<li>创世记：神创造天地（创一1-31）；启示录：神结束旧造，重造新天新地（启二十11；二十一1、5）。</li>
<li>创世记：神按自己的形象造人（创一26-27）；启示录：人被恢复成神的儿子（启二十一4）。</li>
<li>创世记：神所造的是有灵的活人（创二7）；启示录：人在神面前可以活到永永远远（启二十二5）。</li>
<li>创世记：神设立伊甸园（创二8）；启示录：神建造新耶路撒冷（启二十一2）。</li>
<li>创世记：伊甸园里有一条河分为四道，滋润园子（创二10）；启示录：新耶路撒冷有一道生命水的河，供应生命（启二十二1）。</li>
<li>创世记：伊甸园里有一棵生命树（创二9）；启示录：生命树遍布生命水的河两岸（启二十二2）。</li>
<li>创世记：人在伊甸园有一份很有前途的工作（创二15）；启示录：人在新耶路撒冷重新找到了一份更有前途的工作（启二十二3、5）。</li>
<li>创世记：头一个亚当的婚姻（创二22-25）；启示录：末后的亚当的婚姻（启二十一2）。</li>
<li>创世记：撒但诱惑人（创三1-5）；启示录：撒但被扔在火湖里（启二十10）。</li>
<li>创世记：罪进入世界（创三6-7）；启示录：罪从世界被消除（启二十一27）。</li>
<li>创世记：人躲避神的面（创三8）；启示录：人要见神的面（启二十二4）。</li>
<li>创世记：神呼喊、寻找失落的人（创三9）；启示录：神找回了失丧的人，亲自与人同住（启二十一3）。</li>
<li>创世记：咒诅临到受造之物（创三14-19）；启示录：以后再没有咒诅（启二十二3）。</li>
<li>创世记：死亡、悲哀进入世界（创三16、19）；启示录：不再有死亡、悲哀（启二十一4）。</li>
<li>创世记：人被逐出伊甸园，失去了产业（创三23）；启示录：人重返新耶路撒冷，承受这些为业（启二十一7；二十二3-5）。</li>
<li>创世记：人失去了生命树的分（创三24）；启示录：人重享生命树的分（启二十二2、14）。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://cmcbiblereading.com/2015/01/26/%e5%88%9b%e4%b8%96%e8%ae%b0%e7%ac%ac1%e7%ab%a0%e9%80%90%e8%8a%82%e6%b3%a8%e8%a7%a3%e3%80%81%e7%a5%b7%e8%af%bb/" target="_blank" rel="noopener">圣经综合解读</a></li>
<li><a href="http://hebrew.fhl.net/genesis/gen1.html" target="_blank" rel="noopener">http://hebrew.fhl.net/genesis/gen1.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Bible</category>
      </categories>
      <tags>
        <tag>创世纪</tag>
      </tags>
  </entry>
  <entry>
    <title>如何“冥想”圣经</title>
    <url>/2020/04/08/think/</url>
    <content><![CDATA[<h1 id="如何“冥想”圣经？"><a href="#如何“冥想”圣经？" class="headerlink" title="如何“冥想”圣经？"></a>如何“冥想”圣经？</h1><p>冥想的目的并不是放空自己，而是充实自己的头脑。特别在针对圣经的冥想时候，因该让神的话语充满自己。冥想最核心的要点在于：慢。</p>
<p>慢慢地读圣经，慢慢的想圣经。如何帮助我们慢慢的读，慢慢的想呢？推荐尝试如下方法：</p>
<ul>
<li>写写画画</li>
<li>背诵</li>
<li>反复</li>
<li>持之以恒</li>
<li>用自己的话复述经文的内容</li>
<li>总结</li>
</ul>
<p>书写、记笔记、画画等等都是很好方法，这可以让我们的阅读进度慢下来，进而增加对读过内容的理解时间。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Bible</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Z-backtest</title>
    <url>/2020/04/07/z_backtesting/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Why? bother to create another backtest framework, if we already have plenty of them?</p>
<ul>
<li>I can not find even one backtest framework to backtest option (or deriveritive) based strategy properly. (Mix of option and delta one product is a Bigger NO!)</li>
<li>Debug/Reconcile backtest is painful, because of bad state management</li>
<li>Logic components are hard to re-use</li>
<li>And thanks to point 3, strategy code to strategy logic is not easy</li>
<li>Not easy to do strategy of strategies</li>
</ul>
<p>How? to solve above problems?</p>
<ol>
<li>Use unified interface for derivertive and delta-one Node (And Event a Strategy!)</li>
<li>Use explicit state management, things like Redux</li>
<li>Use Algo stacks to express logics</li>
<li>Thanks to point 3, this is solved</li>
<li>Use Tree structure to describe strategy (Check point 1)</li>
</ol>
<p>What? we will achieve in this framework?</p>
<ol>
<li>Derivertive/Delta-one/Strategy can be backtested together</li>
<li>Strategy data will be presented as a tree structure</li>
<li>Common logic can be tested and re-used easily</li>
<li>Compose common logics creats new strategy easily</li>
<li>Strategy logic will be explicitly expressed as Algo stucks</li>
<li>State evolution during backtesting is trasnprent </li>
</ol>
<p>What are not our goals (at least for now):</p>
<ol>
<li>Spead (If you are simple enough, you should be fast as well)</li>
<li>Live trading (state =&gt; order =&gt; trade =&gt; state)</li>
<li>Intraday strategy</li>
<li>A lot of built in batteries (common logics, or complex derivative Node)</li>
</ol>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2>]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Backtest</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio Signal Processing for Music Applications</title>
    <url>/2020/04/06/Audio_Signal_Processing_for_Music_Applications/</url>
    <content><![CDATA[<h1 id="Audio-Signal-Processing-for-Music-Applications"><a href="#Audio-Signal-Processing-for-Music-Applications" class="headerlink" title="Audio Signal Processing for Music Applications"></a>Audio Signal Processing for Music Applications</h1><p><a href="https://www.coursera.org/lecture/audio-signal-processing/dft-1-EZRXC" target="_blank" rel="noopener">Course Link</a></p>
<blockquote>
<p>Perhaps most importantly, from the point of view of computer music research, is that the human ear is a kind of spectrum analyzer. That is, the cochlea of the inner ear physically splits sound into its (quasi) sinusoidal components. This is accomplished by the basilar membrane in the inner ear: a sound wave injected at the oval window (which is connected via the bones of the middle ear to the ear drum), travels along the basilar membrane inside the coiled cochlea. The membrane starts out thick and stiff, and gradually becomes thinner and more compliant toward its apex (the helicotrema). A stiff membrane has a high resonance frequency while a thin, compliant membrane has a low resonance frequency (assuming comparable mass per unit length, or at least less of a difference in mass than in compliance). Thus, as the sound wave travels, each frequency in the sound resonates at a particular place along the basilar membrane. The highest audible frequencies resonate right at the entrance, while the lowest frequencies travel the farthest and resonate near the helicotrema. The membrane resonance effectively <code>shorts out&#39;&#39; the signal energy at the resonant frequency, and it travels no further. Along the basilar membrane there are hair cells which</code>feel’’ the resonant vibration and transmit an increased firing rate along the auditory nerve to the brain. Thus, the ear is very literally a Fourier analyzer for sound, albeit nonlinear and using ``analysis’’ parameters that are difficult to match exactly. Nevertheless, by looking at spectra (which display the amount of each sinusoidal frequency present in a sound), we are looking at a representation much more like what the brain receives when we hear.</p>
</blockquote>
<a id="more"></a>

<p>Discrete Fourier Transform:</p>
<p>$$X[k]=\sum_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$$</p>
<p>Where,<br>$n$: discrete time index(normalized time, T = 1)<br>$k$: discrete frequency index<br>$w_k=2\pi k/N$: frequency in radians per seconds<br>$f_k=f_s k/N$: frequency in Hz ($f_s$ is sampling rate)</p>
<p>Complex exponentials:</p>
<p>$$s_k^* = e^{-j2\pi kn/N}$$</p>
<p>Scalar product:</p>
<p>$$&lt;x, s_k&gt; = \sum_{n=0}^{N-1}x[n]s_k^*[n]$$</p>
<p>Real sinusoid:</p>
<p>$$x[n] = Acos(2\pi fnT + \psi)$$</p>
<p>where,</p>
<p>$x$ is the array of real values of the sinusoid<br>$n$ is an integer value expressing the time index<br>$A$ is the amplitude vaclue of the sinusoid<br>$f$ is frequency in Hz<br>$T$ is sampling period, $1/f_s$, $f_s$ is the sampling frequency in Hz<br>$\psi$ is the initial phase in radians</p>
<p>Complex sinusiod:</p>
<p>$$x[n]=Ae^{j(wnT+\psi)} = Acos(wnT+\psi) + jAsin(wnT+\psi)$$</p>
<p>Inverse DFT:</p>
<p>$$x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]s_k[n]$$<br>where, $s$ is the conjugate of $s^*$.</p>
<p>The bridge between analog and digial signal.</p>
<p>$$f = \frac{F_s}{M}$$<br>where, M is period of digital signal, F_s is the sampling frequency in Hz, f is the frequency in analog signal in Hz.</p>
<p>The discrete-time oscillatory heartbeat:</p>
<p>$$x[n] = Ae^{j(wn+\psi)} = A[cos(wn+\psi)+jsin(wn+\psi)]$$</p>
<p>where, $A$ is amplitude, $w$ is frequency in radians, and $\psi$ is initial phase in radians.</p>
<p>The concept here is that a circular movement, the e part, can always be described as a sin and cos function for two dementions movements.</p>
<p>Multiple e part will rotate the point. hence:</p>
<p>$x[n]=e^{jwn}; x[n+1]=e^{jw}x[n]$</p>
<p>:::warning<br>Not every sinusoid is periodic in discrete time! $e^{jwn}$ is periodic in n, only when $w=\frac{M}{N}2\pi$<br>:::</p>
<p>If $w &gt; 2\pi$, we have issues.</p>
<h2 id="Vector-space-in-DSP"><a href="#Vector-space-in-DSP" class="headerlink" title="Vector space in DSP"></a>Vector space in DSP</h2><p>Once we model something in vector space, all the tools in vectors space is open to us!</p>
<p>:::info<br>The item in vectors, can be any thing! such as functions!<br>:::</p>
<p>Some examples of vector spaces:</p>
<ul>
<li>$\mathbb{R}^2: x=[x_0, x_1]^T$</li>
<li>$\mathbb{R}^3: x=[x_0, x_1, x_2]^T$</li>
<li>$L_2(-1, 1): x=x(t), t\in[-1, 1]$</li>
<li>$\mathbb{R}^N$</li>
</ul>
<p>The ingredients of vector space (Data Structure):</p>
<ul>
<li>the set of vectors, V</li>
<li>a set of scalars, say $\mathbb{C}$</li>
</ul>
<p>At least to some methods to apply to these Data:</p>
<ul>
<li>resize vectors</li>
<li>combine vectors</li>
</ul>
<p>So formal properties of a vector space:</p>
<ul>
<li>x + y = y + x</li>
<li>(x+y)+z = x+(y+z)</li>
<li>a(x+y)= ax + ay</li>
<li>inner product, $&lt;.,.&gt;: V*V \to \mathbb{C}$<ul>
<li>&lt;x+y, z&gt; = &lt;x, y+z&gt;</li>
<li>….</li>
</ul>
</li>
<li>…</li>
</ul>
<p>Inner product reflect the similarity of two vectors! If 0, means orgthogno, or no simalarity! We have <code>norm</code> and <code>distance</code> of two vectors. The <code>distance</code> in $L_2$ function vector space, also called mean square error!</p>
<h2 id="Signal-Space"><a href="#Signal-Space" class="headerlink" title="Signal Space"></a>Signal Space</h2><p>Finite-length and periodic signals live in $\mathbb{C}^N$. </p>
<p>The inner product operation is defined:</p>
<p>$$&lt;x, y&gt; = \sum_{n=0}^{N-1}x^{*}[n]y[n]$$</p>
<p>By finite, it requires the sequences to be square-summable: $\sum |x[n]|^2&lt;\infty$. This is energy of signal, so finite energy!</p>
<p>:::info<br>Hilbert Space: $H(V, \mathbb{C})$:</p>
<ul>
<li>an inner product is defined</li>
<li>completeness on all required vector operation<br>:::</li>
</ul>
<h2 id="Bases"><a href="#Bases" class="headerlink" title="Bases"></a>Bases</h2><p>Linear combination is the basic operation in vector spaces. How can we find a set of building blocks, vectors, to express all the other vectors in the space??</p>
<p>Formal definition of bases:</p>
<p>Given: </p>
<ul>
<li>a vector space, H</li>
<li>a set of K vectors from $W= {w^{(k)}}_{k=0,1,…,K-1}$</li>
</ul>
<p>W is a basis for H if:</p>
<ol>
<li>we can write all $x\in H$:<br>$$x = \sum_{k=0}^{K-1}\alpha w^, \alpha_k\in\mathbb{C}$$</li>
<li>$\alpha_k$ are unique</li>
</ol>
<p>Orthogonal basis</p>
<p>Orthonormal basis</p>
<p>By orthonormal basis, </p>
<p>$$\alpha_k=&lt;w, x&gt;$$</p>
<p>Change basis:</p>
<p><img data-src="https://i.imgur.com/9SdEpoD.png" alt="Change Basis"></p>
<h2 id="Subspace-bases-approximations"><a href="#Subspace-bases-approximations" class="headerlink" title="Subspace bases approximations"></a>Subspace bases approximations</h2><p>Approximate using sub-space.</p>
<h3 id="Least-square-approximation"><a href="#Least-square-approximation" class="headerlink" title="Least square approximation"></a>Least square approximation</h3><p>Given $s^{(k)}<em>{k=0,1,…,K-1}$ are orthonormal basis for S,<br>the orthogonal projection:<br>$$\hat{x}=\sum</em>{}^{}&lt;s^{(k)}, x&gt;s^{(k)}$$</p>
<p>is the best approximation of over S. It has minimum norm error, the error is also orthogonal to approximation, which means this sub space cannot get more information any more.</p>
<p>Gram-Schmidt orthonormlization procedure.</p>
<h2 id="Fouries-Analysis"><a href="#Fouries-Analysis" class="headerlink" title="Fouries Analysis"></a>Fouries Analysis</h2><p>Osillations are everywhere. And system does not move in circles, can’t last long.</p>
<p>Fouries analysis is simply a base change in vector space $\mathbb{C}^N$.</p>
<p>$$w_k[n]=e^{j\frac{2\pi}{N}nk}$$</p>
<p>where $n, k = 0,1,…,N-1$.</p>
<p>Above is an orthogonal basis in $\mathbb{C}$</p>
<h2 id="DFT-Discrete-Fouries-Transformaion"><a href="#DFT-Discrete-Fouries-Transformaion" class="headerlink" title="DFT, Discrete Fouries Transformaion"></a>DFT, Discrete Fouries Transformaion</h2><p>The analysis formular:</p>
<p>$$X_k = &lt;w_k, x&gt;$$</p>
<p>The synthesis formula:</p>
<p>$$x = \frac{1}{N}\sum_{k=0}^{N-1}X_kw^{(k)}$$</p>
<h2 id="Interpreting-DFT"><a href="#Interpreting-DFT" class="headerlink" title="Interpreting DFT"></a>Interpreting DFT</h2><p><img data-src="https://i.imgur.com/z5XIDHQ.png" alt=""></p>
<p><img data-src="https://i.imgur.com/aT146UI.png" alt=""></p>
<h3 id="How-to-label-DFT-result"><a href="#How-to-label-DFT-result" class="headerlink" title="How to label DFT result?"></a>How to label DFT result?</h3><p>Given sample number is N, sample frequency is $f_s$, if we find a peak in DFT at k = 500, what is the corresponding frequency in Hz? </p>
<p>The highest freqency in the system is $f_s/2$.</p>
<p>$f = kf_s/N$</p>
<h2 id="DFT-in-Music"><a href="#DFT-in-Music" class="headerlink" title="DFT in Music"></a>DFT in Music</h2><p>Frequency, harmonics. timbre is different because of the harmonics. But the pitch is just the first frequency component. </p>
<p><img data-src="https://i.imgur.com/UnhGofZ.png" alt=""></p>
<h2 id="DFT-synthesis"><a href="#DFT-synthesis" class="headerlink" title="DFT synthesis"></a>DFT synthesis</h2><p><img data-src="https://i.imgur.com/KfWDMkE.png" alt=""></p>
<p>Frequency in Hz and in radians:</p>
<p>$$f = \frac{wf_s}{2\pi}$$</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><h2 id="STFT-short-term-fouries-transform"><a href="#STFT-short-term-fouries-transform" class="headerlink" title="STFT, short term fouries transform"></a>STFT, short term fouries transform</h2><p>Spectrogram is a way to show STFT. There are two variables: window and frequency. $X[m;k]$, where m is the window, k is frequency index.</p>
<p>Spectrogram show time, frequency at the same time. Once we know the sample frequency, we can label the spectrogram.</p>
<p>$T_s = 1/F_s$, the frequency resolution is $f_s/L Hz$, and the width of time slices is $LT_s$.</p>
<p>Question to ask:</p>
<ul>
<li>width of window?</li>
<li>position of the window?</li>
<li>shape of the window?</li>
</ul>
<p><img data-src="https://i.imgur.com/A5PBgce.png" alt=""></p>
<p>Short window gives better time precision, while long window give better frequency precision.</p>
<p><img data-src="https://i.imgur.com/L2UAe8g.png" alt=""></p>
<p>STFT leads to wavelet transform.</p>
<h1 id="The-DFT-Numerical-Aspects"><a href="#The-DFT-Numerical-Aspects" class="headerlink" title="The DFT: Numerical Aspects"></a>The DFT: Numerical Aspects</h1><p>As a quick reminder, the definitions of the direct and inverse DFT for a length-$N$ signal are:</p>
<p>\begin{align<em>}<br>    X[k] &amp;= \sum_{n=0}^{N-1} x[n], e^{-j\frac{2\pi}{N}nk}, \quad k=0, \ldots, N-1 \<br>    x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1} X[k], e^{j\frac{2\pi}{N}nk}, \quad n=0, \ldots, N-1<br>\end{align</em>}</p>
<p>The DFT produces a complex-valued vector that we can represent either via its real and imaginary parts or via its magnitude $|X[k]|$ and phase $\angle X[k] = \arctan \frac{\text{Im}{X[k]}}{\text{Re}{X[k]}}$.</p>
<h3 id="Numerical-errors-in-real-and-imaginary-parts"><a href="#Numerical-errors-in-real-and-imaginary-parts" class="headerlink" title="Numerical errors in real and imaginary parts"></a>Numerical errors in real and imaginary parts</h3><p>The DFT can be easily implemented using the change of basis matrix ${W}_N$. This is an $N\times N$ complex-valued matrix whose elements are </p>
<p>$$<br>    {W}_N(n,k)=e^{-j\frac{2\pi}{N}nk}<br>$$</p>
<p>so that the DFT of a vector $\mathbf{x}$ is simply $\mathbf{X} = W_N\mathbf{x}$. Note that the inverse DFT can be obtained by simply conjugating ${W}_N$ so that $\mathbf{x} = W_N^*\mathbf{X}$.</p>
<p>We can easily generate the matrix ${W}_N$ in Python like so:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft_matrix</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="comment"># create a 1xN matrix containing indices 0 to N-1</span></span><br><span class="line">    a = np.expand_dims(np.arange(N), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># take advantage of numpy broadcasting to create the matrix</span></span><br><span class="line">    W = np.exp(<span class="number">-2j</span> * (np.pi / N) * (a.T * a))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> W</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT matrix</span></span><br><span class="line">N = len(x)</span><br><span class="line">W = dft_matrix(N);</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT</span></span><br><span class="line">X = np.dot(W, x)</span><br><span class="line"><span class="comment"># inverse DFT</span></span><br><span class="line">x_hat = np.dot(W.T.conjugate(), X) / N</span><br><span class="line"></span><br><span class="line">print(x-x_hat)</span><br></pre></td></tr></table></figure>

<h2 id="Fouries-representation-for-signal-class"><a href="#Fouries-representation-for-signal-class" class="headerlink" title="Fouries representation for signal class"></a>Fouries representation for signal class</h2><ul>
<li>N-point finite-length: DFT</li>
<li>N-point periodic: DFS</li>
<li>infinite length: DTFT</li>
</ul>
<p><img data-src="https://i.imgur.com/ZnK3RgD.png" alt=""></p>
<p><img data-src="https://i.imgur.com/uzP9LOM.png" alt=""></p>
<p><img data-src="https://i.imgur.com/AUUxJbD.png" alt=""></p>
<h2 id="Sinusoidal-modulation"><a href="#Sinusoidal-modulation" class="headerlink" title="Sinusoidal modulation"></a>Sinusoidal modulation</h2><p>Based on where most frequencies are located.</p>
<ul>
<li>lowpass signal</li>
<li>highpass signal</li>
<li>bandpass signal</li>
</ul>
<p>How?</p>
<p><img data-src="https://i.imgur.com/4VwKahL.png" alt=""></p>
<p>Why?</p>
<p><img data-src="https://i.imgur.com/JZGmVkB.png" alt=""></p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p><img data-src="" alt="Uploading file..._kr65l8uvc"></p>
<h3 id="Linear-time-invariant-filters"><a href="#Linear-time-invariant-filters" class="headerlink" title="Linear time-invariant filters"></a>Linear time-invariant filters</h3><p>Linearity</p>
<p><img data-src="https://i.imgur.com/3qUraJ1.png" alt=""></p>
<p>Time-invariant</p>
<p><img data-src="https://i.imgur.com/8nz362v.png" alt=""></p>
<p>Add them we have</p>
<p><img data-src="https://i.imgur.com/HgmAN8f.png" alt=""></p>
<p>In formalar:</p>
<p><img data-src="https://i.imgur.com/htfvgNy.png" alt=""></p>
<h3 id="Convolution-1"><a href="#Convolution-1" class="headerlink" title="Convolution"></a>Convolution</h3><p>LTI filters are entirely characterized by their impulse reponse, i.e., their response to the impulse delta function $\delta[n]$, the output of an LTI filter y[n]  y[n] can be computed by convolving the input x[n]  x[n] with the impulse response,</p>
<p>$$<br>\delta[n]=\sum_{k=-\inf}^{inf}x[k]h[n-k]<br>$$</p>
<h3 id="Filter-by-examples"><a href="#Filter-by-examples" class="headerlink" title="Filter by examples"></a>Filter by examples</h3><p>Moving average: </p>
<p><img data-src="https://i.imgur.com/C8gsV6B.png" alt=""></p>
<p>Leaky integrator: </p>
<p><img data-src="https://i.imgur.com/5UgmloR.png" alt=""></p>
<h3 id="Filter-types"><a href="#Filter-types" class="headerlink" title="Filter types"></a>Filter types</h3><ul>
<li>lowpass, MA, leaky</li>
<li>highpass</li>
<li>bandpass</li>
<li>allpass</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul>
<li><a href="https://ccrma.stanford.edu/~jos/mdft/" target="_blank" rel="noopener">https://ccrma.stanford.edu/~jos/mdft/</a></li>
<li><a href="https://www.youtube.com/watch?v=MBnnXbOM5S4" target="_blank" rel="noopener">The more general uncertainty principle, beyond quantum</a></li>
<li><a href="youtube.com/watch?v=spUNpyF58BY">But what is the Fourier Transform? A visual introduction</a></li>
<li><a href="https://www.youtube.com/watch?v=r6sGWTCMz2k" target="_blank" rel="noopener">But what is a Fourier series? From heat flow to circle drawings</a></li>
<li><a href="http://www.jezzamon.com/fourier/index.html" target="_blank" rel="noopener">An Interactive Introduction to Fourier Transforms</a></li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Signal Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>配和弦的方法</title>
    <url>/2020/04/05/how-to-chords/</url>
    <content><![CDATA[<h2 id="配和弦的基本规则"><a href="#配和弦的基本规则" class="headerlink" title="配和弦的基本规则"></a>配和弦的基本规则</h2><ol>
<li>选择含有旋律音的调内和弦</li>
<li>多种选择的时候，考虑上下文以及和弦功能<ol>
<li>下一个和弦用什么？增加一些变化</li>
<li>功能和弦：比如G7是属和弦，会制造紧张，回归C</li>
<li>其他附属和弦，比如Dm，F等等</li>
</ol>
</li>
<li>多久换一个和弦？</li>
<li>递归上面的过程</li>
</ol>
<h2 id="和弦有什么功能"><a href="#和弦有什么功能" class="headerlink" title="和弦有什么功能"></a>和弦有什么功能</h2><p>分类1：</p>
<ul>
<li>主和弦，Tonic，I</li>
<li>属和弦，dominant, V。G7，<strong>三全音</strong>产生更加不稳定的感觉</li>
<li>下属和弦，桥梁，去G 或者 G7</li>
<li>附属和弦，你要接的下一个和弦的上面5度音的属7和弦，比如下一个是Em，可以用B7过度到他</li>
</ul>
<p>分类2：</p>
<ul>
<li>家：C, I</li>
<li>外面：G7,Bdim. V,vii</li>
<li>桥：Dm，F，他们很喜欢去外面。ii, iv</li>
<li>暂时的家，或者家的延伸：Em，Am. iii, vi</li>
</ul>
<p><img data-src="https://i.imgur.com/EFZjJPV.png" alt="功能"></p>
<a id="more"></a>

<h2 id="递归上面的规则！"><a href="#递归上面的规则！" class="headerlink" title="递归上面的规则！"></a>递归上面的规则！</h2><p>可以选定目标和弦作为暂时的１级和弦，然后在前面添加该调的常见回家进行，比如ii -&gt; V -&gt; I.</p>
<p><img data-src="https://i.imgur.com/n1bl3Ou.png" alt=""><br><img data-src="https://i.imgur.com/oAuXgIT.png" alt=""><br><img data-src="https://i.imgur.com/6buXmP8.png" alt=""></p>
<p>当然，使用上面的方法是，临时的V可以被另外一个包含相同三全音的和弦代替，比如比目标I和弦，高半个音的属和弦。比如下面这个例子：</p>
<p><img data-src="https://i.imgur.com/3EzZzZ8.png" alt=""></p>
<p>还可以通过从平行调中，借用和弦。比如在Ｃ调中，可以借用Ｃｍ中的Ｆｍ和弦，回到Ｃ和弦。</p>
<p><img data-src="https://i.imgur.com/ymKfpIv.png" alt=""></p>
<h2 id="认识和弦"><a href="#认识和弦" class="headerlink" title="认识和弦"></a>认识和弦</h2><ul>
<li>Major</li>
<li>Minor</li>
<li>Dominant</li>
</ul>
<p><img data-src="https://i.imgur.com/iJQPvFb.png" alt=""><br><img data-src="https://i.imgur.com/w4ttqAC.png" alt=""><br><img data-src="https://i.imgur.com/s2deAcz.png" alt=""><br><img data-src="https://i.imgur.com/0VhtLrr.png" alt=""></p>
<h3 id="和弦变化"><a href="#和弦变化" class="headerlink" title="和弦变化"></a>和弦变化</h3><ul>
<li>add</li>
<li>sus</li>
<li>omit</li>
<li>()</li>
<li>转位</li>
<li>其他家族</li>
</ul>
<p><img data-src="https://i.imgur.com/z8ax5Da.png" alt=""><br><img data-src="https://i.imgur.com/Bg4L8JM.png" alt=""><br><img data-src="https://i.imgur.com/7lDnl3B.png" alt=""><br><img data-src="https://i.imgur.com/sokdbbh.png" alt=""><br><img data-src="https://i.imgur.com/rvK0h7b.png" alt=""><br><img data-src="https://i.imgur.com/FKhpfiE.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.musictheory.net/products/lessons" target="_blank" rel="noopener">Musictheory</a></li>
<li><a href="https://www.youtube.com/channel/UCVXstWyJeO6No3jYELxYrjg" target="_blank" rel="noopener">好和弦</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Chord</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title>Major Update</title>
    <url>/2020/03/29/major-update/</url>
    <content><![CDATA[<p>I updated my blog. Not sure I will move old posts here. But I put them here: <a href="https://github.com/wangzhe3224/wangzhe3224.github.io.backup/tree/master/_posts" target="_blank" rel="noopener">Old post</a>.<br>Just in case. </p>
<p>Zhe</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
  </entry>
  <entry>
    <title>Road Map for Investment Tool Box</title>
    <url>/2020/01/01/road_map/</url>
    <content><![CDATA[<h2 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h2><p>Create series of tools to for my investment. Open to public use. </p>
<h2 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h2><p>Build simple and small components, if I cannot see the whole picture. Even I am smart enough to see whole picture, I will do the same.</p>
<h2 id="Software-Engineering"><a href="#Software-Engineering" class="headerlink" title="Software Engineering"></a>Software Engineering</h2><ol>
<li>Composition: Design simple tools in a way that we can chain different tool together.</li>
<li>Test-Driven: Test creats sense of accomplishmen and modularity.</li>
<li>Cloud-Based Deployment: leverage AWS service.<a id="more"></a>

</li>
</ol>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Follow the philosoph, tools</p>
<ul>
<li><input disabled="" type="checkbox"> Data tools</li>
<li><input disabled="" type="checkbox"> VIX term structures</li>
<li><input disabled="" type="checkbox"> Yield curve</li>
<li><input disabled="" type="checkbox"> Time series statistics</li>
<li><input disabled="" type="checkbox"> Correlation tools</li>
<li><input disabled="" type="checkbox"> MOV tools</li>
<li><input disabled="" type="checkbox"> Option tools</li>
<li><input disabled="" type="checkbox"> Backtesting tools</li>
<li><input disabled="" type="checkbox"> Time series generate tools</li>
</ul>
<h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><ul>
<li>Date/Time</li>
<li>Time series</li>
<li>Term structure</li>
<li>Matrix</li>
</ul>
<h2 id="Presentations"><a href="#Presentations" class="headerlink" title="Presentations"></a>Presentations</h2><ul>
<li>Graph</li>
<li>Table</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/robertmartin8/PyPortfolioOpt" target="_blank" rel="noopener">PyPortfolioOpt</a></li>
<li><a href="https://github.com/lballabio/QuantLib-SWIG/tree/master/Python" target="_blank" rel="noopener">QuantLib</a></li>
<li><a href="https://www.backtrader.com/" target="_blank" rel="noopener">Backtrader</a></li>
<li><a href="https://github.com/pmorissette/bt" target="_blank" rel="noopener">Bt</a></li>
<li><a href="http://qoppac.blogspot.com/" target="_blank" rel="noopener">Systematic Trading</a></li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2019/12/31/how_to_read/</url>
    <content><![CDATA[<h1 id="如何阅读一本书"><a href="#如何阅读一本书" class="headerlink" title="如何阅读一本书"></a>如何阅读一本书</h1><p>具体的阅读方法：</p>
<ul>
<li>Layer 1 read: 提出一些原认知问题，一边读书，一边补充完善<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是什么</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
</li>
<li>Layer 2 read: 稍微具体阅读每一个章节，但不会为了不懂得内容停留过长时间，主要在于总结作者每一个章节都在讲什么？<ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
</li>
<li>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</li>
</ul>
<a id="more"></a>

<h2 id="如何主动的阅读"><a href="#如何主动的阅读" class="headerlink" title="如何主动的阅读"></a>如何主动的阅读</h2><p>主动阅读涉及到的问题可以在不同的层次被反复提出，比如最高的层次应该针对这一类书提出，然后针对这一本书提出，然后针对每一个章节提出。</p>
<p>问自己如下几个问题：</p>
<ol>
<li>整体来说，这本书在说什么？这本书的主题是什么？作者是如何一步一步阐述这个主题的？</li>
<li>作者细节上都说了什么？他主要的观点、声明是什么？</li>
<li>这本书说的有道理吗？部分有道理？还是全部有道理？</li>
<li>这本书跟我有什么关系？书上的信息对我有什么意义？跟我已有的知识有什么关系？</li>
</ol>
<p>仅仅提出问题还不够，还需要有效的回答问题。</p>
<ol>
<li>在书上做笔记，标注</li>
<li>记录相关的页码</li>
</ol>
<p>在不同的阅读阶段，所提出和记录的问题是不同的。笔记主要可以分成三种：</p>
<ol>
<li>结构笔记：这是什么样的书？结构如何？如何展开陈述？</li>
<li>概念笔记：可以引用别的书籍的解释</li>
<li>辩证笔记：？？？？？？</li>
</ol>
<h2 id="阅读的四个层次"><a href="#阅读的四个层次" class="headerlink" title="阅读的四个层次"></a>阅读的四个层次</h2><ol>
<li>基础阅读：这个句子在说什么？</li>
<li>检视阅读：这本书属于什么分类？是什么架构？包含那些主要部分？</li>
<li>分析阅读：大量的时间，对书中内容进行系统性的提问，以获得深刻的理解</li>
<li>主题阅读：同一类主题的众多书籍之间的联系？那些内容是新的？那些存在矛盾？</li>
</ol>
<p>这四个层次的阅读存在上一级别包含下一级别的关系。</p>
<h3 id="1、基础阅读"><a href="#1、基础阅读" class="headerlink" title="1、基础阅读"></a>1、基础阅读</h3><p>基本相当于美国9年级的阅读水平。可以认识绝大部分的单词，能够无障碍的理解句子的意思</p>
<h3 id="2、检视阅读"><a href="#2、检视阅读" class="headerlink" title="2、检视阅读"></a>2、检视阅读</h3><p>包含两个部分：系统的略读和？？？？</p>
<p><strong>略读</strong></p>
<p>目的是发现这本书是不是我需要的？这个过程最多不会超过1小时，具体操作如下：</p>
<ul>
<li>书名，副标题。为后续的归类做准备</li>
<li>目录，了解书籍的总体架构</li>
<li>索引，了解书籍涵盖的概念范围，寻找那些主题出现频率最高</li>
<li>前言和作者介绍，一般会向读者说明如何阅读本书或者很多写作的上下文，帮助理解</li>
<li>从目录中挑选几段自己觉得感兴趣的快速的读一下</li>
<li>书的结尾，了解主要的结论，一般作者会在最后对全书进行总结</li>
</ul>
<p><strong>粗浅的阅读</strong></p>
<p>由于检视阅读的最终目的是为了从总体上了解书籍的主题和脉络，因此在这个阶段，先要从头到尾的第一遍，即使遇到了不懂的地方，也<strong>不要</strong>停下来查询或者思索。</p>
<h3 id="3、分析阅读"><a href="#3、分析阅读" class="headerlink" title="3、分析阅读"></a>3、分析阅读</h3><p>能够提供读者对一本书架构的认识。总结如下：</p>
<ol>
<li>依照本书的种类与主题，对书籍进行分类</li>
<li>用最短的句子概括本书的主要内容</li>
<li>按照顺序与关系，列出全书的重要部分，总结各部分提纲。</li>
<li>找出作者希望通过本书解决的问题</li>
<li>诠释作者使用的关键字，与作者首先达成共识；</li>
<li>找到重点句子，并且用自己的方式概括主旨；</li>
<li>找出作者的论述段落，重新架构作者的前因后果，以明白作者的主张；</li>
<li>确定作者解决的了那些问题，那些还没有解决；在没有解决的问题中，那些是作者认为无法解决的？</li>
</ol>
<h3 id="一本书的分类"><a href="#一本书的分类" class="headerlink" title="一本书的分类"></a>一本书的分类</h3><p><strong>第一个原则是知道书籍的分类</strong>，根据不同的分类存在不同的阅读分析方法。应该逐渐建立自己的书籍分类标准，比如小说和论述。论述中又包含科学、人文和哲学。</p>
<p>一般来说，书籍可以分成<strong>实用性</strong>和<strong>理论性</strong>。理论性作品会教你这是什么，而实用性作品会叫你如何做想要做的事情或者你认为应该做的事情。<br>实用性的书籍会经常出现，应该、好坏、结果和意义之类的词语。</p>
<p>人文历史类的书籍，关心时间问题；科学书籍不关心时间；哲学比较像科学，也是追求一般真理，但是哲学往往依托的是主观，而科学依靠事实。（那么数学呢？）</p>
<h3 id="透视一本书"><a href="#透视一本书" class="headerlink" title="透视一本书"></a>透视一本书</h3><p><strong>分析阅读的第二个原则是：使用一个简单的句子或者几句话来叙述整本书的内容。</strong>　也就是发现一本书的作者准备做什么。</p>
<p>将总结落实到文字，记录下来。模糊的印象往往没有效果。</p>
<p><strong>分析阅读的第三个原则是：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。</strong> 一本书的各个部分只有有逻辑的链接在一起才会变的对我有意义。</p>
<p>在完成了原则2的任务后，按照如下方法总结书籍整体架构：</p>
<ol>
<li>作者将全书分为x个部分，第一部分谈。。。第二部分谈。。。</li>
<li>第一个部分可以分成y个段落</li>
<li>第一个段落有z个重点问题</li>
</ol>
<p>:::info<br>读者需要在书籍中发现隐藏的骨架，而作者则是先构建了骨架，确用更加丰富的材料隐藏骨架。这一点跟音乐、美术等等很多东西都一样。<br>:::</p>
<p><strong>分析阅读第四个原则：找出作者想要问的问题</strong>。一本书的作者开始写作时通常有一个或者多个问题，全书的推进就是在试图解决这些问题。</p>
<p>找到与作者共通的词义,或者反复出现的词？</p>
<p><strong>第五个原则（部分1）</strong>：抓住书中的单字，搞清楚作者是如何使用这个单字的。一般就是那些最让我头疼的词。或者理解问书中的反复出现的基础概念。这些基础概念往往会在不同的语境下产生不同的意义。</p>
<p>比如，财富，在国富论中就是专门用于，而物种在进化论中才是专门用语。</p>
<p><strong>第五个原则（部分2）</strong>：判断重要的词汇是不是在各种语境下是不是有专门的含义？</p>
<p><strong>第六个原则</strong>：圈出重要的句子，找出其中的主旨。找出主旨的好办法是，用自己的话重写作者的意思。</p>
<p><strong>第七个原则</strong>：从相关文句的关联中，设法架构出一个本书的基本论述。找到文中的论述段落。</p>
<p><strong>第八个原则</strong>：找出作者对于论述问题的解答。</p>
<p>上述的四个原则，能够提供读者对一本书架构的认识。总结如下：</p>
<h3 id="分析阅读的第三阶段"><a href="#分析阅读的第三阶段" class="headerlink" title="分析阅读的第三阶段"></a>分析阅读的第三阶段</h3><p>:::info<br>必须能评论，提出批评，才算真正完成这件事（主动阅读一本书这件事情）。受教是一种美德，但是受教不是盲目服从。<br>:::</p>
<p>这部分主要涉及读者对书籍的评论。但是在对书籍进行评论前，应该先去报自己已经理解作者想要表达的意义了。</p>
<p>批评观点的几个标准：</p>
<ol>
<li>证明作者的知识不足；</li>
<li>证明作者的知识错误；</li>
<li>证明作者不合逻辑；</li>
<li>证明作者分析和理由是不完整的。</li>
</ol>
<h3 id="不同书籍的阅读方法"><a href="#不同书籍的阅读方法" class="headerlink" title="不同书籍的阅读方法"></a>不同书籍的阅读方法</h3><h4 id="实用性的书"><a href="#实用性的书" class="headerlink" title="实用性的书"></a>实用性的书</h4><p>一般就是讲述规则的书，谈论的主题是关于如何做的更好或者如何避免更糟。这种书籍最主要的任务自然是寻找规则。</p>
<p>另一类实用的书籍，主要谈论规则后面的原理，但是它不是纯理论的书籍。其主旨实在说明某件事情的状态，论述就是强调真的如此。 </p>
<p>阅读实用性书籍的两个主要问题：</p>
<ol>
<li>作者的目的是什么？</li>
<li>他建议用什么方法达到这个目的？</li>
</ol>
<h4 id="科学与数学书籍"><a href="#科学与数学书籍" class="headerlink" title="科学与数学书籍"></a>科学与数学书籍</h4><p>数学其实一种语言，学习语言要学习两次，第一次学习如何说话，第二次学习如何阅读。</p>
<p>首先学习语法，然后才是表达理解。</p>
<h4 id="哲学书"><a href="#哲学书" class="headerlink" title="哲学书"></a>哲学书</h4><h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><h2 id="4、主题阅读"><a href="#4、主题阅读" class="headerlink" title="4、主题阅读"></a>4、主题阅读</h2><p>主题阅读的五个步骤：</p>
<ol>
<li>找到相关章节</li>
<li>用自己的语言表达作者的想法，这样才可以联系不同的作者</li>
<li>厘清问题</li>
<li>界定议题</li>
<li>分析讨论</li>
</ol>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
