<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一些软件设计原则</title>
    <url>/2022/12/21/design_habbit/</url>
    <content><![CDATA[<ul>
<li><a href="#先设计后编码">先设计，后编码</a></li>
<li><a href="#写明显没有错误的代码">写”明显没有错误的“代码</a></li>
<li><a href="#学最激进的技术用最简单的实现">学最激进的技术，用最简单的实现</a></li>
<li><a href="#把可变的东西隔离到配置数据中">把可变的东西隔离到配置数据中</a></li>
<li><a href="#多考虑意外情况不要只实现-happy-path">多考虑意外情况，不要只实现 happy path</a></li>
<li><a href="#在设计阶段就开始考虑异常情况">在设计阶段就开始考虑异常情况</a></li>
<li><a href="#复用的诀窍只做一件事情">复用的诀窍：只做一件事情</a></li>
<li><a href="#学习测试理论">学习测试理论</a></li>
</ul>
<h2 id="先设计，后编码"><a href="#先设计，后编码" class="headerlink" title="先设计，后编码"></a>先设计，后编码</h2><p>需求和设计阶段应该在软件开发的 60% 时间，而实现占 40%。没有事先规划，想哪写哪；结果被层出不穷的状况（还美其名曰需求变更）牵着鼻子、面多了加水水多了加面：这就是绝大多数软件开发时间冗长、状况不断、无疾而终的根本原因。</p>
<h2 id="写”明显没有错误的“代码"><a href="#写”明显没有错误的“代码" class="headerlink" title="写”明显没有错误的“代码"></a>写”明显没有错误的“代码</h2><p>而不是”没有明显错误“的代码。</p>
<p>除非你真的做了设计，否则你的代码一定没有什么”设计感“。用心设计，才能找到达到目标的路径中最短最快的那一条。<br>做到这一点，才能把代码写的简单，让人一眼看出意图、明显没有缺陷。</p>
<p>把复杂的功能写简单、写的让人一眼看懂、且知道是不是有错误，需要深厚的功底。</p>
<h2 id="学最激进的技术，用最简单的实现"><a href="#学最激进的技术，用最简单的实现" class="headerlink" title="学最激进的技术，用最简单的实现"></a>学最激进的技术，用最简单的实现</h2><h2 id="把可变的东西隔离到配置数据中"><a href="#把可变的东西隔离到配置数据中" class="headerlink" title="把可变的东西隔离到配置数据中"></a>把可变的东西隔离到配置数据中</h2><p>换句话说，程序最好只写不变的部分，如果需要变化，用最抽象的实现（元编程）。</p>
<p>“开闭原则”说的其实就是，程序代码写出来就不用再动了，这叫对修改封闭；但随便你需要什么样的功能，都可以借助既有的代码完成，这叫“对扩展开放”。<br>真正做到了“对修改封闭”，表现是“不需要动”“不要去怀疑”“可以增加功能，但没必要触动已有代码”</p>
<h2 id="多考虑意外情况，不要只实现-happy-path"><a href="#多考虑意外情况，不要只实现-happy-path" class="headerlink" title="多考虑意外情况，不要只实现 happy path"></a>多考虑意外情况，不要只实现 happy path</h2><p>Happy path 就是完全不考虑出错、不考虑数据竞争、不考虑操作提交时条件不满足、假定世界是完美的、按顺序来一切都能解决的这么一个执行流。</p>
<p>当然，happy path也是必须先找出来的。</p>
<p>先把happy path找出来，再一点点添加——这里可能出现意外，出现意外怎么办……逐渐添加、丰富下去，正确的设计稿就出来了。</p>
<h2 id="在设计阶段就开始考虑异常情况"><a href="#在设计阶段就开始考虑异常情况" class="headerlink" title="在设计阶段就开始考虑异常情况"></a>在设计阶段就开始考虑异常情况</h2><p>首先，要把异常分为几类。</p>
<p>然后，对确定来源的异常应设计正常处理流程——它是正常流程的一部分，是设计之初就应该考虑好的，可不是什么异常。</p>
<p>之后，对未知来路的奇怪错误，不要姑息——见到了，就让程序崩掉。</p>
<p>最终，如果我们的程序的确有极高可靠性要求的话，我们需要设计一个机制，及早发现程序崩溃并自动拉起新的实例。</p>
<p>如此反复，最终就是：一出错就马上抛异常崩溃掉的程序，出错的机率越来越低、渐至于怎么折腾都不会崩溃、甚至单实例都能7x24小时可靠运行；而使劲容错、绝不崩溃的程序，它几乎每时每刻都在出错、逼得用户不得不“重启下说不定就好了”“这破系统用十分钟就得重启，不然丢数据……不是丢新数据，旧数据都会被破坏……”</p>
<h2 id="复用的诀窍：只做一件事情"><a href="#复用的诀窍：只做一件事情" class="headerlink" title="复用的诀窍：只做一件事情"></a>复用的诀窍：只做一件事情</h2><p>其实一点也不难：只做一件事，把一件事做好，这玩意儿就天然是方便复用的。</p>
<p>这很容易理解。玩过积木吧？什么样的积木摆什么造型都用得上？</p>
<p>方块，对吧。</p>
<p>为什么方块这么容易复用？因为它最简单。</p>
<p>这实际上也是我前面说过的：把可变的东西隔离到数据中，程序只提供一组元规则！程序越简洁，就越是可以随意的拼起来、拼出千变万化五彩缤纷的大千世界。</p>
<h2 id="学习测试理论"><a href="#学习测试理论" class="headerlink" title="学习测试理论"></a>学习测试理论</h2><p>嗯，不可否认，的确“总会有我们意想不到的状况”；但绝大多数情况，我们是可以预想到的。</p>
<p>作者：invalid s<br>链接：<a href="https://www.zhihu.com/question/32255673/answer/2325523343">https://www.zhihu.com/question/32255673/answer/2325523343</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>Software Engineering</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 分层架构</title>
    <url>/2022/12/17/thinking_bitcoin_21/</url>
    <content><![CDATA[<p>之前的<a href="https://zhuanlan.zhihu.com/p/590629166">一篇文章</a>讲述了我对分层信任模型的理解。很自然地我们会思考：分层信任模型会产生怎么样的软件架构？</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>分层信任自然会导致分层架构。我们之前提到越是民主信任，其去中心化程度越高、抗审查能力越高；但是，相应的其效率也会随着共识程度需要而降低。这是一个不能两全的问题，必然是会获得一个，而牺牲另一个。</p>
<p>分层设计是软件工程，乃至整个工程学中重要的设计方法。分成设计的核心是：每一层专注一个功能，为上一层提供一些接口；越接近底层，功能应该越稳定；越接近上层，功能应该越丰富。</p>
<p>这种设计有如下优势：</p>
<ul>
<li>在确保接口稳定的基础上，每一层可以相对独立的优化，不需要意识到它的上层；</li>
<li>底层如果获得性能提升，其优势会被所有他以上的层享受；</li>
<li>底层如果开发新的功能，其上层就会多一个组合因素，新功能会产生更加多的新功能；</li>
<li>越往上的层，越可以快速迭代，而不用担心影响其下层；</li>
<li>分层后，每一层的开发和设计得到了简化，因为开发人员只需要关注本层实现，学习、开发成本都会降低；</li>
<li>分层后，每一层的出现问题的几率都会降低；</li>
<li>分层后，每一层可以由不同的开发人员进行开发。</li>
</ul>
<p>分层设计的弊端在于：</p>
<ul>
<li>接口设计比较困难，因为如果出现接口变化，特别是底层变化，所有上层都会受到影响；</li>
<li>如果相对底层的实现出现问题，会影响它的所有上层（依赖层）。</li>
</ul>
<p>在计算机领域，分层设计无处不在。我举几个例子：</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>学过计算机的同学肯定知道，目前我们的互联网运行在分层的网络协议之上，其中一个常见的模型如下：</p>
<p><img src="https://i.imgur.com/MlcY3C8.png" alt=""></p>
<ul>
<li>物理层，这一层只负责比特的传输，这一层对于比特承载的信息一无所知；</li>
<li>链路层，利用物理层，并增加 MAC 地址的概念，并可以进行纠错、限流等操作；</li>
<li>网络层，增加了 IP 地址的概念，可以进行路径、服务选择等高级操作，著名的 IP 协议就是这一层的协议；</li>
<li>传输层，则利用网络层提供的功能，进行一些端对端的通讯，并且可以确保连接的稳定和数据的完整，TCP 协议就是这一层的代表协议之一；</li>
<li>在网上的三层统称为高层，这里就是我们平时经常会看的应用程序协议啦，比如邮件收发协议、FTP协议、HTTP 等等。</li>
</ul>
<p>这里我们看到了明显的分层结构，以及分层机构的特征：</p>
<ul>
<li>上层协议功能非常丰富，且变化多端，比如 HTTP、FTP 等等，我们还可以构建聊天程序、网购网站等等；而底层对这些应用程序一无所知，比如网络层的设计者完全不需要思考 HTTP 的设计，他们只需要设计好网络层的协议即可；</li>
<li>如果在网络层使用了光纤代替电缆，网速会大大提升，那么所有高层应用都会因此受益。</li>
</ul>
<p>试想，如果计算机网络协议的设计不是分层的，而是一锅烩：比特流和聊天软件放在一起设计？会怎么样？</p>
<ul>
<li>软件 Bug 会成倍增加</li>
<li>软件无法和其他软件组合，形成新的软件</li>
<li>软件更新困难</li>
<li>。。。</li>
</ul>
<p>总之，软件工程的噩梦无外汇：一锅烩。</p>
<h3 id="计算机软件和操作系统"><a href="#计算机软件和操作系统" class="headerlink" title="计算机软件和操作系统"></a>计算机软件和操作系统</h3><p>我们每天使用的操作系统和应用程序也是典型的分层设计。</p>
<p><img src="https://i.imgur.com/shEyQZs.png" alt=""></p>
<ul>
<li>最底层，是我们的硬件，CPU和内存。硬件工程师会开发一种叫做指令集的接口给操作系统调用；</li>
<li>操作系统，就是调度计算机资源的层，这一层开放若干成为系统调用的接口；</li>
<li>应用层，就是我们平时用的软件，比如 word、魔兽世界等等，这些软件几乎意识不到运行在英特尔或者 AMD 的CPU上，他们看到的只是操作系统提供的系统调用。</li>
</ul>
<p>同样，试想如果没有分层设计，如果我们想要开发一款游戏，但是需要考虑不同个的 CPU 型号、重新实现系统调用等等，这将是一场软件开发的噩梦。</p>
<h2 id="Layer-1"><a href="#Layer-1" class="headerlink" title="Layer 1"></a>Layer 1</h2><p>区块链生态的构建显然应该跟从软件开发的分层设计原则：</p>
<ul>
<li>一层做一件事情，并做好；</li>
<li>越往底层越稳定，变化越慢；越往上层越活跃，变化越快；</li>
<li>底层的特性增加会让上层组合出现无限可能性</li>
</ul>
<p>其实这与我们之前讨论的信任分层契合，<strong>比特币主网络就是区块链生态的 1 层</strong>。</p>
<p>比特币层有哪些特征呢？比特币层无疑是最民主的信任网络。比特币协议构成的网络是目前最稳定（非图灵完备智能合约）、最安全（最高哈希率）、去中心化程度最高（超过 15000 个全节点）的网络层。这些特征刚好符合分层模型中的底层模型特征：</p>
<ul>
<li>做好一件事：去中心化、安全<ul>
<li>更慢的出块速度，减少临时分叉</li>
<li>更小的区块链大小，确保可以以最低的成本运行全节点</li>
<li>工作量证明，确保共识难以被修改</li>
</ul>
</li>
<li>特性稳定，变化谨慎<ul>
<li>提供了上层接口：Script 语言和智能合约</li>
<li>Script 的关键字选择非常谨慎，去除了循环、乘法等容易产生危险的指令</li>
<li>比特币社区几乎不会提出需要硬分叉的特性</li>
</ul>
</li>
<li>比特币层虽然稳定，但是每个几年会释放新的特性：<ul>
<li>2017 年，隔离见证通过软分叉部署，使得闪电网络成为可能</li>
<li>2021 年，Taproot 升级通过软分叉部署，打开了更加丰富智能合约的大门，同时也让闪电网络的吞吐大大提高</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/6cJ3HBl.png" alt=""></p>
<p>我们已经看到，比特币协议的更新周期很长，但是每一次更新都是通过软分叉完成的，而且经过长时间的测试确保不会出现问题。同时，每一次升级要么打开新的二级网络的大门，要么让已有的二级网络受益。</p>
<p><img src="https://i.imgur.com/m9tLlmN.png" alt=""></p>
<h2 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h2><p>比特币网络的二级、三级网络，以及侧链非常丰富。比如闪电网络（二级）、Liquid 网络（侧链）等实现，RGB 网络协议等等。</p>
<p><img src="https://i.imgur.com/iL5sdhS.png" alt=""></p>
<p>其实，比特币社区的发展是互联网发展的一个分支，互联网用了 30 年实现了加密、隐私通讯，但是价值传输仍然不存在加密和隐私，直到 2009 年比特币网络的出现，一个互联网原生的价值传输网络才真正的出现，而后面几年的发展仍然遵循了互联网发展的模式：分层。闪电网络发展了小额支付，而其他应用则实现了互联网原生的金融。</p>
<p><img src="https://i.imgur.com/qnvWi79.png" alt=""></p>
<p>由于分层设计，比特币社区的二级网络可以快速的迭代和实验，每一层的更新升级都会为上一层服务；如果上层应用程序出现致命的问题，并不会影响比特币网络，也不会影响其他同级别的应用。</p>
<p>而且，每一个应用程序可以关注自己的小领域，而不需要担心基础出现问题。这样，很多不同的团体可以加入社区进行试验开发。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>作为一个软件工程师，我认为比特币社区的开发模式走在正确的道路。我不知道未来比特币社区会构建出什么样的应用？DeFi 是真实存在的吗？会成功吗？答案并不重要，重要的是，比特币网络会为未来的无限可能提供可靠的基础。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 信任模型</title>
    <url>/2022/12/04/thinking_bitcoin_20/</url>
    <content><![CDATA[<blockquote>
<p>本文偶尔使用“大饼”替换BTC，因此“大饼网络”，“大饼协议”等请自行替换。</p>
</blockquote>
<p>我通常称大饼网络的信任模型为“民主信任”模型。</p>
<h2 id="信任不会消失，只会转移"><a href="#信任不会消失，只会转移" class="headerlink" title="信任不会消失，只会转移"></a>信任不会消失，只会转移</h2><p>每次重新思考这个问题的时候，我都会回到比特币的<a href="https://github.com/wangzhe3224/bitcoin-pro/blob/5fc6fd7140c60aa98fb24c069976873145afa827/docs/assets/Bitcoin%20A%20Peer-to-Peer%20Electronic%20Cash%20System.pdf">白皮书</a>。比特币网络提供了一个不依赖第三方金融机构的、纯点对点的在线电子支付系统。这句话很短，但是非常值得玩味。这句话有三个重点：</p>
<ul>
<li>电子支付</li>
<li>纯点对点</li>
<li>不依赖某<strong>一个或几个</strong>第三方</li>
</ul>
<p>支付系统，就是 A 把某个资产转移给 B 的系统。</p>
<p>其实，在没有互联网的时代完成纯点对点、不依赖第三方的支付非常容易：以物易物即可。比如我把我的黄金给你，你把你的房子给我。但是互联网时代的电子支付让这两点变得很困难。通常，电子支付需要依赖第三方，因为第三方需要防止支付过程中的双花问题（double-spending），即如何确保 A 在支付给 B 的同时，没有也把同一个价值载体支付给 X。换句话说，电子支付无法实现纯点对点，人们需要信任某一个第三方来验证支付的有效性，即避免双花；另外一个第三方需要解决的问题就是资产归属权的问题，人们需要第三方来证明，某个资产属于谁。</p>
<p><strong>大饼协议组成的网络就是为了实现 <code>A -&gt; B</code> 而不需要的第三方 C 的介入这一目的。</strong> 这就是大饼的创新之处：第三方被移除了。但是<strong>信任并没有被移除，只是从某个第三方转移到每个网络参与者</strong>。之前我写过一篇小文稍微涉及了信任的问题：<a href="https://wangzhe3224.github.io/2022/05/29/thinking_bitcoin_5/">比特币随想 - 从数字签名到信任</a>。最后这篇文章的落脚点是：</p>
<ul>
<li>归属权问题不应该是信任问题，而是验证问题（数字签名）</li>
<li>信任不可以被算法移除，但是可以转移（工作量证明）</li>
</ul>
<h2 id="民主的信任模型"><a href="#民主的信任模型" class="headerlink" title="民主的信任模型"></a>民主的信任模型</h2><h3 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h3><p>大饼协议采用了<a href="https://wangzhe3224.github.io/2022/06/04/thinking_bitcoin_7/">工作量证明共识算法（PoW）</a>，这种共识算法将信任从某个第三方转移到了参与网络的群体，更准确的说是群体中付出最能量的群体。</p>
<p>事实上，去中心化网络面临的主要问题是无法决定某个事件发生的先后顺序。因为，如果我们可以确定 A 到 B 的转账，发生在 A 到 C 的转账之前，我们就可以拒绝 A 到 C 的转账（双花）。</p>
<p>那么，由谁来决定 AB 先发生，还是 AC 先发生呢？答案是：谁都可以，这并不是很重要。重要的是，AB发生后，怎么确保历史不会被重写，即 AC 代替 AB 交易（双花）？答案是：PoW。</p>
<p>我们提到虽然网络中的任何人都可以决定 AB 或者 AC 哪一个先发生，但是提出这个<strong>提议</strong>的节点会付出相应的代价：就是挖矿。更具体的说，一个节点想要提出并广播一个提议前，需要进行相当数量的 CPU 计算，即花费相当数量的电能才有资格提出提议（即证明节点花费了相当的工作量）。更重要的是，在提议被接受后，如果有节点想要更改 AB 和 AC 发生的顺序，这个节点需要重复刚刚的计算。</p>
<p>这样的前提下，只要网络中绝大多数节点（&gt;66%），作弊（双花）的经济效益并不高，同时成功率也会随着时间推移越来越低，呈指数级别降低。通过这种博弈的关系，网络中最长的链（最多工作量的链）就称为“真实”的历史，即所有人信任的基础。</p>
<h3 id="网络构成"><a href="#网络构成" class="headerlink" title="网络构成"></a>网络构成</h3><p>大饼网络的节点主要分成了两种：矿工和全节点。矿工就是上面提到的进行工作量证明提出提议的节点，而全节点是负责验证、广播区块（提议）的节点。须知，全节点不会进行工作量证明，也不会提出区块，也就不会获得区块奖励。</p>
<p>这两类节点都非常重要。矿工完成了打包区块、增添历史的功能；而全节点则承担了验证区块和传播区块的功能。</p>
<h3 id="历史共识信任模型"><a href="#历史共识信任模型" class="headerlink" title="历史共识信任模型"></a>历史共识信任模型</h3><p>PoW 形成的共识是一种概率角度的共识，因为理论上，如果网络中出现大量恶意节点用超大的算力对一个新的历史进行快速的计算，并广播这个“伪历史”，且网络中绝大部分节点接受了这个链，那么原本“真实历史”就会被这段“伪历史”替换掉，形成一个新的共识。</p>
<p>但是，这么做一来在技术上几乎不可行，而来其经济利益往往不如利用如此庞大的算力维护最长的“真历史”，从而获得大量区块奖励。</p>
<p>从某个意义上说，工作量证明是“民主”的信任：每个节点都不需要信任任何另一个节点，但是节点可以信任节点群体形成的共识。</p>
<h3 id="协议共识信任模型"><a href="#协议共识信任模型" class="headerlink" title="协议共识信任模型"></a>协议共识信任模型</h3><p>大饼的代币铸币系统设计的非常巧妙：</p>
<ul>
<li>代币的上限 2100 万</li>
<li><a href="https://baloian.medium.com/why-21-million-is-the-maximum-number-of-bitcoins-can-be-created-ecc1ff6edc3d#:~:text=Bitcoin%20Halving%20and%20Reward%20in%20Source%20Code&text=Line%201157%20specifies%20that%20if,Bitcoins%20will%20be%20in%20circulation.">代币铸币政策</a><ul>
<li>约 10 分钟铸造一次</li>
<li>每 210240 个区块铸币量减半一次</li>
</ul>
</li>
</ul>
<p>为了维持铸币政策，即 10 分钟铸造一次，大饼协议会根据网络 PoW 的总算力调节铸币难度。每 2016 个区块，协议会计算这 2016 个区块所花的总时间，同目标时间 20,160 分钟比较，然后难度会相应调节。</p>
<p>上面提到的就是大饼的协议共识，而网络节点对该协议的参数（比如 2100 万，10分钟等等）形成了信任：相信这些参数无法篡改，除非社区的绝大多数节点选择修改。</p>
<p>这种协议共识是通过网络中的全节点实现的。只要网络中绝大多数节点遵守协议，拒绝不符合原有协议的区块，就实现了协议共识，也就确保了网络参数的稳定。</p>
<h2 id="民主信任的弊端"><a href="#民主信任的弊端" class="headerlink" title="民主信任的弊端"></a>民主信任的弊端</h2><p>民主信任模型和第三方（集权）信任最显著的区别在于民主信任没有明确的被信任主体，但是民主信任通常是都是概率性的；集权信任有明确的信任主体，但是决策是决定性的（当然作弊行为也会是绝对的）。</p>
<p>民主信任去除了明确的信任主体，也带来了一些问题。实现真正的民主共识需要更多时间，即需要时间将信息传播到网络的绝大多数<strong>独立的</strong>节点。相应的民主信任网络的执行效率较低。这里格外强调“独立”节点，因为如果传播到的节点不是相互独立，网络就做不到足够“民主”，也就没有所谓的去中心化（去第三方）。</p>
<h2 id="信任的分层"><a href="#信任的分层" class="headerlink" title="信任的分层"></a>信任的分层</h2><p>越是民主信任，网络的效率越低，换来的是一个更加“民主”或者更加“中性”或者更加去中心化的网络层；而越是把信任放在某个、某些个体上，网络的效率越高，失去的是去中心化。</p>
<p>所以，大饼网络提供了一个非常“民主”的信任网络；但是为了提高效率，进行更加复杂的操作，我们需要去掉一些民主，增加一些集权。这就是所谓的二级网络，也就是信任的分层。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 我为什么只买大饼 BTC？</title>
    <url>/2022/11/27/thinking_bitcoin_19/</url>
    <content><![CDATA[<p>这篇回答一个问题：为什么我只买 BTC（大饼）？</p>
<ul>
<li>大饼社区为什么这么佛系？</li>
<li>大饼是什么？</li>
</ul>
<p>关注我一段时间的小伙伴可能知道，我属于所谓的“Bitcoin Maxilism”，即大饼最大化主义。我并不喜欢贴标签，而且这个标签并不是大饼支持者自己按上的，而是所谓的 “Alt coiner” 给我们岸上的，实际上讽刺大饼支持者的意思更浓厚一些。</p>
<p>现在的区块链社区（Crypto、数字货币、Web3等等，名字也是千奇百怪）割裂的很明显：大饼和 Alt Coin（比如 ETH、SOL）。基本的关系是：Alt Coin 攻击、鄙视大饼，Alt Coin 内部互相攻击，大饼社区非常佛系，感觉有点与世无争。</p>
<h2 id="大饼社区为啥这么“佛系”？"><a href="#大饼社区为啥这么“佛系”？" class="headerlink" title="大饼社区为啥这么“佛系”？"></a>大饼社区为啥这么“佛系”？</h2><p>一方面，大饼社区传承了 Cyperpunk（密码朋克）社区的精神，最一开始的时候社区由是一些极客、密码学家、软件工程师组成。这些人通常以关心技术为主，对于宣传、市场、风投这种东西不是很敏感。</p>
<p>另一方面，大饼的“创始人”中本聪在比特币上线后不久便消声遗迹，没人知道他是谁？他去了哪里？甚至他是否还活着都是一个问号。毕竟，中本聪控制的钱包持有约 100 万枚比特币，这些钱包在他消失后就再也没有任何活动记录。没有创始人，对于一个社区来说非常的奇特，这种设定让社区失去了主心骨，从而产生了不同的小领袖，有效的抑制了集权。</p>
<p>这些小领袖，他们的利益往往不直接相关，有一些注重大饼0层开发，比如 Bitcoin Core Dev 的社区；有一些关注2层开发，比如闪电网络实验室；还有一些做商业化，比如硬件钱包公司 Ledger、支付系统 Cash APP、私人节点系统 mynodebtc 等等。这些公司围绕着比特币网络独立的构建自己的产品和生态，本质上这是一个 <em>去中心化</em> 的生态，下一个小节我会继续分析这个点为什么如此重要。</p>
<p>正是因此，相对于 Alt Coin 社区，大饼社区的组成非常纷繁复杂，作为一个整体来看就显得“佛系”。社区参与者都是按照各自独立的想法去构建产品。</p>
<p>Alt Coin 社区的风格完全不同，显得非常“激进”。分析原因也很简单，Alt Coin （无论是 ETH、Sol、Dot）社区基本又风投组成，有明确的领导组织，大量的初始代币发行，市场宣传非常给力，更容易进入大众的视野。</p>
<p><strong>这种社区通常由明确的路线图，代币发行后会通过营销手段，短时间内将代币价格从 0 推到高点，然后倾销给散户，完成盈利。影响方法也很简单：攻击其他 Alt Coin 和 大饼</strong>。</p>
<p><strong>本质上，Alt Coin 属于不受监管的公开募集行为。</strong></p>
<p>这段话可能有点扎 Alt Coiner 的心，伤害他们的去中心化信仰。但是，过去一段时间发生的事情确实印证了我的说话。Luna、FTX 等项目，从出生到死亡也不过短短 2 年时间。</p>
<p>对比大饼和 Alt coin，我想为什么大饼社区如此“佛系”的原因就比较清晰了。</p>
<h2 id="大饼是什么？"><a href="#大饼是什么？" class="headerlink" title="大饼是什么？"></a>大饼是什么？</h2><p>主流媒体认为大饼是货币。这是一个错误认识！</p>
<p><img src="https://i.imgur.com/19If4zg.png" alt=""></p>
<blockquote>
<p>大饼，是一个创新的支付网络，一种新的钱。</p>
</blockquote>
<p><img src="https://i.imgur.com/l5VdjZp.png" alt=""></p>
<blockquote>
<p>一个纯点对点版本的点子现金系统，可以不通过金融机构完成点对点支付。</p>
</blockquote>
<p>上面一个来自大饼官网，一个来自中本聪白皮书的摘要。</p>
<p>大饼是什么呢？<strong>他是一个不需要第三方的点对点支付网络，一种新的钱。</strong></p>
<h3 id="钱不是货币"><a href="#钱不是货币" class="headerlink" title="钱不是货币"></a>钱不是货币</h3><p>一般来说 钱 是用来存储和转移价值的，<strong>而货币（特别是法币）是 钱 的一种形式</strong>。法币没有盛行的时候，人类曾经使用黄金作为 钱 。</p>
<p>大饼，是互联网时代的新的钱的形式，用来实现价值的存储和转移。这种钱在互联网存在以前是不存在的，因为大饼在技术层面是一个网络协议，需要计算机密码学和其他互联网协议支持（比如TCP/IP协议等等）。</p>
<p>大饼，以互联网为依托，通过密码学和其他网络协议实现了一个无需第三方的支付网络。BTC 就是支付代币。</p>
<h3 id="大饼是商品"><a href="#大饼是商品" class="headerlink" title="大饼是商品"></a>大饼是商品</h3><p>我们很难用传统的概念定义大饼的分类。如果非要放在一个门类里面，大饼代币属于商品，而不是证券。</p>
<p>商品和证券有什么区别呢？</p>
<ul>
<li>商品没有发行商</li>
<li>商品无法随意增发</li>
<li>商品没有对手风险</li>
<li>商品不在证券监管部分的监管范畴</li>
</ul>
<p>这么说有点抽象，我举个例子：苹果公司的股票和黄金。显然，股票属于证券，而黄金属于商品。</p>
<ul>
<li>黄金<ul>
<li>黄金没有发行商，只能通过投入人力进行开采</li>
<li>黄金无法随着人意随意增发，只能通过投入时间、人力、资源进行开发</li>
<li>如果你持有实物黄金，你的黄金不会因为某个采矿公司的倒闭而消失</li>
<li>黄金不收各国证监会监管</li>
</ul>
</li>
<li>苹果股票<ul>
<li>股票是由苹果公司通过严格法律程序发型的，即 IPO</li>
<li>苹果公司有权增发股票，即继续募集</li>
<li>如果苹果公司倒闭，你手上的股票会变成价值极低的纸</li>
<li>苹果股票会受到各国证监会的监管，确保不存在内幕交易等不发行为</li>
</ul>
</li>
<li>大饼<ul>
<li>大饼没有发行商，只能通过 PoW 即工作量证明增发（去中心化）</li>
<li>大饼无法随意增发，只能通过 PoW 发行，且上限确定（如何确保这一点跟 PoW 和 去中心化密不可分，下一节具体展开）</li>
<li>大饼没有对手风险，主要你持有私钥，你的大饼不会因为任何个人、公司的破产而消失</li>
<li>大饼不受到的（至少）美国证监会的监管</li>
</ul>
</li>
<li>美金（法币）<ul>
<li>美金有美联储发行</li>
<li>美金可以根据美联储的决定进行增发</li>
<li>如果你持有美金，你的美金价值会根据美联储的货币政策发生变化，极端一点美联储可以强制废除某些序列号的美金的使用权利（制裁恐怖主义比如）</li>
<li>美金不受到证监会监管，但是货币既不是商品也不是证券</li>
</ul>
</li>
<li>Alt Coin（比如 FTX）<ul>
<li>FTX 母公司进行初始代币发行</li>
<li>FTX 可以随意增发，只需要进行 Hard Fork （中心化区块链的通病）</li>
<li>FTX 有对手风险，FTX 已经没了。。。</li>
<li>美国证监会已经对 FTX 的破产进行调查。。。</li>
</ul>
</li>
</ul>
<h3 id="什么支持了大饼的商品属性？"><a href="#什么支持了大饼的商品属性？" class="headerlink" title="什么支持了大饼的商品属性？"></a>什么支持了大饼的商品属性？</h3><p>事实上，商品最为两个核心的属性是：</p>
<ul>
<li>没有对手风险</li>
<li>无法任意增发</li>
</ul>
<p>没有对手风险这点比较容易理解，只要是不依赖第三方可以控制的事物都是没有对手风险的。比如你家里的一个桌子、微波炉、金条等等，这些东西除非是损坏、丢失、或者被抢夺，我们不需要其他人来支配这些物品。而我们手上的股票、国债等，就存在对手风险，比如公司倒闭，我们手上的股票就无法折现了。</p>
<p>接下来我们看最难理解的“无法随意增发”。</p>
<p>刚才我们说，比特币是一个网络协议，参与人员（成为节点和矿工）通过运行符合该协议的软件（比如 Bitcoin core 软件）参与该网络。其实，比特币协议跟其他网络协议非常类似，比如我们每天浏览网页都会输入：<code>https://www.google.com</code>，这个<code>https://</code>其实就是在告诉浏览器使用那种协议介入远端 google 的服务器。这时候，我们需要自己的客户端和谷歌的服务器遵守同一个协议，才能完成网页读取。如果双方使用了不同的协议，则无法进行沟通。</p>
<p>那么比特币网络如何控制大饼的发行呢？主要有两个机制：</p>
<ul>
<li>工作量证明，PoW</li>
<li>2100 万发行上限 + 平均恒定的铸币时间（约10分钟）</li>
</ul>
<p>简单说，PoW 决定了如果想要增发货币，必须投入CPU算力和相应的电能，不能依赖任何其他的特权。<br>关于 PoW 具体原理，请参考：<a href="https://zhuanlan.zhihu.com/p/524285606">比特币随想 - 重拾 Proof of Work
</a>。</p>
<p>最难理解的就是 2100 万发行上限。一个最大的误区就是：2100 万仅仅是通过一段开源代码保证的，任何人都可以修改！<a href="https://unchained.com/blog/bitcoin-source-code-21-million/">How does the bitcoin source code define its 21 million cap?</a></p>
<p>比特币网络是如何通过一段任何人都可以改变的代码维持不变的？<strong>答案就是：去中心化共识</strong>。</p>
<p>之前我们提到，比特币社区具有非常鲜明的去中心化文化，社区鼓励运行自己的全节点，而且成本非常低（如果你懂技术自己配置，可能需要 10 美金；如果不懂，购买成熟的节点产品，可能需要 100 美金）。而维持这种共识的基础恰恰是这些独立全节点。</p>
<p>没错，你可以随意修改比特币代码，然后运行一个执行该代码的节点，但是你提出的区块（记住，提出一个区块是有代价的，消耗电能）会被其他运行不同软件的比特币节点拒绝！这样就会人财两空（电能已经消耗，区块却没有被接受）。</p>
<p>其实，这就是去中心化共识的力量：<strong>人人都可以改变，却没有人可以改变；我不相信每个人，但是我相信所有人！</strong>。</p>
<h2 id="大饼实现了互联网基础上的一次创新"><a href="#大饼实现了互联网基础上的一次创新" class="headerlink" title="大饼实现了互联网基础上的一次创新"></a>大饼实现了互联网基础上的一次创新</h2><p>互联网时代已经有30多年历史了，在互联网普及的过程中，人们经历一系列变革：电子邮件、电子商务、多媒体、自媒体等等，人们可以在网络中传播各种信息，但是价值传输并没有实现。即使是电子商务、网上银行，人们也只是把线下业务放在了线上，并不是互联网原生的价值传递。</p>
<p>比特币协议实现了这一功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我为什么只买大饼？如果只能说一个原因：<strong>大饼具有商品属性，其他Alt Coin都是证券</strong>。</p>
<p>如果要给出第二个原因？大饼是互联网时代的有一次创新，它首次实现了互联网原生的价值传输方法。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Quant Dev 4 - 数据库</title>
    <url>/2022/10/03/quant_dev_5/</url>
    <content><![CDATA[<p>继续之前的系列，这一期我们讲讲 Quant Dev 经常会接触到的数据库。同样，这里我们不讨论高频交易，虽然决大部分内容都是重合的。</p>
<p>数据库的类型和优缺点本身是一个非常大的主题，我无法也没有能力在一篇文章中阐述清楚，这里仅介绍一些量化领域常见的数据库实现和使用场景。</p>
<p>应该注意的是，通用数据库不一定适合某些量化交易使用场景，因此很多公司在使用通用数据库的同时也会开发内部的专用数据可来解决特定的问题。</p>
<h2 id="前置信息"><a href="#前置信息" class="headerlink" title="前置信息"></a>前置信息</h2><p>分析数据库，我们从以下几个方面展开：</p>
<ul>
<li>数据模型，Data Model<ul>
<li>set of records，row based</li>
<li>graph</li>
<li>document，json，bson …</li>
<li>columnar</li>
</ul>
</li>
<li>数据类型描述，Data Define Language - Schema</li>
<li>查询语言，Manipulation and Query Language<ul>
<li>SQL</li>
<li>awk</li>
<li>通用语言，c,python,java,etc..</li>
</ul>
</li>
<li>水平、纵向拓展模型</li>
</ul>
<p>量化交易涉及到的数据库可以分成几类：</p>
<ul>
<li>定制数据库<ul>
<li>完全定制，比如<ul>
<li><a href="https://github.com/man-group/arctic">Next generation of Arctic</a></li>
</ul>
</li>
<li>半定制，比如<ul>
<li><a href="https://github.com/man-group/arctic">Man Arctic</a></li>
</ul>
</li>
</ul>
</li>
<li>通用数据库<ul>
<li>有固定 Schema 的<ul>
<li>关系型 Relational，比如 PostgreSQL，MySQL，TimescaleDB</li>
<li>列数据库 Columnar，比如 KDB，Cassandra</li>
</ul>
</li>
<li>无固定 Schema 的<ul>
<li>文档型 Document，比如 MongoDB，InfluxDB</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>值得注意的是，很多时候定制数据库也不需要重新设计并实现一套数据库（存储、执行、优化等等），我们可以使用已有的数据库进行二次开发。比如，Arctic 就是一个基于 MongoDB 的时间序列数据库，而 TimescaleDB 就是基于 PostgreSQL 开发的时间序列数据库。</p>
<p>另外，在分析数据库的时候还需要注意使用场景：</p>
<ul>
<li>OLTP：适合高写入、高读取，但是数据量较小的场景</li>
<li>OLAP：适合低写入，但是分析复杂且数据量大的场景</li>
</ul>
<p><img src="https://i.imgur.com/aCsAYa3.png" alt=""></p>
<h2 id="我们需要什么技能"><a href="#我们需要什么技能" class="headerlink" title="我们需要什么技能"></a>我们需要什么技能</h2><p><em>SQL 语言是必要的。</em></p>
<p>因为 SQL 的使用场景已经超出了关系型数据库，比如列数据库 Cassandra 的查询语言 CQL 其实也是类 SQL 语言；TimescaleDB 是时间序列数据可，其查询语言也是 SQL；即使是文档型数据库 也可以使用 SQL 进行查询。</p>
<p>另一方面，SQL 是一个设计非常优秀的描述性计算机语言，识别适合描述数据逻辑，由于不需要指定如何进行查询，数据库后台根据查询语句进行进行充分的优化。</p>
<p>最后，SQL 也是很多 DataFrame API（如 Pandas）的设计蓝本。</p>
<p><em>PostgreSQL</em></p>
<p>选择一个 SQL 数据库，学习基本的 SQL 概念，比如Schema、表、View、Trigger、约束等等。至于使用那个一实现，可根据公司的情况，不知道用哪个就选择 PostgreSQL，它是最原汁原味的开源 SQL 数据库。</p>
<p><em>MongoDB</em></p>
<p>文档型数据库的使用，基本的增删查改操作，Index的使用等等。</p>
<h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p>量化行业绝大部分数据可以直接使用 SQL 数据库进行存储和查询。比如中低频的价格信息、标的物的参照信息、标的物的元数据（mapping、id等等）、财报数据等等。</p>
<p>量化行业的另一类数据就是时间序列了。这类信息也可以采用 SQL 数据库存储，但是由于这种信息通常是追加为主，很少修改，而且查询通常涉及非常多的历史记录，且比较复杂，一般会采用专门的数据库或者数据库前端进行处理。比如 TimescaleDB 或者 Arctic。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Hedge Fund</tag>
        <tag>Quant</tag>
        <tag>Python，Database</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ASICs 和去中心化常见问答 - 译</title>
    <url>/2022/09/25/thinking_bitcoin_18/</url>
    <content><![CDATA[<p>本文翻译自：ASICs and Decentralization FAQ</p>
<p>原作者：Andrew Poelstra @ 2015-04-08</p>
<p>原文链接：<a href="https://download.wpsoftware.net/bitcoin/asic-faq.pdf">https://download.wpsoftware.net/bitcoin/asic-faq.pdf</a></p>
<p>关键词：Proof of Work，Proof of Stake，ASICs，去中心化，能量</p>
<p>【方括号里面的内容是我，译者，的话，这是一篇从编程以外的角度理解工作量证明的优秀文章。】</p>
<hr>
<blockquote>
<p>关于作者</p>
</blockquote>
<p><a href="https://www.weusecoins.com/andrew-poelstra/">Andrew Poelstra</a>，<a href="https://blockstream.com/">Blockstream</a> 数学家，2011 年开始参与比特币开发工作，参与开发了高性能密码学库<code>libsecp256k1</code>。Blockstream 参与比特币代码维护开发，致力于构建基于比特币网络的金融体系，比较有名的项目：闪电网络开发维护、Liquid sidechain开发、矿机托管、卫星比特币网络。</p>
<hr>
<blockquote>
<p>以下为翻译内容</p>
</blockquote>
<h2 id="关于这份文档"><a href="#关于这份文档" class="headerlink" title="关于这份文档"></a>关于这份文档</h2><p><strong>1、这篇文档的论点是？</strong></p>
<p>工作量证明，Proof of work，应该尽可能的简单，尽可能的依赖原始的计算资源。话句话说，PoW 应该直接、快速的达到热力学极限（后面会展开解释这一点）。</p>
<p><strong>2、PoW 有趣吗？</strong></p>
<p>并不 ：）【很无聊】。更换或者调整 PoW 算法是抄袭比特币的 Alt Coin 最喜欢做的事情，但是这样做并不能增加任何新的特征或者使用场景。这跟给自行车的瓦盖画画类似，不过不同的是，这么做是有风险的。</p>
<p><strong>3、为什么写这份文档？</strong></p>
<p>两个原因：</p>
<ol>
<li>记载一些关于 PoW 的内容，因为别处没有记载</li>
<li>回答一些普遍的关于 PoW 和其他数字资产的问题（就像刚才说的，PoW 很无聊，所以我不想反复的回答这些问题）</li>
</ol>
<h2 id="什么是工作量证明，PoW"><a href="#什么是工作量证明，PoW" class="headerlink" title="什么是工作量证明，PoW"></a>什么是工作量证明，PoW</h2><p><strong>1、什么是 PoW？</strong></p>
<p>在比特币的背景下，工作量证明是计算证明，证明一些【物理世界的】稀缺的资源被消耗掉了。这样的证明之所以可以存在是因为计算资源通过时间、空间和能量与物理世界产生了联系 <a href="https://arxiv.org/pdf/quant-ph/0502072.pdf">参考文献：NP-complete Problems and Physical Reality</a>。</p>
<p>更进一步说，PoW 实际上通过消耗能量为一些信息签名，并且提交【commit】了这些信息。</p>
<p><strong>2、如何以及为什么使用 PoW？</strong></p>
<p>这些证明主要是用来确保邪恶的参与者因为无法获得无限的能量来证明另一个历史时间线【当然，对他有利的】，同事确保其他参与者【正义的】有足够的时间和带宽对唯一的历史时间线形成共识。这一切的前提是，正义的参与者拥有比邪恶的参与者更多的资源。</p>
<p>比特币的主要创新就是通过经济学刺激，使得拥有大量资源的参与者倾向合理、正义的行为。</p>
<p>这里，“历史”就是由一串工作量证明形成的，每一个证明都会签发一些合法的比特币交易以及前一个工作量证明。用户不仅可以对交易形成共识，也可以对交易发生的顺序形成共识。【这里，作者表达了比特币区块本身就是一个工作量证明的意思】</p>
<p><strong>3、PoW 如何影响共识？</strong></p>
<p>为了让网络中所有参与者（包括矿工和非矿工节点）快速的达到共识，PoW 必须可以被快速验证。换句话说，证明的生成时间和验证时间的比例越大越好。</p>
<p>为了让所有参与者达成共识，PoW 需要足够的时间使前一个被证明的历史传播到其他节点并验证，然后新的历史才能形成【新的块才可以被加入公链】。这里“足够的时间”取决于需要验证的数据量和PoW可以被验证的速度。</p>
<p><strong>4、PoW 如何影响去中心化？</strong></p>
<p>为了让参与个体不会获得不成比例的优势 - （因为这样，在经济限制下，即使一个参与者拥有所有的采矿权并将其出租，以避免工作量证明，因为这在功能上是相同的（但在生态上是不合理的）对于这个参与者来说，只需对每笔交易进行数字签名）- 工作量证明必须是完全可并行的并且不需要状态。换句话说，一个人拥有 2N 哈希率跟两个人分别有 N 哈希率应该是等效的。【作者应该是想表达：比特币 PoW 的这种特性保证了形成中心和不形成中心的成功率是等价的，因此更加鼓励去中心化，而不是中心化挖矿】</p>
<p>比特币通过寻找“部分散列原相”【Partial Hash Pre-images】的方法实现了满足上述要求的工作量证明。该工作是通过不断重复散列操作，每一次都有一个独立同分布的成功几率（这里利用了所谓的“随机预言机假设”散列算法）。成功证明的出现符合泊松过程（Poisson Process）。虽然泊松过程已经为人熟知，但是放在这里仍然有些反直觉。【是的】</p>
<p>PoW 影响去中心化的另一个重要方面是他的物理属性，我们在后面的章节具体阐述。</p>
<p><strong>5、PoW 的泊松过程很重要么？</strong></p>
<p>非常重要，以至于我需要一个单独的部分来解释。为了避免中心化，矿工可以无障碍、无惩罚的加入和离开网络至关重要。另外，一个拥有很多资源的矿工不应该获得不成比例的好处【好处和资源应该是线性的，而不是非线性的】。</p>
<p>这两个要求的相关的，它们都在指出：<strong>花费更多的时间证明和花费更多的资源证明应该是完全等效的。</strong>【请注意，这一点非常重要】</p>
<p>为了达到上述要求，工作量证明必须是“过程独立”（Progress Free）的，换句话说，T 时刻进行的工作量证明不应该依赖于任何之前的任何时间点的证明。这一条，加上好的工作量证明算法应该足够需求以限制出块速度，刚好可以保证在 t0-t1 时间内的完成的工作量证明与 t1 - t0 成正比且与 t1 和 t0 或者其中的任何时间点无关。</p>
<p>上面这些要求加在一起，就是泊松过程。</p>
<p>一个非常反常识的泊松过程的例子：在任何一个当下时间点，下一个比特币出块的时间都是 10 分钟（正负实际的哈希率和难度哈希率）,且与上一个块出现的时间无关，尽管平均出块时间是 10 分钟。【哇哦，停一下，仔细想想这段话，的确非常反常识】</p>
<p><strong>6、PoW 的其他算法方面的考虑？</strong></p>
<p>Greg Maxwell 提出了两个额外的条件：</p>
<ol>
<li>PoW 必须是无法优化的（Optimization Free），即不应该有任何优化的算法的效率可以超过标准算法。【因为】一旦这样的算法被发现，发现该算法的人会有强烈的动机保密，然后利用该算法获得优势。这将导致中心化。</li>
<li>PoW 必须是无法近似的（Approximation Free），即工作量证明不应该有一个有缺陷的变体，它实现了超过其缺陷率的加速。 （如果这是在软件中完成的，它是上述的一个特例；但是它也可以在硬件中完成，例如，通过使用不能解复用某些位串的损坏的多路复用器。）【我。。承认我没看懂这段话。】</li>
</ol>
<h2 id="PoW-的物理属性"><a href="#PoW-的物理属性" class="headerlink" title="PoW 的物理属性"></a>PoW 的物理属性</h2><p><strong>1、什么是（不）可逆计算，为什么不可逆计算很重要？</strong></p>
<p>鉴于这不是一篇物理学论文，这个小节进包含一些声明，没有证明也没有过多的细节。感兴趣的读者可以参考<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%80%86%E8%A8%88%E7%AE%97">这里</a>.</p>
<p>可逆计算，或者绝热计算，是指不会增加熵的计算。这样的计算在时间上可逆，因此必须是输入的单射函数，基于散列计算的工作量证明<strong>不能</strong>被完全逆转。然而，哈希函数的某些组件可能是可逆计算的，这很有用，因为可逆计算不需要能量——更具体地说，在计算速度变为零的极限内，可逆计算的能量需求也变为零。</p>
<p>一般情况下，不可逆计算服从<a href="https://zh.wikipedia.org/wiki/%E8%98%AD%E9%81%93%E7%88%BE%E5%8E%9F%E7%90%86">兰道尔原理</a>，该原则提供了反转一个比特的信息需要能量的下限。</p>
<p>这一点的意义在于：任何不可逆的工作量证明，同时也是一个实际物理世界工作的证明，比如能量耗散。</p>
<p><strong>2、什么是热力学极限？</strong></p>
<p>热力学极限描述了在兰道尔所需能量耗散的下限下实际完成工作量证明的状态。再这样的状态下，两个拥有 N 哈希率的参与者，比一个拥有 2N 哈希率的参与者更有优势，因为独立的参与者有更好的散热能力【PoW 会产生热能，实际上还会产生噪音】。</p>
<p>因此，热力学极限鼓励去中心化。</p>
<p>幸运的是，热力学极限也限制了能源的有效性，比特币对于高效 PoW 的需求也促使矿工尽可能的接近热力学极限。</p>
<p>【这段话基本的意思就是，PoW 会促使矿工寻找更加便宜的能源】</p>
<p><strong>3、谁在乎热耗散？很多大型经济实体在购买电能！</strong></p>
<p>这篇文章不断强调 PoW 有助于抵制中心化，因为大型散热系统不是特别经济，任何挖矿操作都受制于：</p>
<ol>
<li>能够耗散多少热量</li>
<li>能够利用多少余热</li>
</ol>
<p>提高散热需要工程努力和构造，只要余热可以被利用挖矿基本是免费的，但是越过这一点就不是了。【？？？】</p>
<p>然而，很多人提出质疑：现在有很多大型的电力生产者，他们足够大以至于散热需求导致的去中心化显得微不足道。</p>
<p>对此，我有三个回应：</p>
<ol>
<li>首先，如果使用利用其他极限的共识方法（比如内存复杂的PoW使用光速极限）只会让中心化更加严重。如果比特币的经济学鼓励中心化，我们就需要问什么不鼓励中心化呢？</li>
<li>在一些余热可以被直接利用的地方，挖矿的成本仅仅是电取暖和其他能源取暖之间的差别。电能虽然不便宜，但是相对来说比较便宜，等矿机的成本逐渐降低，这将会变成一个重要的因素。</li>
<li>通过廉价电能产生的中心是少数的，比如在中国，但是这不会是长久的。在接下来的几十年里，我们更可能会看到：<ul>
<li>中国【或者其他曾经的廉价地区】的用电成本激增，中心化矿场会逐渐消散</li>
<li>由于线路损耗，高度集中的电力生产效率低下。随着太阳能等技术的成熟，将有可能以更低的启动成本和更少的地缘政治因素在本地生产电力。</li>
</ul>
</li>
</ol>
<p>这些观点体现了对比特币的一个长期看法，在比特币在世界范围内达成它的目的：全球储备资产的时候，去中心化才真正会被重视，才会发挥价值。目前我们有更加迫切的问题去解决，比如可用性、拓展性、和隐私性。我的期望是，当这些问题得到解决时，这些评论将变得不言自明。</p>
<h2 id="关于-ASIC"><a href="#关于-ASIC" class="headerlink" title="关于 ASIC"></a>关于 ASIC</h2><p><strong>1、ASIC邪恶吗？</strong></p>
<p>不。就像刚才论述的，ASIC 矿机让我们更加接近热力学极限，因此也就更加鼓励去中心化。同时，ASIC 在相同的能量消耗下产生更多的哈希率，他们可以产生更多的工作量证明，更少的影响周围环境。</p>
<p>然而，ASIC 带来了生产工厂的中心化，就像我们在比特币早期的挖矿过程中看到的。但是，市场最终摧毁了这种垄断。另外，SHA2 哈希算法的使用也加速了这一过程，因为 SHA2 大大降低了硬件的设计难度。因此，不需要很多资金就可以开设生产 ASIC 的工厂。</p>
<p>更进一步，无论个人如何看待 ASIC，这个趋势是不可逆的。专用硬件永远比通用硬件更加高效（让我们更加接近热力学极限），而比特币 PoW 本质上要求提高就散效率。</p>
<p><strong>2、反 ASIC 好吗？</strong></p>
<p>不。反 ASIC 通常需要设计更加复杂工作量证明算法，但是ASIC仍然是不可逆的趋势，增加算法复杂度只会增加制作成本，进而增加中心化。</p>
<p>更进一步，增加证明算法复杂度，通常也意味着增加验证算法复杂度，这样就会额让非矿工节点（全节点）很失望，进而增加中心化程度。</p>
<p><strong>3、反 ASIC 可行吗？</strong></p>
<p>让 ASIC 工厂提高生产成本是可能得。但是，你不可能提出一个算法，使得通用计算机的计算速度超越其对用的专用计算机，这样只会产生一个新的专用计算机。</p>
<p>（如下观点完全错误：如果 ASIC 出现，软件开发人员只需要更换算法即可。因为在一个去中心化工作量证明网络，开发人员无法这样做；如果是中心化网络，工作量证明本身就是没有意义的）</p>
<p><strong>4、内存困难证明好吗？</strong></p>
<p>不。内存困难证明方法最终会提高 ASIC 的设计负担，降低热力学极限提供的去中心化优势，而且不必要的会提高成本，然后进一步促进中心化。加上 SRAM（静态内存）比 DRAM（动态内存）更快，但是更贵的事实，这只会让事情变得更糟糕。</p>
<p>困难证明方法还需要一部分验证者提供大量的内存，这也会损伤去中心化。</p>
<p>还有一个需要提出的事情是“时间换空间”问题。就是说一个算法可以通过增加使用的内存空间来提速。这一点就不满足“不可优化的”的原则【之前提出的】。</p>
<p><strong>5、scrypt 比 SHA2 更好么？</strong></p>
<p>不。因为：</p>
<ol>
<li>验证太慢。</li>
<li>需要更加复杂的 ASIC【后来证明是显卡成了 ASIC 】</li>
<li>对内存要求更多</li>
</ol>
<p><strong>6、Primecoin 比 SHA2 更好么？</strong></p>
<p>不。【不写了，Primecoin 已经不在了， SAH2 比特币还在，已经说明了一切。】</p>
<p><strong>7、有用的 PoW？</strong></p>
<p>一般来说用 PoW 来做其他“有用的”事情是个坏主意，比如 Primecoin。并且，PoW 对于比特币已经是一件“有用的”事情了。</p>
<h2 id="权益证明（PoS）"><a href="#权益证明（PoS）" class="headerlink" title="权益证明（PoS）"></a>权益证明（PoS）</h2><p><strong>1、什么是 PoS？</strong></p>
<p>PoS 的主要思想是：矿工不是通过消耗物力资源，而是消耗自己的加密货币【虚拟的】来实现自举。【有点像鸡生蛋、蛋生鸡的循环】。但是这种共识方式可能会出现“Nothing to stake”的问题。</p>
<p><strong>2、原则上，PoS 如何工作？</strong></p>
<p>PoS 的基本工作原理是通过自己的加密货币进行投票决定出块。为了增加拓展性和防止“富人邪恶”的情况，每个区块是从一组参与者中产生的，共识算法决定这一组中谁出块。</p>
<p><strong>3、什么是 Nothing to stake？</strong></p>
<p>问题的关键在于，用户可以无成本的投票选出无数个分叉的区块链，但是这么做往往是有利可图的。因此，因此，矿工诚实行事以保护自己币的价值的想法，实际上是一场悲剧。</p>
<p>矿工同时提出多个分叉的优势在于，他们可以改变的未来出块的投票分布。</p>
<p>这对中心化来说是致命的，因为每个矿工都被单独激励以这种方式行事，这对共识也是致命的。</p>
<p><strong>4、PoS 适合其他产品吗？</strong></p>
<p>当然。以密码方式证明一个人在系统中的股份的能力是一个令人兴奋的功能，这是密码产品独有的。它可用于构建我不了解的新的和创新的协议。<strong>但是，它不能用于创建分布式共识</strong></p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>PoW</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 再看工作量证明</title>
    <url>/2022/09/24/thinking_bitcoin_17/</url>
    <content><![CDATA[<p>2022 年 9 月，以太坊完成“融合”，共识算法顺利迁移权益证明（Proof of Stake，POS）。从这一时刻开始，比特币成为唯一有影响力的工作量证明（Proof of Work，POW）公链。</p>
<p>在这个特殊的节点上，我决定再看工作量证明。附之前的几个文章：</p>
<ul>
<li><a href="https://wangzhe3224.github.io/2022/06/04/thinking_bitcoin_7/"> 比特币随想 - 重拾 Proof of Work </a></li>
<li><a href="https://wangzhe3224.github.io/2022/05/26/thinking_bitcoin_3/"> 比特币随想 - Proof of What? </a></li>
<li><a href="https://wangzhe3224.github.io/2022/08/28/thinking_bitcoin_15/"> 比特币随想 - 比特币工作量证明用了多少电？ </a></li>
</ul>
<h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>POW 或者 POS 都是共识实现的工程选择，工程选择问题一定会有取舍，所以并没有明确的好坏之分。</p>
<p>但是，由于工程性质不同，会让比特币和以太坊成为两个截然不同的平台。重申，本文不会比较比特币与以太坊谁好谁坏。</p>
<p>当然，对我而言，比特币最大的创新点就在于工作量证明。<strong>不是比特币定义了工作量证明，而是工作量证明定义了比特币</strong>。</p>
<h2 id="POW，POS-和环境友好"><a href="#POW，POS-和环境友好" class="headerlink" title="POW，POS 和环境友好"></a>POW，POS 和环境友好</h2><p>在《Economic in One Lesson by Henry Hazlitt》这本书中，作者这样总结到：</p>
<blockquote>
<p>经济学的艺术在于两个方面：</p>
<ol>
<li>对于一个政策不仅仅考虑短期效应，还需要考虑中期、长期影响。</li>
<li>对于一个政策不仅仅考虑对某个人群的影响，还需要考虑对不同人群的影响。</li>
</ol>
<p>Henry Hazlitt @ 1946 年</p>
</blockquote>
<p>作者之后用 20 多个例子说明上述两个要点，以及历史上人们在经济学政策方面，因为忽略其中的一点或者两点而犯下的错误。有意思的是，作者也指出，有时候人们犯错误并不是没有意识到正在犯错误，而是为了利益或者便利有意为之。</p>
<p>有了以上的背景，我们来看一下以太坊融合后的官宣：<a href="https://blog.ethereum.org/2021/05/18/country-power-no-more">POS 会降低以太坊 99% 的能源消耗</a>。</p>
<p>我觉得这刚好违背了 Hazlitt 提出的两个要点：仅仅考虑了短期利益，特别是仅仅考虑了一小部分人的影响。</p>
<p>【观点】<a href="https://download.wpsoftware.net/bitcoin/pos.pdf">不可能在不消耗外部能量的前提下达到共识</a></p>
<p>如果我们承认上述观点，那么，如果说 POS 跟 POW 实现了同样的安全模型，那么 POS 的能量耗散在哪里？</p>
<p>这里有两种可能：</p>
<ol>
<li>POS 不能形成跟 POW 一样的安全模型，POS 是另一种的模型</li>
<li>POS 可以形成类似的安全模型，那么其能量耗散应该跟 POW 一致</li>
</ol>
<h3 id="可能-1：POS-不能形成跟-POW-一样的安全模型"><a href="#可能-1：POS-不能形成跟-POW-一样的安全模型" class="headerlink" title="可能 1：POS 不能形成跟 POW 一样的安全模型"></a>可能 1：POS 不能形成跟 POW 一样的安全模型</h3><p>如果这个假设成立，那么 POW 跟 POS 基本不存在可比性了，因为他们想要实现不同的安全模型。<a href="https://download.wpsoftware.net/bitcoin/pos.pdf">关于这点这篇论文进行了详细的论述</a>。这论文的主要论证观点：</p>
<blockquote>
<p>如果人们可以轻易修改历史，那么这个共识系统已经坏掉了。因为如果一方或者多方可以轻易的修改历史，那么他们就可以创造足够多的历史，然后选择对自己有利的一个。</p>
</blockquote>
<p>虽然分布式共识问题是一个非常困难的问题，但是共识问题却不是。共识问题可以轻易地解决，而且可以比分布式系统效率高上十万倍的解决，那就是通过信任的第三方签名。因此，任何加入第三方验证的“分布式”系统，哪怕是一点点第三方的加入，所形成的安全模型都可以被其他模型轻松取代，比如现有的银行体系。<strong>换句话说，分布式只有是和不是两个模型，没有中间模型。</strong></p>
<h3 id="可能-2：POS-可以能形成跟-POW-一样的安全模型"><a href="#可能-2：POS-可以能形成跟-POW-一样的安全模型" class="headerlink" title="可能 2：POS 可以能形成跟 POW 一样的安全模型"></a>可能 2：POS 可以能形成跟 POW 一样的安全模型</h3><p>我个人倾向不相信这个假设。但是即使这个假设成立，那就意味着 POS 模型不能是“节约能源”的系统。</p>
<p>那么，按照这个思路，能源耗散在哪里了呢？</p>
<p>POW 模型下，能源耗散非常明确：哈希率消耗的电能。POS 似乎把能源耗散抹除了。这不科学，难道是免费的午餐吗？</p>
<p>不，我们只看到了矿工的消失，取而代之的是验证节点昂贵的服务器，但是他们消耗的电能几乎可以忽略。</p>
<p>为了理解这个问题，我举一个极端一点的例子：我们现在的记账系统 - 银行。银行没有矿工挖矿，但是银行记账的成本是 0 吗？不是。银行需要购置办公楼、办公设备、需要支付人员工资、开设门店等等。银行的碳排放是 0 吗？宅一看，是，但是按照我们之前提到的经济学原则，我们需要看的更远一些：</p>
<p>银行的员工收到额外的工资（如果他没有这份工作就没有这部分工资）购买了一部汽油跑车。</p>
<p>我想说的是，不消耗电能，不代表没有能量消耗，不代表没有碳排放。</p>
<p><strong>免费午餐的模型，注定是错的</strong>。</p>
<p>POS 需要更加专业的矿池，后面我会讲 POW 矿池和 POS 矿池的本质区别，这些矿池需要更多人工维护，其实这些矿池本传统的银行没有太多区别。</p>
<p><img src="https://i.imgur.com/H5XYDSO.png" alt=""></p>
<h3 id="无论哪种假设"><a href="#无论哪种假设" class="headerlink" title="无论哪种假设"></a>无论哪种假设</h3><p>POW 就像工业革命时代通过重复的机器代替人的重复劳动一样，用重复的哈希算法完成了记账的工作，把人从无聊的记账工作中解放出来。</p>
<h2 id="POW-挖矿-和-POS-验证的区别"><a href="#POW-挖矿-和-POS-验证的区别" class="headerlink" title="POW 挖矿 和 POS 验证的区别"></a>POW 挖矿 和 POS 验证的区别</h2><p>无论 POW 挖矿，还是 POS 验证，都是一种决定出块的机制，换句话说，决定谁来提出下一个区块的内容。POW 的世界里，出块通常是“矿池”完成的；POS 的世界里，是验证节点。</p>
<p>POW 矿池多数是自发形成的松散组织，矿机匿名加入某个矿池，可以随意离开，矿机持有自己的私钥，持有自己的设备，可以自己选择任何合理的能源（这一点我们下一节展开）。</p>
<p>POS 矿池是公司运行托管模式，因为一个验证节点至少需要持有 32 个以太坊，节点服务器需要满足一定的硬件要求。散户与公司签订协议，通过质押自己的以太坊加入矿池。</p>
<p>这种区别导致：</p>
<ul>
<li>POW 矿池的实际节点分布更加广泛，矿机配置相对动态，更加自由</li>
<li>POS 矿池的实际节点分布更加集中，质押配置相对静态，更加约束</li>
</ul>
<h2 id="POW-鼓励能源创新"><a href="#POW-鼓励能源创新" class="headerlink" title="POW 鼓励能源创新"></a>POW 鼓励能源创新</h2><p>刚才提到，无法实现 0 能耗记账功能。POS 和 POW 的能耗体现形式不同而已。</p>
<p>由于 POW 的机制，矿工会尽可能寻找廉价能源，甚至清洁能源，因为只有这样才有更大的经济动力，这也是为什么 POW 矿池运行在各种奇怪的能源供给上：风能、潮汐、地热等等。美国德州的矿工甚至于电网合作，因为电能一旦被生产很难存储，如果没有使用，就只能浪费掉，这些矿工使用这些无用的电能。一些油漆开采公司通常会持续燃烧弃用的天然气，这些能源也被用来 POW。</p>
<p>相对来说，POS 没有类似的经济学动力。POS 的能耗依然倾向于购买电能外的其他服务。</p>
<p><img src="https://i.imgur.com/H5XYDSO.png" alt=""></p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ul>
<li><a href="https://bitcoinmagazine.com/culture/bitcoin-and-teslas-peaceful-energy-vision">Bitcoin Embodies Nikola Tesla’s Vision For Peace And Energy Abundance</a></li>
<li><a href="https://bitcoinmagazine.com/culture/bitcoin-not-proof-of-stake-solves-energy">The Environmental Myth Of Proof Of Stake</a></li>
<li><a href="http://www.tfcbooks.com/tesla/1926-01-30.htm">An interview with Nikola Tesla by John B.  Kennedy</a></li>
<li><a href="https://www.truthcoin.info/blog/pow-cheapest/">Nothing is Cheaper than Proof of Work</a></li>
<li><a href="https://download.wpsoftware.net/bitcoin/pos.pdf">On Stake and Consensus - paper 2015</a></li>
<li><a href="https://download.wpsoftware.net/bitcoin/asic-faq.pdf">ASICs and Decentralization FAQ</a></li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 我不讨厌以太坊！</title>
    <url>/2022/09/18/thinking_bitcoin_16/</url>
    <content><![CDATA[<p>关注我一段时间的朋友可能觉得我讨厌以太坊和一切非比特币网络，<strong>这是一个误会：我不讨厌以太坊。我也不是 Bitcoin Maxilisim</strong></p>
<h2 id="从头说起-不同视角下的比特币"><a href="#从头说起-不同视角下的比特币" class="headerlink" title="从头说起 - 不同视角下的比特币"></a>从头说起 - 不同视角下的比特币</h2><p>第一次听说比特币是 2016 年，然后经历了 2017 年的 ICO 潮、挖矿潮、炒币潮，实话说我赔钱了，对那时候的我来说整个“币圈”就是一场投机：是什么不重要，能赚钱吗？那时没有真正了解过比特币和区块链社区，我的认知停留在媒体的各种报道层面。</p>
<blockquote>
<p>回想起来，亏损不仅仅是运气的问题，也是为认知缺陷买单。</p>
</blockquote>
<h3 id="计算机背景下的比特币"><a href="#计算机背景下的比特币" class="headerlink" title="计算机背景下的比特币"></a>计算机背景下的比特币</h3><p>2018 到 2019 年这段时间，我尝试从技术层面和经济学层面重新理解比特币、以太坊和整个区块链社区，而不是投机和交易的层面。从比特币白皮书开始，通过代码理解比特币如何运作，这其中包括：</p>
<ul>
<li>公钥密码学</li>
<li>加密哈希算法</li>
<li>工作量证明（PoW）原理和实现 - 如何形成共识</li>
<li>区块包含的具体内容<ul>
<li>Merkle Root</li>
<li>Transaction</li>
<li>Script - 智能合约的原理和执行</li>
</ul>
</li>
<li>网路通讯协议</li>
<li>Mempool</li>
<li>钱包的原理和实现<ul>
<li>热钱包</li>
<li>冷钱包</li>
<li>Multi sig</li>
<li>。。。</li>
</ul>
</li>
</ul>
<p>顺带提一句，这个网站是一个非常友好的从技术层面理解比特币的地方：<a href="https://learnmeabitcoin.com/">https://learnmeabitcoin.com/</a> </p>
<p>我也读了这本书：《Programming Bitcoin: Learn How to Program Bitcoin from Scratch》。</p>
<p>只有当我亲手敲下代码，亲自解析一个区块中的每一个交易记录，每一段智能合约的执行后，我才真实了真正的比特币协议，才能判断媒体的报道是否准确。</p>
<h3 id="经济学背景下的比特币"><a href="#经济学背景下的比特币" class="headerlink" title="经济学背景下的比特币"></a>经济学背景下的比特币</h3><p>经济学的角度，我读了两本书：</p>
<ul>
<li>Economics in One Lesson</li>
<li>The Bitcoin Standard</li>
</ul>
<p>这是两本小书，都不长，但是对于一个学工科的人来说，读起来受益且舒适。这两本书很有意思，《Economics in One Lesson》是一本来自 1946 年的“老”书，但是知名经济学家 Walter Block 在 2007 年为这本书的再版写序言的时候这样写道：</p>
<blockquote>
<p>I am still amazed at its freshness. Although the first edition appeared in 1946, apart from a mere few words in it (for example, it holds up to ridicule the economic theories of Eleanor Roosevelt, about which more below) its chapter headings appear as if they were ripped from today’s headlines. Unless I greatly miss my guess, this will still be true in another 60 years from now, namely in 2068.</p>
</blockquote>
<blockquote>
<p>我很吃惊，这本书仍然如此鲜活。尽管第一版是 1946 年发行的，这本书中多数章节题目就像是从今天的报纸头条中取出一样。除非我错的很离谱，60 年后，2068 年，这本仍然如此。。</p>
</blockquote>
<p>而第二本书《The Bitcoin Standard》成书 2018 年，刚好在比特币崩盘后（比特币一度价值仅为 3000 美金）。这本书从货币的历史说起，在法币系统的背景下，阐述了比特币网络的独特性和可能得影响。</p>
<p>在这个视角下，主要分析了比特币网络可能会对全球经济以及法币系统带来的影响。当然，这些影响与比特币的实现方法密不可分，换句话说不能割裂两个视角：计算机和经济学。</p>
<h2 id="我眼中的比特币和以太坊"><a href="#我眼中的比特币和以太坊" class="headerlink" title="我眼中的比特币和以太坊"></a>我眼中的比特币和以太坊</h2><p>在我的认知中，如果大众对一个事物的认知非常割裂且极度摇摆不定，那么这个实物往往是影响深远的。<strong>只不过并不是每个影响深远的实物都会朝着人们最开始认知方向发展。</strong></p>
<p>日心说问世的时候，人们对他的认知是割裂的：教会吵着烧死伽利略，而科学界却为止震动；互联网问世的时候，人们对它的认知的割裂的：旧媒体不断嘲讽和攻击互联网，而极客们却为之付出心血开发网络应用。</p>
<p>现在人们对比特币和以太坊也类似的割裂的态度：有些人觉得比特币和以太坊会带来革命性的改变；有人觉得比特币和以太坊完全没有价值，只是投机炒作的玩具。</p>
<p>更有意思的是，即使在数字资产的圈子里，比特币社区和以太坊社区也是割裂的，水火不容。这种冲突在以太坊升级 PoS 后达到了顶峰：比特币圈子的人觉得 PoS 以后的以太坊彻底失去了去中心化的能力，回到了传统央行模式；以太坊圈子的人则认为比特币协议过于保守，无法实现复杂功能，而且 PoW 是对能源的浪费。</p>
<p>不仅仅比特币社区跟以太坊社区割裂，无数新兴的链都走向了 PoS，并且试图超越以太坊，虽然至今并没有出现任何有竞争力的公链（Solana，Pokladot 等等在市值、参与人员和DApp数量方面均无法跟以太坊抗争）。</p>
<p><img src="https://i.imgur.com/ukJBkZu.jpg" alt=""></p>
<p>其实在我看来，以太坊在升级 PoS 后已经成了与比特币完全不同的事物，他们的实现逻辑和最终目的都变得完全不同。也许，他们现在的关系更像是是孙悟空和贝吉塔：看起来是敌人，其实是朋友。</p>
<p>比特币有两个东西决定了他去中心化和稳定的属性：</p>
<ul>
<li>工作量证明，保持公链和物理世界的联系</li>
<li>保守的智能合约，仅保留和支付相关的指令</li>
</ul>
<p>比特币被设计出来的最初目的只有一个：在没有第三方的情况下，实现价值转移。仅此而已。</p>
<blockquote>
<p>Bitcoin is an innovative payment network and a new kind of money.<br>比特币是一个新的支付网络，一种新的钱。</p>
</blockquote>
<p>曾几何时，人们通过以物易物实现价值交换，后来人们使用黄金把自己的劳动价值存储起来，以便将来交换其他物品。在法币出现以前，“钱”这种特殊的物品都是自然物品，且无法轻易获得：没人可以凭空生产一个桌子，或者以很低的代价生产黄金。但是，实物的“钱”存在一些问题：不方便转移、不方便切分。无奈，人们发明了“货币”代表“钱”，比如 1940 年代的美金，每一美金都可以从银行支付一定的黄金。再后来，“货币”也无法满足人们的欲望，“法币”诞生了。本质上，<strong>法币代表的不再是“钱”，而是信誉（credit）</strong>。从此以后，人们把价值存储在另一群人的信用中，而不是实物。</p>
<p>比特币的诞生正在试图利用互联网把“钱”变回实物，但是方便传输、方便分割。在这个意义上，持有比特币与持有黄金有类似的特性，即你持有的“钱”不是以信誉为基础，而是工作量证明。更进一步，是工作量证明消耗的时间和能源。</p>
<blockquote>
<p>对于人类来说，真正稀缺的只有时间。任何物品都可以随着科技的发展或者地理发现变得不在稀缺。</p>
</blockquote>
<p>比特币的设置会最大化去中心化、最大化吞吐和稳定性，但是相应的他牺牲了速度和灵活度。</p>
<p>我们再看以太坊：</p>
<blockquote>
<p>Ethereum is the community-run technology powering the cryptocurrency ether (ETH) and thousands of decentralized applications.<br>以太坊是一个社区驱动的技术，用来支持数字资产 ETH 和数以千计的去中心化应用程序。</p>
</blockquote>
<p>以太坊的特征是什么呢？</p>
<ul>
<li>权益证明，切断公链和物理世界的联系</li>
<li>激进的智能合约，尽可能多的尝试各种指令，包括循环</li>
</ul>
<p>本质上以太坊是一个软件开发平台，这个平台的目的并不是价值传递，而是构建网络应用程序。既然是构建去中心化应用程序，PoS 无疑是最好的选择，而丰富的智能合约也正是为此。</p>
<p>目前以太坊社区的应用程序门类异常丰富：</p>
<ul>
<li>ERC-20 ：同质化代币</li>
<li>ERC-721：NFT - 非同质化代币</li>
<li>DAO    ：匿名协作组织</li>
<li>DeFi   ：金融</li>
<li>DeSci  ：科研</li>
<li>。。。</li>
</ul>
<p>目前人们还在探索以太坊平台究适合做什么事情。</p>
<p>但是，无论如何，从上面的分析看出比特币和以太坊已经走上了完全不同的道路，他们的领域几乎没有交集。也就无所谓割裂。</p>
<h6 id="tags-Bitcoin-Ethereum"><a href="#tags-Bitcoin-Ethereum" class="headerlink" title="tags: Bitcoin Ethereum"></a>tags: <code>Bitcoin</code> <code>Ethereum</code></h6>]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 比特币工作量证明用了多少电？</title>
    <url>/2022/08/28/thinking_bitcoin_15/</url>
    <content><![CDATA[<p>工作量证明，Proof of Work，是比特币网络的共识算法，也是确保网络安全可靠的根本，具体的算法介绍可以看之前的文章 <a href="https://zhuanlan.zhihu.com/p/524285606">比特币随想 - 重拾 Proof of Work</a>。</p>
<p>这一篇我们探讨工作量证明（PoW）的能源消耗问题，为了理解我们需要知道：</p>
<ol>
<li>工作量证明需要进行大量 CPU 密集的哈希运算</li>
<li>CPU 密集计算最终需要消耗电能</li>
<li>电能有很多产生方式：煤炭、石油、风、太阳、沼气等等</li>
</ol>
<p>这篇讨论分几个不分：</p>
<ol>
<li>比特币网络到底用了多少能源？</li>
<li>比特币用了哪些类型的能源？</li>
<li>使用能源是坏事吗？</li>
</ol>
<h2 id="比特币网络到底用了多少能源？"><a href="#比特币网络到底用了多少能源？" class="headerlink" title="比特币网络到底用了多少能源？"></a>比特币网络到底用了多少能源？</h2><p>给大家看一个官方一点的数据，来自剑桥大学的比特币能源消耗指数<a href="https://ccaf.io/cbeci/index">^1</a>：</p>
<p><img src="https://i.imgur.com/z2B1at7.png" alt=""></p>
<p>上图可以看到，比特币网络的能源消耗期望值为 96.28 TWh 每年。这个数字是什么概念呢？我们看下图，比特币能源消耗占世界能源消耗的百分比：</p>
<p><img src="https://i.imgur.com/1zNhaij.png" alt=""></p>
<p>上图可知，比特币消耗占全球电能产能的 0.43%，全球总能源产能的 0.15%。</p>
<p>我记得 2017 年，媒体黑比特币的时候头条是这样的：<a href="https://www.newsweek.com/bitcoin-mining-track-consume-worlds-energy-2020-744036">比特币在2020年会消耗掉世界的全部能源</a>。现在看起来，这只能是个笑话，因为比特币在全球能源消耗的占比不足 0.5%。</p>
<p><img src="https://i.imgur.com/TfqAlQT.png" alt=""></p>
<p>不过，话说回来，96.28 TWh 不是一个小数字，但是如果我们对比黄金矿业消耗的能源：</p>
<p><img src="https://i.imgur.com/tKt1JBI.png" alt=""></p>
<p>我们发现，比特币网络消耗的能源约为黄金矿业的 70% 左右。让我们继续看比特币能源消耗对比其他生活消耗：</p>
<p><img src="https://i.imgur.com/AsGkbB3.png" alt=""></p>
<p>比特币远远低于空调、化工、炼钢、水泥、冰箱等，比电视消耗的能源略多。</p>
<h2 id="比特币网络使用了哪些类型的能源？"><a href="#比特币网络使用了哪些类型的能源？" class="headerlink" title="比特币网络使用了哪些类型的能源？"></a>比特币网络使用了哪些类型的能源？</h2><p>那么比特币究竟用了哪些能源呢？先给大家看一张图，比特币哈希率（挖矿）分布图：</p>
<p><img src="https://i.imgur.com/bdAyktJ.png" alt=""></p>
<p>这种图通过颜色展示了哈希率的分布情况，有几点值得注意：</p>
<p>首先，截止中国仍然占有 2022 年 1 月，中国仍然占有 21.11% 的哈希率。这就很神奇了，人民政府已于 2021 年 5 月颁布禁令，禁止挖矿行为。请看下图，哈希率确实在 2021 年 5 月迅速下降，但在 2022 年 6 月已经恢复到 2021 年 5 月的水平，而且现在情况看，政府禁令并没有让矿工从中国消失，中国仍然占据了 21% 的哈希值。这也从一个侧面说明了比特币抵抗控制的能力和分布式的特征：禁令是禁令，民意是民意，政府也无法逆势而行。</p>
<p><img src="https://i.imgur.com/ooYga6A.png" alt=""></p>
<p>第二，比特币矿工在世界范围内都用分布。虽然，中国、美国占据了一半的哈希率，另一半矿工却分散在世界各地。这些国家中有发达国家，比如欧洲、日本、冰岛，有发展中国家，比如非洲、南美洲。</p>
<p>这种地区化分布差异也决定了矿工都在是用那些能源挖矿。正所谓靠山吃山，靠水吃水，由于挖矿是一个竞争异常激烈的环境，矿工们也是因地制宜：</p>
<p>俄罗斯天然气工业股份公司（Gazprom）的子公司Gazpromneft近日在其位于西伯利亚的一个石油天然气钻探点设置了一个比特币矿场，<strong>不仅回收了以往浪费掉的能源，还节省了比特币矿场的电费</strong>。</p>
<p>中美洲国家萨尔瓦多正式承认比特币为法定货币后，又开始着手解决如何“生产”比特币的问题。该国总统布克勒 (Nayib Bukele)在6月9日表示，他已指示国有地热发电公司LaGeo制定一项计划，<strong>利用该国火山的地热能为比特币挖矿设施供电。</strong></p>
<p>比特币采矿公司Genesis Mining自2013年在冰岛投产。其创始人之一是该公司首席技术官萨尔特（Philip Salter），他对德国之声总结这个岛国的优势说：”没有国内政治或地缘政治风险，基础设施非常可靠，电力是可持续生产而且便宜得令人难以置信。”</p>
<p>下面的图展示中国矿区的分布，可以发现主要出现在新疆、云贵等能源费用较低的地区。<br><img src="https://i.imgur.com/xASyqGM.png" alt=""></p>
<p>我不在继续举例了，可以发现，由于比特币挖矿的高竞争环境，会激发矿工寻找更加便宜的能源，这其中很多都是<strong>可再生能源</strong>或者<strong>不能被使用而浪费的能源</strong>，而不是直接使用居民用电。</p>
<p>比特币挖矿分布式的特点决定了矿工可以利用零散的电力资源进行挖矿，在维护网络安全的同时获利。最近发生在美国德州的矿工主动停工支持德州因为气温升高导致的电力枯竭的行为，也说明矿工存在道德。</p>
<h2 id="使用能源是坏事吗？"><a href="#使用能源是坏事吗？" class="headerlink" title="使用能源是坏事吗？"></a>使用能源是坏事吗？</h2><p>当然不是。能源被生产就是用来被消耗的，为了改善人们的生活。空调每年消耗 2199 TWh 的电能，但是人们愿意付出代价，因为空调改善了人们的居住环境；在美国，冰箱一年消耗 104 TWh 电能，但是冰箱确保我们可以保存食物；比特币网络提供了全球支付网络，改善了人们的线上支付方式。这些都说明，能源消耗是好事，不是坏事。</p>
<p>可能对于比特币网络来说，唯一反直觉的就是 PoW 看起来像是在做无用功，“浪费”能源。关于这一点，只有理解 PoW 的原理和意义以后，才会明白这些能源为什么被消耗。正是因为这些能源消耗，让比特币网络成为最安全（哈希率最高）、最去中心化的、最难以被操纵的支付网络。关于这一点请参考：<a href="https://zhuanlan.zhihu.com/p/520555857">比特币随想 - Proof of What?</a>。</p>
<p>安全，对于支付网络来说非常重要，我们希望支付网络可以避免双花、及时清算（而不是银行的 T+1，甚至 T+n 清算）；去中心，是比特币支付网络的创新之处，它确保了人们可以在保持隐私（注意隐私不是秘密或者匿名）的情况下，完成跨地域点对点支付；难以被控制，对于民主来说是中关重要的，人们不希望自己的财富被几个中心控制（比如央行或者美联储）。</p>
<p>上述，就是比特币网络消耗能源换来的。</p>
<p>其实反过来想，人们消耗能源也做了很多无意义的、甚至有害的事情，比如用来支持战争机器、用来运行黄色网站的服务器等等。所以，使用能源不是坏事，使用能源做有益于人们的事情就是好事，做有害人们的事情就是坏事，才是一种浪费。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 为什么比特币的智能合约不是图灵完备</title>
    <url>/2022/08/27/thinking_bitcoin_14/</url>
    <content><![CDATA[<p>提到比特币和以太坊，人们喜欢说：</p>
<ul>
<li>以太坊支持智能合约，比特币不支持</li>
<li>以太坊是图灵完备的，比特币不是图灵完备的</li>
</ul>
<p>这两个说法，第一个是错的，第二个是对的。但是人们倾向错误的认为图灵完备更加优秀。</p>
<p>我们从头说起。</p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约，Smart Contract，这个词我也不知道是从什么时开始的，但是这个词实际的意思就是：可编程，Programmable。而智能合约语言就是编程语言。对于比特币来说，这个语言叫做 Script；对于以太坊，这个语言叫做 EVM 虚拟机字节码。</p>
<p>有小伙伴问：以太坊智能合约的语言不是 Solidity 吗？对也不对。在区块链的背景下，智能合约语言通常是用支持的字节码来表达的，可以理解成一般计算机语言的机器码或者 JVM 的字节码，然后我们可以在这些基本的字节码基础上设计高级语言和对应的编译器、解释器。</p>
<h2 id="图灵完备？"><a href="#图灵完备？" class="headerlink" title="图灵完备？"></a>图灵完备？</h2><p>通俗的说，一个计算系统是不是图灵完备的关键在于是否支持循环指令。在计算机语言中循环是非常重要的特性，可是你是否想过为什么比特币的 Script 语言不支持循环？</p>
<p>我们思考两个可能性：1、中本聪（比特币的设计和最初实现者）不知道循环的重要性，无意中忽略了这个特性；2、中本聪为了比特币的工程特征有意的去掉了循环。</p>
<p>可能 1 很难站住脚，从中本聪的第一版比特币节点的 C++ 实现可看出，他是比较专业的程序员，他在 Forth 的基础上实现了 Script 的解释器。以他对密码学和编译原理的理解，我不觉得他会忽略循环这个特性，而且在他已有的实现基础上加入循环，仅仅是增加一个 if 分支那么简单。</p>
<p>既然如此，我觉得原因只能是 2：他有意的去除了循环，把 Script 设计成非图灵完备。</p>
<p>那么究竟是为啥呢？</p>
<p>我们假设 Script 是图灵完备的，那么任何人都可以部署一个无限循环程序，这样执行该智能合约节点就会陷入死循环，不能继续接受新的请求。换句话说，很容收到拒绝服务攻击，DDoS。一个带有无限循环的智能合约就可能阻塞整个比特币网络。更可怕的是，数学家已经证明：给出任意长的程序，人们无法再执行以前判断是否存在无限循环。以太坊采用了带有循环的智能合约语言，因此它必须引入一个费用，Gas，来迫使任何程序终止，不出现无限循环。</p>
<p>另一个原因是，图灵完备的程序员分析起来非常复杂。最经典的例子就是以太坊的 DAO 漏洞了，该漏洞导致了以太坊最终硬分叉，产生了 ETC，以太坊经典。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上，Script 的非图灵完备设计师有意为之的，而且是为了比特币网络本身的稳定。</p>
<p>历史在证明了这一点，在短短 13 年的历史里面，比特币没有因为任何智能合约漏洞硬分叉。</p>
<p>另外一个有意思的点就是：<strong>比特币网络本身就是一个无限执行的机器</strong>。从这个角度看，比特币区块链本身就是图灵完备的，你可以让一个智能合约无限执行下去，即循环。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 生态的时间戳内存探索</title>
    <url>/2022/08/21/python_datetime_memory_profile/</url>
    <content><![CDATA[<p>如何表达一个 <code>datetime</code> ？我们需要三个部分：<code>date</code>, <code>time</code>, <code>timezone</code>。</p>
<p>在 Python 的生态中主要的事件对象包括：</p>
<ul>
<li><code>datetime</code>： Python 原生的时间戳对象</li>
<li><code>np.datetime64</code>： Numpy 的原生时间戳对象</li>
<li><code>pd.Timestamp</code>： Pandas 的原生时间戳对象</li>
</ul>
<p>不过近几年随着 <code>arrow</code> 的兴起，Arrow 的时间戳对象也进入了人们的视野。</p>
<p>使用下面代码来 Benchmark 三个时间戳的内存使用情况。我们随机生成一百万时间戳。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> memray <span class="keyword">import</span> Tracker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_a_lot_datetime</span>(<span class="params">n: <span class="built_in">int</span> = <span class="number">1_000_000</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">&quot;generate_a_lot_datetime.bin&quot;</span>):</span><br><span class="line">        res = []   </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res.append(datetime(<span class="number">2022</span>, random.randint(<span class="number">1</span>, <span class="number">12</span>), random.randint(<span class="number">1</span>, <span class="number">28</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i%<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_a_lot_datetime64</span>(<span class="params">n: <span class="built_in">int</span> = <span class="number">1_000_000</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">&quot;generate_a_lot_datetime64.bin&quot;</span>):</span><br><span class="line">        res = []   </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res.append(np.datetime64(<span class="string">f&quot;2022-<span class="subst">&#123;random.randint(<span class="number">1</span>, <span class="number">12</span>):02d&#125;</span>-<span class="subst">&#123;random.randint(<span class="number">1</span>, <span class="number">28</span>):02d&#125;</span>T01:02:03.123&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_a_lot_Timestamp</span>(<span class="params">n: <span class="built_in">int</span> = <span class="number">1_000_000</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">&quot;generate_a_lot_Timestamp.bin&quot;</span>):</span><br><span class="line">        res = []   </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res.append(pd.Timestamp(<span class="string">f&quot;2022-<span class="subst">&#123;random.randint(<span class="number">1</span>, <span class="number">12</span>):02d&#125;</span>-<span class="subst">&#123;random.randint(<span class="number">1</span>, <span class="number">28</span>):02d&#125;</span>T01:02:03.123&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    res = generate_a_lot_datetime()</span><br><span class="line"></span><br><span class="line">    res = generate_a_lot_datetime64()</span><br><span class="line"></span><br><span class="line">    res = generate_a_lot_Timestamp()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/ZOCoJwE.jpg" alt="三种时间戳的内存占用对比"></p>
<p>可以发现，</p>
<ul>
<li><code>np.datetime64</code>： 39.061 MB， 32 字节每个</li>
<li><code>datetime</code>: 55.063 MB，49 字节每个</li>
<li><code>pd.Timestamp</code>: 117.05 MB， 114 每个</li>
</ul>
<p>numpy 表现最好，pandas 表现最差，而原生python的时间错表现不错，更加接近numpy。当然这个测试不完全是不同时间戳对象的大小不同，还包含了numpy 和 pandas 不同的实现消耗的内存。也许应该读取 <code>pymalloc_alloc</code> 函数调用内存更加准确，但是确实不变且影响较小。</p>
<p>从 <code>memray</code> 的测试结果看，<code>pd.Timestamp</code> 的内存分配次数也最高，因此运行速度最慢。</p>
<p>接下来我们测试如下，生成高频时间戳 18316800 个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_large_pd_index</span>():</span></span><br><span class="line"></span><br><span class="line">    func = inspect.stack()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">f&quot;<span class="subst">&#123;func&#125;</span>.bin&quot;</span>, native_traces=<span class="literal">True</span>):</span><br><span class="line">        index = pd.date_range(<span class="string">&#x27;2022-01-01&#x27;</span>, <span class="string">&#x27;2022-08-01&#x27;</span>, freq=<span class="string">&#x27;1s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Length of index: <span class="subst">&#123;<span class="built_in">len</span>(index)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_large_np_index</span>():</span></span><br><span class="line"></span><br><span class="line">    func = inspect.stack()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">f&quot;<span class="subst">&#123;func&#125;</span>.bin&quot;</span>, native_traces=<span class="literal">True</span>):</span><br><span class="line">        index = np.arange(<span class="string">&#x27;2022-01-01&#x27;</span>, <span class="string">&#x27;2022-08-01&#x27;</span>, dtype=<span class="string">&#x27;datetime64[s]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Length of index: <span class="subst">&#123;<span class="built_in">len</span>(index)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>

<p>结果表明，pandas 和 numpy 使用内存完全一致，说明 Pandas 后台应该就是调用了numpy 的函数。</p>
<p><img src="https://i.imgur.com/9tPstpZ.png" alt=""></p>
<p>值得注意的是，<code>date_range</code> 生成的时间戳大小远远小于单独随机分配的对象大小。<code>date_range</code> 每一个时间戳大小为 8 字节（139.748 * 1024**2 / 18316800）。</p>
<p>该时间戳大小与 Rust 实现的 chrono 库一致（没有timezone信息）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NaiveDateTime</span></span> &#123;</span><br><span class="line">    date: NaiveDate,</span><br><span class="line">    time: NaiveTime,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 date 是 i32， time 也是 i32， 合计 8 字节。</span></span><br></pre></td></tr></table></figure>

<p>【问题】这里我们做到了时间戳最小的内存消耗了吗？ 8 字节。</p>
<p>如果我们观察第一次的实验结果，<code>np.datetime64</code> 每一个对象的大小应该为 32 字节，而不是 8 字节。这应该与每一个对象的 Header 占用空间有关，当我们把时间戳放入一个固定的 array 里面， 8 字节应该是标准的时间戳大小。</p>
<p>【Take Away】<code>np.datetime64</code> 是最节约的时间戳，前提是把他们放入一个<code>ndarray</code>。</p>
<p>接下来我们看看时间戳的影响，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> memray <span class="keyword">import</span> Tracker</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">HK_TZ = pytz.timezone(<span class="string">&quot;Asia/Hong_Kong&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_a_lot_datetime</span>(<span class="params">n: <span class="built_in">int</span> = <span class="number">1_000_000</span>, tz: <span class="built_in">bool</span>=<span class="literal">False</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> Tracker(<span class="string">&quot;generate_a_lot_datetime.bin&quot;</span>, native_traces=<span class="literal">True</span>):</span><br><span class="line">        res = []   </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> tz:</span><br><span class="line">                res.append(datetime(<span class="number">2022</span>, random.randint(<span class="number">1</span>, <span class="number">12</span>), random.randint(<span class="number">1</span>, <span class="number">28</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i%<span class="number">1000</span>, tzinfo=HK_TZ))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(datetime(<span class="number">2022</span>, random.randint(<span class="number">1</span>, <span class="number">12</span>), random.randint(<span class="number">1</span>, <span class="number">28</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i%<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果表明，时间戳并没有增加额外的内存分配，说明他们都指向了同一个时间戳对象。</p>
<p><img src="https://i.imgur.com/DZvLCUQ.png" alt="相同的tz信息"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.rs/chrono/0.4.22/chrono/struct.DateTime.html">chrono - Rust datetime library</a></li>
<li><a href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/core/src/multiarray/datetime.c">numpy - datetime64</a></li>
<li><a href="https://github.com/bloomberg/memray">memray</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 10年后的数字资产市场？</title>
    <url>/2022/08/20/thinking_bitcoin_13/</url>
    <content><![CDATA[<blockquote>
<p>没有什么事情是一杯意式不能解决的，如果有，那就一杯 double。。。</p>
</blockquote>
<p>:warning: 本文不涉及任何投资建议 :warning: </p>
<p>如果把整个加密货币看做一个新的资产类型，跟股票、债券并列，那么十年后，加密货币的市场会是什么结构呢?</p>
<h2 id="不存在“加密货币”，应该叫数字资产。"><a href="#不存在“加密货币”，应该叫数字资产。" class="headerlink" title="不存在“加密货币”，应该叫数字资产。"></a>不存在“加密货币”，应该叫数字资产。</h2><p>【观点】“加密货币”，CryptoCurrency，这个词本身就存在问题，因为站在 2022 年看加密货币市场，绝大多数跟货币没有任何关系。我们应该称这个新兴市场：数字资产，Digital Asset。</p>
<p>【举例 - 1】看下图<a href="https://bitcoin.org/en/">^bitcoin</a>，业内龙头比特币的标语：一种创新的支付网络，一种新的钱。</p>
<p><img src="https://i.imgur.com/iaVHzjd.png" alt=""></p>
<p>货币会形成支付网络，比如采用美金的线下交易，或者采用 VISA 实现美金的线上支付；但是，支付网络本身不是货币。后半部分，一种新的钱（Money），钱和货币一样吗？比较模糊，但是钱的概念比货币要更加广泛一些。比如我们经常说的“挣钱”，是指通过劳动存储价值，以便其他人交换价值；而我们很少说“挣货币”，因为货币仅仅是价值载体中的一个。从这个意义上看，比特币一半是网络（BTC 的交易网络），一半是钱（代币 BTC）。直接叫加密货币不妥当，因为过于狭义，也抹去了支付网络的部分。</p>
<p>【举例 - 2】看下图，业内老二以太坊的标语<a href="https://ethereum.org/en/what-is-ethereum/">^eth</a>：以太坊是一个由社区支持的技术，基于该技术 ETH 和数以千计的去中心化应用得以实现。</p>
<p><img src="https://i.imgur.com/KYsJSvu.png" alt=""></p>
<p>以太坊本身将自己定义为一种技术，通过这种技术支持支付网络和去中心化应用程序。这里面涉及一个概念叫做代币，Token。以太坊的原生代币，ETH 有两个主要作用：支付和支持其他代币。由于以太坊支持比比特币更加复杂的智能合约，用户可以在以太坊的网络中发行新的代币。</p>
<p>从这些定义可以看出，以太坊叫做货币不合适，他是一个平台；以太坊的原生代币 ETH 的功能也不仅仅是支付，与货币的功能也不匹配。以太坊衍生的代币，比如 Dai，可能可以成为货币，因为 DAI 是一个铆钉美金的稳定币。</p>
<p>从这个角度看，以太坊跟比特币类似，由两个方面组成：网络和代币。同理，网络不能成为货币；代币，无论是原生代币 ETH 或者是衍生代币如 DAI，用货币都不能概括其功能。</p>
<p>【举例 - 3】NFT，非同质化代币。NFT 是近两年在以太坊平台兴起的新型代币。与以往的代币，比如 BTC 和 ETH，不同，NFT 代币是非同质化的，即代币和代币是不一样的。比如代表某个图片A的代币，与代表图片B的代币是不一样的，虽然他们由同一个智能合约生成。NFT 已经完全脱离了货币的概念，而是一种可能的资产。</p>
<p>【举例 - 4】Uniswap。Uniswap 本质上是以太坊网络上的一个智能合约，其功能是实现不同代币之间的交换、定价。Uniswap 使用代币 UNI 实现设计功能。UNI 显然与货币没有任何联系。</p>
<p>【重回观点】</p>
<p>通过比特币和以太坊的分析，我们知道，抛开网络的部分，代币（BTC、ETH、DAI、UNI、各类 NFT）称为数字资产更加合适，而不是货币。因为它们的功能和意义远远超出了货币的范畴。</p>
<h2 id="数字资产市场的现状"><a href="#数字资产市场的现状" class="headerlink" title="数字资产市场的现状"></a>数字资产市场的现状</h2><p>理解了数字资产的内涵，把它们与货币区别开来，我们就可以站在这个角度观察当前的数字资产金融市场。</p>
<p>首先，看一下传统资产的金融市场构成。</p>
<p>【举例 - 1】商品。</p>
<p>商品应该是最容易理解的资产类型了，虽然商品在金融市场可能是大众接触较少的资产。商品包括什么呢？理论上我们厨房里面的很多东西属于商品：大米、橘子、油、金属、天然气、电、玉米、猪肉等等。</p>
<p>对于商品人们通常由如下交易形式：</p>
<ul>
<li>现货，Spot，就是实打实的实物交换</li>
<li>期货，Future，这是一种金融合约，可以实时交易而不需要移动实物，直到到期日，才会涉及实物交换</li>
<li>期权，Option，这也是一种金融合约，他的标的物通常是某个期货，期权提供了更加灵活的杠杆和结算方式</li>
<li>对赌合同，SWAP，这也是一种合约，基本上就是双方对某个商品的价格在某个时间的对赌合约，通常不涉及现货结算，仅仅是现金结算</li>
<li>CFD，这是 swap 的一种，只不过是按天结算的，基本不涉及现货结算，仅仅是现金结算。</li>
<li>抵押。这是金融领域一个重要的概念，抵押资产，换取另外的资产，并支付利息。比如房贷，你可以通过抵押黄金，获得美金贷款。</li>
</ul>
<p>总体来说，对于一个成熟的商品种类，其交易方式遵循如下发展路径：现货交易，衍生品交易。衍生品包括：期货、期权、对赌合约、更加复杂的合约。</p>
<p>然后，我们看目前的数字资产的金融市场构成：</p>
<ul>
<li>现货，这种就是直接购买连上的代币，比如 BTC、ETH、UNI 等等</li>
<li>期货，主要由各大交易所提供，值得注意的是传统商品期货交易所 CBOE 也推出 BTC 和 ETH 期货合同</li>
<li>期权，主要由各大交易所提供，包括 CBOE 的 BTC、ETH 期权合同</li>
<li>永续合约，主要由各大数字资产交易所提供，比如币安。</li>
</ul>
<p>其中永续合约算是数字资产比较特殊的合约，本质上他是一个结算周期非常短的对赌合约，通常按照分钟现金结算。</p>
<p>另一个值得注意的区别在于：结算的货币。由于稳定币的存在，一般交易所会提供两种结算：传统外汇结算和稳定币结算。</p>
<p>【观点】作为资产，数字资产的金融市场还处在比较初级的阶段，因为数字资产的金融生态目前缺少重要的一环：合规的抵押和借贷。</p>
<h2 id="数字资产市场的未来"><a href="#数字资产市场的未来" class="headerlink" title="数字资产市场的未来"></a>数字资产市场的未来</h2><p>了解目前数字资产市场的现状，我们来分析一下数字资产市场的未来。</p>
<p>【观点】基于数字资产的借贷业务会急速发展。</p>
<p>对于传统资产，比如黄金、股票、货币，其发展的前期，通常是以交易为主，而发展中后期都会出现大量的借贷业务。随着数字资产规模增加，监管健全，基于数字资产的借贷业务也会急速发展。其实，目前已经出现了一些基于比特币的贷款业务。</p>
<p>【观点】数字资产市场仍然会是百花齐放。</p>
<p>如果，我们把数字资产看做跟商品类似，属于裸资产，那么数字资产的未来就会是多种代币并存的。</p>
<p>【概念】裸资产。资产可以分成两类：有对手风险的和没有对手风险的，而没有对手风险的资产就称为裸资产。比如，股票就是有对手风险的资产，因为如果公司倒闭或者违约，该资产的价值就会归零。而实物黄金就属于裸资产，因为实物黄金并不会因为第三方的任何行为而凭空消失。再比如，黄金期货就不属于裸资产，因为对手可能违约，无法交割。</p>
<p>在数字资产以前，裸资产通常包括：商品现货，比如黄金、手表、房子等等，而数字资产将成为一个新的裸资产。</p>
<p>既然是裸资产，具有商品属性，就一定会存在不同目的的代币。比如 BTC 作为价值存储商品，类似贵金属；ETH 最为功能性商品，类似原油。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 十问</title>
    <url>/2022/08/02/thinking_bitcoin_12/</url>
    <content><![CDATA[<p>一些关于比特币的经典问题、新问题的思考：</p>
<ul>
<li>比特币作为一个开源项目，为什么修改比特币如此困难，比如 2100 万的上限？</li>
<li>量子计算机的商业化会摧毁比特币网络吗？</li>
<li>除了投机，有人真的使用比特币吗？</li>
<li>有“大公司”已经开始关注、持有、投资比特币吗？</li>
</ul>
<h2 id="为什么-2100-万不能被修改？"><a href="#为什么-2100-万不能被修改？" class="headerlink" title="为什么 2100 万不能被修改？"></a>为什么 2100 万不能被修改？</h2><p>这是一个经典问题。这个问题的答案是：不是不能修改，而是没人愿意修改；即使有人修改，硬分叉的网络不会有人参与，理性人会迅速将新分叉的代币，置换成比特币。</p>
<p>我们应该从两个角度理解比特币网络。第一，比特币网络是由运行支持比特币网络协议的节点组成的，这些节点中有一些被称为矿工，他们负责出块；还有一些被称作全节点，他们复杂校验出块，并且把新的块快速的传播到与他相连的节点。第二，比特币网络也是人的网络。每一个参与比特币网络的人都有权运行任何版本的比特币协议，但是如果你运行的节点不能被其他人接受，达成共识，你投票的块不会有其他人接受，因此也就无法被大范围广播。</p>
<p>其实，比特币网络的精髓就是协议和广播。</p>
<p>我举个例子，假设我现在下载了比特币软件的源代码，BitcoinCore，然后再本地修改了该软件，把上限改成 4200 万。现在我就可以启动我的矿工节点，准备出块。我很幸运，很快我就解锁了一个新块，而这个块包含的信息指向了 4200 万的上限。当我广播这个块的时候，周围运行原始版本的代码的节点立刻拒绝这个新块，因为他们运行的软件认为这个块是无效的。一旦我出的块无法被其他节点接受，这个块就没有任何意义，因为他无法被广播到绝大多数节点，形成共识。</p>
<p>再进一步，我知道我无法在原始比特币网络生存，我就去联系风投公司，给我的新比特币网络投资，构建我自己硬分叉网络。在这个网络，比特币的上限是 4200 万。但是，由于这是一个新网络，无论是节点数量，还是网络安全性都无法与比特币主网相比。这个硬分叉很难吸引人加入，即使加入，人们也会倾向把新分叉的代币，置换成更加安全、可用性更高的比特币代币，因为这么做符合经济利益。</p>
<p>事实上，我觉得例子在历史上已经发生过好多次了，其中著名的例子：</p>
<ul>
<li>比特币现金</li>
<li>BSV</li>
<li>比特币黄金</li>
</ul>
<p>这几个项目基本上就是上面的例子的现实版。而他们现在的状况，也跟例子中描述的一样：<strong>无人问津</strong>。</p>
<p>所以，2100 万可以被修改么？当然可以，可以随意修改。但是这个问题的关键并不是代码能不能改，而是网络中参与的人的共识和经济利益。</p>
<h2 id="量子计算机的商业化会摧毁比特币网络吗？"><a href="#量子计算机的商业化会摧毁比特币网络吗？" class="headerlink" title="量子计算机的商业化会摧毁比特币网络吗？"></a>量子计算机的商业化会摧毁比特币网络吗？</h2><p>这个问题有两个分支：</p>
<ul>
<li>量子计算机破解公钥密码学，导致私钥泄露</li>
<li>量子计算机挖矿，导致算力失衡</li>
</ul>
<p>简单的答案是：不必担心，也不会摧毁。</p>
<h3 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h3><p>众所周知，比特币的核心就是公钥密码学，通过私钥和签名实现 UTXO 的转移。简单说，公钥密码学建立在一个假设上：有一类数学问题，目前的电子计算不能再多项式时间内求解。</p>
<p>而目前的量子计算机研究表明，量子计算机可以在多项式时间内求解这类数学问题中的一部分，这其中就包含比特币使用的加密算法：Elliptic Curve Digital Signature Algorithm or ECDSA。</p>
<p>这里面有几个问题：</p>
<p>首先，能够破解该加密算法的量子算法叫做 Shor 算法。但是，有研究指出，按照目前的量子比特（量子计算的计算单元）质量，至少需要 100 万个量子比特，才有可能破解比特币加密强度的算法。而 2022 年，IBM 拥有的世界上最强大的量子计算机只有 100 多个量子比特。更加重要的是，没人知道量子比特是不是可以发展到 100 万级别，即没有知道这是一个简单的工程问题，还是根本无解的问题。</p>
<p>第二，即便量子计算机实现了突破，可以运行大规模 Shor 算法，密码学界也有应对方案。其实，早在上个世纪 90 年代，量子安全的加密算法就已经出现了（有趣的是，Shor 算法也是上个世纪的产物，只不过但是还没有真的量子计算机）。换句话说，比特币可以通过硬分叉更换加密算法。联系上一个问题，这种硬分叉更容易形成共识，并且符合参与者的经济利益。</p>
<p>最后，退一万步说，真的出现了强大的量子计算机，人们首先应该担心的一定不是比特币，而是整个互联网的安全。众所周知，我们日常的互联网行为都是基于公钥密码学来交换秘钥，对通讯进行加密的。一旦这种计算机出现，而互联网没有更新安全算法，几乎所有的加密通讯都不在成立，你的银行账号密码、邮箱密码都会暴露在互联网上。</p>
<h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>关于挖矿，本质上是在一个极大的搜索空间内，搜索一个数字的问题。而一个叫做 grover 算法的量子算法可以把这种搜索从线性时间，降低成平方根时间。理论上，这种算法可以加速机器的挖矿速度。</p>
<p>但是，跟前一个问题一样，这种级别的搜索，需要大量的量子比特。而比特币网络完全可以硬分叉，增大所搜空间，轻易解决这个问题。</p>
<p>综上，量子计算机商业化不能对比特币网络构成实质性的威胁。</p>
<h2 id="除了投机，有人真的使用比特币吗？"><a href="#除了投机，有人真的使用比特币吗？" class="headerlink" title="除了投机，有人真的使用比特币吗？"></a>除了投机，有人真的使用比特币吗？</h2><p>如果是 5 年前问这个问题，答案可能是很少或者没有。但是 2022 年，这个问题的答案是肯定的。</p>
<p>萨尔瓦多共和国已经构建了比特币城市，该城市很多店铺可以使用比特币的闪电网络进行支付，其交易速度、吞吐量和成本都远远低于 VISA 网络。萨尔瓦多共和国属于第三世界国家，应急羸弱，长期以来他们只能依靠美金作为货币，来抑制是用本国货币导致的贬值和通胀。但是，大家都清楚一个国家实用外国货币作为法币的问题。因此，他们另辟蹊径，采用比特币作为法币。</p>
<h2 id="有“大公司”已经开始关注、持有、投资比特币吗？"><a href="#有“大公司”已经开始关注、持有、投资比特币吗？" class="headerlink" title="有“大公司”已经开始关注、持有、投资比特币吗？"></a>有“大公司”已经开始关注、持有、投资比特币吗？</h2><p>2022 年，答案是有。</p>
<p><a href="https://www.buybitcoinworldwide.com/treasuries/">https://www.buybitcoinworldwide.com/treasuries/</a></p>
<p>下图是持有比特币的上市公司：</p>
<p><img src="https://i.imgur.com/ZFKVmwq.png" alt=""></p>
<p>下图是持有比特币的国家和私人公司：</p>
<p><img src="https://i.imgur.com/ZkNFvcU.png" alt=""></p>
<p>下图是目前作为投资工具的比特币：</p>
<p><img src="https://i.imgur.com/geA70rt.png" alt=""></p>
<p>之前我翻译过一篇来自全球最大上市对冲基金公司英士曼集团的关于比特币机构用户投资的文章：<a href="https://zhuanlan.zhihu.com/p/546096802">https://zhuanlan.zhihu.com/p/546096802</a></p>
<p>还有很多其他投资公司也都在关注比特币：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/528930900">比特币随想 - 机构投资评估 1</a></li>
<li>Arc Investment</li>
<li>富达投资，Fidelity</li>
<li>黑石基金，BlackRock</li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>英仕曼集团 - 加密货币投资指南 2022-06 - 译</title>
    <url>/2022/07/25/think_bitcoin_9/</url>
    <content><![CDATA[<blockquote>
<p>原文地址：<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4124576">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4124576</a></p>
</blockquote>
<p>这篇论文是由全球最大的上市对冲基金公司英仕曼集团为主撰写的，其中两位作者来自旗下系统化交易公司 Man AHL。截止 2022 年 6 月，英仕曼集团管理超过 1500 亿美金的资产。</p>
<p>这篇论文从专业机构用户的角度审视了比特币和加密货币市场，给出了一些专业的观点和事实。列出如下。</p>
<p><strong>注意，放在括号中的观点不是原作者的，而是我，笔者，的。</strong></p>
<h2 id="什么是泡沫？"><a href="#什么是泡沫？" class="headerlink" title="什么是泡沫？"></a>什么是泡沫？</h2><blockquote>
<p>We should not confuse bubbles with volatility</p>
<p>我们不应该混淆泡沫和市场波动。</p>
</blockquote>
<p>泡沫的定义为：永久性的偏离其基本价值。对于比特币，他的基本价值（fundamental value）定义并不清晰（起码目前没有股票那么清晰）。但是，比特币过去 13 年价格运动与历史上经历的泡沫有显著区别：比特币的回撤都在短时间内恢复了。</p>
<p><img src="https://i.imgur.com/eZVA3sj.png" alt="比特币的价格回撤"></p>
<p>下面的表格展示了历史上著名的泡沫。其中 4 个从未从回撤中恢复，剩下两个经历了 20 多年才恢复。对比比特币，恢复周期大概只有几年。因此，<strong>我们不应该混淆泡沫和市场波动</strong>。</p>
<p><img src="https://i.imgur.com/ailUMuF.png" alt="历史上的泡沫"></p>
<h2 id="加密货币的分类"><a href="#加密货币的分类" class="headerlink" title="加密货币的分类"></a>加密货币的分类</h2><p>我们主要讲加密货币市场分成 6 类：交易型、智能合约、DEX、借贷、Web3、纪念币。这里忽略了一个重要的币种：稳定币。</p>
<p><img src="https://i.imgur.com/v1E9VL7.png" alt="不同加密货币的历史表现"></p>
<h2 id="加密货币定价的挑战"><a href="#加密货币定价的挑战" class="headerlink" title="加密货币定价的挑战"></a>加密货币定价的挑战</h2><h3 id="经济学机制"><a href="#经济学机制" class="headerlink" title="经济学机制"></a>经济学机制</h3><p>美元（脱离黄金后的美金）的价值基于以下原因。首先，美元是美国的法定货币。其次，美国税收采用美元。最后，拒绝缴税是违法行为。在世界范围内，美元是各个国家的主要储备货币。就像所有的法币一样，美元有价值因为人们相信他有价值，如果信心降低，法币就会贬值。在极端情况下，国民可能会寻求使用其他法币，而放弃本国法币。</p>
<p>但是，为什么想比特币一样的加密货币会有价值呢？它们不是美国的法定货币，波动巨大，而且他们还会面临可能得合规风险。</p>
<p>那么如何解释比特币的价值呢？目前学术圈有几个解释方法，但是似乎都难以服众。</p>
<h4 id="Metcalfe-定律"><a href="#Metcalfe-定律" class="headerlink" title="Metcalfe 定律"></a>Metcalfe 定律</h4><p>如果把比特币网络看做是一个支付网络，那么根据 Metcalfe 定律，网络的价值取决于该网络中用户的总量。下图是各种加密货币的 Metcalfe 拟合曲线：</p>
<p><img src="https://i.imgur.com/pEF9T8c.png" alt=""></p>
<p>可以发现，比特币和以太坊的拟合值非常高，似乎 Metcalfe 定律解释了其基本价值。但是，我们忽略了比特币网络中的地址和用户并不是一一对应的，通常一个用户会拥有多个地址（而且比特币网络有一个地址只使用一次的文化）。</p>
<h4 id="比特币作为数字黄金"><a href="#比特币作为数字黄金" class="headerlink" title="比特币作为数字黄金"></a>比特币作为数字黄金</h4><p>历史上，黄金一直都保持与法币相对独立的金融网络，黄金的工业用途非常有限，在有限的工业用途中，70%以上都是作为装饰品或者珠宝，他的价值主要来自于人们接受他作为跨国货币网络。另一方面，比特币，在这个背景下，也被称作数字黄金。因为比特币有一个写在代码中的总量：2100 万。</p>
<p>（当然，比特币的 2100 万是一个共识上限，如果比特币网络中的大部分矿工决定运行一个修改上限的节点软件，并且保证他们总是提供最长的链，那么这个上限就可以被修改。但是，这么做目前看没有经济学刺激。）</p>
<p>如果把比特币当做黄金来进行定价，目前黄金代表的世界总价值约为 15 万亿美金，假设比特币抢占黄金 10% 的份额，即1.5 万一，一个比特币的估值为 72000 美金。但是，问题在于，比特币到底可以占据多少黄金的比重？0%？5%？ 20%？还是 100% ？</p>
<h4 id="来自“挖矿”的成本"><a href="#来自“挖矿”的成本" class="headerlink" title="来自“挖矿”的成本"></a>来自“挖矿”的成本</h4><p>如果黄金的定价假设可以被接受（即把比特币作为一种大宗商品，当然了只有 PoW 的链才可能有这个属性），我们就可以从另一个角度看待比特币的定价：开采成本。</p>
<p>如下图所示，传统商品，比如是有、黄金、或者铜，他们的价格比成本的比值通常在 0.9 到 2.3 之间，但是比特币的比值远远高于这个数值。尽管，近几年我们已经看到比特币的比例在下降，但是仍然在 10 左右，远远高于普通商品。</p>
<p>如果按照此方法定价，假设比特币的合理比值跟其他商品类似，为 1.5，那么比特币的价格应为：11000 美金。</p>
<p><img src="https://i.imgur.com/sZSo2aj.png" alt="商品价格比开采成本"></p>
<p>当然，这个模型有很多问题。比特币“挖矿”跟传统挖矿非常不同；另外，似乎没有人用这个比例来给传统商品定价。</p>
<h4 id="稀缺性-Flow-vs-Stock"><a href="#稀缺性-Flow-vs-Stock" class="headerlink" title="稀缺性 - Flow vs Stock"></a>稀缺性 - Flow vs Stock</h4><p>还有另一个常见的定价模型，即用生产的速率除以商品的总量。目前比特币的这一比值非常低，远远低于其他法币或者加密货币。</p>
<p><img src="https://i.imgur.com/I7xvHR7.png" alt=""></p>
<h4 id="相对价值"><a href="#相对价值" class="headerlink" title="相对价值"></a>相对价值</h4><p>对比特币的绝对价值进行定价非常困难，我们可以考虑采用相对价值定价，即采用现货价格和期货价格定价。</p>
<p>对于，法币，这种定价方式通常是通过利率的折现实现的。但是如何把这个应用到比特币呢？</p>
<p>我们可以利用 DeFi 生态的数据。比如 2022年2月17日，12个月的比特币借贷利息为 6.2%，而美金的12月Libor利息为 1.3%，这就意味着比特币和美元的价差为 4.8%。假设现在比特币的价格为 42340，这就意味着远期的价格应为 40386，而当时的比特币期货价格为 47183。因此，在这一天比特币的期货的价值被高估了约 17%。</p>
<p>当然，这种方式也有很多问题。比如 Defi 利率并不是无风险利率。</p>
<h2 id="加密货币的风险和回报率"><a href="#加密货币的风险和回报率" class="headerlink" title="加密货币的风险和回报率"></a>加密货币的风险和回报率</h2><p>下图是 buy and hold 和 buy and hold + 波动率调整：</p>
<p><img src="https://i.imgur.com/Wj17r0d.png" alt=""></p>
<p>下图是趋势策略的表现：</p>
<p><img src="https://i.imgur.com/l63ZmE5.png" alt=""></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>首先，再过去的很多年，比特币以及其他加密货币并没有机构用户重视，然而近几年比特币已经走进了各大机构投资人的视野。</p>
<p>第二，比特币的波动率非常高。但是我们有非常成熟的方法控制波动率，我们甚至证明趋势跟踪策略对比特币有效。</p>
<p>第三，比特币与其他金融产品的相关性，在正常市场很低，但是在熊市较高。</p>
<p>第四，机构用户进行比特币交易还应该考虑其它问题，比如 Custody。</p>
<p>最后，面对比特币，监管部门还需要做很多探索。</p>
<p>关于未来：</p>
<p>比特币和加密货币很可能在将来进入主流投资领域，另外代币化可能将一些传统意义上流动性不好的物品，比如艺术品，变得更加流动。</p>
<p>如果，越来越多的机构用户进入这个领域提供更加庞大的流动性，比特币的波动性可能会降低。</p>
<p>最后，监管对比特币来说还是未知的风险。</p>
<p>最后的一点思考：一个投资组合中没有数字货币不代表没有风险敞口。因为，投资组合中的产品可能被某种加密货币取代，因此承受负 beta 敞口。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Cypherpunk 宣言</title>
    <url>/2022/06/21/cypherpunk/</url>
    <content><![CDATA[<blockquote>
<p>By Eric Hughes @ 1993</p>
<p><a href="https://www.activism.net/cypherpunk/manifesto.html">https://www.activism.net/cypherpunk/manifesto.html</a></p>
</blockquote>
<p>在电子时代，隐私（Privacy）是一个开放社会的必需品。隐私不是秘密。一个人的隐私是一些他不想全世界都知道的事情；但是秘密是他不想让任何人知道的事情。隐私是一种能力，一种仅仅向世界展示自己的一部分的能力。</p>
<p>如果两个人一起做了一些事情，他们就都有了这段经历的记忆。他们都可以讲述关于这件事情的记忆，谁能阻止他这么做呢？人们可以通过立法禁止这种事情，但是发声的自由在一个开放的社会比隐私更加重要，我们不会禁言任何人。如果许多个在同一个论坛发言，他的信息可以被每个人看到，而他也可以搜集其他人的信息。电子通讯已经让这种群组通讯成为可能，这种能力不会因为我们想让他消失而消失。</p>
<p>因为我们想要获得隐私，我们必须确保通信涉及的各方仅仅知道与这次通讯直接相关的信息。因为信息可以被（轻易）传播，我们需要确保暴露尽可能少的信息。大多数情况，个人身份并不是必要信息。当我用现在在报亭卖报纸的时候，报停不需要知道我是谁；当我让我的电子邮件提供商发送接受信息的时候，提供商不需要知道我在跟谁说话、我们说了什么，供应商只需要知道如何获取信息以及我欠他们多少费用。当我的身份被某个底层的交易机制暴露后，我就没有隐私了。我不能再选择性的暴露信息，我只能暴露我的隐私。</p>
<p>因此，一个开放社会的隐私需要匿名支付系统。到目前为止，现金是主要的匿名支付系统。<strong>一个匿名支付系统并不是一个秘密支付系统</strong>。匿名支付系统可以让用户在想要的时候披露自己愿意披露的身份，这是隐私的核心内容。</p>
<p>一个开发社会中的隐私需要密码学。如果我说了什么，我希望只有我愿意被听到的人听到，如果我说话的内容被全世界知道了，我就不再有隐私。加密本身就表达了隐私的需要，如果采用较弱的加密算法，就代表我只希望一定程度的隐私。而且，在一个默认匿名的系统中披露自己的身份，数字签名就是必要的。</p>
<p>我们不应该期待政府、公司、或者其他大型机构给与我们这样的隐私。代替我们发言是这些公司的优势，而且他们也一定会这样做。抵制他们的声音就是地址信息的现实。信息不仅仅需要是自由的，它也属于自由。信息会扩张并填满存储空间。信息就像谣言一样但是更加强大，信息比谣言传播的更加快，比谣言知道的更多，但是理解的更少（我不太明白这段）。</p>
<p>如果我们想要隐私，我们必须主动争取。我们必须团结起来创造一个匿名支付系统。几个世纪以来，人们一直在用耳语、黑暗、信封、关门、秘密握手和信使来保护自己的隐私。过去的技术不允许强大的隐私，但电子技术可以。</p>
<p>我们是“密码朋克”，我们构建匿名系统。我们用密码学保护我们的隐私，包括匿名邮件系统、数字签名和匿名支付系统。</p>
<p>密码朋克写代码。我们知道总要有人写也一些软件来维护隐私，除非我们自己写出代码，我们无法保护我们的隐私。我们公开我们的代码，这样其他密码朋克可以参与并且调试。我们的代码在世界范围内是免费的的。我们并不在乎你是否认可我们写的软件。我们知道软件不会被销毁，一个传播广泛的系统不会被关停。</p>
<p>密码朋克对任何针对密码学管制表示不满，因为加密本质上是一种私人行为。事实上，加密行为将信息从公共领域中删除。即使是反对密码学的法律也只能触及一个国家的边界和它的暴力武器。密码学将不可避免地传播到全球，随之而来的是它使匿名交易系统成为可能。</p>
<p>为了让隐私广泛的得到任何，隐私必须是社会契约的一部分。人们必须一同部署这些软件。隐私只能在社会成员协作的基础上存在。我们会积极考虑各方面的声音和忧虑，否则我们就是自欺欺人。但是，我们不回应为任何人不同意我们的宣言就背弃密码朋克的原则。</p>
<p>Cypherpunks 积极致力于使网络更安全，以保护隐私。让我们携手向前！</p>
<p>Eric Hughes <a href="mailto:&#x68;&#117;&#x67;&#104;&#101;&#x73;&#x40;&#115;&#x6f;&#100;&#97;&#x2e;&#98;&#101;&#114;&#x6b;&#x65;&#x6c;&#101;&#x79;&#x2e;&#101;&#x64;&#x75;">&#x68;&#117;&#x67;&#104;&#101;&#x73;&#x40;&#115;&#x6f;&#100;&#97;&#x2e;&#98;&#101;&#114;&#x6b;&#x65;&#x6c;&#101;&#x79;&#x2e;&#101;&#x64;&#x75;</a></p>
<p>1993 年 3 月 9 日。</p>
]]></content>
      <categories>
        <category>Cypherpunk</category>
      </categories>
      <tags>
        <tag>Cypherpunk</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 机构投资评估 1</title>
    <url>/2022/06/14/thinking_bitcoin_9/</url>
    <content><![CDATA[<blockquote>
<p>本文大量数据来自 Ark Investment 的报告</p>
<p>Bitcoin As An Investment @ 2022</p>
</blockquote>
<p>该系列主要评估比特币对于 <em>机构用户</em> 的价值，并不是散户。本篇：比特币的价格历史</p>
<h2 id="比特币的价格历史"><a href="#比特币的价格历史" class="headerlink" title="比特币的价格历史"></a>比特币的价格历史</h2><p>比特币白皮书于 2008 年 11 月公开，但是比特币协议的代码（Bitcoin Core <a href="https://github.com/bitcoin/bitcoin">^bitcoin</a>）至少在两年前已经开始开发。</p>
<p><img src="https://i.imgur.com/NtVl7Ue.png" alt=""></p>
<p>2009 年，New Liberty Standard 公家了第一笔比特币交易：1309.03 BTC = 1 美金。2010 年，bitcointalk.org 论坛上，有人叫价 10000 BTC = 50 美金，但是当时无人竞价。同年，弗洛里达州程序员，Laszlo Hanyecz，花费 10000 BTC （25 美金）购买了两个披萨。截止 2022 年 6 月，10000 BTC 大约相当于 2.2 亿美金。</p>
<p><img src="https://i.imgur.com/rDbWPPK.png" alt=""></p>
<p>显然，比特币交易所的出现让比特币的交易更加方便，也让更多人认识到了比特币。2010 年，Mt. Gox 交易所开始交易，三年后（2013 年）其交易额占据了全球 70% 的份额。</p>
<p>2013 年，比特币首次超过 100 美金。2014 年，突破 1000 美金。随后，Mt 交易所传出被黑传言，市场跌落 200 美金，直到 2017 年，比特币重回 1000 美金。Mt Gox 倒下了，Bitfinex 和火币起来了，Coinbase 后来成为了第一家上市的比特币交易所。</p>
<p>值得一提的是，2015 年，第二大市值的以太坊协议上线了，由于以太坊支持一种叫做 ERC-20 的协议，2017 年大量加密货币通过 ICO 上线，截止 2017 年底，ICO 共计募集了超过 46 亿美金。这次 ICO 泡沫将比特币的价格推高至 20000 美金，然而，在 2018 年随着 ICO 泡沫破裂，比特币下跌超过 80%，随后涨回 70%。好景不长，因为 PlusToken 的庞氏骗局被揭露，比特币重回 3000 美金。2020 年新冠疫情造成市场恐慌，比特币一度跌落 3000 美金，随后随着美联储的放水，比特币重新超过 15000 美金。</p>
<p>2021 年 2 月，特斯拉宣布购入 15 亿美金比特币，并且接受比特币作为支付，比特币价格一度被推高至 60000 美金；然而，同年特斯拉宣布拒绝使用比特币支付，原因是环境不友好（特斯拉好景不长被踢出了所谓 ESG），比特币跌落 50000 美金；同年 9 月，中国政府再次ban掉加密货币，比特币价格跌至 30000 美金。随后进入 2022 年，在美联储连续的加息压力下，比特币持续低迷。直到 2022 年 旁氏骗局 Luna UST 和 Celsius 双双暴雷，DeFi 泡沫破裂，截止发文（2022年6月）比特币跌破 25000 美金。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比特币的价格长期看是上涨的，但是其中伴随着剧烈的波动。造成波动的主要原因是加密货币的衍生市场，比如 ICO，DeFi，并不是比特币本身特性的任何变化导致的。比特币的第一次暴跌，2013 年，主要是因为交易所被黑；2018 年主要是 ICO 泡沫破裂；2022 年主要是 DeFi 泡沫 + 紧张的宏观经济条件（这是 13 年来比特币第一次经历的经济环境），可见比特币的暴跌似乎跟比特币本身没有任何关系，而是其后续的衍生品的失败造成的。</p>
<p>主流媒体对比特币的认知往往受到这些泡沫影响，将暴跌事件处理为比特币事件。其实机构用户，比如 Arc Investment，Fidelity，BlackRock， MicroStrategy等，都把比特币（注意不是其他加密货币）作为一个新的资产类型进行相关研究。自从 2010 年，媒体至少 380 次提到比特币将要死亡，但是实际上真的死亡的是每次泡沫的元凶们，比如 ICO 的空气币、Luca UST等等。</p>
<p>机构用户目前主要在研究比特币作为潜在的全球金融结算层（注意结算和支付不是一个概念）、价值存储等特性的可能性</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 如果有一天以太坊。。。</title>
    <url>/2022/06/05/thinking_bitcoin_8/</url>
    <content><![CDATA[<p>如果有一天以太坊完了，会是因为什么？会是以什么形式结束？</p>
<p>各位，我<strong>没说</strong>以太坊会完蛋！如果你觉得 Long live ETH 就别接着看了，给您添堵。你想的没错，以太坊万岁。</p>
<p>·<del>~ 完 ~</del>·</p>
<h2 id="看历史"><a href="#看历史" class="headerlink" title="看历史"></a>看历史</h2><blockquote>
<p>人类从历史获得教训是：人类从未从历史获得任何教训。</p>
<p>—— 黑格尔</p>
</blockquote>
<p>我先贴一张图把，这是截止 2022 年 6 月市值前十的币。</p>
<p><img src="https://i.imgur.com/3VmfasL.png" alt=""></p>
<p>我们来分析一下，其中比特币市值 560（百万美金），以太坊市值 214（后面省略单位）。目前这是两个 PoW 协议的公链，当然也是最大的公链，占据了整个加密货币市值将近 7 成份额，剩下的数十个币种分享余下 3 成。</p>
<p>在仔细看看这些币，其中 3 种是所谓的稳定币：USDT、USDC和BUSD。Luna 旗下的 UST 已于 5 月暴雷，不在了，曾经也是前十的币种。</p>
<p>然后我们还有：BNB、Cardona、Ripple、Solana、狗币、和 Polkadot（勉强，11 位）。注意到一个现象，这里面唯一的老币就是 Ripple 了，XRP 在 17 年的时候就已经在这个榜单了，关注币圈的朋友肯定还知道它。但是，除此之外，5 年前 Top 10 的币很多已经不再了，请看下图，这是 2017 年的 Top 10：</p>
<p><img src="https://i.imgur.com/lQFjgDa.png" alt=""></p>
<p>注意观察，来特比、Dash、ETH Classic、Monero、NEM、Augur、Golem，都已经半死不活了。恐怕刚开始关注币圈的宝宝可能都没听过这里面的很多名字。但是，没错，5 年前这些币就是 Top 10 的市场份额，如今他们都不在了。即使是 XRP 也从第三跌落第七，也许不久的将来就会跌出前十了，XRP 跟去中心化一点关系没有，因为美国“证监会”竟然可以起诉 XRP 的 CEO，嘿嘿，去中心化网络网络的 CEO，太有意思了。。。。。</p>
<p>刺激不？还不够刺激？我再给你看看 2013 年，就是再 4 年以前：</p>
<p><img src="https://i.imgur.com/cTvHlEK.png" alt=""></p>
<p>看到了吗，出了比特，所有的币都已经不在了。这里面有个东西叫 Peercoin，这个币就是 PoS，权益证明的创世币，他的作者首次提出并实现了 Proof of Stake。</p>
<p>所以 PoS 不是什么新的概念，2011 年 Peercoin 就已经实现了 PoS，只不过市场并不买账，经过将近 10 年的时间，已经不复存在了。继续看如今的前十，其实 7 成的市场份额仍然是 PoW 的，即比特币和以太坊。而其他币基本均为某种形式的 PoS，就像我刚才提到的，市场已经抛弃过 PoS 一次，只不过时间太久了，人们已经忘了。</p>
<p>那么 PoS 经过这么多年的迭代，如今表现如何呢？咱们就说 Solana 吧，上线 2 年，官宣掉线 5 次，最长的一次超过 17 小时，需要社区通知验证节点打补丁，然后重启。非常非常有意思，标榜去中心化的“区块链”技术，竟然还会掉线和重启。事实证明，PoS 并没有市场宣传的那么美好。Pokadot 呢？似乎确实没有出现掉线这种情况，但是总体来说不温不火，最近刚刚从前十跌出去，因为币圈熊市了。</p>
<h2 id="如果有一天以太坊完了"><a href="#如果有一天以太坊完了" class="headerlink" title="如果有一天以太坊完了"></a>如果有一天以太坊完了</h2><h3 id="1雷：DeFi"><a href="#1雷：DeFi" class="headerlink" title="1雷：DeFi"></a>1雷：DeFi</h3><p>以太坊现在最大的雷就是 DeFi 了。关于 DeFi 我有个比喻：在沙地上盖了一个倒置的金字塔。啥意思呢？以太坊本身还在探索，作为公链他的表现并不如人意：高额 Gas，智能合约频繁被黑。现在人们在这个本就不牢靠的基础上添置更多脆弱的东西：金融。金融不是还是请，但是，金融行业有个东西叫杠杆，另一个东西叫流动性。整个 Defi 的繁荣可能在一瞬间因为杠杆和流动性轰然倒下。</p>
<p>一旦发生，我们提到的三个稳定币：USDT、USDC和BUSD 一定会最先遭殃。Luna 已经完了，剩下这三个占据了目前份额的 1 成。</p>
<h3 id="2雷：PoS"><a href="#2雷：PoS" class="headerlink" title="2雷：PoS"></a>2雷：PoS</h3><p>为什么 PoS 对以太网是个雷？我说几个事实：</p>
<ul>
<li>你需要质押 32 个 ETH 才可以成为验证节点（矿工）</li>
<li>你需要优质服务器可以作为验证节点</li>
<li>如果上述都没有，没关系，你可质押你的币到矿池，让矿池帮你质押</li>
</ul>
<p>简单的推测会发生什么？有币的人呢，开矿池（比如大型交易所，Coinbase这种；或者 Lido 这种专门做散户质押的）；没太多币或者没钱没精力经营验证节点的，直接参与矿池。总之，所有的币都会快速的向几个中心汇聚，因为不质押 ETH，不会产生任何收益，而质押可以产生利息，比如 Lido 提供 ETH 质押年化 4% 的利息。如下图所示：</p>
<p><img src="https://i.imgur.com/hTgkpL7.png" alt=""></p>
<p>显然，ETH 会向着几个验证节点汇聚。咱们且说，这些大中心都是道德的，尽管如此一旦某一个中心被黑，都会引起轩然大波；咱们再说，谁能保证这几个中心是道德的？</p>
<p>我这么说吧，这些公司都是一些有限公司，换句话说，大家质押的币都是他们公司的风险资产，一旦公司倒闭，你拿回来的可能只能是千分之一。</p>
<h3 id="双响炮"><a href="#双响炮" class="headerlink" title="双响炮"></a>双响炮</h3><p>最可怕的是，这两个雷不是相互独立的。爆，就是双响炮。我不觉得以太坊能抗住。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>不论 PoS 的宣传有多好，市场并不买账，先有 Peercoin，后有 Solana，DOT，无论是从性能还是市值都没有被认可。<br>但是，以太坊仍然要迁移 PoS，这是为什么？我相信每个事情都原因，但并不总是看起来的那样。</p>
<p>因为 PoS 对于鲸鱼实在是太友好了。其实，这就是我们现实世界的缩影：富人永远更富。你有 32 个 ETH 你就可以开矿池，你没有，你就只能把你的 ETH 交给矿池，因为游戏规则是这样的，你不给，你就没利息。但是你给他让他去质押，他一定会抽成，你得资产不断的稀释。怎么样这个模型挺熟悉把？</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=vyd63iG-l68">https://www.youtube.com/watch?v=vyd63iG-l68</a></li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 重拾 Proof of Work</title>
    <url>/2022/06/04/thinking_bitcoin_7/</url>
    <content><![CDATA[<p>Proof of Work （PoW）工作量证明，并不是比特币首创，但是比特币巧妙的使用了他，把它变成了一种实现共识的方法<a href="https://nakamotoinstitute.org/mempool/the-proof-of-work-concept/">^origin</a>。除了比特币，PoW 协议其实还有很多其他的用途：防止 DoS 攻击、处理垃圾邮件。</p>
<p>本文组织如下：</p>
<ol>
<li>工作量证明的一般原理</li>
<li>比特币工作量证明的社会原理</li>
<li>Proof of Stake </li>
</ol>
<h2 id="工作量证明，PoW"><a href="#工作量证明，PoW" class="headerlink" title="工作量证明，PoW"></a>工作量证明，PoW</h2><p>为了理解 PoW，我们首先脱离比特币的场景，来单独看看 PoW 协议。PoW 最早被提出来是为了主动防御 DoS 攻击，就是拒绝服务攻击，而垃圾邮件可以被认为是某种 DoS 攻击。</p>
<p>一个攻击者可以同时发送 1 百万封垃圾邮件，而不用付出任何代价。但是这对邮件服务器和邮件阅读者都是一种困扰。PoW 的方案是：为每一封邮件都附上一个代价（就好像邮票）。在计算机的世界，这种代价的一个选择是 CPU 资源。当服务器<strong>验证</strong>发信人为这封邮件附上了代价，服务器才会处理该邮件。这种代价往往对于每天只发送几百封邮件的人来说算不上什么，但是对于垃圾邮件攻击者，几百万封邮件意味着极大的成本，因此从经济学角度，他可能选择不再攻击。</p>
<p>现在我们需要一种机制，既可以让发信人花费一定的 CPU 资源，有让服务器可以快速的验证发信人确实花费了一定的 CPU 资源。以下就是一种方案：</p>
<p>假设邮件内容，S；发信人需要寻找一个整数，P，使得 $H = hash(S, P)$。这里 H 是一串长度固定为 N 比特的数字，且 H 的前 M 位均为 0。</p>
<p><img src="https://i.imgur.com/6JhQWty.png" alt=""></p>
<p>这里 Hash 是一个密码学的函数，他可以把任意宽度的比特转化成一个固定长度的比特传，该函数有以下特性：</p>
<ol>
<li>通过 S 和 P 计算 H 的速度非常快</li>
<li>给出 H 几乎不可能找到 S 和 P</li>
<li>输出 H 和输入的关系是随机的，即输入微小的变化，输出就会产生随机巨大变化</li>
</ol>
<p>下面我举个例子，我们选用 SHA-256 作为我们的 Hash 函数，256 的意思就是函数输出结果一共 256 位。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">s</span>):</span></span><br><span class="line">    m = hashlib.sha256()</span><br><span class="line">    m.update(s)</span><br><span class="line">    res = m.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(<span class="string">b&quot;11111&quot;</span>))</span><br><span class="line"><span class="comment"># d17f25ecfbcc7857f7bebea469308be0b2580943e96d13a3ad98a13675c4bfc2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(<span class="string">b&quot;11112&quot;</span>))</span><br><span class="line"><span class="comment"># 744b8397028efb93fc77ef9d12ed82d522a8d168616550a79dec63185c2d3fc2</span></span><br></pre></td></tr></table></figure>

<p>可以看到仅仅从 1 变成 2，hash 的结果已经是面目全非！</p>
<p>下面就是 PoW 协议工作的基本方式：（看注释）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span>(<span class="params">s: <span class="built_in">str</span>, difficulty: <span class="built_in">int</span>=<span class="number">2</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = hashlib.sha256()</span><br><span class="line">        m.update((s + <span class="built_in">str</span>(p)).encode())</span><br><span class="line">        h = m.hexdigest()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> h[:difficulty] == <span class="string">&quot;0&quot;</span> * difficulty:</span><br><span class="line">            <span class="keyword">return</span> p </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作量证明，寻找 p</span></span><br><span class="line">s = <span class="string">&quot;This is a message!&quot;</span></span><br><span class="line">diff = <span class="number">4</span>  <span class="comment"># 这里是难度系数，即 hash 结果开头的 0 的数量，比如 0000xxxxx</span></span><br><span class="line">p = <span class="built_in">pow</span>(s, diff)  <span class="comment"># p 就是我们找到的整数</span></span><br><span class="line"><span class="built_in">print</span>(p)  <span class="comment"># 83205</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发邮件的时候，我们除了发送信息 s，也发送我们找到的整数 p</span></span><br><span class="line"><span class="comment"># （其实这个 Protocol 已经有问题了，发现了吗？我们应该要求把收件人也加入has，不过这个不重要）</span></span><br><span class="line"><span class="comment"># 然后，服务器就可以通过 s 和 p 证明我们做了工作：</span></span><br><span class="line"></span><br><span class="line">m = hashlib.sha256()</span><br><span class="line">s = <span class="string">&quot;This is a message!&quot;</span></span><br><span class="line">p = <span class="number">83205</span></span><br><span class="line">m.update((s + <span class="built_in">str</span>(p)).encode())</span><br><span class="line">h = m.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(h)</span><br><span class="line"><span class="comment"># 这是hash的结果：</span></span><br><span class="line"><span class="comment"># 00002516593e4194cfb8667fa3559f37fb964d0a375c9567c6ca297bfbb48cfe</span></span><br><span class="line"><span class="comment"># 可以看到开头有 4 个 0，也就是验证了发信人做了工作</span></span><br></pre></td></tr></table></figure>

<p>这个协议其实非常巧妙，首先验证结果非常快，只需要一次 hash 操作；但是找到整数 p 却很慢，而且难度是可以控制的，且难度随着 0 的个数程指数上升。我们举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;This is a message!&quot;</span></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">ps = []</span><br><span class="line"><span class="keyword">for</span> diff <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    _s = time.time()   </span><br><span class="line">    p = <span class="built_in">pow</span>(message, diff)</span><br><span class="line">    ps.append(p)</span><br><span class="line">    _e = time.time()</span><br><span class="line">    dur = _e - _s</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;难度：<span class="subst">&#123;diff&#125;</span> - <span class="subst">&#123;dur&#125;</span> &quot;</span>)</span><br><span class="line">    x.append(diff)</span><br><span class="line">    y.append(dur)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">难度：1 - 1.71661376953125e-05 </span></span><br><span class="line"><span class="string">难度：2 - 7.200241088867188e-05 </span></span><br><span class="line"><span class="string">难度：3 - 0.009111881256103516 </span></span><br><span class="line"><span class="string">难度：4 - 0.14280223846435547 </span></span><br><span class="line"><span class="string">难度：5 - 0.19749689102172852 </span></span><br><span class="line"><span class="string">难度：6 - 21.125200271606445 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br></pre></td></tr></table></figure>

<p>可以看出，当难度为 6 时，这个简单的 PoW 协议需要 21 秒才能找到合适整数。当然，你总是可以用更好的算法，使用更好的硬件进行并行计算，但是这个算法复杂度不会因此改变，搜索时间随难度程指数级别增长。</p>
<h2 id="比特币和-PoW"><a href="#比特币和-PoW" class="headerlink" title="比特币和 PoW"></a>比特币和 PoW</h2><p>讲完了 PoW 的基本概念，我们从其他角度看看这个协议。因为 PoW 可能是比特<br>币协议看起来最难解的概念，比特币协议通过 PoW 来定义新块（一组新的交易记录）被加入分布式交易记录链（区块链）。<br>实际上 PoW 来自赛博朋克运动<a href="https://en.wikipedia.org/wiki/Cypherpunk">^1</a>（不是那个科幻小说赛博朋克，而是一种推崇计算机密码学的运动）的一部分，他跟货币政策或者计算机科学都有点格格不入。</p>
<p>所有比特币的区块都包括一个叫做 nonce 的无意义的整数，而“挖矿”做的工作跟我们上一节讲解的内容一样，寻找 nouce（其实就是我们之前提到的 p ）。整个挖矿过程是一个非常随机的过程，谁先找到这个整数，谁就有权利提出下一个区块。</p>
<p>尽管矿机（节点）的目的是为了记账，但是他们做的绝大多数工作却是“挖矿”，即寻找整数，而不是记账。挖矿花费的能源（电力、维护等等）再也不会回来了，用掉了。整个比特币网络具有巨大的计算能力（hash能力），除了一小部分之外，其他一切都是没有目的的。</p>
<p>当一个人升级他们的挖矿计算机时，他们就能挖的更快，然后赚更多的比特币。但是，当每个人都升级时，挖矿整体并没有变得更有效率。不管网络的算力有多大，每十分钟只有一个块加入区块链。为了维持这个出块频率，网络会更新难度（0的个数）。比特币网络更像是一片森林，每棵树都试图长的更高来获得阳光，但是结果是大部分太阳能都被用来长高高的树干。</p>
<p>对于比特币网络来说，我们应该这样理解 PoW：比特币网络由一群自私的人组成，他们相互独立没有从属关系，为了让这群自私的人形成共识，我们需要 PoW，否则如果比特币网络中都是诚实和无私的节点，它就不需要 PoW 形成共识。</p>
<h3 id="成块的-10-分钟发生了什么"><a href="#成块的-10-分钟发生了什么" class="headerlink" title="成块的 10 分钟发生了什么"></a>成块的 10 分钟发生了什么</h3><p>在一个区块生成以前，网络中可能存在大量的交易，也没人决定哪一些交易应该进入下一个区块（mempool）。这些交易中，有一些是无效的，因此需要节点检查；有一些没有交易费，节点需要决定是不是无偿处理这些交易；还有一些交易不能同时为真，比如双花的交易，节点需要选择哪一个作为合法交易等等。</p>
<p>因此，根据当前的交易，其实可以形成无数多个合法的区块，但是没有人应该决定哪一个才是对的，因为就没有对错可言（当然，不合法的交易是不行的）。不同的区块可能对不同人的收益是不一样的。</p>
<p>矿工（节点）可以有意识的拒绝认证他的“敌人”的交易，或者他也可以无私的接受没有交易费的交易，因为他认识交易人。当然他也可以作弊，比如双花。他先向某人购买商品，然后之后把同一笔钱转给另一个人，然后只验证后一笔交易。</p>
<p>有无数多的理由可以让矿工按照自己的目的操纵比特币区块链，但是网络需要共识才能运行，但是网络不需要对某一个特定的目的达成共识。比特币的方案就是通过 PoW 为区块提议增加成本，这样增加了作弊的成本。一旦新的区块提案出现，矿工可以选择接受提议，或者坚持自己的提议。接受是一个合理的选择，是一种自然共识，因为如果下一个幸运儿是他自己，那么他提出的区块可以被以相同的想法接受；不接受相对比较冒险，因为他要说服其他人接受他的观点。</p>
<p>原则就是：第一个被挖出的区块不包含个人喜好，因为 PoW 可以确保第一个发现的人是随机产生的。<strong>换句话说，在 PoW 协议中，第一个发现区块的人只能是因为运气。</strong> 而不是别的什么。因此，任何不接受该区块的行为都是很值得怀疑的。</p>
<h2 id="“不利条件原理”"><a href="#“不利条件原理”" class="headerlink" title="“不利条件原理”"></a>“不利条件原理”</h2><p>你可能也发现了 PoW 之所以可以帮助达成共识似乎并不是基于计算机原理，而是人或者社会学原理。</p>
<p>不利条件原理，Handicap Principle，可以用来解释 PoW 达成共识的原理。不利原理其实是一个生物学的概念，这个原理说，当两只动物有合作的动机时，他们必须很有说服力地向对方表达善意。为了打消对方的疑虑，他们向对方表达友好时必须附上自己的代价，使得自己背叛对方时不得不付出昂贵的代价。<br>即，表达方式本身必须是对自己不利的。</p>
<p>不利原理其实为囚徒困境提供了一个解答。囚徒困境的基本结论是：个体做出理性判断会导致集体非理性。造成这种困境的主要原因是，个体之间无法确认对方可以选择合作。不利原理就可以解决这个问题，我们只需要做一些事情证明我们愿意合作，或者证明背叛的代价比合作更大！</p>
<p>假设两个囚犯有机会与检察官在一起一段时间，其中一名对博弈论特别了解的囚犯对检察官说，“如果另一个囚犯有罪，那么我也同样有罪。”这个声明对他自己来说是一个明显的代价，因为它消除了他在其他囚犯合作时叛逃的能力。然后另一名囚犯可以选择重复陈述。如果他不这样做，那么他知道第一个囚犯唯一可行的选择是叛逃，但如果他这样做了，那么两个囚犯都可以合作。</p>
<p><strong>这就是障碍原则。</strong></p>
<p>其实，有人认为正是这种障碍原则，解释了道德和利他主义。</p>
<p>因为，比特币的 PoW 协议不应该被作为一种资源的浪费或是某种达成共识的黑魔法。他是一种非常自然且有用的通讯协议。当一个分布式系统由一个组织控制，那么系统中的所有节点都是诚实的，PoW 是无意义的。但是比特币网络不是这样的，因此为了达成共识，需要 PoW 协议。</p>
<p>障碍原则在互联网其实非常有意义，因为互联网的绝大部分节点都是自私的（人）。如果电子邮件需要工作量证明，那么我们可能不需要花钱去研究如何过滤垃圾邮件；通讯协议如果需要工作量证明，DDOS （分布式拒绝服务攻击）攻击可能不会存在。</p>
<p>比特币的工作量证明就可以类比成利他主义，或者囚徒的声明。生成区块的计算能力代表了一种实力，但是即使有如此能力，也同意认可社区已经产生的第一个区块就是一种利他和无私的表现。</p>
<p>说一千道一万，共识本身就是需要代价的。要么是信任第三方的协调，要么是障碍原则。信任第三方协调的优势是效率，劣势是第三方可能不道德；障碍原则的优势是不需要第三方，因此也不需要承担信任的风险，劣势是需要能量证明。</p>
<h2 id="阳光下没有新鲜事：PoS"><a href="#阳光下没有新鲜事：PoS" class="headerlink" title="阳光下没有新鲜事：PoS"></a>阳光下没有新鲜事：PoS</h2><blockquote>
<p>所罗门皇帝的名言：阳光下面没有新鲜事。</p>
</blockquote>
<p>没有 PoS 的 PoW 讨论是不完整的！但是今天我们不说 ETH 2.0，我们来说说一个已经无人问津的币：<a href="https://www.peercoin.net/">PPCoin</a>。</p>
<p>PPCoin 于 2012 年启动，是第一个提出并实现 PoS 的点对点加密货币实现<a href="https://decred.org/research/king2012.pdf">^pp</a>。这可以算是 PoS 的鼻祖了，有意思的是，作者们提出 PoS 的时候并没有放弃 PoW，他们在白皮书中这样写道：</p>
<blockquote>
<p>我们使用 PoS 作为网络的安全模型，但是使用 PoW 作为初始代币分发模型，并且逐步降低 PoW 的重要性。</p>
</blockquote>
<p>作者的愿景非常好，而且他们也充分意识到了 PoS 协议的问题：初始代币分发。在 PPCoin 的 PoS 协议中，节点不是跟随算力最多的节点，而是投资该代币最多的节点。每一个 PPCoin 的矿工生成新块后都会失去一些老币，得到一些新币，这也意味着这次出块的节点，下一次很可能不会出块。</p>
<p>工作量证明和权益证明在不同情况下具有不同的成本和收益。根据障碍原则，产生信号的成本必须与信息的含义相关。股权证明系统展示了对硬币本身的投资，而工作证明系统展示的是底层网络中的工作量。</p>
<p>所以，如果两个网络的市值相同，PoW 网络容量更大、流动性更好，但是价格波动也更大；而 PoS 网络的价格稳定性更好。PoW 网络依靠的是：矿工难以说服其他人跟随他，来对抗不诚实的节点；而 PoS 基本上只接受对网络友善的节点的贡献来对抗不诚实的节点。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这篇随想就到这里把，关于 PoS 的讨论可能有点过于简单了，不过以后我可以给大家讲讲 PPcoin 的白皮书，扒一扒 PoS 的源头<a href="https://decred.org/research/king2012.pdf">^pp</a>。</p>
<blockquote>
<p>本文部分内容翻译：<a href="https://nakamotoinstitute.org/mempool/the-proof-of-work-concept/">https://nakamotoinstitute.org/mempool/the-proof-of-work-concept/</a>. 并非全部原创。</p>
</blockquote>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 诸多身份？</title>
    <url>/2022/06/01/thinking_bitcoin_6/</url>
    <content><![CDATA[<p>比特币的“身份”真的是太多了，不知道你有没有想过为什么他会有这么多身份？其实这个是一个很有意思的问题。今天的随想就跟大家分享讨论一下泛泛的想法。</p>
<h2 id="七七八八的身份"><a href="#七七八八的身份" class="headerlink" title="七七八八的身份"></a>七七八八的身份</h2><p>不同的背景的人或者群体会给比特币不同的“身份”，但是我不觉得每一个身份都是对的，比如：</p>
<ul>
<li>电子现金（注意不是货币），这是中本聪最初的定义</li>
<li>货币，这个身份最常见，也最质疑</li>
<li>价值存储，这个身份是最近几年开始流行的，真的吗？</li>
<li>商品，类似黄金一样的稀有商品</li>
<li>金融产品，或者说叫 Security，类似股票</li>
<li>骗局、泡沫、诈骗</li>
<li>一个有趣的去中心化系统</li>
<li>陈旧的区块链技术</li>
</ul>
<p>更有意思的是，这些身份并不是同时出现的，而且各方声音也是此消彼长。这是为什么呢？我觉得两个主要原因：</p>
<ul>
<li>不同背景的人会自然的在自己的知识体系中诠释它</li>
<li>他太独特，也太年轻（13岁），目前无法准确的把它归类，因为没人知道他究竟什么</li>
</ul>
<p>其实这两个原因是相互联系的，正是因为比特币太独特，没人确切的是知道他到底是什么，就会自然根据自己的领域进行分类。比如，脸书出一款聊天软件，大家应该比较轻松的把他归到社交软件的类别，因为聊天软件可能有某种创新，但是人们比较清晰的知道社交媒体软件的特征；相反，如果是一个全新的东西出现（比特币不能算全新，他的两个技术基础：数字签名和工作量证明算法，已经存在很久了），人们往往会经历一个迷茫期，慢慢发现他的身份。</p>
<p>其实从另一个角度说，一个东西的身份或者意义也是人在跟该事物互动的过程中慢慢建立起来的。当然，诸多身份对于比特币来说是非常有利的，这说明它是一个独特且重要的存在，否则不会有人愿意为此争辩；说明他可能是一个影响深远的存在，你越摸不透他，它的潜力越大。一个被时代一眼看穿的事物，很难掀起波澜。</p>
<h2 id="一个一个说"><a href="#一个一个说" class="headerlink" title="一个一个说"></a>一个一个说</h2><p>了解背后的原因，我们就可以知道分析比特币有上面这些身份，以及是否合理。</p>
<h3 id="电子现金（A-Peer-to-Peer-Electronic-Cash-System）还是货币？"><a href="#电子现金（A-Peer-to-Peer-Electronic-Cash-System）还是货币？" class="headerlink" title="电子现金（A Peer-to-Peer Electronic Cash System）还是货币？"></a>电子现金（A Peer-to-Peer Electronic Cash System）还是货币？</h3><p>电子现金系统是比特币的缔造者中本聪赋予比特币的身份，中本聪虽然是个匿名者，但是我们依然可以知道他（或者他们）的背景：他混迹于计算机密码学社区，熟悉C++，还了解一些股票市场的交易细节（参考白皮书第十节，他用股票交易的信息披露类比比特币）。总体来讲，它看起来像一个典型的务实工科男，所以他对比特币的诠释也符合他的身份：一个点对点电子现金系统。</p>
<p>我觉得这个身份拿到 13 年后的今天也是合理的定义，因为它是从软件实现角度谈论的，13 年的时间比特币的软件实现有了很多变化，但是是始终没有脱离中本聪的设计蓝图。而且，试图改变蓝图的动作几乎都失败了。其中讨论最多的就是块的大小、出块速度等等，主流社区终究没有通过这些改变，而执意改变的结果就是 Bitcoin Cash 和 Bitcoin SV 等等这些至今已经毫无影响力的硬分叉。现在，比特币公链仍然是 13 年前的公链，出块速度、大小、2前一百万等等。</p>
<p>这里的电子现金跟货币似乎不一样的，我说似乎，是因为货币的定义就不是很清楚。中本聪这里对电子货币的意义却明确：请你忽略电子货币这几个字，中本聪对比特本身的定义是：一个数字签名组成的链（参考白皮书交易记录一节）。换言之，比特币是一串交易记录，仅此而已。不过这串交易记录有个特性：所有权可以被验证；交易历史不能被篡改（或者说篡改的代价巨大以至于明智的人不会去做）。</p>
<p>虽然货币有很多定义，但是绝对没有一种是上述的定义。<strong>所以，我认为比特币不是货币。但是他的特性似乎有充当货币的能力</strong>。 有能力做货币，不代表他是货币，我们刚才也说了，人们其实还在摸索比特币就是什么，也许有一天他会被人们用作货币，又或是别的什么东西。</p>
<h3 id="价值存储和商品？"><a href="#价值存储和商品？" class="headerlink" title="价值存储和商品？"></a>价值存储和商品？</h3><p>另一种观点是：比特币属于商品。说到商品，就要提到与之相联的另一个身份：价值存储。说到价值存储，就要提到稀缺性。因为大部分的共识是：只有稀缺，才可以存储价值，或者说才会更有价值。</p>
<p>比如，很长的一段时间人们认可黄金作为价值存储。但是黄金不是存粹的价值存储，它有自己的商业属性，比如珠宝啊等等，换句话说，他有商品的属性。在有些落后闭塞的地方，人们曾经用贝壳存储价值，但是外来入侵者带来了茫茫多的贝壳，贝壳就无法再作为价值存储了，因为丧失了稀缺。</p>
<p>继续深入稀缺，什么是真正的稀缺呢？贵金属？贝壳？都不是！事实上《货币未来》一书的作者提到了一个有意思的观点：真正稀缺的只有人类的时间。任何物理材料都不可能是稀缺的，因为人们总是可以花时间开采更多，其实稀缺的是矿工开采金矿消耗的时间！</p>
<p>说回比特币，比特币协议把一个数字化的稀缺性写入了代码，然后扩散到每个全节点（目前 15000 +），通过越来越多的运行同一个协议的节点，比特币确保协议不会变更，进而确保稀缺性。通过工作量证明消耗的能源，不断为比特币注入价值（证明不是垃圾邮件）。</p>
<p>换句话说，从这个角度看，比特币与黄金有个不同，就是比特币没有商品属性，只有稀缺。</p>
<h3 id="金融产品和骗局？"><a href="#金融产品和骗局？" class="headerlink" title="金融产品和骗局？"></a>金融产品和骗局？</h3><p>比特币还有一些金融属性。这主要是人们自发的愿意用美金来标定比特币的价值（价格），因此比特币产生了金融属性，人们开始把他做一个金融资产进行交易。</p>
<p>但是，比特币又不是一般的金融资产，因为他不是股票、不是外汇、不是国债。为什么不是？因为比特币没有对手风险。</p>
<h3 id="技术革命？？"><a href="#技术革命？？" class="headerlink" title="技术革命？？"></a>技术革命？？</h3><p>比特币似乎还引领了一些技术上的激情，媒体倾向把比特币身后的技术成为区块链技术。冷静下来看看，比特币本身并没有技术上重大突破，而且中本聪的白皮书中并没有给这项技术命名为区块链技术，他甚至没有提及比特币是某种新技术，他巧妙的组合了但是已经比较成熟的两个技术：公钥密码学（数字签名）和工作量证明。</p>
<p>公钥密码学正式诞生于 1976 年，工作量证明算法是基于一篇来自 2002 年的<a href="http://www.hashcash.org/papers/hashcash.pdf">论文</a>。其中工作量证明这篇论文非常也有意思的，他的提出是为了杜绝垃圾邮件问题，因为互联网上生产信息的成本太低了，为了解决这个问题，作者提出为邮件设置一个成本函数，即证明自己花费一定的 CPU 资源后服务器才接受该邮件。我觉得，这就是为信息注入价值的方式，用来证明这段信息不是垃圾，因为我愿意为他付出代价。（有意思的是，上个世纪 90 年代人们就开始与<a href="https://dl.acm.org/doi/10.5555/646757.705669">垃圾邮件作战了</a>，至今也没取得胜利。。。）</p>
<p>可以看出，比特币本身是一个优秀的工程产品，他的目的也十分明确：实现无第三方点对点交易，且避免双花问题。如果把公钥密码学加工作量证明作为一项新技术（区块链技术），那么这项技术的目的性也是相对明确的。比特币可能点燃了技术革命，但是它本身也许不是。不过我不觉得这是一件坏事，比特币显然是精心设计来实现他的目的的，而不是为了某种技术革命，因此它选用了成熟的技术作为实现。</p>
<p>但是，比特币设计的实现对于推动整个区块链社区有着不可磨灭的作用。比特币的 C++ 实现 2009 年正式上线，而点燃后来区块链技术的却是该实现中的 Script 功能。我个人觉得这个功能真的是太巧妙了！用现在的时髦的词汇说，Script 就是现在的智能合约。</p>
<p>比特币推出 6 年后，以太坊出现了。它相对比特币做出的重大改变是“增强”了智能合约可以做的事情，把比特币智能合约升级成图灵完备。说简单一些就是给智能合约增加了跳转指令，是的，就是这么简单，一个指令。但是这个指令引爆了区块链社区，也是噩梦的开始。</p>
<p>我不想展开了，但是这个跳转指令是导致以太坊被黑硬分叉的罪魁祸首，新公链 Solana 两年掉线5 次的罪魁祸首。我只能说，中本聪不傻，以他对栈机和Script的了解，他不会不清楚增加一个跳转指令可以做成图灵完备，所以他选择了图灵不完备，事实也证明了，比特币 13 年从未离线。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这仍然是一篇随想，讲的有点散，因为至今我也说不清比特币是个什么东西，这也是我为之着迷的原因。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 从数字签名到信任</title>
    <url>/2022/05/29/thinking_bitcoin_5/</url>
    <content><![CDATA[<blockquote>
<p>长话短说： </p>
<ul>
<li>比特币通过数字签名，把归属权问题从信任问题（高成本）变成了验证问题（极低成本）。</li>
<li>比特币通过工作量证明，把排序和维持不变的问题从信任第三方（不稳定且变数多）变成了信任能源消耗（稳定且标准）。</li>
</ul>
</blockquote>
<h2 id="起起伏伏的密码学"><a href="#起起伏伏的密码学" class="headerlink" title="起起伏伏的密码学"></a>起起伏伏的密码学</h2><p>密码学最辉煌的世代可能是二战的时代（很不幸），战争把人类的通讯推向了密文时代，如何把一段信息从 A 传送给 B，并且不泄漏给第三方成了极为关键的问题，因为泄漏信息的代价可能是战争的失败。</p>
<p>二战结束后，密码学仍然很重要，但是转为地下，而且继续主要为军事目的服务。毕竟，普通人能有什么不能告人的秘密呢（笑）。</p>
<p>然而，90年代，互联网的出现再一次把密码学推向了风口浪尖！人们在互联网互动、娱乐、支付、交易，突然间普通人的信息也很重要了，人们可不希望自己的银行秘钥因为一次晚上交易就被盗，或者误认为一个黑客网站是他的银行网站。</p>
<p>但是，密码学虽然成为了互联网的主要部分，密码学本身却还只是在一个小圈子里，比如学术圈和一些互联网的极客，毕竟普通人不需要知道信息论，也不需要知道如何分解质数也可以上网购物。</p>
<p>然而，2009年一切都变了，一个匿名者：中本聪，在圈子里发布了一个名为比特币的点对点支付网络的提案。从那以后，民用领域最值钱的密码学产品诞生了：比特币。如今，你可以用 2 个比特币在村里买一栋不错的别墅。</p>
<h2 id="数字签名-如何证明你发出这段比特"><a href="#数字签名-如何证明你发出这段比特" class="headerlink" title="数字签名 - 如何证明你发出这段比特"></a>数字签名 - 如何证明你发出这段比特</h2><p>比特币的基石之一：数字签名（Digital Signature）。数字签名可以干什么呢？</p>
<p>咱们说，小明电脑里面有个文件，文件包含：小明给小红 40 元。现在小明把这份文件公开在网络，但是小明希望小红可以确认这文件的内容真的是小明本人发出的，因为互联网的特性，任何人都可以创建一个文件，然后写上：小明给小红 40 元，甚至写上：小明给小红 400 元。如此一来，小明岂不是成了冤大头，背上巨额债务？</p>
<p>小明有两个选择：回到原始时代，写一封信给小红，然后签字画押；寻找一个大家都信任的第三方，证明这段信息是小明本人发出的，并且存留档案以后后续查阅。然鹅，这两个方案都不太理想，因为即使是签字画押也需要司法系统来背书，总之非常低效，与互联网时代格格不入。</p>
<p>非对称密码学给出了答案。现在有一个办法让小明可以把这份文件公开在网上，并且小红可以验证这真的是小明发出的，而且其他人却不能伪造这份文件，即使这份文件只是一串比特而已。很神奇不是吗？</p>
<p>以下是小名的做法：</p>
<ol>
<li>准备两个整数，一个秘密的，d；一个公开的，e （咱们先不说怎么准备，这是数学家们的事情），只需要知道这是两个双生的数字，相互关联，是成对出现的</li>
<li>把 e 公开在网上，告诉大家：嘿！这是我的公钥，你们可以通过他来验证信息是不是我写的</li>
<li>用 d 对那份文件的比特进行操作（没错，程序员负责这里，不是你）得到另一个整数，sig。这个 sig 就是所谓的数次签名了</li>
<li>小明公开了他的文件，同时也公开了这个签名。然后告诉大家：嗨！这是我写给小红的信息，你们都来看看！哦对了，这是这份信息的签名，你们可以用之前的整数 e 来验证这信息确实是我写的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">magic_number &#x3D; h(e, d) &lt;-- e 和 d 是相关的，但是不同的</span><br><span class="line">sig &#x3D; f(m, d)   &lt;-- 签名就是用 d （私钥） 处理信息后，得到的一串比特</span><br><span class="line">m &#x3D;？g(sig，e) 验证就是用 签名 sig、公钥 e 计算后得到数字跟信息源比较，对上了就验证成功</span><br></pre></td></tr></table></figure>

<p>如此，小明就证明了信息的所有权。公钥密码学精妙的地方在于：咱们假设签名的信息是 m，即使m，e 和 sig 都是公开的，而且 sig 是根据 m 和 d 计算得到（没有任何随机性哦，确定的函数），黑客也无法轻易获得小明的私钥，d！奇妙的是，任何人都可以通过<br>m，sig，和 e 验证信息是否属于生成 e 的私钥 d，即小明！</p>
<p>但是这里有两个问题：</p>
<p>d 是秘密的，只有小明一个人知道。但是如果 d 被泄露，任何人都可以伪造小明的身份发言。在缺乏第三方的时候，你不是你，你的私钥就是你。所以比特币圈子有个名言：不是你的私钥，不是你的币！</p>
<p>另外，我们说小名公开了自己的公钥，e，但是 <strong>我们如何相信 e 属于小名呢？</strong>。当然这个问题对比特币来说不重要，以为没有任何动机发布一个错的公钥。但是这个问题对于整个互联网安全却至关重要，为了解决这个问题甚至诞生了一个产业：证书颁发机构！基本上这就是一个被大众信任的第三方，用来确保公钥背真的是公钥应该的主人。</p>
<h2 id="数字签名和比特币"><a href="#数字签名和比特币" class="headerlink" title="数字签名和比特币"></a>数字签名和比特币</h2><p>比特币的基础之一正式数字签名。比特币网络协议正式通过数字签名的方式证明交易记录的所有权的。正如刚才的例子，通过数字签名，小明证明了他发出了那段信息，同样，比特币交易的所有权也是通过数字签名的保证的。</p>
<p>中本聪甚至在白皮书中这样定义比特币：我们将电子货币定义为：一串数字签名。所以，下次别人再问你比特币是啥，你就告诉他，比特币是一串数字签名！</p>
<p>我们常说的比特币地址，就是上文例子中的，e，也叫公钥。这么说不全对，因为比特币地址跟私钥，d，的关系并不是一一对应的，而是一个私钥控制多个地址。但是道理一样，我们把地址理解公钥的作用就好了。</p>
<p>而我们常说的钱包，其实就是私钥，d，就是那个你不能告诉别人的秘密数字！这么说也不全对，钱包的核心是私钥，但是钱包本身通常是套用来帮助你与比特币网络互动，但是只要你有私钥，e，你甚至可以直接编程与比特币网络互动，不需要钱包软件帮助你；同样，没有私钥，e，钱包什么也做不了。</p>
<h2 id="信任在哪里"><a href="#信任在哪里" class="headerlink" title="信任在哪里"></a>信任在哪里</h2><p>正如公钥密码学把终极问题推向了信任，对公钥的信任；<strong>整个比特币网络也需要信任，这可能跟媒体的宣传不符</strong>，比特币难道不是去中心化网络吗？不需要信任吗？哈哈，对也不全对。</p>
<p>比特币通过工作量证明去除了对第三方机构的信任，可以有效避免双花。但是比特币终归是交易系统，交易，或者说交流最终都要归于信任！只不过，比特币的工作量证明，有意或者无意的把信任推给了能源！</p>
<p>我们为什么相信比特币区块链记录的信息呢？因为每条信息都需要矿工花费电力和CPU资源，换句话说，每天信息都有能源背书，有巨大的成本。这就是我们信任的基础！</p>
<p>因为有了公钥密码学（数字签名）我们不需要<strong>信任</strong>交易的归属权，我们只需要<strong>验证</strong>归属权；但是关于交易还有一个重要的概念就是顺序和不可变性。试想，如果我今天付给你的钱，明天单方面反悔怎么办？你肯定会起诉我，让我付出代价对吧？但是这时我把信任放在了第三方仲裁机构上。</p>
<p>比特币网络通过工作量证明，巧妙把排序和惩罚连接到了能源消耗上，我把信任放在能源的消耗上。只要作弊的经济收益小于作弊的成本，就没有理由作弊。</p>
<h2 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h2><p>比特币通过数字签名，把归属权问题从信任问题（高成本）变成了验证问题（极低成本）。</p>
<p>比特币通过工作量证明，把排序和维持不变的问题从信任第三方（不稳定且变数多）变成了信任能源消耗（稳定且标准）。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - Altcoin 去哪了？</title>
    <url>/2022/05/27/think_bitcoin_3/</url>
    <content><![CDATA[<p>币圈历史不长，从2009年（比特币上线哪一年）算起不太合适，因为那时候还没有所谓的币圈。咱们就从2013年开始算吧，哪一年比特币第一次减半。</p>
<p>首先我们看看过去的10年时间，币圈前十币。</p>
<h2 id="Top-10-2013-2020"><a href="#Top-10-2013-2020" class="headerlink" title="Top 10 (2013 - 2020)"></a>Top 10 (2013 - 2020)</h2><p>比特币一直都是第一，我贴一个 Bitcoin Dominance 的图，这图代表了比特币市值在整个币圈市值的比例。可以看到有一个有意思的现象，比特币一直占据了50%左右的份额。</p>
<p><img src="https://i.imgur.com/lFSvWCa.png" alt=""></p>
<p>但是，如果我们在看历年前十的币，我们就发现一个现象：</p>
<blockquote>
<p>铁打的比特币，流水的Altcoin。</p>
</blockquote>
<p>牛市来了，Altcoin大涨；熊市来了，Altcoin大跌；牛市来了，新的Altcoin大涨，之前的一些币就说拜拜了。</p>
<p>一般这些币撑不住 5 年，比如来特币，2013年还是第二，2016年已经部件踪影了：</p>
<p><img src="https://i.imgur.com/HLnU1Tt.png" alt="LTC vs BTC"></p>
<p>还有一些币呢，如果我们看长期对 BTC 的价值，他们绝大多数都在走下坡路，比如 XRP，虽然现在还在排行榜，但是对比特币已经跌破发行价了。即使是以太坊，似乎也无法再创新高了。</p>
<p><img src="https://i.imgur.com/ykuZ7qu.png" alt=""></p>
<p><img src="https://i.imgur.com/AE8A98V.png" alt=""></p>
<p><img src="https://i.imgur.com/TPSm7pp.png" alt=""></p>
<h2 id="历年-top10-截图"><a href="#历年-top10-截图" class="headerlink" title="历年 top10 截图"></a>历年 top10 截图</h2><p><img src="https://i.imgur.com/YgEruca.png" alt="2013"></p>
<p><img src="https://i.imgur.com/JgCTPXi.png" alt="2014"></p>
<p><img src="https://i.imgur.com/vtB1UBt.png" alt="2015"></p>
<p><img src="https://i.imgur.com/kL8oVTY.png" alt="2016"></p>
<p><img src="https://i.imgur.com/oagHoe8.png" alt="2017"></p>
<p><img src="https://i.imgur.com/aZTcatj.png" alt="2018"></p>
<p><img src="https://i.imgur.com/USIyap2.png" alt="2019"></p>
<p><img src="https://i.imgur.com/0QEzMym.png" alt="2020"></p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>其实，市场会发现价值，即使有各种定价问题，但是终究会发现合理的价格。这既是为啥比特币的市值一直保持在大于 50%，一个币撑住币圈半边天。</p>
<p>关于比特币的价值请看：<a href="https://zhuanlan.zhihu.com/p/520555857">https://zhuanlan.zhihu.com/p/520555857</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=nXfAMzu7eZk&list=RDCMUCF31eojFKhWQJviyMICWO2w&start_radio=1">Your Altcoin Is Dying</a></li>
<li><a href="https://coinmarketcap.com/historical/">https://coinmarketcap.com/historical/</a></li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 白皮书译注</title>
    <url>/2022/05/27/thinking_bitcoin_4/</url>
    <content><![CDATA[<blockquote>
<p>它利用了信息易于传播但难以扼杀的特性。<br>—– 中本聪</p>
</blockquote>
<p>从技术角度看，比特币就是什么东西？比特币<a href="https://www.ussc.gov/sites/default/files/pdf/training/annual-national-training-seminar/2018/Emerging_Tech_Bitcoin_Crypto.pdf">白皮书</a>中提到：比特币在已有技术的基础上，解决了点对点网络的“双花”问题，及重复执行交易。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>一个点对点版本的电子现金应该实现点对点直接线上支付，而不需要金融机构介入。数字签名提供了部分解决方案，但是数字签名方案仍然需要依赖第三方来避免“双花”问题。这篇文章提出了一个利用点对点网络解决双花问题的方案。该网络通过将每笔交易哈希到一个不断增长的哈希工作证明链上，为其打上时间戳，这样修改一条记录的代价就是重新进行工作证明。最长的链不但证明了一些列有序的交易记录，也代表了他背后最大的CPU工作量（译者注：即电能）。只要主流的CPU工作量来自不会攻击网络的节点，他们就会生成最长的链并且抵御攻击。网络本身仅仅需要最基本的结构，信息广播基于最大努力，节点可以随时加入或者离开网络，当节点回到网络会使用最长的工作证明链作为基础。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>互联网经济依赖金融机构作为信任第三方来处理电子支付。对于大部分支付行为这个系统都可以胜任，但是它也继承了一些信任模型带来的缺点。比如因为金融机构无法避免仲裁行为，真正的完全不可逆交易并不能实现。仲裁也会提高交易费用、限制最小交易金额，不适合大量小额交易。（译者注：比特币网络并没有实现大量小额交易的目的，但是其二级网络闪电网络实现了该功能。）而且，无法对不可逆服务进行不可逆交易也有一定的成本。因为有回滚的风险，就需要信任。因此商家必须对他们的客户保持警惕，向他们索取比他们原本需要的更多信息。一定比例的欺诈也是不可避免的。这些成本和支付不确定性可以通过使用实物货币避免，但如今还不存在在没有受信任方的情况下进行支付的机制。</p>
<p>我们需要的是一个基于密码学证明的电子支付系统，而不是一个基于信任的系统，该系统可以让交易双方直接进行交易，而不需要信任第三方。从计算复杂度角度看，交易的不可逆性可以保护买家免于欺诈，通过常规托管机制（译者注：不理解到底什么意思）也可以保护买家。在这篇文章中，我们提出了一种解决双花问题的方法，该方法使用一个点对点的时间戳服务器生成交易时间顺序的计算证明。只要诚实节点控制的CPU算力超过不诚实的节点，系统就是安全的。</p>
<h2 id="交易记录"><a href="#交易记录" class="headerlink" title="交易记录"></a>交易记录</h2><p><strong>我们将电子货币定义为：一串数字签名。</strong> 电子货币的拥有者对前一个记录的哈希和目标拥有者的公钥进行数字签名，然后把这个数字签名添加到该货币的末端，这样就实现了货币的转移。被支付人可以通过验证支付人的签名来验证所有权链。</p>
<p><img src="https://i.imgur.com/UC35MD9.png" alt=""></p>
<p>虽然被支付人可以验证币的所有权，即支付拥有币，但是显然，被支付人无法证明支付人是否仅仅把币支付给自己一个人，即无法证明支付人是否双花。一般的办法是引入一个信任的第三方，或者叫铸币局，来验证每一笔交易是否双花。这样，每一笔交易后，币需要被返还铸币局，并发行一个新币，只有铸币局发行的货币是合法的并且保证没有双花问题。然而，这个方案最大的问题在于整个货币系统都会依赖铸币局，每一笔交易都要经过铸币局。换句话说，铸币局就是银行。</p>
<blockquote>
<p>译者：信任其实不可以被移除，而是转移。整个公钥密码学是强大的，如今整个互联网都依靠公钥密码学来实现秘钥传递和验证。公钥密码学解决了对称密码学的问题：私钥传递，但是问题变成了如何信任公钥？目前的解决方案跟银行差不多：CA，即证书机构。通过一个被信任的中心化组织分发信任的公钥。比特币系统其实把信任从银行转移到了工作证明，即最长公链消耗的能源。</p>
</blockquote>
<p>我们需要一个方法，让被支付人确认支付人之前没有为交易签名，即当前是支付人第一次为这个交易签名。因为，我们只在乎最早的交易，而不是后续的双花问题。确认交易没有发生唯一办法就是查验之前所有的交易。在铸币局方案中，铸币局知晓所有的交易，因此可以确定顺序。在没有第三方的情况下实现这一目的的方法就是将交易广播<a href="http://www.weidai.com/bmoney.txt">^1</a>。因此我们需要一个系统来保证所有的参与者可以认可一个唯一的历史记录。被支付人需要证明在交易发生的时刻，绝大多数节点认可该笔交易第一次发生。</p>
<h2 id="时间戳服务器"><a href="#时间戳服务器" class="headerlink" title="时间戳服务器"></a>时间戳服务器</h2><p>我们提出的方案首先需要一个时间戳服务器。时间戳服务器首先拿到一个准备加时间戳的区块的哈希值，然后广播这个哈希值，就好像报纸或者 Usenet<a href="https://www.anf.es/pdf/Haber_Stornetta.pdf">^2</a>。时间戳可以证明数据在当时是存在的，这样他的哈希值才可能写入。每一个时间戳包含了前一个时间戳的哈希，这样就形成了一个链，后面的每一个时间戳都包含前面所有时间戳的部分信息。</p>
<p><img src="https://i.imgur.com/uGX4F10.png" alt=""></p>
<h2 id="工作证明"><a href="#工作证明" class="headerlink" title="工作证明"></a>工作证明</h2><p>为了实现一个基于点对点网络的分布式时间戳服务器，我们需要一个类似 Adam Back 的 Hashcash <a href="http://www.hashcash.org/papers/hashcash.pdf">^4</a> 中的工作证明系统，而不是报纸或者 Usenet。工作证明会检查哈希值（比如 SHA-256）是不是以若干 0 比特开头。找到这样一个哈希的平均时间与需要 0 比特的位数呈指数关系，但是验证过程只需要执行一次哈希算法。</p>
<p>为了实现上一节提到的时间戳服务器，我们通过一个区块中递增的整数（nonce）实现工作证明，直到找到一个整数刚好使区块的哈希值以若干 0 比特位开头。一旦已经花费了CPU算力得到了满足工作证明的哈希，这个区块就无法被改变，除非重做工作证明（译者：即重新投入一次CPU资源）。</p>
<p><img src="https://i.imgur.com/Ki3KoZD.png" alt=""></p>
<p>工作量证明解决了在多数决策中确定代表的问题。如果多数决策采用“一个地址一票”的方式，任何掌握多个 IP 地址的组织都可以破坏规则。工作量证明本质上是“一个CPU一票”。（译者：其实不完全是，本质上是一度电一票，这就是物理世界和数字世界的连接点）多数决策的代表就是最长的工作量证明链，也就是投入工作量最多的链。如果大部分的 CPU 资源被诚实节点控制，诚信的链就会变得最长且可以抵御攻击。为了修改一个区块，黑客需要重做该区块的工作量证明以及改区块后续的所有区块的工作量证明，并且追赶且超过诚实的节点。我们后面会证明，一个慢的黑客实现这种攻击的成功几率会随着诚实链的增长成指数级降低。</p>
<p>为了应对硬件速度和节点数量的增加，工作量证明的难度（译者：即 0 比特的位数）会随着出块时间进行调整。基本上确保网络每小时出相同多的区块（译者：6个每小时）。如果区块增加速度过快，难度会相应提升。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>运行比特币网络的步骤如下：</p>
<ul>
<li>新的交易被广播到所有节点（译者：尽可能多的）</li>
<li>每个节点（译者：矿工）选择准备打包新区块的新的交易</li>
<li>每个节点（译者：矿工）开始工作量证明（译者：即寻找整数）</li>
<li>当一个节点发现了整数，它会把这个区块广播到所有节点（译者：尽可能多的）</li>
<li>节点（译者：全节点？还是矿工）会检查新快的所有交易是不是合法以及是否存在双花，一切正常就接受该块</li>
<li>节点（译者：矿工）接受新区块后会在此块基础上继续工作量证明</li>
</ul>
<p>节点永远采纳最长的链作为“正确”的链，并且在此基础上继续增加区块。如果两个节点同时（译者：延迟意义上的）广播了不同的区块，有些节点会接受前一个，有些则接受后一个。这种情况下，他们会在第一个接受的链上工作，并存储第二个链，以备第二个链变得更长时，以第二个链作为基础工作（译者：就是舍弃之前工作的链）。这种僵局一般会在新的区块被发现，导致某个链变得更长时打破；所有再短链上工作的链都会转向新的更长的链。</p>
<p>新的交易记录不必广播到所有节点，只要他们可以被送达一些节点即可，不久他们就会被加区块。区块的广播也对信息丢失不敏感。如果一个节点没有接到区块，他会请求区块，当他收到新的区块后，就会发现之前错过的区块。</p>
<h2 id="激励"><a href="#激励" class="headerlink" title="激励"></a>激励</h2><p>按照惯例，每个区块的第一个交易记录是一个特别的交易（译者：Coinbase），这个交易的拥有者（译者：第一个拥有者）是这个区块的创建者（译者：即成功破解工作量证明的地址）。这样就提供了节点运行而维持网络的激励，并且提供了初始的代币分发，因为比特币网络没有中心机构决定代币的分发（译者：太美妙了）。这种持续的代币增发机制类似有金矿，金矿会投入资源开采更多的黄金加入流通。比特币网络中，CPU 时间和电力就是开采的成本。</p>
<p>另一个激励机制就是交易费。如果一个交易的输出比输入小，差价就是交易费，该交易费就会被包含在包含该交易的区块中。一旦所有预订的代币全部进入流通（译者：2千1百万），交易费将会是唯一的激励机制。换句话说，代币没有通胀问题（译者：通缩这么办？）。</p>
<p>激励机制鼓励诚实的节点。如果一个贪婪的黑客聚集了比诚实节点更多的 CPU 资源，他需要选择作弊，或者成为诚实的节点获取区块奖励（译者：coinbase 或者 交易费）。他应该发现遵守规则更有利可图，这些规则使他获得的新硬币比其他人的总和还要多，而不是破坏系统和他自己财富的有效性。</p>
<h2 id="回收硬盘空间"><a href="#回收硬盘空间" class="headerlink" title="回收硬盘空间"></a>回收硬盘空间</h2><p>在不运行全节点的情况，我们也可以验证支付。用户只需要存储最长工作量证明链的区块头信息，该信息可以通过查询网络中的其他节点获得，知道它确认自己拿到了最长的链。然后，他可以获得 Merkle 分支（译者：Merkle 是一种数据结构），该分支连接了这笔交易和他被加入时间戳的区块。他不能查看自己的交易，但是通过上述连接，他可以看到网络中有节点已经接受了他的交易，然后他可以查看最长公链后续的区块来确保网络已经确认了他的交易。</p>
<p><img src="https://i.imgur.com/DVpudtX.png" alt=""></p>
<p>只要诚实节点控制网络，他就是可以确认这个验证是有效的，但是这种验证会相对不可靠，如果网络被黑客的节点控制。虽然网络节点可以自己验证交易，但只要攻击者能够继续控制网络，这种简化的方法就会被攻击者伪造的交易所欺骗。防止这种情况的一种策略是在网络节点检测到无效块时接受来自网络节点的警报，提示用户的软件下载完整的块并警告交易以确认不一致。当然，运行自己的节点是实现更独立的安全性和更快的验证的最佳方案。</p>
<h2 id="组合与拆分"><a href="#组合与拆分" class="headerlink" title="组合与拆分"></a>组合与拆分</h2><p>尽管我们可以独立地处理每一个代币，为每一笔交易创建一个记录也是不明智的。为了实现交易的组合和拆分，一个交易记录可以包含多个输入和输出。一般情况下，通常会有来自较大先前交易的单个输入或组合较小金额的多个输入，并且最多两个输出：一个用于支付，另一个将零钱（如果有的话）返回给发送者。</p>
<p><img src="https://i.imgur.com/ZbNMdOT.png" alt=""></p>
<p>需要注意的是，扇出（fan-out）并不是问题。一个交易依赖于多个交易，而这些交易依赖于更多交易。因为我们不需提取交易历史的完整独立副本。</p>
<h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>传统银行是通过控制信息的访问权限实现隐私的。尽管比特币网络会广播所有的交易，仍然可以保证隐私。因为公钥是匿名的。大众可以看到一个地址向另一个地址转账，但是这笔交易不会跟任何人产生联系。这跟股票交易所的信息披露有些像，每笔交易的时间和大小都会被记录并且公开，但是不会公开交易双方的身份。（译者：有意思，中本聪似乎了解股票市场的运作）。</p>
<p><img src="https://i.imgur.com/buymzsO.png" alt=""></p>
<p>另一个保护隐私的方法：每一笔交易都可以使用一个新的钥匙对（译者：公钥跟私钥），这样就无法把这些交易联系到同一个人。当然，对于多输入交易，一些联系是无法避免的，因为输入的持有人可能会泄漏一些信息。风险在于，如果一个人的公钥与身份链接泄漏，可能会影响该持有人后续交易的隐私性。</p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>现在我们假设一个攻击者试图更快的生成一条不同于诚实链的链。即使这种情况发生了，也不会让系统面临一些随机的变化，比如凭空创造一个代币或者获取从来不属于攻击者的代币。节点（译者：全节点）不会接受非法交易记录，诚实节点也不会接受包含这样交易的区块。攻击者只能改变自己的交易记录，收回他之前支付的代币。</p>
<p>攻击者节点和诚实节点之间的竞争可以用 Binomial Random Walk 模型模拟。诚实节点成功添加一个区块，增加 +1；或者攻击者节点增加一个区块，-1。</p>
<p>攻击者成功修改记录并且赶上诚实链的几率与赌徒的破产问题（译者：一个拥有有限赌本的赌徒玩一场公平的游戏（即每次游戏双方的期望值都是零），在一个拥有无限赌本的对手面前，最终将破产。）类似。攻击者节点赶上诚实节点的概率计算如下：</p>
<ul>
<li><p>$p$ 诚实节点找到下一个区块的概率</p>
</li>
<li><p>$q$ 攻击者节点找到下一个区块的概率</p>
</li>
<li><p>$q_z$ 攻击者节点赶上诚实链的概率</p>
</li>
<li><p>$q_z = 1$ 如果 $p &lt;= q$</p>
</li>
<li><p>$q_z = (q/p)^z$ 如果 $p &gt; q$</p>
</li>
</ul>
<p>我们应假设 p &gt; q，攻击者追赶诚实链的几率呈指数下降。在对攻击者不利的情况下，如果他没有足够幸运，那么他会进一步落后，他的机会就会变得微乎其微。</p>
<p>现在我们来分析一个收款人需要等多久才能确认他的交易不会被改变。我们假设攻击这是付款人，他想要让收款人相信他一直完成支付，然后一段时间后他通过攻击改变这笔交易。如果该情况发生，收款人回收到警报，而攻击者希望攻击已经完成。</p>
<p>收款人生成了一个新的钥匙对，仅在交易发生前，把公钥给了发款人（攻击者）。这可以防止攻击者提前准备一个区块链，然后是不断地处理它，直到他幸运地领先足够远，然后在那个时刻执行交易（译者：然后才公布他的链，在此之前网络不知道这条链的存在）。一旦交易发出，攻击者开始秘密的在另外一个链进行工作量证明，而这条链包含了一个被改变的交易（译者：他自己的交易，大概率是降低支付金额）。</p>
<p>收款人等到他的交易被加入区块并且$z$个此后的区块已经被加入公链。他并不知道攻击者的秘密连已经进行了多少，但是他可以假设诚实的区块需要平均时间加入（译者：10分钟），黑客可能的进度可用比松分布模拟：</p>
<p>$$\lambda = z * (q/p)$$</p>
<p>我们将泊松密度乘以赶上公链的概率：</p>
<p><img src="https://i.imgur.com/BtKtnw5.png" alt=""></p>
<p>整理：</p>
<p><img src="https://i.imgur.com/1rKGzfK.png" alt=""></p>
<p>该公式的 C 语言代码：</p>
<p><img src="https://i.imgur.com/9W3Kv7h.png" alt=""></p>
<p>运行结果如下：</p>
<p><img src="https://i.imgur.com/YfcfaoB.png" alt=""></p>
<p>如果求解 p &lt; 0.001 的情况：</p>
<p><img src="https://i.imgur.com/t6xHRf7.png" alt=""></p>
<p>（译者：可以看到，在攻击者出块概率为 10% 的情况下，等待 5 个区块，黑客成功的概率仅为 0.1%）</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们提出了一个不需要第三方的电子支付系统。首先，我们介绍了常见的数字签名方法，该方法有利的解决了资产的所有权问题，但是却无法解决双花问题。为了解决双花问题，我们提出了一个采用工作量证明的点对点网络来记录交易历史，而且该记录让攻击者难以改变，只要网络有大部分诚实节点控制。比特币网络的稳定性来源于他非结构化的简单性（译者：多么美妙，如今区块链发展越来越复杂，但是这岂不是丢掉了区块链的核心，即稳定性）。节点完全自主独立的运行，几乎不需要同步。他们不需要被识别，因为信息并不是分发到某个特定的节点，而是任何节点。节点可以随时加入或者退出网络，然后接受最长工作量证明链作为离开期间的历史。他们通过 CPU 资源进行投票，表达他们接受或者拒接区块的意愿。任何规则和激励措施都可以通过这种共识机制来执行。</p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - Proof of What?</title>
    <url>/2022/05/26/thinking_bitcoin_3/</url>
    <content><![CDATA[<h2 id="Proof-of-work-的价值在哪里？"><a href="#Proof-of-work-的价值在哪里？" class="headerlink" title="Proof of work 的价值在哪里？"></a>Proof of work 的价值在哪里？</h2><p>比特币区块链为什么有价值？他的价值在于它的账本，就是比特币公链。换句话说，他的账本有价值，为什么？正是因为 Proof of work。账本上的每一笔记录，每一个区块，背后都有相应真实世界成本（主要是电力，当然还有矿机、人力成本等等忽略不计）。这就是公链价值的来源，价值不能被凭空产生，特别是数字资产。我举个栗子，如果你有一个 SQL 数据库，在里面添加一条记录的成本是多少？0。再换个例子，魔兽世界的一件装备，你获得成本是多少啊？100元，但是你要信任游戏运营商的诚实和存在。这里涉及两个问题：创建数字资产几乎没有成本；数字资产想产生价值要么通过信任，要么通过做工，无论哪种你必须跟物理世界产生联系。</p>
<blockquote>
<p>总体来说，计算（技术）是通过更快、更便宜来最大化其价值。比特币（作为一项技术）似乎走了一个诡异的路线：它不是通过工作（work）提供价值，而是工作证明（proof of work）。它依赖于增加的工作量，而不是提高效率；它用复杂性代替了简化。在我看来，这种情况颠覆了数字经济中流行的价值观念——因为这种价值源于通过不可逆的加密方式破坏信息的过程，它破坏了传统的价值意义观念。– 引用 <a href="https://www.journals.uchicago.edu/doi/epdf/10.1086/717303">From work to proof of work</a></p>
</blockquote>
<blockquote>
<p><strong>注意：在一个数据库添加一条记录的成本是 0，即使这是一条被数字签名的信息。</strong></p>
</blockquote>
<p>这就是 Proof of work 的价值，它把数字资产锚定到物理世界的资源（能源），这也是他价值的真实来源。记住：价值背后一定有物理世界的支持。当然，这不是什么新闻，我们对银行的信任也来自物理世界，我们看到银行的大楼、工作人员在工作、司法系统会运行等等，注意，这些东西背后都有能源投入，<strong>所以我们相信银行的账本有价值（第三方）</strong>，愿意把自己创造的价值放入这个账本。但是，比特币和工作证明提供了一种不需要信任第三方的方式存储价值，其价值来源是现实世界消耗的能源。</p>
<blockquote>
<p><strong>这就是 Proof of work 的价值，它把数字资产锚定到物理世界的资源（能源），这也是他价值的真实来源</strong></p>
</blockquote>
<p>换句话说，比特币是 Proof of energy。</p>
<h2 id="Proof-of-Stack-的价值在哪里？"><a href="#Proof-of-Stack-的价值在哪里？" class="headerlink" title="Proof of Stack 的价值在哪里？"></a>Proof of Stack 的价值在哪里？</h2><p>Proof of stake （PoS）, 走上了另一个路线，无论社区如何改进这个算法，都没有改变这个事实：它去掉了区块链跟现实世界的联系：能源。按照我们刚才的逻辑，PoS 公链没有价值。从某种角度说，PoS 公链一条记录的成本几乎为 0 （当然运行服务器需要用电，但是跟 PoW 比起来可以忽略）。所以，从这个角度说，PoS 公链的物理价值为 0。</p>
<p>PoS 算法无论在技术如何更新，它不能改变这个事实：</p>
<p>PoS 通过拥有代币证明自己有能力增加一条记录，但是由于初始代币的获得几乎是没有成本的，因为 PoS 需要初始代币分发才可以启动节点运行。验证节点因为持有无成本代币就可以增加记录。<strong>那么这跟向一个 SQL 数据库写入一条记录一样廉价。</strong></p>
<p>这个模型其实早就存在了，就是股票。IPO 股票（代币）被分发给持股人，然后持股人持续获得分红（验证节点的奖励）。但是股票跟物理世界有着非常强的连接，而区块链最终仅仅是一个账本，硬盘中的一串比特。PoS 决定了这串比特代表的价值为 0，因为没有物理价值被注入这个账本。</p>
<p>更多细节，请看这篇博客：<a href="https://medium.com/@BobMcElrath/whats-wrong-with-proof-of-stake-77d4f370be15">https://medium.com/@BobMcElrath/whats-wrong-with-proof-of-stake-77d4f370be15</a></p>
<h2 id="为什么新公链都是-PoS？"><a href="#为什么新公链都是-PoS？" class="headerlink" title="为什么新公链都是 PoS？"></a>为什么新公链都是 PoS？</h2><p>为什么新公链多数选择了 PoS？我分析最直接的原因是：PoS 对开发人员更有吸引力。为什么?</p>
<ol>
<li>通过初始代币发行快速融资，即快钱</li>
<li>PoW 的路走不通，因为比特币网络的哈希率太高</li>
</ol>
<p>比特币有独特的优势，2009年，几乎没人知道比特币，但是比特币网络就悄悄展开了。没有风投、没有宣传，甚至没有精神领袖。但是目前比特币已经是哈希率最高的网络，换句话说，后来者已经很难与之竞争。比如比特币的仿品来特比，或者比特币的硬分叉比比特币现金都已经几乎死亡。</p>
<p>关于比特币现金，我可以讲另一个故事了，按下不表。但是比特币现金的故事向我们证明比特币协议的健壮和稳定。</p>
<h2 id="浪费资源还是使用资源"><a href="#浪费资源还是使用资源" class="headerlink" title="浪费资源还是使用资源"></a>浪费资源还是使用资源</h2><p>另一个 PoS 的优势在于低能耗，网上对 PoW 的评价通常是浪费能源。这个问题要看从哪个角度看。</p>
<p>我们的空调消耗掉的能源比比特币网络多得多，但是没人会说空调是浪费能源，因为我们使用资源创造了某种服务；同样，PoW 提供为数字资产注入能源的服务，不然我们需要第三方来记账。没有人说银行浪费资源，但是我敢肯定全世界各大银行用于交易的能源不会比比特币更低 + 你需要负担对手风险。</p>
<p>PoS 确实实现了低能耗，但是正如我们分析的，它提供的是一个没有物理世界连接的账本，这个账本的价值是 0.换句话说， PoS 确实是低能耗，但是它也没有提供任何价值。</p>
<p>公平吧，没有免费的午餐！</p>
<p><img src="https://i.imgur.com/1EOD1sz.png" alt=""></p>
<p>这张图告诉我们（<a href="https://global-uploads.webflow.com/61d2416d1d63f07ecbfd010c/6269b2b0f7583e175cce2464_Key%20Facts%20on%20Bitcoin%20_%20the%20Environment-03%20_1_%20_1_%20_1_%20_1_%20(2).pdf">原图点这里</a>）：</p>
<ul>
<li>将近一半的 PoW 使用了绿色能源</li>
<li>比特币挖矿使用的能源低于金矿产业，远远低于空调使用的能源</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=RHqwYtGss_0">https://www.youtube.com/watch?v=RHqwYtGss_0</a></li>
<li><a href="https://www.journals.uchicago.edu/doi/epdf/10.1086/717303">From work to proof of work</a></li>
<li><a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4067739">Proof-of-Stake Is a Defective Mechanism</a></li>
<li><a href="https://medium.com/@BobMcElrath/whats-wrong-with-proof-of-stake-77d4f370be15">What’s Wrong with Proof of Stake?</a></li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 第三世界国家</title>
    <url>/2022/05/23/thinking_bitcoin_2/</url>
    <content><![CDATA[<p>我承认我喜欢比特币，原因也很简单，因为它被设计成一个中性的系统。而其他模仿者是有国籍的，以太坊有精神领袖；风投币的 PoS 共识算法让初始股东有用几乎无限的权利。这篇文章，我想说说比特币是如何正在影响第三世界国家的。</p>
<p>你可以争辩，比特币可以被邪恶的人控制并使用，我想说的是，任何中性的东西都可以被如此使用。水可以供养人类，也可以溺死人类。这不是水的问题，是人的问题。但是如果一个系统被设计出来就是有倾向的，没人可以逆转。</p>
<h2 id="你，我亲爱的读者"><a href="#你，我亲爱的读者" class="headerlink" title="你，我亲爱的读者"></a>你，我亲爱的读者</h2><p>我亲爱的读者，既然你读到这篇文章，我几乎可以肯定你是幸福的。因为你可以上网，你应该也拥有智能手机和平板电脑，而你用来购买他们的货币不出意外就是你的本国货币。</p>
<p>但是，你也许不会经常思考，世界上很多国家的人并没有你那么幸福。他们的国家没有自己的货币，他们的老百姓可能也用不上苹果手机。</p>
<h2 id="无声的国家"><a href="#无声的国家" class="headerlink" title="无声的国家"></a>无声的国家</h2><p>媒体被发达国家和强大的国家掌握，我们平时更多听到的是美国的声音、欧洲的声音、中国的声音。但是，世界上有超过200个国家，他们的声音呢？</p>
<p>他们中有很多真正的第三世界国家，来自非洲、中美洲、南美洲。这些国家通常是殖民地国家，大多数刚刚独立不久，经济、政治都非常不稳定。而他们最大的问题之一就在于货币。这些国家要么直接使用美元，要么使用殖民国锚定的货币。比如萨尔瓦多共和国，一个中美国家，一直以来只能用美元作为货币；中非共和国，一个非洲国家，只能使用中非法郎作为货币。</p>
<p>这些“无声”的国家被外国法币遏住喉咙，由于无法控制本国货币，这些国家虽然已经独立了，经济上仍然是被殖民国或者强国控制，从而也在渐渐失去政治自由。</p>
<p>说个题外话，美金遏住不仅仅是第三世界，也摁住了战争中的俄罗斯。</p>
<h2 id="开始于萨尔瓦多共和国"><a href="#开始于萨尔瓦多共和国" class="headerlink" title="开始于萨尔瓦多共和国"></a>开始于萨尔瓦多共和国</h2><p>2022年5月，这些无声的国家（44个国家）在萨尔瓦多聚集，这些代表来到萨尔瓦多是因为萨尔瓦多将比特币作为该国法定货币，并且美元同时使用。在此之前，该国只能使用美元。而这 44 个国家的代表就是来萨尔瓦多参观、学习和讨论比特币作为储备货币的可能性。各国代表不仅仅是开会，也在小市场用比特币闪电网络支付购买食品和饮料。</p>
<p><img src="https://i.imgur.com/7hVgJNq.png" alt=""></p>
<p>5 月 15 日，萨尔瓦多总统 Nayib Bukele 宣布，来自 44 个国家的 32 位央行行长和 12 个金融当局将在该国举行会议，以通过比特币的数字经济实现金融包容性和为没有银行账户的人提供银行服务。</p>
<p><img src="https://i.imgur.com/qw9hMzB.jpg" alt=""></p>
<p>讽刺的是，1944 年 7 月，同样是 44 个国家开会确定了布雷顿森林金融体系。布雷顿森林体系是以美元和黄金为基础的金汇兑本位制，其实质是建立一种以美元为中心的国际货币体系，基本内容包括美元与黄金挂钩、国际货币基金会员国的货币与美元保持固定汇率（实行固定汇率制度）。</p>
<p>后面的故事大家都清楚了，1973 年布雷顿森林体系瓦解，美元与黄金脱钩，成为软通货，开启了石油美金的时代。换句话说，美国可以通过增发货币轻易向那些被迫依赖美金的第三世界国家输出通货膨胀（我之前也分析过，这就是盗窃行为，只不过政府雇了“经济学家”合理化这个行为）。而这些第三世界国家都是“无声”的国家。</p>
<p>2022 年，将近 50 年后，比特币给了这些国家一个机会脱离他国货币，夺回主动权的机会。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我们得承认，人类脱离金本位的时间并不长，目前的法币体系更加年轻，没有人知道那种货币政策才是合理的。但是有些货币设计出来就是邪恶的，有些则是中性的。</p>
<p>我不知道未来会怎样，星星之火可以燎原，今天的萨尔瓦多，就可能是明天的中非共和国。目前，中非共和国政府已经承认比特币作为法定货币，跟中非法郎一起。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.youtube.com/watch?v=zDbU87c2ZDs">https://www.youtube.com/watch?v=zDbU87c2ZDs</a></li>
<li><a href="https://bitcoinmagazine.com/culture/el-salvador-brought-44-countries-to-bitcoin">https://bitcoinmagazine.com/culture/el-salvador-brought-44-countries-to-bitcoin</a></li>
</ul>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币随想 - 误解、现状、未来</title>
    <url>/2022/05/18/think_bitcoin/</url>
    <content><![CDATA[<p>我在知乎发过几个关于比特币的回答，在评论区我看到了另一个天地。我突然意识到比特币虽然已经13岁了，这颗蓝色星球上对它有基本认识的人仍然很少，甚至很多人充满恶意。</p>
<p>分析导致这个现象的原因有三：<br>其一，不愿意花时间真正的了解比特币；<br>其二，把比特币跟区块链和其他 altcoin 混为一谈；<br>其三，金融泡沫和贪婪。</p>
<p>本文组织如下：介绍一些常见的误解或者可以讨论的观点，然后，从机构用户的角度分析比特币的现状和未来。</p>
<h2 id="比特币的误解"><a href="#比特币的误解" class="headerlink" title="比特币的误解"></a>比特币的误解</h2><h3 id="异常离谱的观点"><a href="#异常离谱的观点" class="headerlink" title="异常离谱的观点"></a>异常离谱的观点</h3><p>以下是我在评论区看到一些非常“离谱”的观点：</p>
<ul>
<li>比特币是庞氏骗局、郁金香</li>
<li>比特币是显卡涨价、降价的罪魁祸首</li>
<li>比特币不安全，因为如果钱包公司倒闭，币就没了</li>
<li>比特币没有智能合约</li>
<li>比特币没有实际用途</li>
</ul>
<p>类似的观点已经没有任何讨论价值了，因为它们是错的。比如好多庞氏骗局的人恐怕连什么是庞氏骗局，什么是郁金香泡沫都懒得弄清楚，就安在比特币头上，以讹传讹；在比如显卡涨价部分原因是以太坊矿机导致的，以太坊今年计划迁移 PoS 共识算法，矿机不再被需要了，显卡也就掉价。</p>
<p><code>比特币没有实际用途?</code> - 萨尔瓦多共和国已经构建了一个比特币城市，你可以用比特币和闪电网络麦咖啡，去逛超市。还有一些第三世界国家正在学习萨尔瓦多共和国的做法并准备尝试。</p>
<p>形成这类观点的主要原因：懒于思考 + 轻信碎片信息（包括我写的这一篇） + 混淆比特币和其他。</p>
<p>建议阅读：</p>
<ul>
<li>无编程基础：《The Bitcoin Standard》(《货币未来：从金本位到区块链》)</li>
<li>有编程基础：《Programming Bitcoin》</li>
</ul>
<h3 id="可以讨论的观点"><a href="#可以讨论的观点" class="headerlink" title="可以讨论的观点"></a>可以讨论的观点</h3><p>有一些观点是可以讨论的：</p>
<ul>
<li>比特币会被政府接受吗？政府可以ban掉比特币</li>
<li>比特币的基础价值在哪里？看起来没有价值基础</li>
<li>比特币的共识算法 PoW 对环境不友好，应该换 PoS</li>
<li>比特币图灵不完备，不能做 Defi 等</li>
<li>比特币不能跟互联网相提并论</li>
<li>比特币不如后来者 ETH、Solana 等等</li>
</ul>
<p>持有这些观点的人应该已经具备了一些对比特币概念有比较正确的了解，因为这些问题是好的问题。</p>
<p>这里有一些观点目前还是开放性的，比如比特币和政府的管控的关系。这可能不是一个非黑即白的问题，但是我相信正朝着好的方向发展，第二节我讨论这个问题。再比如 PoW 和 PoS 应该用哪个，我个人（和很多其他人）认为最为价值存储和货币使用，只有 PoW 才是正确的，因为 PoS 跟法币的模型没有区别。</p>
<p><em>比特币不能跟互联网相提并论？</em> - 最后一个观点也很意思，只有时间能给我们答案。但是，有个事实是：任何革命性的东西在发展初期都会被充满恶意的抵制。<strong>我们应该担心的不是比特币被质疑，而是比特币无人问津。</strong></p>
<p><em>比特币不如 ETH、Solana 等等？</em> - 这个问题关键在于“不如”是指哪里，我是个程序员，每个软件被设计出来都是带着某种目的的，对比目的不同的软件，就好比苹果跟石头作比较，毫无意义。比特币在的领域，没有任何可已经与其竞争的产品（Bitcoin Cash 已死、莱特币已死）。而且事实上，比特币如今（2022）仍然占据整个加密货币市场接近 50% 的份额，数字已经说明了一切。</p>
<h2 id="比特币的现状"><a href="#比特币的现状" class="headerlink" title="比特币的现状"></a>比特币的现状</h2><p>这一节我们从机构的动作分析比特币的现状。</p>
<p>不久之前我写过一篇文章总结：<a href="https://wangzhe3224.github.io/2022/03/06/who_has_bitcoin/">谁持有比特币</a>。文章列出了已知的持有比特币前十的公司，其中第二名正是特斯拉，它持有超过 4 万比特币。有句老话说得好：不要看他说什么，而是看他做什么。这些公司大肆购买比特币这个事实已经说明他们看好比特币。</p>
<p>比特币正式进入金融机构，首先是通过灰度的基金，然后 CBOE（芝加哥期货、期权交易所）上市了比特币期货，目前多个国家（加拿大、澳大利亚）正在审核比特币现货 ETF。</p>
<p>Fidelity 计划今年将比特币纳入 <a href="https://edition.cnn.com/2022/04/26/success/fidelity-bitcoin-401k/index.html">401k（链接）</a>。一旦这个计划付诸实践，就像我在<a href="https://www.zhihu.com/question/530592159/answer/2464782937">这个答案</a>中分析的：</p>
<blockquote>
<p>美国的养老金体量大概在 40 万亿美金，虽然 Fidelity 不是唯一的养老金提供商，这个产品一旦成功，其他养老金公司必然会提出类似商品。</p>
</blockquote>
<p>所以，比特币正在进入一个 40 万亿体量的市场，比特币现在的市值仅为 7 千亿，换句话说，如果比特币可以吃掉养老金市场 5% 的份额，那就是 2 万亿美金进入比特币市场，那意味着比特币市值翻三倍，即 2万亿，按照比特币现在是价格计算，1 BTC 将达到 12 万美金。</p>
<p>注意，如果这个假设成立，5%美国养老金市场，那么一定意味着其他的“热钱”会进一步涌入，热钱是什么呢？股票和债券。美国股票市场市值：100 万亿，债券市值 130 万亿。黄金市值 12 万亿。</p>
<p>Fidelity 仅仅是比特币资本化的一小部分，其他金融机构早就已经入局了：摩根大通、Jump Trading等等。</p>
<p>这样规模的资本化才刚刚开始，比特币已经不是那个散户玩玩的资产了；另一个值得注意的事情是，几乎没有机构对 Altcoin 感兴趣，比如 Solana 着这种。</p>
<p>关于 Altcoin 可以参考这个：<a href="https://zhuanlan.zhihu.com/p/452488138">区块链和币圈的一些观察</a></p>
]]></content>
      <categories>
        <category>Bitcoin</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据时代的“Pandas” - Dask|Ray|Modin|Vaex|Polars|...</title>
    <url>/2022/03/19/pandas_and_more/</url>
    <content><![CDATA[<h2 id="从-Pandas-说起"><a href="#从-Pandas-说起" class="headerlink" title="从 Pandas 说起"></a>从 Pandas 说起</h2><p>Pandas 在 Python 的数据工程领域可谓是半壁江山，Pandas 的作者 Wes Mckinney 于 2008 年开始构建 Pandas，至今已经走过了十几个年头。然而，Wes 在 2017 年的一篇博客中写道：</p>
<blockquote>
<p>我开始构建 Pandas 的时候并不是很了解软件工程，甚至不太会使用 Python 的科学计算生态。我当时的代码丑陋且缓慢，也是一边学一边写。2011年，我引入了 <code>BlockManager</code> 和 <code>Numpy</code> 作为 Pandas 的内部内存管理和数据结构。<br>。。。<br>然而这个决定也是 Pandas 如今无法自如处理超大数据的罪魁祸首。毕竟在 2011 年我们几乎不去思考处理超过100 GB 甚至 1TB 的数据。</p>
<p><strong>如今，我的经验是：如果你想用 Pandas 分析一个 1GB 的数据，那么你至少需要 5 - 10 GB 的内存才可以。</strong>，然而，今天我们碰到更多地情况恰恰相反，分析的数据比内存大 5-10 倍。<br><a href="https://wesmckinney.com/blog/apache-arrow-pandas-internals/">https://wesmckinney.com/blog/apache-arrow-pandas-internals/</a></p>
</blockquote>
<h3 id="Pandas-的“十一大”问题"><a href="#Pandas-的“十一大”问题" class="headerlink" title="Pandas 的“十一大”问题"></a>Pandas 的“十一大”问题</h3><ol>
<li>内部数据结构距离硬件太过遥远</li>
<li>没有内存映射</li>
<li>数据库和文件读写性能差</li>
<li>丢失值处理支持差</li>
<li>内存管理不透明，过于复杂</li>
<li>Category 数据类型支持差</li>
<li>复杂的分组运算性能差</li>
<li>数据Append性能差</li>
<li>数据类型依赖于numpy，不完整</li>
<li>只有Eager evaluation，没有询问计划（query plan）</li>
<li>慢，大数据集多核性能很差</li>
</ol>
<p>今天我们来列举目前针对这些问题一些可能的解决方案：Dask、Ray、Modin、Vaex、Polars。当然，我们还会提到一个项目就是：Apache Arrow。</p>
<h2 id="Dask"><a href="#Dask" class="headerlink" title="Dask"></a>Dask</h2><p><img src="https://i.imgur.com/7Jq7KQJ.png" alt="Dask"></p>
<p>Dask 本质上是两个部分：动态计算调度 + 一些数据结构。调度器主要负责在多核心或者多个计算机之间组织并行计算，而数据结构则提供了一些熟悉的API，比如类Pandas 的 Dask DataFrame、类 Numpy 的 Dask Array 等等。Dask 把人们已经熟的 Pandas、numpy 的 API 拓展到多核以及计算集群上进行计算。</p>
<p>当然，Dask 本身完全是由 Python 写成的，在单个计算任务方面并没有比 Pandas 有本质的提升，甚至 Dask 还是用到了一些 Pandas 的功能。我以为，Dask 真正的核心其实是他的调度器，理论上他的调度器可以执行任意Python函数、采用任意Python数据结构，只不过 Dask 为了使用数据科学的场景，自带了一些常见的 API，比如 DataFrame 或者 ndarray，这些数据结构可以更好的拓展到计算集群。</p>
<p>目前，Dask 已经将调度器部分独立成了新的项目：<a href="https://github.com/dask/distributed">A distributed task scheduler for Dask</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Arrays</span></span><br><span class="line"><span class="keyword">import</span> dask.array <span class="keyword">as</span> da</span><br><span class="line">x = da.random.uniform(low=<span class="number">0</span>, high=<span class="number">10</span>, size=(<span class="number">10000</span>, <span class="number">10000</span>),  <span class="comment"># normal numpy code</span></span><br><span class="line">                      chunks=(<span class="number">1000</span>, <span class="number">1000</span>))  <span class="comment"># break into chunks of size 1000x1000</span></span><br><span class="line"></span><br><span class="line">y = x + x.T - x.mean(axis=<span class="number">0</span>)  <span class="comment"># Use normal syntax for high level algorithms</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrames</span></span><br><span class="line"><span class="keyword">import</span> dask.dataframe <span class="keyword">as</span> dd</span><br><span class="line">df = dd.read_csv(<span class="string">&#x27;2018-*-*.csv&#x27;</span>, parse_dates=<span class="string">&#x27;timestamp&#x27;</span>,  <span class="comment"># normal Pandas code</span></span><br><span class="line">                 blocksize=<span class="number">64000000</span>)  <span class="comment"># break text into 64MB chunks</span></span><br><span class="line"></span><br><span class="line">s = df.groupby(<span class="string">&#x27;name&#x27;</span>).balance.mean()  <span class="comment"># Use normal syntax for high level algorithms</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bags / lists</span></span><br><span class="line"><span class="keyword">import</span> dask.bag <span class="keyword">as</span> db</span><br><span class="line">b = db.read_text(<span class="string">&#x27;*.json&#x27;</span>).<span class="built_in">map</span>(json.loads)</span><br><span class="line">total = (b.<span class="built_in">filter</span>(<span class="keyword">lambda</span> d: d[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;Alice&#x27;</span>)</span><br><span class="line">          .<span class="built_in">map</span>(<span class="keyword">lambda</span> d: d[<span class="string">&#x27;balance&#x27;</span>])</span><br><span class="line">          .<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<h2 id="Ray"><a href="#Ray" class="headerlink" title="Ray"></a>Ray</h2><p><img src="https://i.imgur.com/9r3AzwF.png" alt="Ray"></p>
<p>Ray 是一个来自伯克利 RISE 实验室的开源产品，主要针对机器学习领域的分布式计算框架，其底层调度器与 Dask 类似，但是提供了完全不同的上层API和工具，Ray主要的提供了：Turn，分布式调参工具；RLlib，强化学习；Train，分布式深度学习；Dataset，分布式数据读取和计算。</p>
<p>Ray 在某种程度上不算是 Pandas 的替代品，而是大数据分布式机器学习的框架。</p>
<h2 id="Modin"><a href="#Modin" class="headerlink" title="Modin"></a>Modin</h2><p><img src="https://i.imgur.com/I10D1CN.png" alt="Modin"></p>
<p>Modin 的目的非常明确：取代 Pandas。Modin 拥有几乎和 Pandas 一致的API，但是有用原生多核计算和处理超过内存数据集的能力。绝大部分场景下，完全相同的代码，Modin 比 Pandas 要快出数倍，但是编码成本几乎与Pandas一致。</p>
<p><img src="https://i.imgur.com/H7mUZjh.png" alt=""></p>
<p>与 Dask 和 Ray 不同，Modin 的主要目的是提升单机（多核）处理大于内存数据集的能力，而不是采用集群计算。但是，Modin 拥有更换执行引擎的选项，也就是说，Modin 可以通过采用 Ray 或者 Dask 作为引擎轻松实现集群计算。</p>
<p><img src="https://i.imgur.com/x4cRIZu.png" alt=""></p>
<p>从编码角度说，Modin 采用了纯 Python 编码，因此单核能力提升并不会较 Pandas 有太多优势，他的优势主要在于超大数据、分布式计算和友好的 pandas API。话句话说，Mondin 是分布式 Pandas。</p>
<h2 id="Vaex"><a href="#Vaex" class="headerlink" title="Vaex"></a>Vaex</h2><p><img src="https://i.imgur.com/7gYhST2.png" alt="Vaex"></p>
<p>Vaex 的主要目的也是提升单机处理大数据的能力和速度，在这一点与 Modin 类型，但是 Vaex 并没有想要完全兼容 Pandas 的API，而是倾向探索数据和数据可视化。虽然 Vaex 的 API 看起来跟 Pandas 很像。事实上，Vaex 这个名字的由来正是：Visualization and eXploration。</p>
<p>Vaex 采用了内存映射、0拷贝、惰性计算等技术提高性能，可以实现单机每秒处理超过10亿行数据；同时 Vaex 还有非常棒的开箱数据可视化能力。</p>
<p>从编码的角度，Vaex 核心采用了 Python 和 C++ 混合编程，在一定程度提升了单核计算性能。</p>
<h2 id="Apache-Arrow"><a href="#Apache-Arrow" class="headerlink" title="Apache Arrow"></a>Apache Arrow</h2><p><img src="https://i.imgur.com/Zd4laBa.png" alt="Apache Arrow"></p>
<p>Arrow 实际上并不是一个库，而是一个规范。官方文档的定义是：Arrow 是一个内存内分析平台。它包含了一系列大数据处理和数据传输的技术。它规定了一个标准化的、语言无关的列内存格式（Columnar memory format），该格式适合于现代硬件进行高性能分析运算。当然，只有规范不能形成生态，Arrow社区维护了很多不同语言的实现，比如<code>C++</code>,<code>Python</code>,<code>Java</code>, <code>Rust</code>, <code>Go</code>等等。这些实现都遵循了<code>Arrow</code>的内存模型，并且主要包含如下主题：</p>
<ul>
<li>0拷贝和基于RPC的数据传输</li>
<li>多种文件格式的读写</li>
<li>内存分析和查询处理</li>
</ul>
<p>其实<code>Arrow</code>的创始人之一正是<code>pandas</code>的作者 Wes，他在<a href="https://wesmckinney.com/blog/apache-arrow-pandas-internals/">这篇博客</a>中阐述了<code>pandas</code>的问题，并解释了为什么<code>arrow</code>是解决这些问题的第一步。</p>
<p>虽然<code>arrow</code>不是<code>pandas</code>直接的替代品，但是其他库提供了一个坚实的数据结构基础，这里我给大家介绍一个正在开发的库：Polars。</p>
<h2 id="Polars"><a href="#Polars" class="headerlink" title="Polars"></a>Polars</h2><p><img src="https://i.imgur.com/tbILHHT.png" alt="Polars"></p>
<p>前文我们介绍了<code>Dask</code>和<code>Ray</code>，他们提供的主要功能是大数据的集群计算，实际上没有专注解决单机问题；<code>Modin</code>和<code>Vaex</code>，主要是提供单机处理大数据的能力，但是没有在单核计算上做过多努力。换句话说，实际上他们的每一个单核计算任务还是依赖<code>Python</code>库，比如<code>numpy</code>和<code>pandas</code>。也就是说，在某种程度上，他们并没有解决<code>pandas</code>的问题，而是把问题拆解放在了集群解决。</p>
<p><code>polars</code>则利用<code>arrow</code>的生态，直接解决<code>pandas</code>的痛点，采用<code>Rust</code>编写核心代码，试下如下特性：</p>
<ul>
<li>惰性、非惰性求值</li>
<li>原生多核计算</li>
<li>SIMD</li>
<li>查询优化</li>
<li>类 pandas API</li>
</ul>
<p>在 <a href="https://h2oai.github.io/db-benchmark/">h2oai</a> 提供的 Benchmark 中<code>Polars</code>几乎占据了所有测试项目的首位：</p>
<p><img src="https://i.imgur.com/QrQa9gb.png" alt=""></p>
<p><img src="https://i.imgur.com/JwARa86.png" alt=""></p>
<p>当然，<code>polars</code>与之前介绍的项目并不冲突，特别是<code>Dask</code>和<code>Ray</code>，因为单机性能的提升对集群来说也是非常有益。而且<code>arrow</code>近些年已经成为了数据科学的标准数据格式，这种优势让数据的内存通讯、网络通讯成本大大降低，降低了序列化、反序列化的成本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.google.com/presentation/d/10XHc4LQ5K6WXAS24vp6jE7KkjouVZnQEuKbNwUVqmq4/edit#slide=id.g11a7293d561_0_77">大数据时代Pandas的替代品</a></li>
<li><a href="https://wesmckinney.com/blog/apache-arrow-pandas-internals/">Wes Mckinney的博客</a></li>
<li><a href="http://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/">Jake Vanderplas的博客</a></li>
<li><a href="https://arrow.apache.org/docs/">Apache Arrow</a> </li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>Dask</tag>
      </tags>
  </entry>
  <entry>
    <title>股票中低频股票系统化交易 | Quant dev 技能框架</title>
    <url>/2022/03/08/quant_dev_4/</url>
    <content><![CDATA[<p>中低频策略主要由两个方面的定义：</p>
<ol>
<li>持仓周期以天为单位（注意是持仓周期，不是交易频率，中低频也存在日内交易）</li>
<li>目标仓位生成与交易执行之间的反馈循环频率较低</li>
</ol>
<ul>
<li><a href="#场景">场景</a><ul>
<li><a href="#研究回测">研究回测</a></li>
<li><a href="#实盘交易">实盘交易</a></li>
<li><a href="#复盘审核">复盘审核</a></li>
</ul>
</li>
<li><a href="#基础组成部分">基础组成部分</a></li>
<li><a href="#软件框架">软件框架</a><ul>
<li><a href="#数据存储和版本控制">数据存储和版本控制</a></li>
<li><a href="#计算">计算</a></li>
<li><a href="#实盘交易-1">实盘交易</a></li>
</ul>
</li>
<li><a href="#系统实现">系统实现</a><ul>
<li><a href="#数据">数据</a></li>
<li><a href="#计算-1">计算</a></li>
<li><a href="#部署">部署</a></li>
</ul>
</li>
<li><a href="#软件和框架总结">软件和框架总结</a></li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>系统化交易的实际场景主要可以分为：研究回测、实盘交易和复盘审核。因为产生目标投资组合（Target）与订单执行（Execution）的反馈循环较弱，通常可以拆分目标投资组合生成和订单执行，这是中低频策略的主要特征之一。</p>
<p>设计系统化交易系统主要实现如下目标：</p>
<ul>
<li>可回溯，包括数据和配置</li>
<li>可警报</li>
<li>人工干预接口</li>
<li>易于拓展，包括数据、信号和附加组件</li>
</ul>
<p>系统化交易中所有信息都是应该是时间序列，且是 Point in time，PIT 的。换句话说，每一个数据点应该有两个时间戳：事件发生的时间（$t$, time）和事件被观测的时间（$ot$, observe time）。</p>
<p>另外一个思路就是 Append Only，即只增加，不更新。这样每个事件只有一个时间，即发生的时间，$t$。但是，我们需要重构历史，或者建立快照，snapshot，来提速。</p>
<p>这样做的主要原因是提供了回溯的可能性，而可回溯是盘后分析、模拟实盘差异分析的关键。</p>
<h3 id="研究回测"><a href="#研究回测" class="headerlink" title="研究回测"></a>研究回测</h3><p>这个部分也可以叫做<strong>信号生成</strong>。</p>
<p>这部分的产出是某个时间节点，$t$，的目标投资组合 $sig_t$ 或者 $signal_t$，即在该时间点，我们希望实现的持仓，通常是一揽子股票、期货的权重，$w_i$，即 $sig := {w_0, w_1, …, w_N}$，其中 $i$ 代表交易标的物。</p>
<p>通常，目标投资组合是历史数据的函数，$sig_t = g(data_{0..t-1}, config_t)$。这里 $data$ 可以包含各种类型，比如常见的价格、成交量数据、公司财报、天气、专家意见、Stock Loan $sl$、持仓 $pos$、交易约束 $cons$ 等等。$config_t$ 属于策略的配置部分，这部分就是系统化交易的人工因素。</p>
<p>当然，为了评估策略的历史表现，我们需要对信号，即 ${sig_0, sig_1, …, sig_n}$，的历史收益情况进行计算，$PnL = f(sig, price, cost)$，即<strong>回测</strong>。$PnL$ 通常是信号、标的价格、花费的函数。在这个部分，$cost$ 的计算比较复杂，可以建立各种模型，也是研究回测的重头戏，<strong>花费的计算对评估策略的表现有至关重要的作用</strong>。</p>
<h3 id="实盘交易"><a href="#实盘交易" class="headerlink" title="实盘交易"></a>实盘交易</h3><p>理想情况下，实盘交易只需要生成最新的目标，$sig_t$，当然这不代表我们只需要 $data_{t-1}$。事实上，我们希望实盘交易系统和回测研究系统采用相同的，$g$ 和 $data$ 来计算。这一点在设计交易系统时非常重要。虽然，$g$ 是一样的，但是通常实盘仅仅需要近期的历史数据。</p>
<p>实盘交易过程中还有一个重要的部分，就是审核。审核包含：数据异常、信号异常、订单异常三个主要部分。审核的主要目的是确保每个时间点，$t$，发出的订单都是正确和合理的。</p>
<p>最后，在实盘交易中还存在很大的操作风险，即 Operation Risk。这部分其实跟审核相关，也跟运行时异常相关。比如，数据出现异常，导致信号异常，如何人工介入重写？</p>
<p>$sig_{new} = h(sig_t, data, human)$</p>
<p>其中，$human$ 属于主观部分。</p>
<p>实盘最后一步就是根据当前仓位和信号生成订单提交：</p>
<p>$order_t = pos_{t-1} - sig_{t}$ </p>
<h3 id="复盘审核"><a href="#复盘审核" class="headerlink" title="复盘审核"></a>复盘审核</h3><p>复盘这个部分主要是计算回测结果和实盘结果之间的差异，并寻找差异根源。模拟和实盘的差别可以说是系统化交易一个老大难问题了。</p>
<p>$\Delta_t^{sig} = sig_t^{sim} - sig_t^{live}$</p>
<p>$\Delta_t^{pnl} = PnL_t^{sim} - PnL_t^{live}$</p>
<p>$\Delta_t^{sig}$ 是模拟得到的投资组合权重与实盘记录的投资组合的权重之间的差异，$\Delta_t^{pnl}$ 是模拟盈亏和实盘盈亏之间的差异。这两个差异是不同的，因为 $PnL^{sim} = f(sig, price, cost)$，而实盘盈亏是直接根据仓位计算的，这里面除了 $sig$ 至少多一个 $cost$ 的区别，而且还可能有其他的区别。</p>
<h2 id="基础组成部分"><a href="#基础组成部分" class="headerlink" title="基础组成部分"></a>基础组成部分</h2><p>通过上述分析可以发现如下值：</p>
<ul>
<li>$data$，一切数据源</li>
<li>$sig^{sim}$，信号或者 Alpha</li>
<li>$config$，配置文件</li>
<li>$human$，人工输入</li>
<li>$cons$，交易约束</li>
<li>$cost^{sim}$，模拟交易成本</li>
<li>$pos$，仓位</li>
<li>$sig^{live}$，实际成交的仓位</li>
<li>$PnL^{live}$，实盘盈亏</li>
<li>$cost^{live}$，实盘交易成本</li>
</ul>
<p>其中，$pos$, $sig^{live}$, $PnL^{live}$, $cost^{live}$ 只能通过实盘记录累积获得历史。</p>
<p>可以发现如下关系：</p>
<ul>
<li>$g$, $sig_t = g(data_{0..t-1}, config_t, cost, cons)$</li>
<li>$h$, $sig_{new} = h(sig_t, data, human)$</li>
<li>$f$, $PnL^{sim} = f(sig, price, cost)$</li>
</ul>
<p>其中，$g$ 是数据+配置产生信号的函数，$h$ 是人工干预函数，$f$ 就是模拟函数，即计算模拟盈亏的函数。</p>
<p>复盘信息：</p>
<ul>
<li>$\Delta_t^{sig}$</li>
<li>$\Delta_t^{pnl}$</li>
</ul>
<h2 id="软件框架"><a href="#软件框架" class="headerlink" title="软件框架"></a>软件框架</h2><p>识别基础数据类型、函数和需求后，就可以考虑构建支持这种系统的软件架构。</p>
<h3 id="数据存储和版本控制"><a href="#数据存储和版本控制" class="headerlink" title="数据存储和版本控制"></a>数据存储和版本控制</h3><p>数据主要包含两大类：外部数据和内部数据。</p>
<p>外部数据即由第三方提供的数据，比如：</p>
<ul>
<li>价格、成交量数据</li>
<li>基本面数据</li>
<li>Ticker Mapping</li>
<li>Reference Data</li>
<li>其他非传统数据，比如天气、流量、新闻等等</li>
</ul>
<p>内部数据即本地产生的数据，比如：</p>
<ul>
<li>策略或者信号的配置文件</li>
<li>人为干预事件</li>
<li>实盘成交数据、税收、交易费用等等</li>
</ul>
<p>（文本数据可以轻松版本控制，其他格式呢？比如二进制数据，如何版本控制）</p>
<p>所有数据应该尽可能做到版本控制，一方面可以回溯，另一方面可以快速回滚。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>计算包括：信号生成和回测、复盘分析、实盘信号生成。</p>
<p>这部分主要考虑如何高效组织大规模计算。通常的做法是采用计算图，Computation Graph，进行组织。</p>
<h3 id="实盘交易-1"><a href="#实盘交易-1" class="headerlink" title="实盘交易"></a>实盘交易</h3><p>实盘交易部分主要涉及：</p>
<ul>
<li>警报系统</li>
<li>实盘报告系统</li>
<li>人工干预接口</li>
<li>执行接口</li>
</ul>
<p>一般来说，中低频交易系统中，执行系统往往呈现黑箱状态，即通过API进行沟通。</p>
<h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li>低频数据：基于文件、Rest API、爬虫</li>
<li>高频数据：socket</li>
</ul>
<p>主要涉及的软件：</p>
<ul>
<li>消息队列：比如 Kafka</li>
<li>高速缓存：比如 Redis</li>
<li>持久化：比如 MySQL、MongoDB或者其他定制实现</li>
<li>数据管道管理：比如 Airflow</li>
</ul>
<p>特别是对于持久化，选择那种方案，多数取决于数据的使用场景和频率。在股票系统化交易中，数据多数为二维，少数情况为多维数组。最常见的数据结构就是一个二维的 Table like 数据，索引（index）通常是时间，列通常是股票id或者其他任何标签。写入通常是重写、追加、更新，而读取通常需要一些过滤，比如选中某段时间的，某些列，或者一些窗口等操作。</p>
<p>股票交易中还有一个比较复杂的数据就是ID的映射和一些静态信息，比如一只股票在不同的数据源就有用多个ID，比如 Bloomberg，Reuters，ISIN 等等，他们之间映射往往是 PIT 的，即不同的时间观察，会有不同的结果，这对实盘和回测都有较大影响。</p>
<h3 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h3><p>计算可以分成两个部分：描述和执行。描述一般是通过 DAG，有向无环图完成，即惰性。而执行则是 DAG 的运行时。目前 DAG 的运行时选择很多，后端也很多。</p>
<p>这里推荐一个：Dask。Dask 的运行时后端可以是 K8s，Spark，或者单机多核心。</p>
<p>当然，DAG 中的每一个任务还是执行代码，这部分 Python 生态也非常优秀：</p>
<ul>
<li>numpy</li>
<li>pandas</li>
<li>scipy</li>
<li>tensorflow</li>
<li>polars</li>
</ul>
<p>注意，将计算的描述和执行分开是非常有用的抽象，因为计算描述在某种程度上可以被版本控制，而且可以最大限度的降低重复计算，提高效率。</p>
<p>不同的任务之间，可以采用类似 Airflow 的软件进行管理。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>部署涉及：</p>
<ul>
<li>代码部署</li>
<li>计算资源部署</li>
<li>策略配置文件部署</li>
</ul>
<p>再部署方面，把代码、计算资源和配置分离，可以最大限度的增加灵活性和可控性。</p>
<p>这部分用到的主要软件：</p>
<ul>
<li>Docker</li>
<li>Git</li>
<li>Linux</li>
<li>Jenkins</li>
</ul>
<p>另外，最好维护三个不同的环境：dev、stage、prod。dev 是主要的开发环境，变化最快嘴不稳定；stage 是主要的测试环境，相对比较稳定；prod是生产环境，只有通过stage测试阶段的 Image、config 才会被部署到prod。</p>
<h2 id="软件和框架总结"><a href="#软件和框架总结" class="headerlink" title="软件和框架总结"></a>软件和框架总结</h2><ul>
<li>Kafka</li>
<li>Redis</li>
<li>MySQL | MongoDB</li>
<li>Airflow</li>
<li>Git</li>
<li>Linux</li>
<li>Jenkins</li>
<li>Spark</li>
<li>Docker</li>
<li>K8s</li>
</ul>
<p>语言和库：</p>
<ul>
<li>Python<ul>
<li>numpy</li>
<li>pandas</li>
<li>sicpy</li>
<li>dask</li>
<li>polars</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Quant</tag>
      </tags>
  </entry>
  <entry>
    <title>谁持有比特币</title>
    <url>/2022/03/06/who_has_bitcoin/</url>
    <content><![CDATA[<blockquote>
<p><strong>声明：</strong></p>
<ul>
<li>文章不涉及任何政治、经济、道德等非客观复杂事实</li>
<li>文章不涉及比特币的实现原理、加密货币实现原理</li>
<li>文章不涉及投资建议</li>
</ul>
</blockquote>
<p>比特币，Bitcoin，是一个分布式账本系统，起源于 2008 年的一份白皮书文件，其作者 Satoshi Nakamoto 身份不详；其C++标准实现，Bitcoin Core，正式运行于2009年1月3日。比特币是该账本的原生代币，bitcoin。</p>
<p>目前（2022-03），那些机构已经或者声明将要持有比特币？你可能想不到哪家机构是目前持有比特币最多的。。。</p>
<h2 id="官网备案确认持有的机构"><a href="#官网备案确认持有的机构" class="headerlink" title="官网备案确认持有的机构"></a>官网备案确认持有的机构</h2><p><img src="https://i.imgur.com/jH4bzVw.png" alt=""></p>
<h3 id="MicroStrategy"><a href="#MicroStrategy" class="headerlink" title="MicroStrategy"></a>MicroStrategy</h3><p>该公司持有至少 124391 BTC，约为 58 亿美金，作为公司的主要储备资金。</p>
<p>该公司 CEO Michael Saylor 公开发文称他个人持有 17732 BTC，约为 8 亿美金。</p>
<p><img src="https://i.imgur.com/63ipNeq.png" alt=""></p>
<p>根据 BitInfoChart 的统计，单个地址持有超过 10万 BTC的地址只有3个。</p>
<h3 id="特斯拉"><a href="#特斯拉" class="headerlink" title="特斯拉"></a>特斯拉</h3><p>根据美国 SEC Filing 的数据，特斯拉持有 42902 BTC，价值约为 20亿美金。</p>
<h3 id="Galaxy-Digital-Holdings"><a href="#Galaxy-Digital-Holdings" class="headerlink" title="Galaxy Digital Holdings"></a>Galaxy Digital Holdings</h3><p>这是一家面向机构的加密货币投资公司，于 2022 年挂牌在多伦多上市。它持有 16400 BTC，价值约为 7.8 亿美金。</p>
<p>2022年，该公司向美国证监会提交了 BTC 现货ETF，但是目前仍然在审理过程，暂未通过。</p>
<h3 id="Voyager-Digital-LTD"><a href="#Voyager-Digital-LTD" class="headerlink" title="Voyager Digital LTD"></a>Voyager Digital LTD</h3><p>Voyager 是加密货币 Broker，持有 12260 BTC，价值约 5.8 亿美金。</p>
<h3 id="Block-Inc"><a href="#Block-Inc" class="headerlink" title="Block, Inc"></a>Block, Inc</h3><p>Block 的前身就是线上支付公司 Square，创始人正是 Twitter 的创始人 Jack Dorsey。 Block 持有 8207 BTC，价值约为 3.8 亿美金。</p>
<h3 id="Marathon-Digital-Holdings-Inc"><a href="#Marathon-Digital-Holdings-Inc" class="headerlink" title="Marathon Digital Holdings Inc."></a>Marathon Digital Holdings Inc.</h3><p>这是一家比特币挖矿公司，持有 7649 BTC，价值约为 3.6 亿美金。</p>
<h3 id="Hut-8-Mining-Corp"><a href="#Hut-8-Mining-Corp" class="headerlink" title="Hut 8 Mining Corp"></a>Hut 8 Mining Corp</h3><p>持有 5242 BTC，约为 2.5 亿美金。</p>
<h3 id="Coinbase-Global-Inc"><a href="#Coinbase-Global-Inc" class="headerlink" title="Coinbase Global, Inc."></a>Coinbase Global, Inc.</h3><p>持有 4482 BTC，约为 2.1 亿美金。</p>
<h3 id="Riot-Blockchain-Inc"><a href="#Riot-Blockchain-Inc" class="headerlink" title="Riot Blockchain, Inc."></a>Riot Blockchain, Inc.</h3><p>持有 3995 BTC, 约为 1.9 亿美金。</p>
<h3 id="Bitcoin-Group-SE"><a href="#Bitcoin-Group-SE" class="headerlink" title="Bitcoin Group SE"></a>Bitcoin Group SE</h3><p>德国的风投公司</p>
<p>持有 3947 BTC, 约为 1.9 亿美金。</p>
<h3 id="FBI-对联邦调查局，，，"><a href="#FBI-对联邦调查局，，，" class="headerlink" title="FBI (对联邦调查局，，，)"></a>FBI (对联邦调查局，，，)</h3><p>FBI 于 2022年2月报告，追缴回2016年被盗的比特币，合计 119754 BTC。。。<a href="https://www.justice.gov/opa/pr/two-arrested-alleged-conspiracy-launder-45-billion-stolen-cryptocurrency">^2</a> 所以，FBI 可能是目前个体机构持有比特币最多的，价值约为 45 亿美金。</p>
<h2 id="声明将要或支持投资人持有的机构"><a href="#声明将要或支持投资人持有的机构" class="headerlink" title="声明将要或支持投资人持有的机构"></a>声明将要或支持投资人持有的机构</h2><h3 id="萨尔瓦多共和国，El-Salvador"><a href="#萨尔瓦多共和国，El-Salvador" class="headerlink" title="萨尔瓦多共和国，El Salvador"></a>萨尔瓦多共和国，El Salvador</h3><p>萨尔瓦多，一个中美洲国家，总人口 700 万，属于第三世界国家。<br>2022年，萨尔瓦多宣布发售价值 10 亿美金的比特币10年国债，年收益 6.5%。<br>政府称，其中 5亿 将用于购买比特币，剩余 5 亿用于构建全新的比特币支付城市。<br>该国债计划于 2022年3月20日 正式发行。</p>
<p>其实这个国债，跟 MicroStrategy 的产品差不多，只不过是国家层面的行为，虽然规模远不如 MicroStrategy。</p>
<h3 id="KPMG"><a href="#KPMG" class="headerlink" title="KPMG"></a>KPMG</h3><p>KPMG 的加拿大分部将比特币和以太币加入了他们的公司储备金。<a href="https://www.cityam.com/kpmg-canada-adds-bitcoin-and-ethereum-to-balance-sheet/">^1</a></p>
<h3 id="ARK-Invest"><a href="#ARK-Invest" class="headerlink" title="ARK Invest"></a>ARK Invest</h3><p>ARK 是业界知名的资产管理公司，2020 年，该公司发出了一份名为：Bitcoin as an investment 的分析报告，详细分析了 BTC 进入资产投资组合的可能性、优势和风险。</p>
<h3 id="Fidelity"><a href="#Fidelity" class="headerlink" title="Fidelity"></a>Fidelity</h3><p>Fidelity 是老派资管公司了，其管理资产超过 7 千亿美金，2022年，该公司的数字货币分公司发表了一份名为：Bitcoin first 的分析报告，分析了为什么投资人需要将 BTC 作为一个投资资产考虑，以及为什么应该把 BTC 和其他数字货币区别开来。</p>
<h3 id="Blackrock-黑石基金"><a href="#Blackrock-黑石基金" class="headerlink" title="Blackrock, 黑石基金"></a>Blackrock, 黑石基金</h3><p>目前没有黑石没有明确表明自己持有 BTC，但是黑石分别持有 Marathon Digital 6% 股份、 riot blockchain 7% 股份，总计价值约 4 亿美金，而上述两家公司均持有大量比特币。</p>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p><a href="https://github.com/wangzhe3224/all_about_bitcoin">https://github.com/wangzhe3224/all_about_bitcoin</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Bitcoin">https://en.wikipedia.org/wiki/Bitcoin</a></li>
<li>Bitcoin: A Peer-to-Peer Electronic Cash System</li>
<li><a href="https://github.com/wangzhe3224/all_about_bitcoin/blob/main/report/bitcoin-first-fidelity.pdf">[Fidelity] Bitcoin first: why investor need to condsider bitcoin separately from other digital asset?</a></li>
<li><a href="https://github.com/wangzhe3224/all_about_bitcoin/blob/main/report/ARKinvest_Bitcoin_II_An%20Investment.pdf">[ARK invest] Bitcoin as an investment</a></li>
</ul>
]]></content>
      <categories>
        <category>Investing</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>如何成为 Quant Dev 3 - 语言</title>
    <url>/2022/01/22/quant_dev_3/</url>
    <content><![CDATA[<p>之前的连篇文章主要介绍了 Quant Dev （QD） 的分类和学习路径，这一篇我们重点介绍行业内常用的软件、语言和框架。</p>
<p><strong>注意</strong> 本系列主要针对买方 Quant Dev，而不是卖方或者 Quant 这个职业。通常来说，Quant 和 Quant Dev 的技能和技术栈有一些重叠，但是差异仍然较大。</p>
<p>之前的文章提过，Quant Dev 首先必须是一个好的程序员，通常是一个好的后端程序员，因此，QD 的基础技术栈跟一般的后端程序员非常类似，而由于业务的关系 QD 对某些语言、框架和知识的需求更多一些。</p>
<p>首先我们来说买方 QD 常用的计算机语言，不出预料就是下面四位：</p>
<ul>
<li>Python</li>
<li>Java</li>
<li>C#</li>
<li>C++</li>
</ul>
<p>近些年，我也观察到一些其他语言正在慢慢进入 QD 的世界，其中比较有潜力的就是<code>Rust</code>，因为 Rust 是近些年底层语言领域唯一有希望跟 C++ 在性能和流行度一争高下的语言。当然，也有一些公司会用一些比较小众的语言，比如 JaneStreet 大量使用了<code>Ocaml</code>，一些做量化交易软件的公司会配合使用<code>F#</code>。</p>
<p>虽然在对冲基金内部，使用的语言通常跑不出这些主流语言，但是他们的应用场景却非常不同。</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><blockquote>
<p>TL;DR</p>
</blockquote>
<p>优势：</p>
<ul>
<li>数据科学生态好</li>
<li>研究和生产部署统一技术栈</li>
<li>快速迭代、部署、Debug</li>
</ul>
<p>劣势：</p>
<ul>
<li>执行效率低、内存占用高</li>
<li>动态类型、运行时异常</li>
<li>GC、无法提供稳定延迟</li>
</ul>
<p>解决方案：</p>
<ul>
<li>执行效率和内存：numba | cython | pypy</li>
<li>运行时异常：mypy + 类型标注</li>
<li>相对稳定 GC 延迟：pypy</li>
</ul>
<p>适用领域：</p>
<ul>
<li>数据预处理、清洗</li>
<li>策略以及投资组合研究、分析</li>
<li>中低频策略执行</li>
<li>盘后分析</li>
</ul>
<p>不适领域：</p>
<ul>
<li>订单执行、管理系统</li>
<li>高频策略执行</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><code>Python</code> 现在是数据相关行业的首选，包括对冲基金，主要是得益于他强壮的数据科学生态：数据抓取、清洗、分析、机器学习等等方面都有丰富的支持。</p>
<p><code>Python</code>还有一个独特的优势，就是对于研究人员，比如 Quant 非常友好，同时它又有相对健全的通用编程生态，比如异步、并发、数据库接口、丰富的云生态等等，这些都使得<code>Python</code>在很多对冲基金同时成为了研究语言和生产语言，也就是说同一个语言兼顾了研究和生产环境。这种协调统一显然加速了策略从研究到投产的过程，使得交易策略可以快速迭代。这一点新兴的“科学计算”语言<code>Julia</code>就相差较远了。</p>
<p><code>Python</code>的另一优势在于动态语言方便的 Debug 能力和自省能力，代码编写变得非常轻松，通常比起语言需要更少的代码量来实现业务功能。而且，量化对冲基金的业务模式对 Bug 非常敏感，一旦出现软件问题，能否快速的定位和修复异常重要。当然，这些不是一个语言单独可以解决的问题，但动态语言的特性绝对有助于加速定位和修复。</p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p><code>Python</code>的短板也非常明显。主要由两个问题：性能和动态类型。这两个短板也是相互联系的，通常动态语言的性能都会相对较差。</p>
<p>首先，性能。性能主要体现在两个方面：内存和运行速度。Python 的内存占用对比其他语言，比如 C++，要大不少，这种劣势会随着数据量和计算量的增加逐渐凸显。特别是当使用类似 Pandas、Numpy 库时，一些数据计算单次需要用到的内存可能会达到 80 到 100GB。而且通常是峰值内存较大，比如计算过程中需要拷贝数据，这种峰值内存导致容器化的内存上线必须提高，造成浪费。而且如果类似的计算太多，就会对计算集群提出更高的需求。运行速度则是另外一个短板，尽管我们有一些方案，比如 <code>PyPy</code>，<code>numba</code>，<code>Cython</code>，但是这些方案无疑提高了开发复杂度，同时语言本身的Overhead仍然存在。</p>
<p>其次，动态类型。动态类型再生产过程中最主要的问题是，运行时错误。因为没有静态类型，也没有编译器，编译器无法提前告诉我们代码中潜在的类型问题。这一点在项目体积变大，文件数量庞大的时候，变得尤其突出，经常是改了一个地方，隐藏的破坏了另一个地方，而没有编译器提前告诉程序员。这些错误，通常只能在运行时暴露出来，所以 Python 开发对于测试的编写非常依赖。但是。。测试终究不能覆盖所有情况。当然，社区也有对应的解决方法，比如类型分析包：<code>mypy</code>，通过在代码中增加类型标注，配合 <code>mypy</code> 进行静态类型检查。</p>
<p>GIL，全局解释器所，也是 CPython 一直被诟病的点，社区提出了不少应对方案，如 <code>PyPy</code>、多进程、异步，当终究隔靴搔痒。</p>
<p>最后一点是所有带垃圾回收的语言都会存在的问题，延迟不稳定。因为 Python 也带有一个 STW，Stop The World，GC，因此系统随时可能迎来GC，特别是当堆内存巨大的时候，这种延迟可能达到数百毫秒。因此，在对实时性要求较高的应用中 CPython 并不合适。</p>
<h2 id="C-Rust"><a href="#C-Rust" class="headerlink" title="C++ / Rust"></a>C++ / Rust</h2><blockquote>
<p>TL;DR</p>
</blockquote>
<p>优势：</p>
<ul>
<li>执行效率高</li>
<li>内存占用低</li>
<li>延迟可控</li>
<li>类型系统和编译器（ Rust 尤其突出 ）</li>
</ul>
<p>劣势：</p>
<ul>
<li>数据科学工具链相对薄弱、难用</li>
<li>上手难度大、语言特性繁多</li>
<li>内存安全问题 （ Rust 基本没有这个问题 ）</li>
<li>编写复杂业务逻辑成本较高</li>
</ul>
<p>适用领域</p>
<ul>
<li>回测框架的核心代码</li>
<li>高频交易系统</li>
<li>低延迟订单管理、执行系统</li>
</ul>
<p>不适领域：</p>
<ul>
<li>策略研究、原型测试</li>
</ul>
<h2 id="Java-C-Go"><a href="#Java-C-Go" class="headerlink" title="Java / C# / Go"></a>Java / C# / Go</h2><blockquote>
<p>TL;DR</p>
</blockquote>
<p>这一卦的语言呢，介于 Python 和 Rust、C++ 之间，基本属于万金油。特别 Java 系在大数据领域仍然出于老大哥位置，绝大部分的中间件都是 JVM 实现的，比如 Kafka、Spark、Flink 等等。在各大投行、对冲基金中，这一卦 GC 语言仍然占据半壁江山。</p>
<p>如果说 Python 的优势在于快速迭代测试、适合中低频策略；C++、Rust 适合高频、低延迟领域；这一卦 GC 语言就比较适合订单管理、执行系统。</p>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Hedge Fund</tag>
        <tag>Python</tag>
        <tag>Quant</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub 设置任意网站</title>
    <url>/2022/01/15/github_4_build_website/</url>
    <content><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>使用 GitHub Page 功能，每一个仓库设置某个 Branch 为 Page 的 Host，然后再该 Branch 中的 <code>index.html</code> 文件就是网站的入口文件，设置好后，网站可以通过 <code>https://&#123;你的用户名&#125;.github.io/&#123;你的仓库名&#125;/</code> 访问。</p>
<ol>
<li>创建仓库</li>
<li>创建网站分支</li>
<li>创建网站入口</li>
</ol>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>这一步很简单，去 GitHub 网站即可完成。</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>把刚才建立的仓库 Clone 下来，进入 Clone 的目录，输入：<code>git checkout -b front-end</code>，开一个新的分支专门用来 Host 我们的网站。</p>
<p>然后，把新的分支推到远端仓库：<code>git push -u origin front-end</code>，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total 0 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#39;front-end&#39; on GitHub by visiting:</span><br><span class="line">remote:      https:&#x2F;&#x2F;github.com&#x2F;wangzhe3224&#x2F;Jesus_is_Lord&#x2F;pull&#x2F;new&#x2F;front-end</span><br><span class="line">remote:</span><br><span class="line">To github.com:wangzhe3224&#x2F;Jesus_is_Lord.git</span><br><span class="line"> * [new branch]      front-end -&gt; front-end</span><br><span class="line">Branch &#39;front-end&#39; set up to track remote branch &#39;front-end&#39; from &#39;origin&#39;.</span><br></pre></td></tr></table></figure>

<h3 id="创建入口文件"><a href="#创建入口文件" class="headerlink" title="创建入口文件"></a>创建入口文件</h3><p>创建文件 <code>index.html</code> , 这就是我们网站的入口。Push 到 <code>front-end</code> 分支即可。</p>
<h3 id="配置-GitHub-Page"><a href="#配置-GitHub-Page" class="headerlink" title="配置 GitHub Page"></a>配置 GitHub Page</h3><p>来到：<a href="https://pages.github.com/">https://pages.github.com/</a> 选择 <code>Project Site</code>，按照提示配置入口页面为 <code>index.html</code></p>
<p>然后我们就可以通过下面网址访问我们的网站：<code>https://&#123;你的用户名&#125;.github.io/&#123;你的仓库名&#125;/</code></p>
<h2 id="使用建站软件"><a href="#使用建站软件" class="headerlink" title="使用建站软件"></a>使用建站软件</h2><p>当然，我们不希望自己一个一个的编写 html、css ，已经有很多建站工具在开源社区。比如个人博客，可以选择：<a href="https://hexo.io/">hexo</a>；项目文档，可以选择：jekyll；甚至 GitHub 自己都有文档模板可以选择。</p>
<p>这里我们选择 Hexo 作为例子。Hexo 简单说就是一个用 Markdown 作为输入的建站软件，所有的文章、博客采用 MD 的形式书写，框架会自动根据选定的主题和配置，生成对应的 Html 和 CSS 文件，然后就像我们之前的 <code>index.html</code> 会被 GitHub Page 锁定并载入。</p>
<p>Hexo 的安装请参考官方文档：<a href="https://hexo.io/docs/">https://hexo.io/docs/</a>，整体比较简单，基本上就是安装：<code>node.js</code> 和 <code>git</code>。</p>
<p>首先，进入我们的分支根目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init page   <span class="comment"># 初始化一个博客的文件夹。</span></span><br><span class="line"><span class="built_in">cd</span> page</span><br><span class="line">npm install  <span class="comment"># 安装依赖</span></span><br></pre></td></tr></table></figure>

<p>安装结束，可以看到如下文件架结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>其中，网站的配置文件在 <code>_config.yml</code>，而博客的 MD 文件都在 <code>source/_post</code> 文件夹下。</p>
<p>为了方便起见，我们修改 <code>_config.yml</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;&#123;你的用户名&#125;.github.io&#x2F;&#123;你的仓库名&#125;&#x2F;</span><br><span class="line">public_dir: ..&#x2F;docs</span><br></pre></td></tr></table></figure>

<p>这样，我们就把生成的网站文件生成在 <code>../docs</code> 文件夹，这主要是为了方便 GitHub Page 识别，因为 GitHub Page 只能识别根目录或者 <code>docs</code> 两个目录。还有一种办法就是把网站生成在另一个新的分支，但是比较麻烦。</p>
<p>接下来，我们尝试本地生成并运行一下网站：<code>hexo s</code>，该命令会生成一个名为 <code>public</code> 的文件夹，里面就是生成的网站文件，其中 <code>index.html</code> 就是入口文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000&#x2F;Jesus_is_Lord&#x2F; . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:4000/Jesus_is_Lord/">http://localhost:4000/Jesus_is_Lord/</a> 即可看到网站。</p>
<p>最后，我们把分支推送远端：</p>
<p>我们需要编辑隐藏的 <code>.gitignore</code> 文件，把 <code>public</code> 目录纳入 git 的追踪目录，否则无法推送 public 文件夹。打开 <code>.gitignore</code> 文件，删除 public 行，保存即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first push&quot;</span><br></pre></td></tr></table></figure>

<p>我们需要改变Github Page 的入口到 <code>docs</code> 文件夹</p>
<p>Push 后，我们就可以在之前的链接看到网站了。</p>
<p><img src="https://i.imgur.com/ZdWnAmA.jpg" alt=""></p>
<h2 id="自动化部署和发布"><a href="#自动化部署和发布" class="headerlink" title="自动化部署和发布"></a>自动化部署和发布</h2><p>现在，我们只要增加或者更新 <code>source/_post</code> 文件夹下面的 MD 文件，然后运行 <code>hexo g</code>，最后 Push 更新即可。</p>
<p>这样呢，就是记得要多跑一步 <code>hexo g</code>，才能 push 文件。我们也可以通过设置 GitHub Action，来实现自动化部署，即我们只需要修改 MD 文件或者配置文件，然后直接 push，GitHub Action 运行 <code>hexo g</code>，然后把生成的网站文件部署到一个默认分支：<code>gh-page</code>。</p>
<p>可以参考：</p>
<p><a href="https://hexo.io/docs/github-pages">https://hexo.io/docs/github-pages</a></p>
<p>需要建立 <code>.github/workflows/pages.yml</code> 文件进行配置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pages.github.com/">https://pages.github.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>编程时，你在思考什么 1 - 抽象</title>
    <url>/2022/01/15/think_coding_1_abstraction/</url>
    <content><![CDATA[<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>这个系列叫<code>思考编程</code>。有趣的话题，不是吗？当你使用一种编程语言你在思考什么？如何开始思考这个问题？</p>
<p>更重要的，作为一个程序员，编写代码是我们的工作也是乐趣所在，我们需要思考我们编程的思维过程，这对理解、学习计算机语言有非常大的帮助。</p>
<p>另外，还以一个重要的话题需要思考，就是<strong>如何阅读代码</strong>，这也是这个系列想要解决的问题的。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>我会从 <strong>抽象</strong> 开始思考。抽象有很多定义，比如：隐藏细节，暴露接口；有时候 API 会被直接等价成抽象；抽象也有语义，semantic ，的意思，就是这个抽象在运行时的行为是怎么样的。</p>
<p>当然，我也可以从具体的<strong>抽象对象</strong>思考。一个编程语言最基础的要提供两种抽象：计算资源抽象 和 存储资源抽象。</p>
<ul>
<li>计算机资源包括：CPU 指令，进程，线程，协程。</li>
<li>存储资源包括：缓存，内存，硬盘，网络。</li>
</ul>
<p>这些抽象想我们隐藏了计算机硬件的诸多细节，暴露给我们语义明确的接口，或者API。这就是我们编程的基本模块，编程的时候我们就是用这些模块的组合和互动完成我们的计算任务。</p>
<p>当然这些仅仅是最基础的模块，开发人员还会在此基础上，进一步封装抽象，提供更加高级、但目的性更强的抽象。</p>
<p>举个例子，Python 的数据处理 pandas ，这是一个专门处理 table like 数据的库，它提供了一套 API 可以进行一些数据处理相关的运算，比如 groupby mean sort 等等。而这些 API 隐藏了内部线程和内存配置的细节，因为 Pandas 库内部有独立的Block manager 利用 python 提供的更加底层的没错抽象，管理自己的内存空间。这样，使用者就不必关心内存和CPU 的抽象了，直接可以在 pandas api 层面进行数据处理。</p>
<p>比如当我们初始化一个 DataFrame ，我的脑子里想的是一个表格，他有3列，100行，数据类型都是小数行。</p>
<p>我可能<strong>不会</strong>去想：我有一片内存的Buffer ，它是线性的，我的stride是3，头部的x字节包含了这个buffe的各种信息，比如列的名字，数据类型等等。不过，当你遇到性能瓶颈的时候，这种次级抽象的理解就可以帮助你解决问题了。</p>
<p>我<strong>可能会想</strong>：pandas 的内部其实大部分是另一个库的抽象，numpy，比如我的数据其实可以被一个 ndarray 代表，ndarray 就是更加底层的一个库提供的抽象。这样思考有时候会帮助我们更好的使用 pandas。</p>
<p>所以，当我们编程的时候，我们已经不自觉的按照语言和库提供给我们的抽象进行思考了。意识到这一点很重要，因为不同语言提供了迥然不同的抽象。也决定了这个语言可以做哪些事情，不可以做哪些事情。比如 Python 通过一个运行时的垃圾回收器进行内存管理，用户基本不能控制内存的分配跟回收，因此你就不能操作内存上的比特；而 Rust 提供了丰富的内存抽象，你可以控制那些东西分配在栈中，那些分配在堆中，那些是可变的，那些是可变的，那些是不可变的，那些可以被清理，那些不可以等等。</p>
<h2 id="下一期"><a href="#下一期" class="headerlink" title="下一期"></a>下一期</h2><p>这一期就到这里，下一期我们具体谈谈不同语言提供的抽象，后面我们谈谈那些代码是写给人看的，那些代码是写给编译器看的等等问题。</p>
<h6 id="tags-编程思考-Rust-Python"><a href="#tags-编程思考-Rust-Python" class="headerlink" title="tags: 编程思考 Rust Python"></a>tags: <code>编程思考</code> <code>Rust</code> <code>Python</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Rust</tag>
        <tag>编程思考</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习一门新语言</title>
    <url>/2022/01/08/how_to_learn_a_language/</url>
    <content><![CDATA[<h2 id="学习新事物的一般规则"><a href="#学习新事物的一般规则" class="headerlink" title="学习新事物的一般规则"></a>学习新事物的一般规则</h2><h3 id="2-8法则"><a href="#2-8法则" class="headerlink" title="2-8法则"></a>2-8法则</h3><ul>
<li>找到 20% 的知识点，解决 80% 的问题</li>
<li>与已知的知识体系建立联系</li>
</ul>
<h3 id="分析问题的方法"><a href="#分析问题的方法" class="headerlink" title="分析问题的方法"></a>分析问题的方法</h3><ul>
<li>拆分</li>
<li>逐个分析</li>
<li>关联</li>
<li>衍生</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><blockquote>
<p>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣。<br>– 荀子</p>
</blockquote>
<blockquote>
<p>What I cannot create, I do not understan<br>– Richard Feynman（物理学家，诺奖得主）</p>
</blockquote>
<h2 id="语言的组成"><a href="#语言的组成" class="headerlink" title="语言的组成"></a>语言的组成</h2><p>当我们按照固定的模式去看待计算机语言，所有的语言看起来都很像（当然不是语法上）。这是为什么呢？其实很好理解，因为所有的计算机语言都有一个目的：被编译成指令和内存地址。目的一致，所以其内核非常相似。</p>
<ul>
<li>语法，写出没有语法错误的代码</li>
<li>语义，代码的意义是什么？<ul>
<li>类型系统、抽象方法</li>
<li>内存模型</li>
<li>运行时、执行模型</li>
</ul>
</li>
<li>最佳实现模式，Idioms</li>
<li>工具链：Debug、测试、包管理、IDE</li>
<li>标准库，做事情</li>
<li>社区和生态，答疑、解惑、反馈、构建大型软件</li>
</ul>
<p>上面 6 个方面就是学习计算机语言的框架，初学的时候，最重要的两个部分是：语义和idioms。语法也比较重要，但是语法是最无聊和好学的。工具链和标准库，大家会在语言的日常使用中不断的学习，开始的阶段不需要花很多时间，只要知道还有这两个内容就好。最后，关于语言的生态和社区，是一个需要关注的部分，因为我们需要通过社区进行交流解惑，而生态决定了这个语言在那个业务领域更有竞争力。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>这是最无聊的部分，因为语法包含的内容都是静态的，换句话说他们是一些事实（Fact）。语法是一些规则，定义那些关键字、文本可以形成一个合法的该语言的程序。比如关键字、空格、逗号、大括号等等的使用。</p>
<p>这也是不同计算机语言<strong>差异最大</strong>的地方。也是容易引战的地方，就是吐槽某个语言的语法不好等等，大家不要参与这种讨论（除非你是语言设计者）。</p>
<h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><p>语义是最丰富的部分，语义规定了我们程序的运行行为。换句话说，语义就是程序的意思，即一段符合语法的代码代表了什么样的计算过程。</p>
<p>语义通常分为两种：动态和静态。动态语义规定了程序的运行时行为；静态语义规定了编译时的合法行为，当然这里不是语法检查。最常见的静态语义就是类型检查了，即确定程序是不是类型健康的。</p>
<h3 id="最佳实践模式"><a href="#最佳实践模式" class="headerlink" title="最佳实践模式"></a>最佳实践模式</h3><p>这个就是该语言解决问题的常见模式。在计算机领域，我们解决的问题通常是比较固定的，比如并发问题、调度问题、并行问题等等，但是不同的语言，由于语义的区别，其解决问题的方式大有不同，这就是所谓的最佳实践模式。</p>
<p>举例，你当然可以用 Haskell 写出很像 Java 的程序来进行计算，但是 Haskell 程序员就很难读懂你的代码，而且其执行效率恐怕也会被影响。</p>
<p>学习最佳实践的另一个好处是，你可以更加快速的阅读这个语言其他人的代码。</p>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p>这里包括很多，比如语言的Debuger，测试框架，包管理，编辑器，IDE等等。</p>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>一般语言都提供一些标准库，比如常用的数据结构：HashMap、Array、Vector、Tree，文件读写库，并发库等等。</p>
<h3 id="社区和生态"><a href="#社区和生态" class="headerlink" title="社区和生态"></a>社区和生态</h3><p>社区对于一个语言比较重要，因为在学习的过程中遇到问题，社区是最好的答疑解惑场所；等到学有所成，可以帮助社区其他人。</p>
<p>生态一般是指该语言的第三方库。比如 Python 的生态，有大量优质数据分析和机器学习库，比如 Numpy, Pandas, PyTorch 等等，这些库（生态）往往决定了语言应用的场景。</p>
<p>一般来说，如果一个语言社区和生态都很繁荣，那么学起来会更容易，也更加容易构架大型软件。</p>
<h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><p>读项目、参与开源、写自己的项目、重复造轮子。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://cs3110.github.io/textbook/chapters/basics/intro.html">https://cs3110.github.io/textbook/chapters/basics/intro.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Progamming Language</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年，是时候放弃面向对象（OOP）- 新萌共勉</title>
    <url>/2022/01/02/drop_oop/</url>
    <content><![CDATA[<blockquote>
<p>TL;DR</p>
</blockquote>
<p>面向对象范式（OOP）正在逐渐被工业界抛弃，新兴语言，如Go、Rust完全抛弃了OO支持，清一色的Struct、接口、泛型、函数模式；老大哥语言，如C++，Java，在新的版本中也逐渐加入了非OOP特性，使用接口、泛型、函数模式；宇宙语Python，自打出生就是个混血，目前的最佳实践也是接口、函数模式。<br>不要再关注OO啦，更加关注OO想要实现的软件工程特性。</p>
<blockquote>
<p>长版</p>
</blockquote>
<p>刚接触的编程时候（2015年左右），市面上一股脑的OOP，那时候还是个小新萌，感觉编程就是面向对象，干啥都要先写个Class，然后搞点继承实现代码复用，市面上大部分语言都会标榜自己对OOP支持很给力。</p>
<p>OOP是一个技术，他想解决一个工程问题：就是如何构建健壮、容易拓展、容易维护的软件。这个问题的背后，其实是<em>如何解决软件工程出现的复杂度</em>。OOP其实是一个古老的方案，最早萌发于1960年 Simula 语言；90年代被 Java 扭曲，“发扬光大”了。</p>
<p>OOP主要采用四个技术尝试解决<strong>上述问题</strong>：</p>
<ul>
<li>继承：实现代码复用和多态</li>
<li>封装：通过对象的内部状态实现</li>
<li>多态：通过继承实现</li>
<li>对象：维护内部状态和函数调用</li>
</ul>
<p>近40年的工程实践证明上述方案不合适，目前工业界普遍认为：</p>
<ul>
<li>组合+泛型：实现复用</li>
<li>模块：实现封装</li>
<li>函数一等公民：实现组合</li>
<li>Struct：维护状态</li>
<li>不可变性，Immutability</li>
</ul>
<p>是符合目前应用的方案。泛泛觉得这个趋势跟目前分布式系统、并发系统的流行有关系，在这些系统中，OOP举步维艰。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链和币圈的一些观察</title>
    <url>/2022/01/01/crypto_observation/</url>
    <content><![CDATA[<h2 id="一些观察"><a href="#一些观察" class="headerlink" title="一些观察"></a>一些观察</h2><h3 id="金融属性"><a href="#金融属性" class="headerlink" title="金融属性"></a>金融属性</h3><p>2021年区块链又火了一波，整个区块链总市值达到2万亿美金，整个币圈都在为NFT疯狂，比特币一度达到6万美金。上一次这种盛况还是在2017年，那时候比特币的达到2万美金，整个币圈在位空气币ICO疯狂。</p>
<p>这波币圈牛市主要是专业风投支撑的。请看下图，Solana 50%代币SOL被insider持有；Polkadot超过70%的代币被创造者和insider持有；Binance公链，超过50%；以太坊稍好，20%。比特币出初始代币发行没有机构接入，只是创始人自己挖矿，他有用多个账号，但是这些账号几乎没有太多动静，中本聪也销声匿迹了<a href="https://whale-alert.io/transaction/bitcoin/a922ec6d34e1a36cc935c7e9b37b5d8be826e11fb299a25d83285cc8b484e965">^4</a>。</p>
<p><img src="https://i.imgur.com/5YscdOk.png" alt=""></p>
<h3 id="共识算法、黑客和硬分叉"><a href="#共识算法、黑客和硬分叉" class="headerlink" title="共识算法、黑客和硬分叉"></a>共识算法、黑客和硬分叉</h3><p>2021年，第二大公链以太坊ETH准备做一次硬分叉，因为要更换共识算法，提高网络处理交易的容量，从 Proof of work，POW 到 Proof of stake，POS。当然，这不是ETH第一次硬分叉了，比2016年，以太坊漏洞被黑客利用，公链必须硬分叉修复Bug，老的ETH变成了ETH Classic。</p>
<p>在ETH完成POS更新后，几乎所有的智能合约平台都将采用POS系的共识算法。包括新秀智能合约平台Solana和Polkadot。</p>
<p>智能合约公链并不稳定，ETH屡次被黑客攻击，导致分叉<a href="https://medium.com/mycrypto/the-history-of-ethereum-hard-forks-6a6dae76d56f">^2</a>；新秀平台Solana，成块时间只有400ms（比特币大概10分钟），但是启动一年多的时间，网络瘫痪两次，其中一次主网掉线超过17小时<a href="https://solana.com/news/9-14-network-outage-initial-overview">^1</a>。比特币从2009年主网上线以来遭受多次攻击，但是没有导致主网掉线或者硬分叉<a href="https://en.wikipedia.org/wiki/List_of_bitcoin_forks">^3</a>。</p>
<h3 id="公链的参与者"><a href="#公链的参与者" class="headerlink" title="公链的参与者"></a>公链的参与者</h3><p>因为升级POS，想要参与公链挖矿（即为网络提供安全性），各大公链都提出了最小机器要求。也就是说，你无法用你的笔记本参与这个网络，你需要购买大型工作站。</p>
<p>我举个例子，Solana的节点最小需求<a href="https://docs.solana.com/running-validator/validator-reqs">^6</a>：12核心CPU + 128G内存。感受一下吧，这个网络把普通人排除在外了已经。</p>
<h3 id="Web1-2-3"><a href="#Web1-2-3" class="headerlink" title="Web1+2=3"></a>Web1+2=3</h3><p>Web3又又又又被重新定义了，这次是基于区块链和Token经济的，传递的主要精神是反抗Facebook这样的互联网公司，掠夺用户信息，用于生财。愿景是互联网用户自己掌握信息，自己生财。。Polkadot算是主要的推动者。</p>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>我们来分析这些观察的事实</p>
<h3 id="金融属性-1"><a href="#金融属性-1" class="headerlink" title="金融属性"></a>金融属性</h3><p>新兴公链，ETH2、Solana、Polkadot、Binance Chain，的代币绝大部分由资本市场和缔造者控制，这通常意味着，如果代币发行价格上涨，投资人的美金资产上涨，而上涨的动力就是后入场的其他散户。也就是说这些币种在上市之初已经充满庄家，庄家在了交易量不大的时候可以轻松做盘，基本上，庄家想让价格怎么走，价格就能怎么走就这么简单。</p>
<p>有小伙伴可能会问，那股票IPO不是一样的吗？确实，股票也有股东有庄家，但是有两个巨大的不同。其一，监管。股票市场的金融监管非常严格，做盘操作市场，是要蹲号子的；其二，利益。大部分公司上市是为了融资，更好的促进公司发展，公司是投资人的心血（当然，也有黑心的），即使他们是庄家，也不会轻易用手上的股票操盘，因为稳定的股价才是公司长远发展的核心。</p>
<p>然而，数字货币没有这两个东西。监管全无，特别是小币种，盘子就那么点，想怎么玩怎么玩；Insider不会想要赚长期的钱，他们希望快速翻倍，砸盘操盘是最好的手段了，比慢慢等待市场涨要快的多。</p>
<p>这其实解释了，为啥一个用着“上古”区块链技术的公链比特币，历经10几年，任你空气币怎么玩，仍然是市值第一，而且领先第二名ETH 两倍以上的市值。因为，还是明白人多一些，比特币由于没有初始代币发行，代币配置相对比较均匀，当然不乏庄家，但是这些庄家的币可不是白来的，要么是挖来，要么发币收来，成为庄家的成本很大，而且比特币的盘子太大了，操盘比较困难了。起码比其他代币困难。</p>
<h3 id="共识算法、黑客和硬分叉-1"><a href="#共识算法、黑客和硬分叉-1" class="headerlink" title="共识算法、黑客和硬分叉"></a>共识算法、黑客和硬分叉</h3><p>再看看共识算法，如今的主流声音是POS，就是Proof of stack，然后贬低POW，就是Proof of work。主要就是说POW环境不友好啊，效率不行啊之类。说白了就是黑比特币，又慢，又环境友好，又没有智能合约，不是图灵完备等等。</p>
<p>我就说一个事儿，你觉得中本聪傻到不会写图灵完备的公链？图灵完备听起来很牛逼，其实，只要支持跳转就是完备的。那为啥他不写？原因已经狠清楚了，你看看ETH和Solana被攻击的要么分叉、要么直接掉线，直接原因就是智能合约是图灵完备的！程序员都很清楚，只要是程序他就难免有Bug，图灵完备只会让公链更加容易出Bug。比特币不完备，但是他还真支持智能合约<a href="https://en.wikipedia.org/wiki/Smart_contract">^5</a>。</p>
<p>然后就是这个共识算法的问题。你觉得为啥所有的资本币，无一例外采用了PoS？</p>
<p>我稍微解释一下PoS，简单说就是，<strong>谁的币多</strong>，谁就更有可能成为下一个验证区块的节点。换句话说，下一个区块是谁来验证，在概率上是可以预测的。这里面两个问题，其一，谁的币多。还记得吗？资本家获得了巨大部分的初始代币，比如Solana，他的公链网络其实就是这些持币人控制的，因为他币多啊，他可以更高概率的验证区块啊；其二，这种预测性质，对黑客来说简直就是天堂。</p>
<p>反观比特币，POW，没有上述问题。事实很明显，比特币11年从未因为被攻击而硬分叉，难道是因为没有黑客愿意攻击吗？树大招风啊，只不过没人成功而已。</p>
<p>比特币有其他问题，比如低效。但是他真的去中心，且健壮。一会儿我会解释为啥这个特性这么重要，甚至超过了效率。</p>
<h3 id="Web1-2"><a href="#Web1-2" class="headerlink" title="Web1+2"></a>Web1+2</h3><p>概念挺好，但是如果建立在如今的新共连上，不想评论了，瞎扯淡的东西。举例，Polkadot就是为了推自己的币，然后用初始代币，套现走人。</p>
<h2 id="区块链的核心价值"><a href="#区块链的核心价值" class="headerlink" title="区块链的核心价值"></a>区块链的核心价值</h2><p>我认为，如今币圈已经跑偏了，当然这跟资本带方向很有关系。比如，比特币被贬低的一无是处。但是，市场不傻，比特币仍然是老大哥，为何？</p>
<p>这就要分析一下区块链最重要的核心价值：去中心。</p>
<h3 id="从概念说"><a href="#从概念说" class="headerlink" title="从概念说"></a>从概念说</h3><p>比特币网络提供了一个什么东西呢？提供了一个不依托于美金的价值交换系统。换句话说，他是一个世界币，只要参与人愿意，大家可以不通过美金或者其他法币进行交易和记账。而实现世界币的要点就是该网络不可以被任何中心控制；另外，网络要足够健壮，不可以掉线或被攻击。</p>
<p>目前，只有比特币做到了以上两点。你用个人电脑可以参与挖矿，你也可以用工作站，用GPU，或者矿机，但是无论如何，你都可以参与；没有组织或者机构可以轻易控制比特币网络，当然你可以控制超过51%的算力，其成本将会是巨大的。</p>
<p>而这个健壮的去中心公链，肯定不会被资本家和国家喜欢，因为国家和资本家剥削的主要工具就是货币！一个不受控制的货币是不能被接受的。</p>
<h3 id="从技术说"><a href="#从技术说" class="headerlink" title="从技术说"></a>从技术说</h3><p>从技术上说，区块链属于分布式系统，但是非常不一样，因为要容错、容许恶意节点，并且保持一致性。币圈有一个著名的三元悖论：可拓展、去中心、安全。每个公链最多只能实现两个为主，而比特币选择了去中心和安全。因为这两个是让数字货币脱颖而出的特征，而不是可拓展。</p>
<p>因为，区块链在这么拓展，性能也不会超过中心化数据中心，因为哪里没有恶意节点，效率才会最大化。现在新兴公链都在迁移POS，其实就是在渐渐放弃去中心化换取可拓展，这绝对是得不偿失，毫无意义。</p>
<h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p>如果你想投资币圈，很简单，买上比特币，存入自己的私钥地址，不要放在交易所里。然后，时间就会证明他的价值。</p>
<p>如果你想择时，那么比特币四年一个循环，增加难度。</p>
<p><img src="https://i.imgur.com/s89SJX5.png" alt=""></p>
]]></content>
      <categories>
        <category>Investing</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>国内如何提升GitHub访问速度</title>
    <url>/2021/12/31/github_speedup/</url>
    <content><![CDATA[<h2 id="使用镜像网站"><a href="#使用镜像网站" class="headerlink" title="使用镜像网站"></a>使用镜像网站</h2><p>可以用来现在下载github原版的的仓库：</p>
<ul>
<li><a href="https://ghproxy.com/">https://ghproxy.com/</a> </li>
<li><a href="http://toolwa.com/github/">http://toolwa.com/github/</a></li>
</ul>
<h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><p><a href="https://github.com/fhefh2015/Fast-GitHub">Fast-GitHub</a></p>
<h2 id="Gitee同步更新"><a href="#Gitee同步更新" class="headerlink" title="Gitee同步更新"></a>Gitee同步更新</h2><p>登陆 <a href="https://gitee.com/">Gitee</a> 账号，点击右上角的 + 号，点击「从 GitHub 导入仓库」，在跳转的页面中授权 Gitee 访问。</p>
<p><a href="https://gitee.com/help/articles/4284#article-header0">https://gitee.com/help/articles/4284#article-header0</a></p>
<h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><p>VPN开起来</p>
<p><a href="https://github.com/vpncn/vpncn.github.io">https://github.com/vpncn/vpncn.github.io</a></p>
]]></content>
      <categories>
        <category>FunCoder</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub怎么用 - 1 入门和检索</title>
    <url>/2021/12/28/github_1/</url>
    <content><![CDATA[<h2 id="GitHub·能干啥"><a href="#GitHub·能干啥" class="headerlink" title="GitHub·能干啥"></a>GitHub·能干啥</h2><p><code>GitHub</code>是通过<code>Git</code>进行 <em>版本控制</em> 的软件 <em>源代码</em> 托管服务平台。创建于2008年，最初的版本是 <code>Ruby</code> 完成的（啊，那时候正式Ruby on Rails的全胜时期）。目前拥有超过4000万用户（我觉得这是4000万程序员吧：&gt;），是目前最大的开源项目托管平台。</p>
<p>GitHub对于程序员来说意味着：</p>
<ul>
<li>代码相关<ul>
<li>代码仓库托管</li>
<li>代码阅读、学习</li>
<li>开源项目参与和学习</li>
<li>Devops</li>
</ul>
</li>
<li>打造个人IP<ul>
<li>博客</li>
<li>图床</li>
<li>写书</li>
<li>社交媒体</li>
</ul>
</li>
<li>资料库<ul>
<li>学习路线图</li>
<li>教程</li>
<li>电子书集合</li>
</ul>
</li>
</ul>
<p>这一篇，泛泛给大家聊聊如何利用GitHub获取资源和入门GitHub，以后会给大家具体讲讲上面提到的一些功能，比如如何实现博客、图床、写书、代码阅读等等。</p>
<h2 id="GitHub·如何检索资源？"><a href="#GitHub·如何检索资源？" class="headerlink" title="GitHub·如何检索资源？"></a>GitHub·如何检索资源？</h2><p>GitHub获取资源主要靠搜索和索引仓库。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>首先注册一个GitHub账号，只需要一个邮箱，就可以开启GitHub之旅了。访问 <a href="https://github.com/">https://github.com/</a> 会看到这样一个页面：</p>
<p><img src="https://i.imgur.com/1eTu38j.png" alt=""></p>
<p>具体的功能已经放在图例说明啦。需要注意的是，输入关键词后，会出现提示，注意观察：<code>All GitHub</code> 意味着从整个Github进行搜索，有时候可能会出现其他选项，比如 <code>搜索当前仓库</code>等等。</p>
<p><img src="https://i.imgur.com/qKfnD2W.png" alt=""></p>
<p>一般我们会得到如下结果，我们可以利用GitHub的选项进一步对结果进行筛选和排序，得到我们想要的结果。</p>
<p><img src="https://i.imgur.com/ZRljtqv.png" alt=""></p>
<h3 id="索引仓库"><a href="#索引仓库" class="headerlink" title="索引仓库"></a>索引仓库</h3><p>GitHub的搜索功能比较强大，但是肯定没有“人工”智能更加智能，因此我们需要找到相关主题的索引仓库。这些仓库一般是其他开发人员花时间精心整理的，一般汇集了更加实用和相关的仓库和文章。比如这个仓库（哈哈）包含了泛泛整理的量化交易相关的代码仓库和教程仓库：</p>
<p>![](<a href="https://i.imgur.com/6TCdJN9.png">https://i.imgur.com/6TCdJN9.png</a> =x300) </p>
<p>另外，推荐一个索引仓库 <a href="https://github.com/EvanLi/Github-Ranking">GitHub Ranking</a>，这里你可以查看GitHub上 Star最多、Fork最多、还有按照语言排序的仓库榜单等等。</p>
<p><img src="https://i.imgur.com/DY9f0kN.png" alt="GitHub Ranking"></p>
<p>上面可以找到非常实用的资源，比如 <a href="https://github.com/freeCodeCamp/freeCodeCamp">freeCodeCamp.org</a>，该项目有33万star，里面包含很多入门计算机、编程的教程，还可以在 Issue 区讨论和寻求帮助。</p>
<p>![freeCodeCamp.org](<a href="https://i.imgur.com/1rrd9eo.png">https://i.imgur.com/1rrd9eo.png</a> =x400)</p>
<p>当然，闲来无事，可以当抖音刷刷，经常会发现宝藏。比如这货 <a href="https://github.com/996icu/996.ICU/blob/master/README_CN.md">996.ICU</a>- 这仓库有26万star，是用来吐槽和黑名单那些黑心996企业的。</p>
<p>![996.ICU](<a href="https://i.imgur.com/P6fAPq3.png">https://i.imgur.com/P6fAPq3.png</a> =250x)<br>![](<a href="https://i.imgur.com/nY3tgFV.png">https://i.imgur.com/nY3tgFV.png</a> =400x)</p>
<h3 id="通过follow专家用户"><a href="#通过follow专家用户" class="headerlink" title="通过follow专家用户"></a>通过follow专家用户</h3><p>比如，你发现了一个仓库很好，然后你就可以看看他的作者，如果他是一个活跃的贡献者，你就可以follow他，接到他的动态。比如数据科学家： Nicolas P. Rougier，他持续的输出各种高质量的数据科学教程：</p>
<p><img src="https://i.imgur.com/IXHiEcc.png" alt=""></p>
<h2 id="GitHub·如何参与开源和社交"><a href="#GitHub·如何参与开源和社交" class="headerlink" title="GitHub·如何参与开源和社交"></a>GitHub·如何参与开源和社交</h2><p>GitHub是一个合作软件开发平台，一旦你找到了你感兴趣的项目，就可以通过GitHub提供的各种功能参与其中。我给大家举个例子，比如下面这个<a href="https://github.com/pola-rs/polars">Polars</a>。</p>
<p><img src="https://i.imgur.com/p2jLzbV.png" alt=""></p>
<p>Issues通常会被标记不同的tag，比如<code>Bug</code>,<code>Feature</code>,<code>Help Wanted</code>等等。通常想要开始贡献开源项目通常有如下几个情况：</p>
<ul>
<li>在使用过程中自己发现Bug，这时就可以自己提交Issue说明</li>
<li>认领已经存在的Issue，可以在相应的Issue下评论认领，然后提交PR。比如认领Bug或者认领Feature。</li>
</ul>
<p>通常，如果你对项目不是特别熟悉，也没发现什么明显的Bug，<code>help wanted</code> tag 的issue是开始贡献最好的起点。</p>
<h2 id="GitHub·基本使用方法学习"><a href="#GitHub·基本使用方法学习" class="headerlink" title="GitHub·基本使用方法学习"></a>GitHub·基本使用方法学习</h2><p>学习GitHub基本使用的<strong>最好</strong>方法是：<a href="https://lab.github.com/">GitHub Learning Lab</a>。 这个lab中有Github官方提供的制作精良的教程，而且是互动式，一步一步的教会你：</p>
<ul>
<li>认领一个issue</li>
<li>提交、关闭issue</li>
<li>创建一个branch</li>
<li>commit文件</li>
<li>开启一个新的Pull Request，即PR</li>
<li>回复、讨论PR的回复</li>
<li>合并你的PR</li>
<li>Git的基本使用</li>
</ul>
<p>推荐一个学习路径</p>
<ol>
<li><a href="https://lab.github.com/githubtraining/first-day-on-github">First Day on GitHub</a></li>
<li><a href="https://lab.github.com/githubtraining/first-week-on-github">First Week on GitHub</a></li>
</ol>
]]></content>
      <categories>
        <category>FunCoder</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>2021总结</title>
    <url>/2021/12/27/summary_2021/</url>
    <content><![CDATA[<h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><p>2021年，我是这样观察世界的：</p>
<ul>
<li>COVID-19</li>
<li>证券市场</li>
<li>Crypto<ul>
<li>金融属性</li>
<li>Web3 和 元宇宙</li>
</ul>
</li>
</ul>
<h3 id="Covid-19"><a href="#Covid-19" class="headerlink" title="Covid-19"></a>Covid-19</h3><p>一个代号19年的病毒，影响了整个2020年，也影响了整个2021年，想想有点后怕呢。也许，他还会继续影响2022年。</p>
<p>Covid-19在2021年经历了Delta，Omicron两个变种，从发病至今，世界范围内累积感染2亿人口，死亡4百万人。</p>
<p><img src="https://i.imgur.com/7XOBxYP.png" alt="COVID-19"></p>
<h3 id="证券市场"><a href="#证券市场" class="headerlink" title="证券市场"></a>证券市场</h3><p>虽然，Covid-19还在，但是今年却没有发生2020那样的股票市场“闪崩”，相反的标普竟然是大涨27%。</p>
<p><img src="https://i.imgur.com/dWpAetD.png" alt="SP500指数"></p>
<p>当然，这里不仅跟市场对Covid的态度有关系，也跟美联储的大放水分不开。看下图，从2020闪崩开始，美国10年国债利息一度降到近50年最低点：0.33%。随后，在2021年缓慢增加，可以预知，美联储在2022年仍然会继续加息。</p>
<p><img src="https://i.imgur.com/Gfrpc9b.png" alt="10年国债利率"></p>
<p>我通常用下面的这几个图来观察市场状态：标普、20年国债、黄金、日元、VIX。从目前的状态看，市场仍然比较兴奋，但是TLT的价格增加也意味着来年的大牛市应该不会出现了，不过经典的避险资产黄金和日元持续走低，证明资本还是Risk on的，VIM指标也比较正常。</p>
<p><img src="https://i.imgur.com/h8vDtXL.png" alt="我的市场晴雨表"></p>
<h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="金融属性"><a href="#金融属性" class="headerlink" title="金融属性"></a>金融属性</h4><p>Crypto已经成了一个不能忽略的“正经”金融产品了，这一年标普也启动了一系列Crypto指数，下图是Large cap Crypto指数，可以看到2021年，该指数获得了411%的收益，远远超过了股票市场。当然，其波动率也是非常可观，可以说是投机的绝佳·标的物。</p>
<p><img src="https://i.imgur.com/2BSUMGJ.png" alt="S&amp;P Cryptocurrency BDM Ex-LargeCap Index"></p>
<p>关于Crypto在投资组合中的作用，可以参考：<a href="https://wangzhe3224.github.io/2021/12/01/portfolio_with_crypto/">为什么你的投资组合需要Crypto？
</a></p>
<p>事实上，自从比特币期货在CBOE发行后，数字货币已经被主流金融机构接受了，2021年，第一个比特币ETF也发行了，标志着数字货币渐渐被被动投资人接受，从投机产品，逐渐过度到稳定的金融产品。</p>
<h4 id="Web3-和-元宇宙"><a href="#Web3-和-元宇宙" class="headerlink" title="Web3 和 元宇宙"></a>Web3 和 元宇宙</h4><blockquote>
<p>WTF is NFT？</p>
</blockquote>
<p>Crypto 经过了10年的发展，现在已经不仅仅具有金融属性（投机和投资），还需有一些社会属性。Web3 和 元宇宙 这些概念的相继提出，其实是一种变革价值交换体系的尝试。我不知道Web3 和 元宇宙 会走多远，会以什么形态呈现出来，我知道的是，社会有这样一种需求：变革价值交换体系。</p>
<p>现在的价值交换是通过什么呢？货币和银行。货币和银行是谁掌握的？国家和政府。国家和政府是谁掌握的？资本家。</p>
<p>区块链提供的价值交换是通过什么？Crypto和分布式账本。看起来很美好对吗？真正的民主胜利（去了解一下DAO）？其实不然，资本家不会放弃自己的对货币控制，国家如果没有对货币的控制，就好像壮汉断了一臂（另一只手臂是军队）。</p>
<p>那么，区块链就没未来了吗？也不是，因为区块链确实实现了去中心化，但是对应的代币（token）并没有。资本家可以控制代币，特别是当目前区块链技术由proof of work 像 proof of stake 过度后，掌握大量的代币就相当于控制了该代币的网络。</p>
<p><img src="https://i.imgur.com/SKCNKsI.png" alt=""></p>
<p>看一下这张图就知道，绝大部分网络的代币由投资人（即资本家）控制。特别是新兴的“第三代”区块链技术，比如Solana、Binance Chain，Polkadot。而这些区块链无疑都是POS，即只要你手握大量代币，你就是大概率成为Validator。而且，成为这些公链的验证节点，你需要购买强大的计算中心，普通的个人电脑是不能挖矿的，或者挖矿效率低下。</p>
<p>一个事实是：比特币。它是一个例外，第一个数字货币，至今仍然是POW，这就意味着控制比特币网络非常的困难。而且，比特币 没有 机构投资人参与，是一个完全的大众链。最后，比特币节点的门槛极低，个人电脑即可。</p>
<p>所以，Crypo肯定会在以后的很长一段时间存在，但是就其社会意义而言，只有比特币是独特的，而且他公链总归是资本家的工具。我个人看好整个区块链产业，因为其一，比特币提供了一种独特的价值交换方式，其二，资本家已经控制了大部分公链，不会很快放弃他们的。</p>
<h4 id="Crypto-与-Rust"><a href="#Crypto-与-Rust" class="headerlink" title="Crypto 与 Rust"></a>Crypto 与 Rust</h4><p>区块链的兴起也带动了技术的蓬勃发展，甚至盘活了新秀语言Rust。Rust一直是我关注的一个新兴语言，它改变了我对 System Programming 语言的看法。在Rust以前，提到 System Programming 语言，我只能想到 C/C++。但是这两个语言都是爷爷辈的语言了，以至于他们的问题都成了程序员的一种技能，要掌握。比如手动垃圾回收，如何避免悬垂指针、如何避免段错误等等。而Rust的出现改变了这个现状，Rust的编译器帮助程序员做了上面的工作，它的类型系统更加现代和强大，代数类型系统、模式匹配、内存管理模型都让系统编程变的非常舒服，而Rust的这些特性，我觉得会让他走出系统编程的领域，扩展到更加上层的应用。</p>
<p>而 区块链 的发展正是Rust的地盘。目前，主流的智能合约公链，比如Solana，Polkadot，都是围绕 Rust 构建的，甚至 ETH 也有这个想法，虽然目前ETH生态是以 Solidity 和 Go 为主的。</p>
<h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p>聊完世界，看看自己。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>这一年恐怕是我最痛苦的一年了，看到了世事无常，看到了生命的脆弱，经历这些反而让我更加看清这个世界的绝望，看清神对人的爱。靠着神，我们挺了过来，我希望我可以时刻用这段经历提醒自己，未来的盼望才是确实的，眼前的往往是虚幻的。（是的，与世界的看法背道而驰）。</p>
<p>教会渐渐恢复了下线聚会活动。今年夏天，我第一次站在讲台上<a href="https://www.gospelhome.org.uk/sermon/?sermon_id=691">布道</a>。虽然只是短短的讲道，我也体会到了专职传道人的不易。他们要花很多时间准备讲道内容，讲道结束还需要反思。</p>
<blockquote>
<p>你的“财宝”在哪里，你的心思和时间就在哪里。</p>
</blockquote>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><h4 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h4><p>修了<a href="https://www.cs.ox.ac.uk/softeng/courses/subjects.html">Msc in Software Engineering</a>的四门课，还需要再修3门就可以毕业啦。</p>
<ul>
<li>[Deep Neural Networks]</li>
<li>[Quantum Computing]</li>
<li>[Cloud Computing and Big Data]</li>
<li>[Design Patterns]</li>
</ul>
<p>但是，有一说一，计算机这个学科更多时间是靠自学的，而且自学起来非常轻松，因为网络上的资源非常丰富。</p>
<p>2021年是我自学计算机的第五个年头了，这一年大部分的学习时间仍然在基础知识上，花了大量的时间学习计算机的底层知识。列出比较成体系的文章系列如下：</p>
<ul>
<li><a href="https://github.com/wangzhe3224/Python-zhifou">Python知否 - Python进阶视频和与代码</a></li>
<li><a href="https://github.com/wangzhe3224/Python-zhifou/tree/master/src/design_pattern">重拾面向对象设计模式 - Python实现</a></li>
<li><a href="https://wangzhe3224.github.io/2021/02/16/python_1_gc/">重新认识Python系列</a>: 深入分析CPython虚拟机的内部原理，包括GC、GIL、二次开发、Cython的使用等等</li>
<li><a href="https://wangzhe3224.github.io/2021/03/06/pyos_1/">编程101 PyOS 一个Python写的OS</a>: 用Python讲述并发原理和操作系统调度系统</li>
<li><a href="https://wangzhe3224.github.io/tags/CSAPP/">重读CSAPP笔记</a></li>
<li><a href="https://wangzhe3224.github.io/categories/Leetcode/">重拾 Leetcode 系列</a> | <a href="https://github.com/wangzhe3224/leetcode_py">Leetcode In Python 仓库</a></li>
</ul>
<p>在开源社区，我准要参与了 <a href="https://github.com/bmoscon/cryptofeed">Cryptfeed</a> 这个仓库的共享，同时我在AWS部署了Crypto tick数据和Orderbook数据的记录器，记录主流货币和交易的数据信息，以备将来分析。</p>
<p>当然，读书是必不可少的：</p>
<ul>
<li><a href="https://wangzhe3224.github.io/2021/12/01/reading-soft-skill/">代码之外生存指南</a></li>
<li><a href="https://github.com/wangzhe3224/CSAPP-Lab">CSAPP</a></li>
<li><a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional</a></li>
<li><a href="https://github.com/wangzhe3224/books/blob/master/ProgrammingLanguages/Rust/Rust%20in%20Action%20by%20Timothy%20Samuel%20McNamara.pdf">Rust In Action</a></li>
<li><a href="https://github.com/wangzhe3224/books/blob/master/Design/Clean%20Architecture%20A%20Craftsman's%20Guide%20to%20Software%20Structure%20and%20Design.pdf">Clean Architecture</a></li>
</ul>
<h4 id="量化交易"><a href="#量化交易" class="headerlink" title="量化交易"></a>量化交易</h4><p>量化交易是我的本职工作，大部分的学习过程其实是在工作中进行的，在一次一次的debug中进行的。</p>
<p>产出：</p>
<ul>
<li><a href="https://wangzhe3224.github.io/categories/Quant/">一些列量化学习路线图</a></li>
<li><a href="https://github.com/wangzhe3224/awesome-systematic-trading">Awesome Systematic Trading: 一个量化交易开源软件资源的合集</a></li>
</ul>
<p>读书：</p>
<ul>
<li><a href="https://wangzhe3224.github.io/2021/12/22/quantitative_portfolio_management/">Quantitative Portfolio Management</a></li>
</ul>
<p>除了工作以外，主要是通过开源社区学习量化开源框架的设计模式和功能，尝试不同的框架，为将来的计划做准备。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><h4 id="主业"><a href="#主业" class="headerlink" title="主业"></a>主业</h4><p>今年的项目比较复杂，一个是关于 PnL归因的，一个是关于 投资组合优化的。收获还是蛮大。</p>
<p>明年会接受一个更大一些的项目，一个end to end的策略生产化。</p>
<h4 id="副业"><a href="#副业" class="headerlink" title="副业"></a>副业</h4><p>开启了自媒体之路！10月份开始做小红书和一些开源项目，虽然只做了两个月，但是感觉还是很有意思，可以分享自己的收获，为他人创造价值。</p>
<p>我的IP：泛程序员，泛泛，FunCoder</p>
<p>目前主要经营小红书，同时经营知乎、B站和油管。</p>
<h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><p>2021年我的高流动性投资组合回报率:</p>
<ul>
<li>杠杆类账户，权重 33%：14.17 % （木有跑赢标普500，哎）</li>
<li>现金类账户，权重 58%：8.7 %</li>
<li>Crypto，  权重  9%：60.2%</li>
</ul>
<p>加权平均收益：14.5 % (木有跑赢标普</p>
<p>波动率目标：15%</p>
<p>主要原因是，Cover call 花费太大了。。今年市场比我认为的要更加牛市。</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>关于生活</p>
<ul>
<li>意识可以决定物质，经常暗示你自己</li>
<li>关心你身边熟悉的人，起码比关心陌生人更关心他们</li>
</ul>
<p>关于学习和输出</p>
<ul>
<li>学习要有章法和框架，在框架中有目的填充内容，不可盲目学习</li>
<li>输出要有框架和目的性，确定框架后，分解成小任务，分别输出</li>
<li>学习和输出的内容最好是相对独立的，正交的内容，这样以前的产出就可以重新组合形成新的内容。（类似软件工程的组合原则）</li>
<li>学习其实一种投资，有时间成本，所以开始之前想要是不是符合自己的大计划；一旦选中，不要放弃，专注</li>
<li>一门技术，掌握20%的内容，就可以解决80%的问题，所以，首先识别20%的内容是什么？然后掌握它</li>
<li>学习的最高境界是教授，而教授可以为其他人创造价值</li>
</ul>
<p>关于专注力</p>
<ul>
<li>分解成小任务，使用番茄时钟，强迫自己有专注时间</li>
<li>记录自己的工作量，在回顾的过程中就可以更好的认识自己，而且对未来的工作量有更好的估计</li>
<li>一定要有自己的专精领域，不可多而不深，多没有问题，但是必须要有一个细分方向非常深入</li>
</ul>
<p>关于职业</p>
<ul>
<li>有意识的专精一个细分方向，比如我做量化交易，我专精股票交易，专精中长线策略</li>
<li>专精不代表不去了解其他内容，相反应该尽可能的了解其他相关方向，然后围绕自己的专精，拓展自己的知识和技能</li>
</ul>
<p>关于投资</p>
<ul>
<li>永远不要孤注一掷，多样性是免费的午餐，当然多样性也有代价</li>
<li>黑天鹅比想象中的更加频繁</li>
<li>市场不会按照你想的方向运行</li>
<li>没事儿不要看盘，计算机会帮你做这些事情</li>
</ul>
<h2 id="展望2022"><a href="#展望2022" class="headerlink" title="展望2022"></a>展望2022</h2><p>好好生活，多读圣经。</p>
<p>强化计算机基础知识，逐渐为业务专精和第二专精服务。比如熟悉量化交易框架、输出文章、代码、视频。</p>
<p>强化量化知识，逐渐形成自己的职业细分专精方向：股票量化交易。</p>
<p>开拓一个新的相关业务专精：Crypto量化交易。</p>
<p>进一步经营个人IP，为他人创造价值。</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Quantitative Portfolio Management</title>
    <url>/2021/12/22/quantitative_portfolio_management/</url>
    <content><![CDATA[<p>这是一本针对股票类资产的统计套利书，系统的描述了该类投资组合的交易：数据、Alpha生成、风险控制、成本控制、投资组合优化。</p>
<p>系统化交易 = 数据 + 模型</p>
<p>数据 = 收集 + 后处理</p>
<p>模型 = 预测模型 + 风险模型 + 花费模型 + 投资组合构成模型</p>
<p>预测模型 = Alpha + Alpha组合模型</p>
<p>风险模型 = 投资组合协方差 + 回撤 + Alpha协方差</p>
<p>花费模型 = 滑点 + 市场冲击</p>
<p>投资组合优化 = 目标 + Penalty + 约束</p>
<p>最后，还需要检测回测模拟和实盘交易之间的区别。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul>
<li>Tick and Bar</li>
<li>Corporate actions and Adjustment</li>
<li>How to compute “return”</li>
</ul>
<p>股票数据的特点，Corporate actions和调整因子以及回报率计算。</p>
<p>简化成两类：分红，D；拆分，S。</p>
<p>$adj_d = \frac{S_d}{1 - D_d/C_{d-1}}$</p>
<p>收益率计算分成凉了：算术回报率 和 对数回报率。<br>算术回报是横向可加，而算术回报率是竖向可加。</p>
<p>$$R_{log} = log(1 + R) = R - R^2/2 + \mathbb{O}(R^3)$$</p>
<p>算术收益率对投资组合优化比较有帮助，而对数回报率对Kelly公式比较有帮助。</p>
<h2 id="预测（Alpha）"><a href="#预测（Alpha）" class="headerlink" title="预测（Alpha）"></a>预测（Alpha）</h2><h3 id="预测的数据"><a href="#预测的数据" class="headerlink" title="预测的数据"></a>预测的数据</h3><ul>
<li>Point-in-Time，PIT and lookahead</li>
<li>Survival bias</li>
<li>Move the market, ie, market impact</li>
<li>ID mapping</li>
</ul>
<h3 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h3><p>对于股票，应该把他们按照Sector或者流动性进行分组，然后执行动量策略或者均值回归策略。<br>同时，最好不要混用ETF和个股的策略，因为他们的内在特性非常不同。</p>
<ul>
<li>均值回归</li>
<li>动量</li>
<li>成交量（Volume）<ul>
<li>有成交量支撑的趋势往往是动量，而没有成交量支持的趋势往往是均值回归</li>
</ul>
</li>
<li>统计指标<ul>
<li>Hurst exponent，分型指标，判断动量还是均值回归</li>
</ul>
</li>
<li>其他相关的不同类型资产</li>
</ul>
<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><h2 id="组合预测（Combine-Alpha）"><a href="#组合预测（Combine-Alpha）" class="headerlink" title="组合预测（Combine Alpha）"></a>组合预测（Combine Alpha）</h2><h3 id="相关性和分散"><a href="#相关性和分散" class="headerlink" title="相关性和分散"></a>相关性和分散</h3><p><img src="https://i.imgur.com/vhdJKHw.png" alt="分散度提升的极限"></p>
<h3 id="维度缩减"><a href="#维度缩减" class="headerlink" title="维度缩减"></a>维度缩减</h3><h3 id="Alpha-池管理"><a href="#Alpha-池管理" class="headerlink" title="Alpha 池管理"></a>Alpha 池管理</h3><blockquote>
<p>维护一个分散化的Alpha池，运行一个有效的组合算法，以及一个考虑花费的投资组合优化算法，这三者可能是最有效的量化模型了。<br>但是我们很难知道一个组合算法是否是最好的，有时候组合alpha的开销，可能达到了挖掘一个alpha开销的30%。</p>
</blockquote>
<p>Alpha开发的纲领：</p>
<ul>
<li>尽量使用PIT数据</li>
<li>预测时长和尺度</li>
<li>回报率的类型：实际回报、市场中性回报、因此残值或者引子回报。线性回报率还是指数回报率。</li>
<li>衡量预测准确性的指标：分布、MSE、相关性、残值的偏度</li>
<li>衡量预测不确定性的指标：置信区间？</li>
<li>与已有信号的相关性</li>
<li>过拟合的检查</li>
</ul>
<h3 id="Pnl-Attribution，回报率归因"><a href="#Pnl-Attribution，回报率归因" class="headerlink" title="Pnl Attribution，回报率归因"></a>Pnl Attribution，回报率归因</h3><p>Marginal attribution 和 regression-based attribution</p>
<h2 id="风险，Risk"><a href="#风险，Risk" class="headerlink" title="风险，Risk"></a>风险，Risk</h2><p>在量投资组合管理的背景下，风险（risk）一般被认为是PnL的波动和控制这种波动方法。最简单的风险指标是：Variance（方差）。不过方差本身也比较复杂，还有如下简化指标：</p>
<ul>
<li>VaR, Value at Risk，$VaR(p)$</li>
<li>CVaR, expected shortfall</li>
<li>drawdown</li>
</ul>
<h3 id="Factor-Model"><a href="#Factor-Model" class="headerlink" title="Factor Model"></a>Factor Model</h3><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><h3 id="Alpha-Risk"><a href="#Alpha-Risk" class="headerlink" title="Alpha Risk"></a>Alpha Risk</h3><h2 id="花费，Trading-Cost"><a href="#花费，Trading-Cost" class="headerlink" title="花费，Trading Cost"></a>花费，Trading Cost</h2><h2 id="投资组合构成，Portfolio-Construction"><a href="#投资组合构成，Portfolio-Construction" class="headerlink" title="投资组合构成，Portfolio Construction"></a>投资组合构成，Portfolio Construction</h2><h2 id="模拟，Simulation"><a href="#模拟，Simulation" class="headerlink" title="模拟，Simulation"></a>模拟，Simulation</h2><h6 id="tags-Sysytematic-Trading-Statistical-Arbitrage"><a href="#tags-Sysytematic-Trading-Statistical-Arbitrage" class="headerlink" title="tags: Sysytematic Trading Statistical Arbitrage"></a>tags: <code>Sysytematic Trading</code> <code>Statistical Arbitrage</code></h6>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Systematic Trading</tag>
        <tag>Statistical Arbitrage</tag>
      </tags>
  </entry>
  <entry>
    <title>如何选择下一个语言 - 续</title>
    <url>/2021/12/12/pick_next_language_2/</url>
    <content><![CDATA[<p>前不久写了一个小文 <a href="https://wangzhe3224.github.io/2021/12/07/pick_next_language/">如何选择（第一）下一个语言</a> 给大家提供了一种选择计算机语言的思路。那篇文章更多是从纯技术层面分析的，今天这一篇我来给大家提供另一种思路：生态和未来。</p>
<ul>
<li><a href="#为什么选择二外">为什么选择“二外”</a></li>
<li><a href="#选择一个什么样的二外">选择一个什么样的“二外”</a><ul>
<li><a href="#业务">业务</a></li>
<li><a href="#趋势和成本">趋势和成本</a></li>
<li><a href="#生态">生态</a></li>
</ul>
</li>
<li><a href="#写在最后">写在最后</a></li>
</ul>
<h2 id="为什么选择“二外”"><a href="#为什么选择“二外”" class="headerlink" title="为什么选择“二外”"></a>为什么选择“二外”</h2><p>大部分时候，我们选择第一门语言比较简单/被动，特别是在我们还没有什么技术审美和偏好的时候，无外乎：</p>
<ul>
<li>工作的公司用什么语言？</li>
<li>学校的课题组用什么语言？</li>
<li>大作业用什么语言？</li>
<li>行业标准用什么语言？</li>
</ul>
<p>举个例子，工作的公司基本用Python，数据相关的行业生态Python是主流，所以Python就理所当然的成了第一门语言。</p>
<p>可是，当我们进入一个行业一段时间，逐渐了解行业痛点，而且慢慢产生技术审美以后，就会产生选择第二门语言的需求和冲动。可能是因为行业本身就是混合多种语言，比如量化交易行业除了Python，还充满了大量Java和C++程序；也可能以为看到语言本身的限制，比如Python在某些情况下，性能成为瓶颈，需要结合其他语言进行混合编程，如 <code>Cython</code> 或者 <code>Rust</code> 之类；还有可能仅仅因为对其他技术和生态的好奇和审美，比如我觉得 <code>Rust</code> 很好的结合底层和强大的类ML类型系统，我不喜欢<code>Java</code>的啰嗦和虚拟机重量，就会选择 <code>Rust</code>。</p>
<h2 id="选择一个什么样的“二外”"><a href="#选择一个什么样的“二外”" class="headerlink" title="选择一个什么样的“二外”"></a>选择一个什么样的“二外”</h2><p>不过这里我们从另外的角度看看，选择第二个语言需要考虑那些问题（技术相关请看之前的<a href="https://wangzhe3224.github.io/2021/12/07/pick_next_language/">文章</a>）。</p>
<p>选择语言应该综合如下三个方面：业务、趋势、生态。不应单独考虑，而是综合考虑选择。</p>
<p>夹带私货 - 一个存放系统化交易业务相关库的仓库：<a href="https://github.com/wangzhe3224/awesome-systematic-trading">Awesome Systematic Trading</a></p>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>你的二外不应该完全脱离你的业务专精。比如你是做数据科学的，目前在使用<code>Python</code>，<code>Java</code>可能是你最好的二外，因为大数据的基础设施目前绝大部分是基于<code>Java</code>的，学习<code>Java</code>可以最大程度的帮助你，而选择 <code>C++</code> 可能就不是很合适。</p>
<p>在比如，我做系统化交易，Python是常用语言，但是经常会遇到性能瓶颈，需要混合编程，比如使用<code>Cython</code>或者<code>C</code>语言，那么<code>C</code>或者<code>C++</code>是一个不错的选择，因为可以直接服务我的业务痛点，而选择 <code>Java</code> 就不合适。</p>
<h3 id="趋势和成本"><a href="#趋势和成本" class="headerlink" title="趋势和成本"></a>趋势和成本</h3><p>计算机语言其实也有市场。选择第二门语言，其实是一种<strong>投资</strong>，有时间成本。是投资就要考虑回报，回报有长期和短期之分，但是无论如何都应该考虑语言的趋势。</p>
<p>在哪里看语言趋势呢？</p>
<ol>
<li><a href="https://www.tiobe.com/tiobe-index/">TIOBE Index</a></li>
</ol>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211212111029.png" alt="TIOBE Index"></p>
<p>上图列出了排名前五的语言的趋势图，C++，Java 都在走下坡路，Js在震动，Python显著增长。金融领域有个名词叫：趋势交易。就是假设过去看涨的股票，未来还会继续增长；反之亦然。</p>
<p>显然，单看趋势应该选择<code>Python</code>。那如果我已经是一个 Python程序员了，应该如何选择？继续看。</p>
<ol start="2">
<li><a href="https://insights.stackoverflow.com/survey/2021">Stack Overflow 调研报告</a></li>
</ol>
<p>Stack Overflow 是程序员的问答社区，每年它会做一个开发人员调研，会调研开发人员对不同技术、框架、语言的喜好程度以及他们的流行程度。</p>
<p>比如下面是程序员最爱的语言排行榜：</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211212114545.png" alt="Most loved languages"></p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211212114950.png" alt="Most wanted languages"></p>
<p>你看，你可能看到了一些“陌生”的名字：<code>Rust</code>, <code>Clojure</code>, <code>F#</code> 等等。而且Stack Overflow 还会告诉你：<code>Rust</code>已经连续6年是最爱的语言了（小知识 Rust 1.0 版本是2015年发行的）。而 <code>Python</code> 是程序员最想要学的语言，且连续5年都是如此。</p>
<p>这个调研中 <code>Rust</code> 和 <code>Python</code> 无疑是胜利者。</p>
<p>TIOBE Index排行中的前10名，<code>Java</code>, <code>C++</code>, <code>Js</code>，就好比蓝筹股，选择学习会不有太大问题，但是未来收益不一定可观；而<code>Rust</code>和<code>Go</code>这样的受欢迎语言就像小盘股，目前仍然相对小众，但是未来趋势良好，收益可观。</p>
<p>需要注意的是，学习“蓝筹股”语言成本可能较高，且不容易“出头”，因为他们通常已经存在了超过20年，拥有复杂的生态系统和错综复杂的历史包袱，有大量相关从业人员。而学习“小盘股”则可能成本较低，容易出头，你可以参与尚在起步阶段的项目，付出较小的成本，就有可能成为该领域的专家。</p>
<p>当然，与购买小盘股类似，学习这类语言需要承担风险，就是语言渐渐被社区和工业界抛弃了。</p>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><p>生态是另一个重要的考量指标。我举个例子，在web前端，<code>JavaScript</code> 占有统治地位，如果你做前端几乎没太多选择。虽然，从审美的角度看你有一些其他选择：<code>TypeScript</code>, <code>Reason</code> 等等，但是 JS 仍然他们的基础。</p>
<p>刨除上述特殊情况，应该根据判断一个语言的生态和特性，是不是可以应用到你正在从事的业务领域。包括：</p>
<ul>
<li>语言的特性是不是合适？</li>
<li>是不是已经有一些相关的探索项目？</li>
<li>是不是已经有用很多成熟的相关项目？</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>语言的审美也很重要，你需要找到一门自己写起来很舒服，或者自己觉得设计的很优雅的语言，而不是人云亦云。须知：任何领域深耕都会有所成就。</p>
<p>以上。<br>泛程序员</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Python</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>量化投资学习路线图 - 软件篇</title>
    <url>/2021/12/11/quant_trading_software/</url>
    <content><![CDATA[<p>继续 <a href="https://wangzhe3224.github.io/2021/12/04/quant_trading_books/">量化投资学习路线图 - 书籍篇</a>，本篇从代码和实现角度讲讲量化投资的学习路线图。一些思考，我放在最后。</p>
<p>注：量化交易、量化投资、系统化交易本篇按照同义词处理。</p>
<ul>
<li><a href="#主要目的">主要目的</a></li>
<li><a href="#开源框架">开源框架</a><ul>
<li><a href="#事件驱动-event-driven">事件驱动 (Event Driven)</a><ul>
<li><a href="#vnpy">Vnpy</a></li>
<li><a href="#backtrader">Backtrader</a></li>
<li><a href="#quantconnect">QuantConnect</a></li>
<li><a href="#hummingbot">Hummingbot</a></li>
</ul>
</li>
<li><a href="#向量驱动vectorized">向量驱动（Vectorized）</a><ul>
<li><a href="#vectorbt">vectorbt</a></li>
</ul>
</li>
<li><a href="#计算图computation-graph">计算图（Computation Graph）</a><ul>
<li><a href="#bt">bt</a></li>
<li><a href="#incremental">Incremental</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#关于目前开源框架的思考">关于目前开源框架的思考</a></li>
</ul>
<h2 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h2><p>量化交易的代码主要实现三个功能：回测分析、实盘交易、复盘分析。这里不展开讲，因为每一块内容都相对复杂，而且根据不同的策略，具体实现会大不相同。</p>
<p><strong>回测分析</strong>通过历史数据测试新策略的历史表现，分析一些基本的指标，比如Sharpe Ratio、回撤、杠杆、滑点等等。同时，回测也是策略参数选择的重要手段。显然，只有策略回测各方面指标达标后，才会考虑实盘交易。</p>
<p><strong>实盘交易</strong> 负责连接实际的交易商API，提交订单，并发执行数据反馈给策略进行处理；另外负责连接数据源（很多时候也是通过交易商API），把实时数据推送给策略进行处理；负责管理仓位信息。</p>
<p><strong>复盘分析</strong> 负责收集实盘交易过程中的各类日志，以备后续复盘分析之用。比如收集提交的订单数据和实际执行的订单数据。同时，这部分内容也会关系到如何Debug实盘交易系统，寻找问题根源。</p>
<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><p>开源社区有不少还OK的量化交易回测和实盘框架，但是值得注意的是，这些框架在复盘分析这个部分都比较羸弱。</p>
<p>从设计模式讲，量化交易软件可以分成两种类型：<code>事件驱动</code>和<code>向量驱动</code>。不过关于组织计算，其实还有一类非常优雅但是在量化开源领域比较小众的框架：<code>计算图</code> （Computation Graph）。</p>
<h3 id="事件驱动-Event-Driven"><a href="#事件驱动-Event-Driven" class="headerlink" title="事件驱动 (Event Driven)"></a>事件驱动 (Event Driven)</h3><p>事件驱动框架的计算是逐渐进行的，代码的核心是一个事件循环和一系列事件，用户需要实现不同的“回调函数”（Callback），比如：<code>on_order(order)</code> 用来处理订单事件，<code>on_tick(tick)</code>用来处理刚刚到来的tick数据等等。</p>
<p>这种框架的优势在于比较方便的模拟实盘交易过程，大部分实时交易系统都是事件驱动的，计算逻辑都是通过不同的事件回调函数实现的。比如处理蜡烛图的事件回调函数可以用来计算各种指标，然后可以生成一个信号事件，再由对应的函数处理，如此实现链式计算进行回测或者实盘交易。而且，设计良好的框架几乎不需要修改回测代码，就可以直接进行实盘交易，因为大部分逻辑已经写入回测过程了。</p>
<p>缺点就是，事件驱动框架通常回测速度较慢，因为在计算模式上属于路径依赖，只能一个事件一个事件地进行。</p>
<ul>
<li><a href="https://github.com/vnpy/vnpy">Vnpy</a></li>
<li><a href="https://github.com/mementum/backtrader">Backtrader</a></li>
<li><a href="https://github.com/QuantConnect/Lean">QuantConnect</a></li>
<li><a href="https://github.com/CoinAlpha/hummingbot">Hummingbot</a></li>
</ul>
<h4 id="Vnpy"><a href="#Vnpy" class="headerlink" title="Vnpy"></a>Vnpy</h4><p>Vnpy 是这里唯一一个国产框架，目前Github已经接近17k Star，做的非常成功。我大概是几年前开始关注这个框架的，看着他一点点重构，发展到现在的规模。社区也在欣欣向荣的发展。这个框架，最开始的时候主要以连接多个交易平台为目的，是实盘交易导向的，回测功能是后面慢慢发展起来的，功能比较有限。但是由于代码量不大，如果有时间自己拓展也是一个不错的选择。</p>
<p>这个框架最大的优势在于已经集成了很多国内常用的券商API，比如飞鼠、亿盛、中泰等等，几乎是开箱即用，做国内交易的小伙伴不要错过。</p>
<ul>
<li>推荐指数：3 星</li>
<li>回测类型：Event driven</li>
<li>回测速度：慢</li>
<li>实盘模拟：中</li>
<li>实盘支持：是</li>
<li>社区建设：非常好</li>
<li>组件灵活：好</li>
<li>是否开源：是</li>
<li>文档：好</li>
<li>语言：Python3</li>
</ul>
<h4 id="Backtrader"><a href="#Backtrader" class="headerlink" title="Backtrader"></a>Backtrader</h4><p>Backtrader, 是一款纯Python的回测+实盘框架。从软件工程的角度，这个项目非常值得学习。这个框架的代码风格非常 Pythonic，也值得借鉴和学习。作者是一个很严谨的德国人，从他的代码审查和社区管理可见一斑。backtrader允许您专注于编写可重复使用的交易策略，指标和分析器，而不必花时间构建基础架构。</p>
<p>我仔细研究过这个框架的源代码，作者软件工程功力不错，代码干净、架构合理，特别容易拓展。代码量并不大，元测试相对比较完善。得益与清晰的源代码，二次开发非常容易。</p>
<p>社区相对比较完整，参与度较高。作为一款没有任何商业支持的开源框架，我认为他做的非常成功。</p>
<ul>
<li>推荐指数：5 星</li>
<li>回测类型：Event driven 和 Vectorized</li>
<li>回测速度：中</li>
<li>实盘模拟：好</li>
<li>实盘支持：是</li>
<li>社区建设：好</li>
<li>组件灵活：非常好</li>
<li>是否开源：是</li>
<li>文档：非常好</li>
<li>语言：Python3</li>
</ul>
<h4 id="QuantConnect"><a href="#QuantConnect" class="headerlink" title="QuantConnect"></a>QuantConnect</h4><p>QuantConnect, 除了提供Web接口以外，还提供本地的SDK进行测试，代码已经开源：QuantConnect/Lean，核心的代码是C#完成的，但是提供F# 和 Python 的API。</p>
<p>Lean Engine是一个开源算法交易引擎，专为简单的策略研究，回溯测试和实时交易而构建。我们与通用数据提供商和经纪商集成，因此您可以快速部署算法交易策略。<br>LEAN引擎的核心是用C＃编写的;但它可以在Linux，Mac和Windows操作系统上无缝运行。它支持用Python 3.6，C＃或F＃编写的算法。QuantConnect的社区建设也很不错，结合相关的Web前端，交流比较方便。由于开放了本地SDK，你可以不必上传自己的策略，隐私保护方便比较完善。同时定制方便也更加优秀。</p>
<ul>
<li>推荐指数：3 星</li>
<li>回测类型：Event driven</li>
<li>回测速度：快</li>
<li>实盘模拟：好</li>
<li>实盘支持：是</li>
<li>社区建设：好</li>
<li>组件灵活：好</li>
<li>是否开源：是</li>
<li>文档：非常好</li>
<li>语言：C#，F#, Python</li>
</ul>
<h4 id="Hummingbot"><a href="#Hummingbot" class="headerlink" title="Hummingbot"></a>Hummingbot</h4><p>另外，还有一类比较特殊的事件驱动框架，就是<code>时间驱动</code>。这类框架系统会定期观察市场一次，然后由此引发后续计算和订单提交。Hummingbot 就属于这类框架，它每隔一段时间（1s默认）观察市场，得到样本价格（Sampling），然后进行计算。</p>
<p>框架采用 Python + C 实现，可以实现1s以下心跳策略。代码方面，很适合学习如何混合Python和C++编程以提升Python的性能，同时不牺牲Python的灵活性和生态环境。项目提供了一个酷酷的基于命令行的GUI进行交互。不要重复造轮子，也要谨慎使用轮子。这个框架是个不错的起点。</p>
<ul>
<li>推荐指数：4 星</li>
<li>回测类型：没有回测</li>
<li>回测速度：-</li>
<li>实盘模拟：-</li>
<li>实盘支持：是</li>
<li>社区建设：好</li>
<li>组件灵活：好</li>
<li>是否开源：是</li>
<li>文档：非常好</li>
<li>语言：Python + Cpp</li>
</ul>
<h3 id="向量驱动（Vectorized）"><a href="#向量驱动（Vectorized）" class="headerlink" title="向量驱动（Vectorized）"></a>向量驱动（Vectorized）</h3><p>向量驱动框架与事件驱动不同，计算模型主要以向量为基础，指标计算、仓位管理等等都是一多维向量的形式呈现。由于这种张量形式，策略的计算通常可以直接转化成张量计算，得益于我们已有的张量计算代码，速度惊人。</p>
<p>缺点也比较明显，就是策略代码不能直接接入实盘，因为实盘交易往往是事件驱动的。但是如果你的策略频率较低，手工实盘的话，这也不是大问题。</p>
<h4 id="vectorbt"><a href="#vectorbt" class="headerlink" title="vectorbt"></a>vectorbt</h4><p><a href="https://github.com/polakowo/vectorbt">vectorbt</a>，是目前我看到的向量回测框架中比较优秀的。这款框架不提供任何实盘交易功能，是一个纯回测平台。集成了Yahoo finance的数据源，开箱带有很多内置的信号指标，比如 ta-lib等等，同时由于是Python原生库，Python的数据科学生态，比如numpy，pandas，plotly，都可以完美接入。</p>
<p>由于大量使用了Numba进行JIT编译，vtbot的性能远远超越了经典时间序列分析库Pandas。从技术层面，vtbot是基于pandas的，但是通过定制化Accessor拓展了pandas的API，结合Numba，形成了一套运行效率极高的回测框架。从业务层面，绝大部分交易策略都可以被表达成向量的模式，进而实现向量计算；而具有路径依赖的策略，不能完全进行向量化，可以通过JIT实现性能提升。</p>
<p>缺点吗，就是处理路径依赖的策略确实没啥好办法；另外，跟所有向量化回测工具一样，很难模拟真实交易环境，无法像事件驱动回测框架那样灵活。不过，对于快速信号搜索、优化，这个包还是非常舒服,有兴趣的小伙伴可以一试。</p>
<h3 id="计算图（Computation-Graph）"><a href="#计算图（Computation-Graph）" class="headerlink" title="计算图（Computation Graph）"></a>计算图（Computation Graph）</h3><p>（悄悄de：机构玩家一般是这种模型）</p>
<p>计算图其实是把计算节点组织成DAG（Directed acyclic graph），就是有向无循环图。其实这种设计模式在大数据分析平台非常常见，比如Spark（类似向量驱动），Flink（类似事件驱动），都是采用了DAG作为组织和调度计算的主要模型。在这种模型中，每一个节点（node）负责根据自己的输入计算输出，然后把计算交给下一个以他的输出作为输出的节点，如此引发连式计算。正如Spark和Flink一样，计算图模型既可以是向量驱动也可以是事件驱动。</p>
<p>这种模型的优势在于可以很好的组织计算的依赖关系，重复利用已经完成的计算。这种优势在计算节点数量庞大的时候，会更加明显。而且，可以避免Callback Hell。这种模式的模块性能非常好，方便代码复用和测试，同时对计算机的进程可控性更高。</p>
<p>目前，我还没有见到这类开源框架，给大家推荐两个：</p>
<ul>
<li><a href="https://github.com/pmorissette/bt">bt</a></li>
<li><a href="https://github.com/janestreet/incremental">Incremental</a></li>
</ul>
<h4 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h4><p><a href="https://github.com/pmorissette/bt">bt</a> 是一个基于Python的回测框架，他的设计理念类似计算图，但是没有明确提出DAG的模型，而是一个Tree（还记得吗？Tree就是一种Graph）。</p>
<p>框架的核心节点是 <code>Algo</code>，每一个 Algo 就是一个小的计算逻辑，可以是波动率调整算法、投组组合优化算法，也可以是一个简单的选择标的函数。<code>Algo</code>可以进一步放在一起形成一个线性的<code>AlgoStack</code>。</p>
<p>另一个很精巧的设计是：<code>StrategyTree</code>。通过树状结构，可以随意把多个策略放在一起，利用AlgoStack连接形成一个新的策略。</p>
<p>也许你已经发现了，这种设计其实就是一种线性的计算图模型。</p>
<h4 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h4><p>Incremental采用Ocaml编写，框架提供了一种构建复杂计算的方法，而且计算图只会根据变化的数据出发必要的下游计算，而不会全部重新计算。</p>
<p>这个库来自世界最大的ETF做市商之一，JaneStreet。但是这个框架仅仅是提供了一个编写计算的工具，没有任何回测或者交易的功能，需要自己进行开发。</p>
<h2 id="关于目前开源框架的思考"><a href="#关于目前开源框架的思考" class="headerlink" title="关于目前开源框架的思考"></a>关于目前开源框架的思考</h2><p>目前市面上常见的开源框架以事件驱动为主，架构基本大同小异；而向量化框架较少，这可能是因为这类框架通常没有实盘功能，需要额外的开发工作进行实盘；而计算图模型基本处于缺失状态。计算图模型恰恰是专业的机构用户青睐的模型，而且计算图模型对复盘分析来说也有这个独特的优势，以后专门写个文章给大家分析。</p>
<p>其次，开源框架往往忽视了复盘分析这个重要部分，这是很大的问题。因为一个专业的量化交易策略不能缺少复盘和故障回溯分析。</p>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investment</tag>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>如何选择（第一）下一个语言</title>
    <url>/2021/12/07/pick_next_language/</url>
    <content><![CDATA[<p>如何选择你的第一门（或者下一门）计算机语言？这是一个重要的问题。</p>
<ul>
<li><a href="#选择语言">选择语言</a></li>
<li><a href="#硬件抽象层次">硬件抽象层次</a><ul>
<li><a href="#硬件直接抽象">硬件直接抽象</a></li>
<li><a href="#硬件独立抽象">硬件独立抽象</a></li>
<li><a href="#中级语言">中级语言</a></li>
<li><a href="#带复杂运行时的预言">带复杂运行时的预言</a></li>
<li><a href="#解释型语言">解释型语言</a></li>
<li><a href="#更高级的抽象">更高级的抽象</a></li>
</ul>
</li>
<li><a href="#语言的灵活度">语言的灵活度</a><ul>
<li><a href="#想干啥干啥">想干啥干啥</a></li>
<li><a href="#一些偶尔很烦人的约束">一些偶尔很烦人的约束</a></li>
<li><a href="#一些合理的约束">一些合理的约束</a></li>
</ul>
</li>
<li><a href="#写给选择第一门语言的人">写给选择第一门语言的人</a></li>
<li><a href="#写给选择下一门语言的人">写给选择下一门语言的人</a></li>
</ul>
<p>为什么重要？因为现在市面上的计算机语言太多了！看一下计算机语言指数，大家喜闻乐见的语言都不下10种了，且不说一些比较小众的语言。不花时间，我们很难弄清楚这些语言之间的区别，或者弄清楚那个语言更是我们的需求。这篇小文就尝试给大家一个选择语言的方向。</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211207153533.png" alt="计算机语言指数"></p>
<p>当然，也有很多时候，你并没有什么选择，你只能用你公司或者课程指定你用的语言 ：）</p>
<h2 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h2><p>当我们有一堆东西要选择的时间，最明智的做法是首先归类。谈到语言的归类，最先映入脑海的就是所谓”编程范式“。比如，我们经常听到：面向过程、面向对象、或者函数式等等。但是，一会儿我们就会发现，现代语言多数都是多范式的，不同范式之间的界限也没有那么明确。相反，现代计算机语言可能在抽象、生态上更加能够区分彼此，而不是范式。</p>
<p>在我们开始选择语言之前，还有一点我觉得值得说明，即<strong>所有的语言几乎都是等价的，他们可以做的事情是相同的</strong>，比如打印、计算、IO等等。他们不同的地方在于你可以如何做这些事情。比如有一些语言更加适合做数值计算，有一些语言更加适合做高并发网站后台，而另一些语言则适合做网页或者移动端应用。</p>
<p><strong>所以，在选择一个语言之前，最好先弄清楚你想做什么事情。</strong></p>
<p>以下我们从两个层面给语言分类，然后介绍每一个门类下面的特征和语言，也许在哪之后我们就可以选择我们”心仪“的语言了。</p>
<h2 id="硬件抽象层次"><a href="#硬件抽象层次" class="headerlink" title="硬件抽象层次"></a>硬件抽象层次</h2><p>市面上的语言可以按照他们对硬件的抽象程度做一个比较明确的分类，一般来讲如果一个语言暴露给程序员许多硬件层面的控制，比如内存、寄存器，这类语言我们称之为”低级语言“（Low level）；如果一个语言更多地隐藏了计算机硬件的属性，就成为”高级语言”（High Level）。显然，低级语言和高级语言没有好坏之分，他们提供了截然不同的硬件抽象层次。</p>
<p>通常，抽象是有性能代价的（速度或者内存），高级语言的性能低于低级语言。值得指出的是，即使是高级语言，在目前的硬件支持下，性能也足够满足大部分应用程序的需求了。这也是为什么在那个计算资源匮乏的时代（上个世纪80年代），大部分语言现在看起来都属于低级语言。</p>
<p>我们0抽象说起：</p>
<h3 id="硬件直接抽象"><a href="#硬件直接抽象" class="headerlink" title="硬件直接抽象"></a>硬件直接抽象</h3><p>在这个层次，硬件直接直接暴露给我们，<code>汇编语言</code>生活在这里。因为它几乎把每一个CPU指令都提供给你，你可以精确的控制CPU执行那个指令，访问内存的哪一个地址等等。你可以明确的告诉计算机，把这个整数存入存入内存的0xxxxx地址，然后把寄存器a的数字和寄存器b的数字相加，把结果存入寄存器c。</p>
<p>这种抽象级别的语言，<code>汇编</code>，通常用于非常底层的程序，比如操作系统的代码中你可能会看到一些汇编代码，再比如一些需要“榨干”机器性能的程序，例如视频解码程序。需要注意的是，汇编代码对不同的硬件架构，都是不一样的。通常一套代码只能运行在一类处理器或者硬件之上，不是很方便移植。</p>
<p><strong>你应该不会把汇编作为第一门语言</strong></p>
<p>代表语言：<code>汇编</code></p>
<h3 id="硬件独立抽象"><a href="#硬件独立抽象" class="headerlink" title="硬件独立抽象"></a>硬件独立抽象</h3><p>在这个级别的代表语言就是 The <code>C</code> Programming Language。这类语言，仍然出于低级语言的范畴，仍然可以对硬件进行直接的操作，比如它语言程序员自己管理内存的使用情况。但是这类语言已经比汇编语言跨出了重要的一步：加入了类型（描述内存里面装了什么东西）、函数（可以重复使用的代码）和循环（可以循环执行的代码）。</p>
<p>另一个重要的特点是，这类语言通常是<strong>编译型</strong>语言，即源代码会被<strong>编译器</strong>按照不同的平台和系统，编译成不同的二进制可执行文件。正式因为编译器，这类语言的源代码可以跨平台使用。</p>
<p>这类语言本身通常比较简单，仅提供很少的功能，运行性能比较稳定，基本上你写什么，他执行什么，很透明。而且，他们的运行性能通常非常高，与汇编有的一拼。而弊端就是，如果业务逻辑很复杂，你需要写很多代码，而且需要运用自己的大脑管理内存（我们并不是很擅长）。</p>
<p><strong>如果，你的使用场景对性能又很高要求，你可以选择这类语言</strong></p>
<p>代表语言：<code>C</code></p>
<h3 id="中级语言"><a href="#中级语言" class="headerlink" title="中级语言"></a>中级语言</h3><p>再增加一些抽象，我们就来到了“中级语言”。这类语言通常的特征是：</p>
<ul>
<li>闭包（Closure）：运行时的动态函数</li>
<li>半自动内存管理（运行时或者编译时）：智能指针（C++），引用计数（Swift）或者所有权（Rust）</li>
<li>更加复杂的类型系统：更好的实现代码复用，减少代码量<ul>
<li>泛型</li>
<li>多态</li>
</ul>
</li>
</ul>
<p><strong>如果你对性能有要求，同时希望做更加复杂的业务逻辑，增加代码的清晰度，可以选择</strong></p>
<p>这类语言包括：<code>C++</code>, <code>Swift</code>, <code>Rust</code></p>
<h3 id="带复杂运行时的预言"><a href="#带复杂运行时的预言" class="headerlink" title="带复杂运行时的预言"></a>带复杂运行时的预言</h3><p>进一步增加抽象，就需要语言提供一个自己的运行时系统（runtime），这就意味着你写好的源代码并不是最后执行程序全部，语言的运行时会跟你的代码一起运行，目的是为你提供方便，让你的代码写起来更加轻松。运行时的代表包括：垃圾回收期（GC），一个帮助你自动回收内存的程序；协程，比如Go的Goroutine，一个帮助你轻松并发的系统。当然，这些抽象跟中级语言中的抽象不同，他们有较大的性能花费（当然仅仅是相对的，这里谈到的花费通常是毫秒或者MB级别的内存）。他们带来的好处确实很大，比如GC可以大大减少处理内存的代码，同时可以避免内存管理错误（比如段错误）。</p>
<p>这类语言占据了编程语言的主流：<code>Java + JVM</code>, <code>Scala</code>, <code>Go</code>, <code>C# + .Net</code>, <code>Ocaml</code>, <code>Haskell</code></p>
<p><strong>如果，你不知道你的应用场景，多半你可以在这里挑一个。。</strong></p>
<h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>这类语言的性能比之前提到的语言会降低较多，但是好处是，这些语言可以一部分一部分的执行，即在运行过程中，可以进行更多动态的操作。这类语言写起来非常快，很容易就可以形成代码，而且运行时通常可以改编类型，这让编程变得特别轻松。不过，由于缺少编译器的帮助，这些语言更容易出现运行时的<br>Bug。</p>
<p>这类语言包括：<code>Python</code>, <code>Javascript</code>, <code>PHP</code>, <code>Ruby</code> …</p>
<p><strong>如果你关心快速实现程序，或者你需要他们的生态，选择解释类语言吧</strong></p>
<h3 id="更高级的抽象"><a href="#更高级的抽象" class="headerlink" title="更高级的抽象"></a>更高级的抽象</h3><p>当我们进一步抽象，我们的语言可以直接脱离硬件，只思考数据结构和算法问题。其实很多解释型语言也可以放在这个分类里面。不过这里我想说另一类语言：声明式语言。</p>
<p>之前提到的语言中，我们的程序往往给出一系列执行，告诉计算机我们希望如何一步一步执行程序，计算结果，而声明式语言中我们更强调描述我们希望进行那种计算，而把具体如何计算交给语言的运行时和编译器去完成。这种方式更加方便人类去思考，因此也可以减少错误和Bug，在某些情况下，这类语言的性能甚至可以跟中级语言一样好，因为编译器会进行优化。这类语言通常是带运行时的。</p>
<p>这类语言包括：<code>Haskell</code>, <code>Ocaml</code>, <code>F#</code>, <code>Lisp</code>, <code>SQL</code></p>
<h2 id="语言的灵活度"><a href="#语言的灵活度" class="headerlink" title="语言的灵活度"></a>语言的灵活度</h2><p>从抽象层面看语言，可以为我们选择语言提供一些指导。这里我们换一个维度看不同的语言，就是语言的灵活程度。声明，不是灵活度高就更好。</p>
<h3 id="想干啥干啥"><a href="#想干啥干啥" class="headerlink" title="想干啥干啥"></a>想干啥干啥</h3><p>这了语言不是很严格，你基本可以做你想做的任何事情。比如，你可以写 <code>x = 1 + &#39;s&#39;</code>，你的程序会开心的执行，但是有有可能出一个运行时bug，如果你没有定义如何把一个整数和一个字符相加的话。通常这类语言都是<strong>动态类型</strong>或者<strong>解释型</strong>，你可以一直通过 <code>运行 - 出错 - 修改 - 运行</code> 这样的循环快速的迭代程序，当然，当程序的变得越来越大，你会感觉力不从心，想要一个编译器。</p>
<p>这类语言：<code>Javascript</code>, <code>Ruby</code>。 也有一些稍微严格一点的：<code>Python</code>, <code>TypeScript</code>等等</p>
<h3 id="一些偶尔很烦人的约束"><a href="#一些偶尔很烦人的约束" class="headerlink" title="一些偶尔很烦人的约束"></a>一些偶尔很烦人的约束</h3><p>这类语言会给你增加一点约束，已免你写出明显有问题的代码。比如你定义了一个函数：<code>func(int, int) -&gt; int</code>，那么你就不能写 <code>func(1, &#39;2&#39;)</code>，编译器会不高兴，然后告诉你你错了。这类语言通常被称为：<strong>静态类型</strong>或者<strong>编译型</strong>。</p>
<p>这类语言：<code>Go</code>, <code>C/C++</code>, <code>Java</code>…</p>
<h3 id="一些合理的约束"><a href="#一些合理的约束" class="headerlink" title="一些合理的约束"></a>一些合理的约束</h3><p>有一些语言会提出更加多的约束，不仅仅为了避免类型错误，还会试图避免一些可能的运行时错误。比如，<code>Rust</code>，默认不运行改变变量的值，除非你明确的说你要改变它，以防止不必要的问题；Rust还会检查你的内存管理是不是合理等等。</p>
<p>这类语言包括：<code>Rust</code>, <code>Haskell</code>, <code>Ocaml/F#</code>, <code>Swift</code> </p>
<h2 id="写给选择第一门语言的人"><a href="#写给选择第一门语言的人" class="headerlink" title="写给选择第一门语言的人"></a>写给选择第一门语言的人</h2><p>如果你刚刚接触编程，也不知道未来想要做什么样的程序，选择一个语言挺难的。不过，如果你觉自己希望花些时间好好学习计算机，我建议你学习一个低级语言，比如 <code>C</code>，因为他会帮助你理解计算机硬件和程序之间的关系，为你以后的学习打好基础，比如操作系统。当然，如果你有一些工科背景或者数学背景，希望通过编程快速的做一些事情，那么可以选择一个高级语言，比如 <code>Python</code>。</p>
<p>还有一个选择语言的维度是：生态。我举个例子，机器学习。大部分的机器学习生态都是围绕Python建立的，那么学习Python就是你最好的选择了。</p>
<h2 id="写给选择下一门语言的人"><a href="#写给选择下一门语言的人" class="headerlink" title="写给选择下一门语言的人"></a>写给选择下一门语言的人</h2><p>只有一条建议：选择一个不是你熟悉的分类下的语言学习。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
  </entry>
  <entry>
    <title>如何成为 Quant Dev 2 - 技能树</title>
    <url>/2021/12/05/quant_dev_path_2/</url>
    <content><![CDATA[<p>上一篇文章介绍了量化对冲基金中程序员的分类和职能，其中 <code>Quant Dev</code> 是量化对冲基金的核心业务开发人员，所以这一篇我们重点讨论 Quant Dev 的要求、技能和学习路径。</p>
<ul>
<li><a href="#总体要求">总体要求</a></li>
<li><a href="#技能树">技能树</a><ul>
<li><a href="#合格的程序员">合格的程序员</a></li>
<li><a href="#量化">量化</a></li>
</ul>
</li>
<li><a href="#学习路径">学习路径</a><ul>
<li><a href="#计算机学习">计算机学习</a></li>
<li><a href="#量化学习">量化学习</a></li>
</ul>
</li>
</ul>
<h2 id="总体要求"><a href="#总体要求" class="headerlink" title="总体要求"></a>总体要求</h2><p>Quant Dev 首先得是一个合格的开发者，然后需要对业务有比较深刻的理解。<strong>Quant Dev 是连接策略思想和自动化交易的桥梁</strong>，不同的策略对软件的要求也不尽相同，有一些策略，比如高频策略，对计算机底层技能的要求更高；而另一些策略，比如中低频策略，对软件架构和软件工程要求更高。</p>
<p>因此，一个好的 quant dev：</p>
<ul>
<li>首先是一个合格的程序员</li>
<li>然后根据不同的策略类型，深入理解模型和执行特性等业务逻辑。</li>
<li>对计算机和量化充满热情 &lt; — 这是最重要的</li>
</ul>
<h2 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h2><p>知道了2个需求，我们看一下技能树。</p>
<h3 id="合格的程序员"><a href="#合格的程序员" class="headerlink" title="合格的程序员"></a>合格的程序员</h3><p>关于这个我做过另一起视频（文章）讲解。这里总结必备基础技能如下：</p>
<ul>
<li>计算机组成原理</li>
<li>操作系统</li>
<li>数据库原理</li>
<li>计算机网络</li>
<li>计算机语言和编译原理</li>
</ul>
<p>多说点，计算机语言方面：</p>
<ul>
<li>经典语言：Python | Java/C# | C++</li>
<li>更加现代的语言： Go | Rust</li>
<li>极客公司：Ocaml | F# | Clojure</li>
</ul>
<p>关于语言的选择，一定要有自己的“灵魂”语言，即这门语言可以做到精通：掌握基本的语法，可以流畅写出适合该语言代码风格的程序，熟悉语言的生态圈（库和框架），了解语言背后的逻辑（虚拟机、垃圾回收、编译器等等）。</p>
<p>绝大部分公司的技术栈都是比较单一的（这是好事情），你的灵魂语言可能决定了你可以去哪家公司。当然这不是绝对的，一个好的程序员应该可以在短时间适应一个新的语言。尽管如此，精通一门语言会让学习其他语言更轻松。</p>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>这部分属于业务相关技能，跟从事的量化策略分类有很大关系，所以应该根据自己所处的公司选择。</p>
<p>当然还是有一些共通的技能：</p>
<ul>
<li>基本的概率论和统计</li>
<li>基本的线性代数</li>
<li>基本的金融市场基础知识</li>
<li>基本的量化交易基础知识</li>
</ul>
<p>这些共通技能之后，就要根据自己的领域，选择专精了。比如高频、做市、期货、股票等等。</p>
<h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><h3 id="计算机学习"><a href="#计算机学习" class="headerlink" title="计算机学习"></a>计算机学习</h3><p>可以参考我之前关于转行计算机的视频（文章），里面有推荐书籍和课程。</p>
<p><a href="https://wangzhe3224.github.io/2021/10/20/roadpath/">如何转行计算机做程序员</a></p>
<h3 id="量化学习"><a href="#量化学习" class="headerlink" title="量化学习"></a>量化学习</h3><p>这里我推荐一些书籍和课程，当然主要是针对上面提到的基础知识部分，因为专精的部分我只能根据我自己的领域推荐了，以后会专门给大家讲。</p>
<p>以下是一些量化基础知识：</p>
<p><a href="https://wangzhe3224.github.io/2021/12/04/quant_trading_books/">量化投资学习路线图 - 书籍篇</a></p>
<p>基本的数学知识：</p>
<ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/">Mathematics for Computer Science</a></li>
<li><a href="https://linear.axler.net/">Linear Algebra Done Right</a></li>
<li><a href="https://ocw.mit.edu/courses/mathematics/18-700-linear-algebra-fall-2013/index.htm">Linear Algebra</a></li>
</ul>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Hedge Fund</tag>
        <tag>Quant</tag>
      </tags>
  </entry>
  <entry>
    <title>量化投资学习路线图 - 书籍篇</title>
    <url>/2021/12/04/quant_trading_books/</url>
    <content><![CDATA[<p>从业人员，利益无关。推荐一下我走的路线。这些书都是实际从业老兵写的，内容都是实打实的，经过实践检验的，而不是纸上谈兵。书中都有详细的代码和数据供读者检验和学习。<br>空谈的、哲学炒股、玄学交易的书趁早别看。</p>
<p>具体书评，我放最后了。小红书  泛程序员  更多精彩量化交易和编程分享！</p>
<ul>
<li><a href="#路线">路线</a><ul>
<li><a href="#入门ernest-p-chan的两本早期经典">入门：Ernest P. Chan的两本早期经典</a></li>
<li><a href="#进阶-robert-carver-的两本经典">进阶： Robert Carver 的两本经典</a></li>
<li><a href="#实战新书-python-for-algorithmic-trading-from-idea-to-cloud-deployment2021">实战新书 Python for Algorithmic Trading: From Idea to Cloud Deployment（2021）</a></li>
<li><a href="#量化的基础efficiently-inefficient-how-smart-money-invests-and-market-prices-are-determined">量化的基础：Efficiently Inefficient: How Smart Money Invests and Market Prices Are Determined</a></li>
</ul>
</li>
<li><a href="#书评">书评</a><ul>
<li><a href="#quantitative-trading-how-to-build-your-own-algorithmic-trading-business">Quantitative Trading: How to build your own Algorithmic Trading Business</a></li>
<li><a href="#algorithmic-trading-winning-strategies-and-their-rationale">Algorithmic Trading: Winning Strategies and Their Rationale</a></li>
<li><a href="#systematic-trading-a-unique-new-method-for-designing-trading-and-investing-systems">Systematic Trading: A unique new method for designing trading and investing systems</a></li>
<li><a href="#smart-portfolio-a-practical-guide-to-building-and-maintaining-investment-portfolios">Smart Portfolio: A practical guide to building and maintaining investment portfolios</a></li>
</ul>
</li>
</ul>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><h3 id="入门：Ernest-P-Chan的两本早期经典"><a href="#入门：Ernest-P-Chan的两本早期经典" class="headerlink" title="入门：Ernest P. Chan的两本早期经典"></a>入门：Ernest P. Chan的两本早期经典</h3><p>特别适合没有经验的小伙伴，因为作者都是从最基础的内容讲起来，逐渐增加难度，非常有体系。读完后，对整个量化交易行业的交易策略和具体实施会有更加深刻、全面的认知。</p>
<ul>
<li>《Algorithmic Trading: Winning Strategies and Their Rationale》</li>
<li>《Quantitative Trading: How to Build Your Own Algorithmic Trading Business》</li>
</ul>
<h3 id="进阶：-Robert-Carver-的两本经典"><a href="#进阶：-Robert-Carver-的两本经典" class="headerlink" title="进阶： Robert Carver 的两本经典"></a>进阶： Robert Carver 的两本经典</h3><p>Robert是退休前在老牌量化对冲基金 Man AHL (AHL 目前管理超过400亿美金的资产) 做交易员，经历过两次金融危机，可以说是身经百战的老兵。所以他的书，没有花里胡哨的内容，直接给出量化交易的精髓：系统构建。Robert在书中特别强调自顶向下的量化模型，即首先构建框架，再去纠结细节。适合对量化交易感兴趣的各个阶段的小伙伴，特别是对于新手，这是两本好书。因为量化这个行业充斥着大量水平较低的书籍，会误导刚刚接触的小伙伴。</p>
<ul>
<li>《Systematic Trading: A unique new method for designing trading and investing systems》</li>
<li>《Smart Portfolio: A practical guide to building and maintaining investment portfolios》</li>
</ul>
<h3 id="实战新书-Python-for-Algorithmic-Trading-From-Idea-to-Cloud-Deployment（2021）"><a href="#实战新书-Python-for-Algorithmic-Trading-From-Idea-to-Cloud-Deployment（2021）" class="headerlink" title="实战新书 Python for Algorithmic Trading: From Idea to Cloud Deployment（2021）"></a>实战新书 Python for Algorithmic Trading: From Idea to Cloud Deployment（2021）</h3><p>这是一本实践性很好的关于算法交易的书籍。作者由浅入深的描述了如何形成一个交易策略，如何把这个策略部署在云端的基础设施上进行交易。本书成书2020年，内容与时俱进。</p>
<p>作者在前言这样写道：近些年随着开源软件、数据、云计算平台以及券商API的普及，算法交易早已不是只有机构用户才能参与的游戏了，散户和小投资人都可以利用这些资源进行自己的算法交易。我很认同他的说法，特别是数字货币领域，我自己的算法就部署在AWS上，而数字货币的实时数据甚至都是免费提供的，大家可以轻易免费获得2级订单部数据，进行交易。</p>
<p>这本书很适合初学者，特别是有一点点Python经验的，对算法交易感兴趣的小伙伴。因为这本书的每一个章节都有对应的notebook代码进行说明，这些代码都开源在Github，大家可以在本书的Github仓库找到对应的代码，学起来非常轻松且实用。我觉得更贴心的是，作者还简单介绍了一些策略部署的问题，如何使用docker，如何使用队列中间件比如ZeroMQ，以及如何连接券商API，如何进行实际交易等实践性质的内容。这些内容，往往是其他算法交易书籍所缺乏的，我读到的大部分书籍都仅仅关注策略和统计，忽略了这个非常重要的实践部分，而这个部分恰恰是算法交易落地交易的重要一环。从我自己的经验看，策略往往是简单的，而策略的实现和运行往往需要花费更多的精神（哈哈，其实Quant Dev的工作便是如此）。</p>
<p>从策略角度说，本书更适合初学者，策略本身都是基础策略，更强调如何落地实现。比如如何搭建回测框架，如何搭建数据源等等。总而言之，是一本不可多得的好书。</p>
<h3 id="量化的基础：Efficiently-Inefficient-How-Smart-Money-Invests-and-Market-Prices-Are-Determined"><a href="#量化的基础：Efficiently-Inefficient-How-Smart-Money-Invests-and-Market-Prices-Are-Determined" class="headerlink" title="量化的基础：Efficiently Inefficient: How Smart Money Invests and Market Prices Are Determined"></a>量化的基础：Efficiently Inefficient: How Smart Money Invests and Market Prices Are Determined</h3><p>一本有关量化投资策略的好书，作者在学术圈和工业界都有很好的口碑，跟著名的资管公司AQR有着各种渊源，所以，这本书的内容即涵盖了许多学术观点，但也通俗易懂。<br>全书分为四部分，第一部分主要讲解投资策略的回测与衡量；第二部分主要讲股票方面的策略；第三部分讲解资产配置与宏观策略；第四部分讲解套利策略。每章节最后都有一个相关对冲基金经理的采访。</p>
<p>这本书适合对量化投资领域感兴趣的小伙伴，可以对这个行业有比较全面的认识。但是这本书总体来说比较偏重概念，实践性的内容较少。</p>
<h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2><h3 id="Quantitative-Trading-How-to-build-your-own-Algorithmic-Trading-Business"><a href="#Quantitative-Trading-How-to-build-your-own-Algorithmic-Trading-Business" class="headerlink" title="Quantitative Trading: How to build your own Algorithmic Trading Business"></a>Quantitative Trading: How to build your own Algorithmic Trading Business</h3><p>这是一本来自2009年的“老”书了，全文只有200页，言简意赅。如果你对量化交易感兴趣，却不知道从哪里下手，这本书很合适。<br>我对这本书有着特殊的情感，因为这是我入行量化读的第一本书，帮助我构建了最早的框架。而且作者身体力行地回答了一个基本问题：个人量化交易可以成功吗？（可以，不然意义何在？）<br>这本书适合谁呢？主要适合两类人：</p>
<ol>
<li>个人交易员，想要从0开始自己的量化交易生涯</li>
<li>学生，想要进入量化交易领域，开始自己的量化交易职业生涯</li>
</ol>
<p>这本书讲了什么呢？这本书的重点不在于策略，而是量化交易的组成部分。作者试图告诉读者如何自己去寻找盈利的策略，如何评估一个策略的好坏、如何回测、如何确保策略在实盘后仍然盈利等等。主要内容如下：</p>
<ul>
<li>量化交易的3w（What/Who/Why)</li>
<li>如何寻找、发现好的策略</li>
<li>回测的基本要领</li>
<li>量化交易的一些准备</li>
<li>执行系统</li>
<li>资金和风险管理</li>
<li>一些常见的策略类型</li>
<li>结论：个人量化交易可以成功吗？</li>
</ul>
<p>最后一个问题很有意思：个人做量化交易可能成功吗？作者通过自己和其他一些个人交易员的真实经历给出了肯定的答案。他也点出了这中间的要害：资金容量。一个10万美金的账户比一个1亿美金的账户更容易产生高的Sharpe。当然这句话我是在机构做了几年量化后，才有更深刻的体会，当初学习的时候并没有真正体会到这句话背后的意义。</p>
<h3 id="Algorithmic-Trading-Winning-Strategies-and-Their-Rationale"><a href="#Algorithmic-Trading-Winning-Strategies-and-Their-Rationale" class="headerlink" title="Algorithmic Trading: Winning Strategies and Their Rationale"></a>Algorithmic Trading: Winning Strategies and Their Rationale</h3><p>这是Chen的第二本关于量化交易的书，这本书更加关注策略的测试和逻辑。这是读完《Quantitative Trading》后最好的选择。虽然本书名为算法交易，但是并不是指订单执行算法，而是指系统化交易。</p>
<p>这本书主要分成四个大部分：</p>
<ul>
<li>回测和自动化执行</li>
<li>均值回归类策略</li>
<li>趋势类策略</li>
<li>风险控制</li>
</ul>
<p>基本上涵盖了经典的基于价格和成交量数据的策略类型，作者详细解释了每个策略的数学统计模型和实现方法，最后讲述了一些常见的风险控制工具，比如杠杆优化（凯利公式）、风险指标、止损以及回撤控制。</p>
<p>这本书很适合对量化交易一无所知的小伙伴或者刚刚入行的小伙伴，因为作者介绍了这个行业最基本的一些策略，这些策略特别适合流动性较好的标的物，比如股票、ETF、期权和期货。因为这些标的物市场份额最大，而且流动性好且容易接触和交易，实盘操作不容易出现问题。比如流动性突然消失、或者交易自己完全不懂的产品（比如加密货币）。</p>
<p>作者也回答了一个“致命”问题：为什么要分享这些策略？如果真的可以盈利，为何要分享？这些策略和知识并不是要你直接真金白银的直接进行交易，而是提供一个基础的框架，在此基础上逐步完善，比如选择不同的标的物、不同的模型、不同的资金容量等等，但是大框架不会变化，这就是所谓一般知识。而且，比如趋势策略，已经是人尽皆知的策略了，但是仍然可以产生收益。至于为什么会这样，似乎没有人可以说清楚。</p>
<h3 id="Systematic-Trading-A-unique-new-method-for-designing-trading-and-investing-systems"><a href="#Systematic-Trading-A-unique-new-method-for-designing-trading-and-investing-systems" class="headerlink" title="Systematic Trading: A unique new method for designing trading and investing systems"></a>Systematic Trading: A unique new method for designing trading and investing systems</h3><p>此书作者是退休前在老牌量化对冲基金 Man AHL (AHL 目前管理超过400亿美金的资产) 做交易员，经历过两次金融危机，可以说是身经百战的老兵。所以他的书，没有花里胡哨的内容，直接给出量化交易的精髓：系统构建。Robert在书中特别强调自顶向下的量化模型，即首先构建框架，再去纠结细节。</p>
<p>尽管如此，Robert在书中给出了实打实的实现量化交易框架的细节，提出了一些交易理论，但是他没有纸上谈兵。他甚至开源了自用的代码（以后给大家讲讲这个），这套代码可以实现书中的所有细节，当然也包含了更多额外的功能。</p>
<p>这本书适合对量化交易感兴趣的各个阶段的小伙伴，特别是对于新手，这是一本好书。因为量化这个行业充斥着大量水平较低的书籍，会误导刚刚接触的小伙伴。</p>
<h3 id="Smart-Portfolio-A-practical-guide-to-building-and-maintaining-investment-portfolios"><a href="#Smart-Portfolio-A-practical-guide-to-building-and-maintaining-investment-portfolios" class="headerlink" title="Smart Portfolio: A practical guide to building and maintaining investment portfolios"></a>Smart Portfolio: A practical guide to building and maintaining investment portfolios</h3><p>这是另一本来自 Robert Carver 的关于个人投资框架的书，这本书朴实无华的回答了三个问题：</p>
<ol>
<li>应该投资什么资产？</li>
<li>每个资产应该投资多少？</li>
<li>如何调整投资组合？</li>
</ol>
<p>书中详细的给出了一套系统的选择、计算、调整投资组合的框架，贯彻着自顶向下的理念。作者从基本问题出发，通过逐一回答这些问题，逐步构建投资组合框架。总体来说，这本书适合个人投资者，科学合理的构建稳健的投资组合，同时告诉读者如何在这个框架中植入自己的新想法，比如新的策略、对某个股票或者资产的观点。</p>
<p>如果你手上有多余的现金，不知道如何科学投资，就从这本书开始吧。Robert不是那种股评人，而是真正在市场中经历风雨的作者，他写的东西我觉得都是从实践中总结的，而不是纸上谈兵。</p>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investment</tag>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么你的投资组合需要Crypto？</title>
    <url>/2021/12/01/portfolio_with_crypto/</url>
    <content><![CDATA[<blockquote>
<p>本文送你一个 Sharpe Ratio 2.0 的简单投资组合 + 源代码</p>
</blockquote>
<ul>
<li>量化分析</li>
<li>基本面分析</li>
</ul>
<h2 id="量化分析"><a href="#量化分析" class="headerlink" title="量化分析"></a>量化分析</h2><p>先给我们的讨论定个调调。假设我们的benchmark是一个按月再平衡的投资组合: SPY + TLT + GLD。就是一个股票、债券、黄金的组合。每月按照波动率取逆确定权重，即波动率调整。具体可以看我之前的文章(<a href="https://zhuanlan.zhihu.com/p/249909117">https://zhuanlan.zhihu.com/p/249909117</a>)。</p>
<p><strong>总而言之，无他：低相关 + 正期望 = 成功的投资组合</strong></p>
<p>可以看到，我们的基准是 sharpe 1 年化 8% 的策略，这个策略只有三个ETF，每个月rebalance一次。</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211130224840.png" alt="SPY + TLT + GLD"></p>
<p>以下是一些投资组合的统计指标：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Stats for classic from 2014-09-15 00:00:00 - 2021-11-29 00:00:00</span><br><span class="line">Annual risk-free rate considered: 0.00%</span><br><span class="line">Summary:</span><br><span class="line">Total Return      Sharpe  CAGR    Max Drawdown</span><br><span class="line">--------------  --------  ------  --------------</span><br><span class="line">82.83%              1.06  8.73%   -13.77%</span><br><span class="line"></span><br><span class="line">Annualized Returns:</span><br><span class="line">mtd    3m     6m     ytd    1y     3y      5y      10y    incep.</span><br><span class="line">-----  -----  -----  -----  -----  ------  ------  -----  --------</span><br><span class="line">0.85%  0.72%  4.66%  4.63%  6.85%  15.27%  10.93%  -      8.73%</span><br><span class="line"></span><br><span class="line">Drawdowns:</span><br><span class="line">max      avg       # days</span><br><span class="line">-------  ------  --------</span><br><span class="line">-13.77%  -1.28%     27.75</span><br></pre></td></tr></table></figure>

<p>接下来，我们加入BTC，其他不变。可以发现，加入BTC可以轻松将sharpe 提高到1.7！如果我们继续加入ETH，sharpe将超过2.0。</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211130225507.png" alt="加入Crypto的投资组合对比"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Stat                 spy,tlt,btc-usd    spy,tlt,btc-usd,gld    spy,tlt,gld    spy,tlt,btc,eth</span><br><span class="line">-------------------  -----------------  ---------------------  -------------  -----------------</span><br><span class="line">Start                2015-08-06         2015-08-06             2015-08-06     2015-08-06</span><br><span class="line">End                  2021-11-26         2021-11-26             2021-11-26     2021-11-26</span><br><span class="line">Risk-free rate       0.00%              0.00%                  0.00%          0.00%</span><br><span class="line"></span><br><span class="line">Total Return         237.23%            172.09%                78.72%         542.72%</span><br><span class="line">Daily Sharpe         1.79               1.70                   1.15           2.12</span><br><span class="line">Daily Sortino        2.79               2.72                   1.84           3.47</span><br><span class="line">CAGR                 21.25%             17.20%                 9.64%          34.31%</span><br><span class="line">Max Drawdown         -19.85%            -16.34%                -13.77%        -23.92%</span><br><span class="line">Calmar Ratio         1.07               1.05                   0.70           1.43</span><br><span class="line"></span><br><span class="line">MTD                  -0.37%             -0.02%                 0.70%          -0.85%</span><br><span class="line">3m                   3.66%              2.47%                  1.60%          5.10%</span><br><span class="line">6m                   11.75%             5.99%                  4.54%          13.43%</span><br><span class="line">YTD                  15.77%             8.83%                  4.47%          29.00%</span><br><span class="line">1Y                   24.29%             15.99%                 6.98%          40.47%</span><br><span class="line">3Y (ann.)            28.42%             23.85%                 15.46%         41.19%</span><br><span class="line">5Y (ann.)            22.68%             18.13%                 10.93%         33.77%</span><br><span class="line">10Y (ann.)           -                  -                      -              -</span><br><span class="line">Since Incep. (ann.)  21.25%             17.20%                 9.64%          34.31%</span><br></pre></td></tr></table></figure>

<p>我们得承认Crypto再过去的今年确实是牛市。但是通过相关性可以发现，Crypto与股票市场和债券市场相关性较低。这也是为什么加入Crypto可以轻松提高收益风险回报率。</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211130225620.png" alt="各个策略的相关性"></p>
<p>从相关性可以看出，加入crypto的投资组合回报率与我们的基准投资组合的相关性只有0.56，这是我们希望看到的，这也是sharpe提高的因素之一。</p>
<p>如果我们观察这些标底资产的相关性：</p>
<p><img src="https://raw.githubusercontent.com/wangzhe3224/pic_repo/master/images/20211130225843.png" alt="20211130225843"></p>
<p>可以crypto和其他资产比如股票、债券、黄金的相关性都非常低，而它具有正期望（背后的原因下一节讲），这是加入投资组合最好的特性，而 2.0 的 sharpe ratio 也证明了这个事实。</p>
<h2 id="基本面分析"><a href="#基本面分析" class="headerlink" title="基本面分析"></a>基本面分析</h2><p>我们再来看看Crypto的基本面。我们得承认Crypto市场目前有泡沫，但是时至今日没有人可以忽略Crypto这个市场了，或者还在叫嚷这Crypto是骗局。</p>
<p>今天我们从一下几个点看看Crypto的“基本面”，其实也不算基本面，就是一些帮助我看Crypto这个市场的指标。这行指标可以帮助我们明确Crypto（垃圾币、烂项目另说）是一个实际存在生态，特别Defi和Web3，有很多人正在为这个产业实际付出。正式这些因素佐证了Crypto的未来的正期望。</p>
<ul>
<li>金融指标</li>
<li>开发者生态</li>
<li>其他机构的动作</li>
</ul>
<h3 id="金融指标"><a href="#金融指标" class="headerlink" title="金融指标"></a>金融指标</h3><p>金融指标我们主要看：</p>
<ul>
<li>市值</li>
<li>流动性和交易额</li>
</ul>
<p>首先看市值，根据 coinmarketcap 的数据，目前（2021-11）加密货币总市值为2.6万亿美金。而市值前十的币几乎占据了超过95%的总市值。什么概念呢？标普500的头部公司，比如苹果、微软、谷歌，的市值基本上是2万亿级别。</p>
<p>然后我们看流动性和交易额，日交易额约为1000亿美金。什么概念呢？世界交易最频繁的外汇USD-EUR的日均交易额为5000亿美金。如果我们仅仅关注Crypto的货币属性，这已经是一个足够大的、流动性足够好的市场了。</p>
<h3 id="开发者生态"><a href="#开发者生态" class="headerlink" title="开发者生态"></a>开发者生态</h3><p>Crypto本质上是计算机科学的产物，没有计算机和互联网的支持，Crypto本身不可能存在。而计算机和互联网的主要建造者正是开发人员，即程序员。当然Crypto的载体是计算机，参与者实际上还是人，还是价值保存和交换过程（这其实也是一个Crypto注定会成为常态的原因）。</p>
<p>根据 decrypt 的调研，有超过8000名开发人员每个月在进行各种Crypto项目的开发，其中以太坊最为集中，约有2300人每月；而新兴的区块链项目 Polkadot 每月也有超过400名开人员参与开发。新兴的急速区块链项目 Solana 有超过100名开发人员提交了代码，平均每个月有超过300个Commit被提交合并。可以看出，开源社区正在助力 Crypto。</p>
<h3 id="其他机构的动作"><a href="#其他机构的动作" class="headerlink" title="其他机构的动作"></a>其他机构的动作</h3><p>我们再来看看老派的金融机构是怎么看Crypto的。我有所耳闻的：</p>
<p>摩根大通早在几年前就开始为客户提供Crypto产品了，而且内部成立了相应的Trading desk。高频交易公司Jump Trading最近成立了一个80人的团队进行区块链开发。英国对冲基金Maven正在组建Crypto自营交易组。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>无论是从回测数据，还是所谓“基本面”分析，在你的投资组合中加入Crypto都是不错的选择。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://academy.binance.com/en/articles/a-guide-to-cryptocurrency-fundamental-analysis">https://academy.binance.com/en/articles/a-guide-to-cryptocurrency-fundamental-analysis</a></li>
<li><a href="https://app.intotheblock.com/">https://app.intotheblock.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>Investing</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>投资组合</tag>
      </tags>
  </entry>
  <entry>
    <title>读书 - 代码之外生存指南</title>
    <url>/2021/12/01/reading-soft-skill/</url>
    <content><![CDATA[<h2 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h2><ul>
<li>设定目标</li>
<li>学会如何与人打交道</li>
<li>成为专业人事</li>
<li>创造产品</li>
</ul>
<h3 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a>设定目标</h3><p>你的职业目标是什么？</p>
<h3 id="与人打交道"><a href="#与人打交道" class="headerlink" title="与人打交道"></a>与人打交道</h3><ul>
<li>每个人都希望被认为自己是重要的。</li>
<li>不批评，而是换位</li>
<li>为别人提供价值</li>
</ul>
<h3 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h3><p>我在那个方向专精？永远不要只能称自己是Python程序员或者数据科学家。<br>要找到自己专精的一个细分领域。可以说自己是Python专家都比Python程序员好。</p>
<p>你的细分专精领域是？</p>
<ul>
<li>我的公司有哪些痛点？我可以成为解决这种问题的专家吗？</li>
<li>哪类问题我回复的最多？</li>
<li>那种工作缺乏经验丰富的人？</li>
</ul>
<h3 id="创造产品"><a href="#创造产品" class="headerlink" title="创造产品"></a>创造产品</h3><h2 id="自我营销"><a href="#自我营销" class="headerlink" title="自我营销"></a>自我营销</h2><blockquote>
<p>营销就是一场争夺人们注意力的竞赛。</p>
</blockquote>
<blockquote>
<p>很多人都喜欢向只比自己稍微优秀一点点的人学习，因为这些 人才是可望而又可及的。</p>
</blockquote>
<blockquote>
<p>我该如何向你传递这些对你 有益的信息?我如何才能为你提供价值?</p>
</blockquote>
<ul>
<li>打造个人品牌</li>
<li>给别人创造价值</li>
<li>社交媒体的使用<ul>
<li>博客文章</li>
<li>新闻</li>
<li>小窍门</li>
<li>吸引人的问题</li>
<li>自己的推广（别太多）</li>
</ul>
</li>
<li>做演讲或者录制培训</li>
<li>写书(甚至自出版)</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>刻意练习，实践，然后教授给其他人。</p>
<p>掌握一门技术：</p>
<ul>
<li>如何开始。想要开始，我需要哪些基础前置知识？</li>
<li>学科范围。了解这个学科的大致轮廓，明确我自己在哪里</li>
<li>基础知识。20%的知识，解决80%的问题。</li>
</ul>
<p>了解自己不知道什么就足矣。然后，利用这些信 息勾勒出学习的范围，即需要学哪些内容，以及学成之后又会获得什么。依靠这些知识，你可以找出各种资源(不局限于书) 来帮助自己学习。最后，你可以创建自己的学习计划，列出要去学习哪些相关课程，筛选学习材料，只保留能帮助自己达成目 标的优质内容。</p>
<p>实践一下，挑选一项你已经烂熟于胸的技术，看看你能否明确以下几点。</p>
<ul>
<li>如何开始用它? </li>
<li>该技术的应用广度如何? </li>
<li>利用你需要知道的20%发挥出80%功效。</li>
</ul>
<h3 id="10步学习法"><a href="#10步学习法" class="headerlink" title="10步学习法"></a>10步学习法</h3><p>其中 1 - 6 只需要做一次，属于前期准备，很重要；7-10不需要不断循环：学习 实践 掌握 教授。</p>
<ol>
<li>了解全局，找到自己不知道的内容</li>
<li>确定范围，选择子问题</li>
<li>定义目标，明确“成功”的含义极为重要</li>
<li>寻找资源</li>
<li>创建学习计划<ul>
<li>打造自己的学习计划，一个好方法就是观察别人是如何教你感兴趣的主题的。</li>
</ul>
</li>
<li>筛选资源，一两本书或者教程</li>
<li>开始学习<ul>
<li>权衡准备知识和开始学习的平衡</li>
</ul>
</li>
<li>动手操作，一边学习一边就开始操作</li>
<li>全面掌握，学以致用</li>
<li>乐为人师，融会贯通<ul>
<li>你只需要超前别人一步，就可以成为他们的老师</li>
<li>写教程、做视频、回答问题</li>
</ul>
</li>
</ol>
<h3 id="关注自己的短板"><a href="#关注自己的短板" class="headerlink" title="关注自己的短板"></a>关注自己的短板</h3><p>记录他们。</p>
<ul>
<li>在哪些工作上花费时间最多?</li>
<li>可以改进的重复性劳动</li>
<li>自己没有完全理解的东西</li>
<li>你回答不出来的面试题</li>
</ul>
<h2 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h2><p>一切开始于专注。</p>
<h3 id="番茄时钟"><a href="#番茄时钟" class="headerlink" title="番茄时钟"></a>番茄时钟</h3><p><a href="https://kanbanflow.com/board/cKY25uN#">https://kanbanflow.com/board/cKY25uN#</a></p>
<h3 id="时间是怎么被浪费的"><a href="#时间是怎么被浪费的" class="headerlink" title="时间是怎么被浪费的"></a>时间是怎么被浪费的</h3><p>社交媒体，把他们放入一个固定的时间查看？</p>
<h3 id="形成惯例"><a href="#形成惯例" class="headerlink" title="形成惯例"></a>形成惯例</h3><h3 id="习惯的力量"><a href="#习惯的力量" class="headerlink" title="习惯的力量"></a>习惯的力量</h3><p>《《习惯的力量》》</p>
<p>找出坏习惯，改掉。</p>
<p>？？？</p>
<p>建立新的好习惯。</p>
<p>比如每天早上确定自己今天的计划。</p>
<p><a href="https://johnresig.com/blog/write-code-every-day/">Write Code Every Day</a></p>
<h3 id="分解任务"><a href="#分解任务" class="headerlink" title="分解任务"></a>分解任务</h3><blockquote>
<p>造成拖延的首要原因之一，同时也是造成生产力低下的祸根，就是总是在感慨一个问题:好忙啊，问题好大啊。实际上，你并没有真正试着去解决问题。</p>
</blockquote>
<h3 id="任何行动都比不行动好（真的吗？）"><a href="#任何行动都比不行动好（真的吗？）" class="headerlink" title="任何行动都比不行动好（真的吗？）"></a>任何行动都比不行动好（真的吗？）</h3><p><img src="https://i.imgur.com/irSQI2y.png" alt=""></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Soft Skill</tag>
      </tags>
  </entry>
  <entry>
    <title>在VS Code中使用VIM (VIM教程)</title>
    <url>/2021/11/30/vim1/</url>
    <content><![CDATA[<ul>
<li><a href="#在vs-code中使用vim">在VS Code中使用VIM</a><ul>
<li><a href="#一些基本配置">一些基本配置</a><ul>
<li><a href="#中文输入法的梦魇">中文输入法的梦魇</a></li>
<li><a href="#按键绑定">按键绑定</a></li>
</ul>
</li>
<li><a href="#基础">基础</a><ul>
<li><a href="#模式">模式</a></li>
<li><a href="#移动">移动</a><ul>
<li><a href="#normal-mode">Normal Mode</a></li>
<li><a href="#insert-mode">Insert Mode</a></li>
<li><a href="#visual-mode">Visual Mode</a></li>
</ul>
</li>
<li><a href="#页面展示">页面展示</a></li>
<li><a href="#编辑">编辑</a></li>
</ul>
</li>
<li><a href="#常用操作">常用操作</a></li>
<li><a href="#高级主题">高级主题</a><ul>
<li><a href="#寄存器">寄存器</a></li>
<li><a href="#标记">标记</a></li>
</ul>
</li>
<li><a href="#插件">插件</a><ul>
<li><a href="#surround">surround</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一些基本配置"><a href="#一些基本配置" class="headerlink" title="一些基本配置"></a>一些基本配置</h2><p>:information_source: VS Code Vim 不是 Vim。不过他模拟了绝大部分的Vim操作。<br>但是也会出现很多支持不太好的功能，比如宏、Vim script等等。但是，就我个人的使用Code<br>的Vim模拟器已经满足我的需求了。更加复杂的功能，还是需要 code 的命令支持：<code>Cmd+Shift+p</code>.</p>
<h3 id="中文输入法的梦魇"><a href="#中文输入法的梦魇" class="headerlink" title="中文输入法的梦魇"></a>中文输入法的梦魇</h3><p>如何解决VSCode Vim中文输入法切换问题？ - Daniel的回答 - 知乎<br><a href="https://www.zhihu.com/question/303850876/answer/540324790">https://www.zhihu.com/question/303850876/answer/540324790</a></p>
<h3 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">jj -&gt; ESC</span><br><span class="line">enter -&gt; :</span><br><span class="line">caps lock -&gt; ctrl</span><br></pre></td></tr></table></figure>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Vim常用的有三种模式，但是不能孤立的用，要结合起来用。<br>Vim的规则非常简单，但是组合起来非常强大，提供了一套文本编辑的“高级”语言。</p>
<p>Vim语言的基本语法：<code>动词 + 「数量、介词」 + 名词</code><br>Vim语言充满了名词做动词的情况。</p>
<p>Vim的精髓在于重复，<code>.</code></p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>三种基本模式：</p>
<ul>
<li>Normal，用来移动和编辑</li>
<li>Insert，用来输入</li>
<li>Visual/Selection，用来选择编辑块</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Esc                Insert -&gt; Normal</span><br><span class="line">i/I/o/O/c/a/A      Normal -&gt; Insert</span><br><span class="line">v / V              Normal -&gt; Visual</span><br></pre></td></tr></table></figure>

<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><h4 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h4><p>基本操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hjkl       👈 ⬆️ ⬇️ 👉</span><br><span class="line">w&#x2F;b&#x2F;e      按照单词移动</span><br><span class="line">&#123; &#125;        按照段落移动</span><br><span class="line">%          在闭合的括号之间移动</span><br><span class="line">gg         回到文档最上端</span><br><span class="line">G          回到文档最低端</span><br><span class="line">0          回到行首</span><br><span class="line">$          回到行尾</span><br></pre></td></tr></table></figure>

<p>加入数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1j         向下移动1行</span><br><span class="line">8j         向下移动8行</span><br></pre></td></tr></table></figure>

<p>移动到某一行：</p>
<ul>
<li><code>:12&lt;Enter&gt;</code>  移动到12行</li>
<li><code>12gg</code>        移动到12行</li>
</ul>
<p>搜索移动：</p>
<p>这是非常高效移动方式：j</p>
<ul>
<li><code>fa</code>: 向右移动到下一个a</li>
<li><code>ta</code>: 向右移动到下一个a的前一个字符</li>
<li><code>Fa</code>: 向左移动到下一个a</li>
<li><code>Ta</code>: 向左移动到下一个a的前一个字符</li>
</ul>
<p>另外，可以直接按 <code>\</code> 进入搜索模式，去寻找目标单词或字母。</p>
<h4 id="Insert-Mode"><a href="#Insert-Mode" class="headerlink" title="Insert Mode"></a>Insert Mode</h4><p>插入模式就是其他编辑的模式，用来输入信息。但是在插入模式，我们也可以直接移动光标、删除。<br>这进一步增加了Vim的灵活性，也就是说对于很局部化的操作，我们可以在插入模式下进行移动。</p>
<p>在插入模式下，Vim的光标移动遵循了一半 Bash shell 的快捷键。</p>
<p>def cls():<br>    …</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Ctrl+p     up</span><br><span class="line">Ctrl+n     down</span><br><span class="line">Ctrl+b     left</span><br><span class="line">Ctrl+f     right</span><br><span class="line">Ctrl+a     到行首</span><br><span class="line">Ctrl+e     到行位</span><br><span class="line">Ctrl+h     delete 1 </span><br><span class="line">Ctrl+w     delete back 1 word</span><br><span class="line">Ctrl+u     delete back to start of line</span><br></pre></td></tr></table></figure>

<h4 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h4><p>选择模式下的移动与正常模式的完全一致的。</p>
<p>:point_right:<strong>纵向编辑</strong> :point_left: 神器</p>
<p><code>ctrl+v</code></p>
<h3 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h3><p>窗口移动</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zz         把光标置于屏幕中间</span><br><span class="line">ctrl + e   向上移动屏幕</span><br><span class="line">ctrl + y   向下移动屏幕</span><br></pre></td></tr></table></figure>

<p>折叠、展开代码块</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zc        关闭代码块</span><br><span class="line">zo        打开代码块</span><br><span class="line">za        打开、关闭代码块</span><br></pre></td></tr></table></figure>

<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>这就是Vim强大的地方：编辑。</p>
<p>Vim中的动词：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">d</span><br><span class="line">c</span><br><span class="line">y</span><br><span class="line">p</span><br><span class="line">x</span><br><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">u</span><br><span class="line">Ctrl - r</span><br><span class="line">. </span><br></pre></td></tr></table></figure>

<p>名词，这些东西在Vim中成为 Text Object，推荐使用他们进行操作，这是一种高于<code>hjkl</code>移动的抽象。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">w       词（可以做动词）</span><br><span class="line">p       段落（可以做动词）</span><br><span class="line">jk      行 （可以做动词）</span><br><span class="line">各种括号、引号等等</span><br><span class="line">s       句子</span><br></pre></td></tr></table></figure>

<p>介词</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i     表示里面</span><br><span class="line">a     表示外面</span><br></pre></td></tr></table></figure>

<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>格式化代码：<code>==</code></li>
<li>注释代码：<code>gc&#123;c,j,k&#125;</code></li>
<li>切换tab：<code>gt&#123;tab的数字&#125;</code></li>
<li>回退：<code>u</code></li>
<li>重做：<code>Ctrl+r</code></li>
</ul>
<h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="surround"><a href="#surround" class="headerlink" title="surround"></a>surround</h3>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>著名空头预言家Michael Burry清仓了</title>
    <url>/2021/11/21/bigshort/</url>
    <content><![CDATA[<h2 id="Micheal-Burry是谁？"><a href="#Micheal-Burry是谁？" class="headerlink" title="Micheal Burry是谁？"></a>Micheal Burry是谁？</h2><p>麦克贝瑞（Micheal Burry）作为对冲基金经理，有着“奇怪”的背景：他同时是一名内科医生。</p>
<p>让他在对冲基金领域声望达到顶点的事件正是成功的预测08年次贷危机，并且顶着各种压力，说服高盛在内的多家投行，卖给他次级贷款CDS，在那次金融海啸中获利超过8亿美金，其中1亿是他自己的收益，其余是他为投资人赚得利润。电影《大空头》就是以他为原型拍的。</p>
<p>其实，麦克并不是依靠运气，他属于价值投资的跟随者，最擅长做空估值过高的股票。2001年，美国标普暴跌11.8%，他的基金，Scion Capital，上涨55%；2002年，标普暴跌22%，Scion再次上涨16%；2003年，标普回暖涨幅28%，Scion却再一次击败了标普，上涨50%。</p>
<h2 id="Scion的持仓"><a href="#Scion的持仓" class="headerlink" title="Scion的持仓"></a>Scion的持仓</h2><p>Micheal早在去年就开始发表一些空头言论了，只不过直到2021年第三季度，他的基金（Scion）才真正减仓！我们看一下他Q3和Q2的持仓变化：</p>
<p><img src="https://i.imgur.com/EKXajMa.png" alt=""></p>
<p><img src="https://i.imgur.com/CWC40pm.png" alt=""></p>
<p>大家注意前两行就好，当前持仓面值4千万美金，而Q2的持仓面值20亿美金，另外Scion的AUM大约是6亿美金。这些数字告诉我们什么呢？Micheal这次不是用推特看空，而是用真金白银看空了。从20亿到4千万，他几乎等于持有现金了。</p>
<p><img src="https://i.imgur.com/XP74Tet.png" alt=""></p>
<p>目前，他只持有6只股票，抛掉绝大部分股票和看涨期权。重仓股票只有三只，分别是CVS、LMT和GEO，分别属于医疗、军工和地产。</p>
<p><img src="https://i.imgur.com/SKJ2rdH.png" alt=""></p>
<h2 id="美股怎么样了？"><a href="#美股怎么样了？" class="headerlink" title="美股怎么样了？"></a>美股怎么样了？</h2><p>下面几幅图分别是：PE，Shiller PE，SP500价格和Earning。</p>
<p>这几个图说明啥呢？PE ratio逼近2000年互联网泡沫，SP500经历了长达10年牛市，而经济大周期一般是10年左右，这几个事实通常意味着崩盘；但是另一方面，我们看到Earning也是历史高位，换句话说目前的价格高位有高位的Earning支持，看起来还是比较健康的。</p>
<p><img src="https://i.imgur.com/2S9uYVC.png" alt="PE ratio"></p>
<p><img src="https://i.imgur.com/CHOsOXK.png" alt="Shiller PE Ratio"></p>
<p><img src="https://i.imgur.com/FmbnQ4m.png" alt="S&amp;P 500"></p>
<p><img src="https://i.imgur.com/qtnGgpl.png" alt="Earning"></p>
<p>但是，有一个事实我们也不应该忽略，就是10年国债的利息已经是近100年的最低值了。换句话说，政府已经没水可以放了，美国人只能印钱。</p>
<p><img src="https://i.imgur.com/eYH6gUk.png" alt=""></p>
<h2 id="我该怎么办"><a href="#我该怎么办" class="headerlink" title="我该怎么办"></a>我该怎么办</h2><p>我目前的持仓是一个近似60股票30债券10其他的投资组合，我认为崩盘发生的几率不大，即使发生也不会产生想2000年那样深远的影响。但是，考虑到我们的Big Short大王已经清仓了，我还是有点慌乱，所以我的策略是：</p>
<ul>
<li>买长期看跌期权做保险</li>
<li>分散股票投资到其他（比如加仓Crypto）</li>
</ul>
<p>我不是一个价值投资者，但是大周期还是参与一下，毕竟趋势还是在的。至于为啥加仓crypto，以后我再分享。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://whalewisdom.com/filer/scion-asset-management-llc">https://whalewisdom.com/filer/scion-asset-management-llc</a></li>
<li><a href="https://www.reddit.com/r/Burryology/comments/qulbfz/michael_burry_scion_asset_management_q3_2021/">https://www.reddit.com/r/Burryology/comments/qulbfz/michael_burry_scion_asset_management_q3_2021/</a></li>
<li><a href="https://www.barchart.com/etfs-funds/quotes/SPY/volatility-greeks?expiration=2022-03-18-m&amp;moneyness=50">https://www.barchart.com/etfs-funds/quotes/SPY/volatility-greeks?expiration=2022-03-18-m&amp;moneyness=50</a></li>
</ul>
]]></content>
      <categories>
        <category>Investing</category>
      </categories>
      <tags>
        <tag>空头</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust包管理和文件组织</title>
    <url>/2021/11/13/rust_module/</url>
    <content><![CDATA[<h2 id="包（package）、Crate"><a href="#包（package）、Crate" class="headerlink" title="包（package）、Crate"></a>包（package）、Crate</h2><p>首先关于文件和文件夹管理的两个概念：</p>
<ul>
<li>包（Package）</li>
<li>Crate（不知道翻译成啥）<ul>
<li>库，lib</li>
<li>二进制，bin</li>
</ul>
</li>
</ul>
<p>一个包，包含一个<code>Cargo.toml</code>文件，描述如何构建这个包内部的一个或者多个<code>Crate</code>。<code>Cargo.toml</code> 负责根据配置将这些Crate进行编译和连接。</p>
<p><strong>规则</strong>：</p>
<ul>
<li>一个包中最多只能包含一个库（lib）Crate</li>
<li>包可以包含多个二进制（bin）Crate</li>
<li>包至少要包含一个Crate（lib或者bin）</li>
</ul>
<p><code>Crate</code> 可以有两种形态：二进制（bin）或者库（lib）。区别这两者的规则是：如果只存在<code>src/main.rs</code>，这是一个与包同名的二进制（bin）Crate，且这个文件就是Crate的根。如果存在<code>src/lib.rs</code>，这是一个与包同名的库（lib）Crate，且这个文件是Crate的根；如果同时含有这两个文件，则这个包包含两个Crate：一个库，一个二进制。</p>
<p>通过将文件放在<code>src/bin</code>目录下，一个包可以包含多个二进制Crate，每一个文件都会被编译成独立的二进制Crate。</p>
<p>注意每一个二进制（bin）Crate都需要有一个main函数作为二进制的入口。</p>
<h2 id="模块（mod）"><a href="#模块（mod）" class="headerlink" title="模块（mod）"></a>模块（mod）</h2><p>模块 帮助代码分组、重用，隐藏内部状态，即封装。使用<code>mod</code>可以生命一个模块，模块可以嵌套子模块。<code>pub</code>用来暴露模块和他的API。</p>
<p>通常一个模块（包括他的子模块）会被放在同一个文件夹内部，有两种主要的方式：内部库，外部库。</p>
<p>内部库的文件结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">  - lib1</span><br><span class="line">    - impl.rs，模块的实现</span><br><span class="line">    - mod.rs, 主要包含模块引入</span><br><span class="line">  - lib2</span><br><span class="line">    - impl.rs</span><br><span class="line">    - mod.rs</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>

<p>外部库文件结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">  - src</span><br><span class="line">    - main</span><br><span class="line">  - lib_ext</span><br><span class="line">    - src</span><br><span class="line">      - impl.rs</span><br><span class="line">      - mod.rs or lib.rs</span><br><span class="line">    - Cargo.toml</span><br><span class="line">  - Cargo.toml</span><br></pre></td></tr></table></figure>

<p>外层Cargo文件需要增加<code>dependency</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">util</span> = &#123; path = <span class="string">&quot;lib_ext&quot;</span>, version = <span class="string">&quot;0.1.0&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果是二进制Crate，可以直接把文件放入<code>src/bin</code>中，不需要额外引导。</p>
<p>模块的引用方式为：<code>mod1::submod::item</code>，可以采用 <code>use</code> 关键字缩短引用路径。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>如何成为 Qaunt Dev 1 - 分类</title>
    <url>/2021/11/06/quant_dev_1/</url>
    <content><![CDATA[<p>量化对冲基金程序员分类：</p>
<ul>
<li>基础设施</li>
<li>运维</li>
<li>业务 (Quant Dev)<ul>
<li>基础设施</li>
<li>交易系统</li>
<li>研究系统</li>
<li>量化开发</li>
<li>前端开发</li>
</ul>
</li>
</ul>
<h2 id="基础设施，Infrastructure"><a href="#基础设施，Infrastructure" class="headerlink" title="基础设施，Infrastructure"></a>基础设施，Infrastructure</h2><ol>
<li>主要职能</li>
</ol>
<p>基础设施的程序员主要是负责公司的整体计算机基础设施，保证计算、存储和网络资源正常运行，满足业务需求。</p>
<p>包括（不是全部）：</p>
<ul>
<li>数据、计算中心硬件的维护和升级</li>
<li>计算资源集群，Spark集群，k8s集群，日常的虚拟机群等等</li>
<li>网络，网络安全、VPN等等</li>
<li>分布式文件系统</li>
<li>数据库开发和维护</li>
</ul>
<ol start="2">
<li>技术栈</li>
</ol>
<ul>
<li>Linux</li>
<li>k8s</li>
<li>Spark</li>
<li>数据库</li>
</ul>
<ol start="3">
<li>语言</li>
</ol>
<ul>
<li>C/C++/Rust</li>
<li>Bash</li>
</ul>
<h2 id="运维，Dev-Ops"><a href="#运维，Dev-Ops" class="headerlink" title="运维，Dev Ops"></a>运维，Dev Ops</h2><ol>
<li>主要职能</li>
</ol>
<p>对冲基金的运维，跟其他科技公司的运维功能类似，主要是确保各个应用的连续测试和构建，合理化的容器化APP等等。</p>
<ol start="2">
<li>技术栈</li>
</ol>
<ul>
<li>Linux</li>
<li>Jenkins</li>
<li>K8s</li>
<li>Docker</li>
</ul>
<ol start="3">
<li>语言</li>
</ol>
<ul>
<li>Bash</li>
<li>Python</li>
</ul>
<h2 id="业务，Quant-Dev"><a href="#业务，Quant-Dev" class="headerlink" title="业务，Quant Dev"></a>业务，Quant Dev</h2><p>这部分是量化对冲基金比较独有的程序员，每个公司可能也会不太一样，这部分程序员需要对金融知识，<br>不过大体可以分为：</p>
<ul>
<li>基础设施</li>
<li>交易系统</li>
<li>研究系统</li>
<li>量化开发</li>
<li>前端开发</li>
</ul>
<h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>这部分的基础设施主要是面向业务逻辑的一些工具和框架的开发，比如</p>
<ul>
<li>高性能时间序列数据库</li>
<li>实时计算图，Computation Graph</li>
<li>机器学习框架</li>
<li>股票的话，比如Ticker map，分红，换名字啊等等一些琐碎但是重要的事情</li>
</ul>
<p>语言框架：</p>
<ul>
<li>C++/Rust/Python</li>
</ul>
<h3 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h3><p>负责订单的执行和仓位管理，主要是负责把策略生成的信号或者订单提交到不同的Broker进行执行，并且<br>返回执行结果，也负责仓位的查询等等。这块其实内容很丰富，也会直接影响公司的PnL。</p>
<p>语言框架：</p>
<ul>
<li>Java/Python</li>
</ul>
<h3 id="研究系统"><a href="#研究系统" class="headerlink" title="研究系统"></a>研究系统</h3><p>这部分主要是为了研究人员进行量化研究做一些工具，比如回测工具，基本的分析模块，新的数据集，<br>Alpha的分析等。</p>
<p>语言框架：</p>
<ul>
<li>Python</li>
</ul>
<h3 id="量化开发"><a href="#量化开发" class="headerlink" title="量化开发"></a>量化开发</h3><p>这部分程序员的主要任务是把研究人员证明可行的信号，转化成可以实际交易执行的代码，投放到交易系统<br>进行交易。属于连接想法和实践的桥梁，这块其实内容很丰富，也会直接影响公司的PnL。</p>
<p>语言框架：</p>
<ul>
<li>Java/Python</li>
</ul>
<h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><p>这部分跟正常的前端差不多，主要为后端API提供一个GUI</p>
<p>语言框架：</p>
<ul>
<li>Js/Python</li>
<li>React</li>
</ul>
]]></content>
      <categories>
        <category>Career</category>
      </categories>
      <tags>
        <tag>Hedge Fund</tag>
        <tag>Quant</tag>
      </tags>
  </entry>
  <entry>
    <title>如何转行计算机做程序员</title>
    <url>/2021/10/20/roadpath/</url>
    <content><![CDATA[<h1 id="如何转行计算机？"><a href="#如何转行计算机？" class="headerlink" title="如何转行计算机？"></a>如何转行计算机？</h1><hr>
<ul>
<li>程序员的分类</li>
<li>如何开始</li>
</ul>
<hr>
<h2 id="程序员的分类"><a href="#程序员的分类" class="headerlink" title="程序员的分类"></a>程序员的分类</h2><hr>
<p>职能：</p>
<ul>
<li>前端</li>
<li>后端</li>
</ul>
<hr>
<p>业务知识：</p>
<ul>
<li>互联网</li>
<li>金融</li>
<li>游戏</li>
<li>计算机基础设施</li>
<li>各行业各</li>
</ul>
<hr>
<h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><ul>
<li>基础部分</li>
<li>业务部分</li>
</ul>
<hr>
<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul>
<li><em>英语</em></li>
<li>计算机基础</li>
<li>计算机进阶</li>
</ul>
<hr>
<h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ol>
<li>计算机导论</li>
<li>数据结构和算法</li>
<li>计算机组成原理</li>
<li>操作系统</li>
<li>计算机网络</li>
<li>查缺补漏的课。。。。。</li>
<li>一些数学</li>
</ol>
<hr>
<ol>
<li><p><strong>计算机导论</strong></p>
<ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/">MIT - 6.0001</a></li>
<li><a href="https://cs50.harvard.edu/college/2020/fall/">Harvard - CS50</a></li>
<li><a href="https://cs61a.org/">Berkeley - CS61A</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>数据结构和算法</strong><ul>
<li><a href="https://web.stanford.edu/class/cs106b/schedule.html">Berkeley - CS61B</a></li>
<li><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms, Part I,II</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm">MIT - 6.006</a></li>
<li><a href="https://leetcode.com/"><strong>Leetcode</strong> <code>:)</code></a></li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>计算机组成原理</strong><ul>
<li><a href="https://cs61c.org/fa21/">Berkeley - CS61C: Great Ideas in Computer Architecture</a></li>
<li><a href="https://www.cs.cmu.edu/~213/">CMU - 15213: Introduction to Computer Systems</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>操作系统</strong><ul>
<li><a href="https://cs162.org/">Berkeley - CS162: Operating Systems and Systems Programming</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT - 6.S081: Operating System Engineering</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><strong>计算机网络</strong><ul>
<li><a href="https://cs144.github.io/">Stanford - CS114: Introduction to Computer Networking</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><strong>查缺补漏的工具啊</strong><ul>
<li><a href="https://missing.csail.mit.edu/">MIT - 6.null: The Missing Semester of Your CS Education</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li><strong>一些数学</strong><ul>
<li><a href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/">MIT 18.06: 线性代数</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-041-probabilistic-systems-analysis-and-applied-probability-fall-2010/">MIT 6.431: 概率论</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/">MIT 6.042: Mathematics for Computer Science</a></li>
</ul>
</li>
</ol>
<hr>
<h3 id="计算机进阶"><a href="#计算机进阶" class="headerlink" title="计算机进阶"></a>计算机进阶</h3><p>根据业务方向选择：</p>
<ol>
<li>软件工程</li>
<li>数据库</li>
<li>分布式系统</li>
<li>编译系统</li>
<li>机器学习</li>
<li>计算机语言理论</li>
</ol>
<hr>
<ol>
<li><strong>软件工程</strong><ul>
<li><a href="http://web.mit.edu/6.031/www/fa21/">MIT 6.031: Software Construction</a></li>
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2021sp/">Cornell CS3110: Data Structures and Functional Programming</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>数据库</strong><ul>
<li><a href="https://15445.courses.cs.cmu.edu/fall2019/assignments.html#">CMU 15445: 数据库系统</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>分布式系统</strong><ul>
<li><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824: 分布式系统</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>编译系统</strong><ul>
<li><a href="https://web.stanford.edu/class/cs143/">Stanford CS143: 编译器</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li><strong>机器学习</strong><ul>
<li><a href="https://openlearninglibrary.mit.edu/courses/course-v1:MITx+6.036+1T2019/course/">MIT 6.306: Introduction to Machine Learning</a></li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li><strong>计算机语言理论</strong><ul>
<li><a href="https://stanford-cs242.github.io/f19/">Stanford CS242: 计算机语言</a></li>
</ul>
</li>
</ol>
<hr>
<h2 id="业务部分"><a href="#业务部分" class="headerlink" title="业务部分"></a>业务部分</h2><ul>
<li>框架</li>
<li>语言</li>
<li>中间件</li>
<li>数据库</li>
</ul>
]]></content>
      <tags>
        <tag>presentation</tag>
      </tags>
  </entry>
  <entry>
    <title>自学计算机的5年</title>
    <url>/2021/10/10/%E8%87%AA%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA5%E5%B9%B4/</url>
    <content><![CDATA[<p>今天无意打开了Github主页翻到了2015年9月的第一个commit，突然意识到我的“计算机”转行之旅就是在那段时间正式开始的。（那年，Github还没被微软收购呢）</p>
<p>赖的朋友直接看这里，如何自学计算机？</p>
<ul>
<li>先学一门语言，啥基础没有就Python</li>
<li>Github是最好的资源，学习、接受、贡献</li>
<li>经典书籍要读，练习要做，亲手编码<ul>
<li>CSAPP</li>
<li>SICP</li>
<li>CS3110</li>
</ul>
</li>
<li>注重基础，练习要做，亲手编码<ul>
<li>操作系统</li>
<li>数据结构</li>
<li>数据库</li>
<li>计算机网络</li>
<li>计算机语言原理（编译原理）</li>
</ul>
</li>
<li>寻找自己的业务知识专精，围绕它展开计算机学习</li>
<li>在灵魂语言后，探索多种语言，注意是探索不是精通。<ul>
<li>Python</li>
<li>C</li>
<li>Ocaml/F#</li>
<li>Clojure</li>
<li>Haskell</li>
<li>Erlang</li>
<li>Go</li>
<li>Rust</li>
<li>Java （我真的爱不起来Java，太啰嗦了。。。。）</li>
<li>C++ (我真的爱不起来C++，太复杂了。。。。)</li>
</ul>
</li>
<li>无他，唯手熟尔</li>
</ul>
<h2 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h2><p><img src="https://i.imgur.com/Hhoybvl.png" alt="2015年的Github主页"></p>
<p>那一年，我做了我的第一个博客，另外两个仓库：一个是 《<code>C++</code>Primer 5th》的练习题，一个是《数据结构与算法分析<code>C++</code>实现（第五版》的练习题。燃鹅，我点进去一看，一个做了三章，一个做了两章，就没有后续了。:) 具体发生了什么已经记不住了，但是隐约感觉自己应该是被C++给恶心到了，感觉自己完全不适合学习计算机，因为练习题都做不出啊，全是抄代码。</p>
<p>同年12月，开了另一个坑《Data Structures and Algorithms in Python》，这次坚持了4章。但是，感觉Python跟<code>C++</code>比起来好舒服啊，算法题居然也能写出几个了。在那个时候，我还不清楚C++和Python究竟哪里不一样，编译型？解释器？分不清，仅仅是听说过。总之，我的自学之旅就这么开始了。</p>
<h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p>2016年，我博士三年级，找到了人生的第一个“计算机”行业的兼职工作。是一家只有两个人的金融公司，老板是半个程序员+交易员，而我，就是所谓的程序员。</p>
<p><img src="https://i.imgur.com/cdtzsXv.png" alt="2016"></p>
<p>那一年，我的Github上面有了第一个给其他仓库的PR，<a href="https://github.com/vnpy/vnpy">VNPY</a>。PR的内容竟然是把IB的API接口翻译成了英文哈哈。那时候，VNPY只有几百个星吧，现在已经有足足16k星了！除此之外，我的github没什么动静了。那一年，我大部分时间都用在了工作上。因为公司只有我跟老板两个人，老板大部分时间用来搞业务了，我就成了唯一的开发人员。我魔改了VNPY的事件引擎，做了自己的交易系统，用来交易老板的一个日内CFD策略。而开发语言就是Python。</p>
<p>现在想想也是后怕，当时FUM大概7百万英镑，不是大数目，但是我的代码就那么风风火火的上线了。这期间，乱七八糟的功能修修补补的，也除了各种Bug，也赔过钱。但是，我对编程的理解加深了，然后莫名其妙的学会一些量化交易的知识。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>2017年，那年我博士毕业了（结构工程方向的博士，如果你感兴趣的话）。我的github留下了我的第一个“开源项目”：<a href="https://github.com/wangzhe3224/chanlun">缠论（已经不再维护了）</a>。因为工作一直都是量化交易、金融相关的，哪一年我其实花了很多时间在学些这方面的知识，就是所谓的 Domain Knowledge。</p>
<p>但是，我的计算机知识并没有太多提升，我只是会用Python实现一些不那么优雅的代码，它们刚好可以完成我想做的事情，虽然有各种各样的问题，但是我能忍受，况且，我也不知道要怎么改善它们。但是，好在公司很小很小（虽然陆陆续续又来了几个程序员），我几乎成了全干程序员。从后台数据库、API、到前端的Web我都碰过，因为工作需要，我们不追求好看、高效，仅仅追求快速迭代、上线，实现最基本的监控和操作。</p>
<p>这期间，我给 VNPY 和 QUANTAXIS 这两个仓库提了一些Issue，而我也从这两个项目中间获得了很多灵感。</p>
<p><img src="https://i.imgur.com/7vCKXCM.png" alt="我的第一个笔记仓库（已经归档了）"></p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>2018年，我的Github格外安静。这一年除了工作，就是零零星星的学习一些计算机“技术”，为了应付工作中的各种问题，比如AWS全家桶。。。这一年，我开始逐渐意识到计算机科学和所谓的“技术”是不一样的。</p>
<p><img src="https://i.imgur.com/HDuxHTu.png" alt=""></p>
<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>这一年，我开始刷leetcode了，因为想要跳槽换工作，换一个平台去学习新的技术。</p>
<p>这一年，我也fork了许多量化交易的框架仓库，比如 <code>AlgoTrade</code>, <code>backtrader</code>, <code>bt</code> 等等，主要是学习他们的框架和编码模式。</p>
<p>这一年，我开源了一个奇葩库：<a href="https://github.com/wangzhe3224/zhihu-hotlist">知乎热榜</a>。哈哈哈，可能算不上库把。。</p>
<p><img src="https://i.imgur.com/dAcCPz4.png" alt=""></p>
<p>这一年，我的忘了我的初心：计算机科学。我花了不少时间在量化交易的框架上，也花了很多时间研究一些交易策略。我为数不多的commit都去了自己的一个研究量化策略的私有仓库里。所以，我开始计划零零星星的时间去学习计算机科学的基础知识：计算机组成原理、操作系统、数据库、计算机网路、编译原理。</p>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><p>啊，2020年，我换了新的工作，到了一个大一些的对冲基金，公司的FUM从1亿美金变成了40亿美金。我终于看到了“大”的对冲基金是怎么用计算机的。每天除了完成被分配的任务，就是疯狂的阅读代码，感受到了真的成长。以前，什么都是自己写，没有参考，在这个更成熟的代码仓库里，我看到了自己曾经想要而不得的东西：如何构建大尺度的项目？如何协调计算机集群进行计算？当然，我也学到了更多关于量化交易的 Domain 知识，如何构建复杂计算？如何处理异常？如何设计API和前端？等等。</p>
<p>啊，2020年，新冠疫情来了，我开始了长达一年的“work from home”。我的Github也热闹起来了。</p>
<p><img src="https://i.imgur.com/vMwhfPY.png" alt="2020"></p>
<p>我提交了两个更加有意思的项目：<a href="https://github.com/wangzhe3224/pygraph">Py Graph</a> 和 <a href="https://github.com/wangzhe3224/">pyca</a>。这两个项目，无论是成熟度和完整度都更高了。</p>
<p>这一年，我开始集中补充我的计算机基础知识，开始上一些网上的公开课，写作业，读计算机的经典书籍，基础各种各样的计算机语言：C，Java，Haskell，Ocaml，Erlang，Clojure，基本上是课程或者书籍设计到的语言我都接触一下。</p>
<p>这里是我的<a href="https://github.com/wangzhe3224/books">计算机书单</a>，然而，我又犯了老毛病：没长性。很多课程和书籍都是，学了一点点就放弃了，或者被其他的主题吸引了。所以这一年，我是涨了见识，但是我觉得我的思想似乎没有变得更深邃，我写了一片关于这个的文章：<a href="https://wangzhe3224.github.io/2021/05/30/admin2/">https://wangzhe3224.github.io/2021/05/30/admin2/</a> 。 即便如此，付出还是有收获的，我对计算机本身和编程也算有了更深的认识，也更认识到计算机这行业，基础知识是何等的重要，特别是对于转行的人来说。这不是学习一门语言或者学习一个框架可以带给你的。</p>
<p><strong>框架来框架去，操作系统、数据结构还是你大爷。</strong></p>
<p>同年，我在AWS部署了第一个“自主研发”的比特币日内交易系统。</p>
<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>转眼已经是第五年了，兜兜转转我还是决定回到基础了。我终于慢慢的读完了CSAPP这本书，慢慢做了很多练习，慢慢的发现C语言其实挺好理解的，并发和并行也不再神秘。我终于慢慢的读完了SICP这本书，慢慢的做了很多联系，慢慢的发现Clojure其实也挺好理解的。我终于完成CS3110这门课的联系，慢慢的发现组织程序的规则其实也挺好理解的，慢慢的发现Ocaml其实也很有意思，一点都不另类。</p>
<p>这一年，我的博客也开始热闹起来了，我开始更新自己对CPython内部的各种新的认识，毕竟Python仍然是我的灵魂语言！与当年不同的是，因为基础变得好起来了，Python对我来说不再神秘，不再是一个黑盒子，我渐渐的了解如何去分析程序，如何去理解它的性能，如何理解他跟其他语言的区别，明白他的长处和弱点。</p>
<p>这一年，我也开始变成了视频博主，开始把自己的得找分享给更多像我一样的人，像我一样想要在计算机中寻找乐趣的人们。<a href="https://github.com/wangzhe3224/Python-zhifou">Python知否</a></p>
<p><img src="https://i.imgur.com/HXk9H9N.png" alt=""></p>
<p>这一年，我也真正意义的开始为开源社区做贡献了！</p>
<p><img src="https://i.imgur.com/enU3SoJ.png" alt=""></p>
<h2 id="2026"><a href="#2026" class="headerlink" title="2026"></a>2026</h2><p>我希望5年后，当我再次回首，可以看着过往微笑。然后，写下下一个5年。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾面向对象设计模式</title>
    <url>/2021/10/02/design_pattern/</url>
    <content><![CDATA[<blockquote>
<p>Python的视角<br>转载请注明出处。<br>代码见：<a href="https://github.com/wangzhe3224/Python-zhifou/tree/master/src/todo/design_pattern">https://github.com/wangzhe3224/Python-zhifou/tree/master/src/todo/design_pattern</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>面向对象设计模式就是一系列的组织类和对象的方法，这些方法的目的就是产生更加清晰，且容易拓展和<br>修改的代码。但是，如果我们翻开设计模式的教科书，我们会发现很多的名词，但是这其中很多的模式仅仅<br>是由于语言的限制所产生的的。因为有些语言缺乏函数一等公民或者属于静态类型等等。</p>
<p>尽管如此，学习设计模式仍然非常有用，只不过我们可能需要换一种角度重新审视这些设计模式，去思考<br>这些模式背后的原则：</p>
<ul>
<li>面对接口编程，而不是面对实现</li>
<li>延迟执行，即不到不得不实例化的时候，选择延迟</li>
</ul>
<p>这两个原则不光在面向对象编程中成立，他们在任何一种语言范式中都存在。这两个原则的核心在于如何管理<br>依赖，而管理依赖的方法就是隐藏（或者说封装）和依赖注入。这篇文章我们就讨论如何将这些原则应用到<br>传统的设计模式中：</p>
<ul>
<li>创造模式，Creational Patterns</li>
<li>结构模式，Structural Patterns</li>
<li>行为模式，Behavioral Patterns</li>
</ul>
<h2 id="创造模式，Creational-Patterns"><a href="#创造模式，Creational-Patterns" class="headerlink" title="创造模式，Creational Patterns"></a>创造模式，Creational Patterns</h2><p>创造模式主要是提供一些实例化对象的模式，主要包括：</p>
<ul>
<li>工厂方法</li>
<li>抽象工厂</li>
<li>建造者</li>
<li>原型</li>
<li>单例</li>
</ul>
<p>这些创造模式都是关于实例化一个或者若干个相关的对象的，让我们来看看他们是怎么用到上述两个原则的。<br>下面的小节有如下结构：面临的问题、解决方案、跟原则的关系。由于我们是用Python举例的，Python的<br>很多语言特性，比如鸭子类型、函数一等公民等等，可能会让这些模式看起来与传统的设计模式不太一样，<br>但是，道理是一样的。当然，如果考虑一些更加强大类型系统，比如代数数据类型，很多问题甚至都不存在，<br>比如抽象工厂想要解决的问题，实际上就是 Sum Type 和 Product Type 的组合。。</p>
<h3 id="工厂方法，Factory-Method"><a href="#工厂方法，Factory-Method" class="headerlink" title="工厂方法，Factory Method"></a>工厂方法，Factory Method</h3><p>假设我们有如下类，<code>RobotController</code> 包含一个 <code>Robot</code> 对象，然后可以控制它，<br>比如 <code>some_function</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.robot = Robot()  <span class="comment"># &lt;-- 注意这里，Controller提前实例化的其他的对象，就产生了依赖。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br></pre></td></tr></table></figure>

<p>看起来不错，现在问题来了，这个Controller现在需要为控制另一种机器人，<code>RobotB</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotB</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这时，我们的 controller 类就需要更改代码，才能支持新的 RobotB。其实问题的关键在于<br> controller 过早的实例化 Robot 导致了依赖。这时候我们可以给controller注入一个工厂类，<br> 这个类负责对象的实例化，从而把责任委托给工厂类。而这个工厂类应该是一个抽象（接口）才能保证<br> controller 代码可以实用与更多的不同类型的 Robot。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotInterface</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>():</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">RobotInterface</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotB</span>(<span class="params">RobotInterface</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> moves.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotCreator</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   这个就是所谓的 工厂方法！   &lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>() -&gt; RobotInterface:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotACreator</span>(<span class="params">RobotCreator</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>) -&gt; RobotInterface:</span></span><br><span class="line">        <span class="keyword">return</span> Robot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotBCreator</span>(<span class="params">RobotCreator</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>) -&gt; RobotInterface:</span></span><br><span class="line">        <span class="keyword">return</span> RobotB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, creator: RobotCreator</span>):</span></span><br><span class="line">        <span class="comment"># 原则1：针对抽象编程</span></span><br><span class="line">        <span class="comment"># 原则2：延后对象实例化</span></span><br><span class="line">        <span class="comment"># 原则3：委托责任（给 creator 对象）</span></span><br><span class="line">        self.robot: RobotInterface = creator.create()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    creator_a = CreatorA()</span><br><span class="line">    creator_b = CreatorB()</span><br><span class="line">    controller = RobotController(creator_a)</span><br><span class="line">    controller.move()</span><br></pre></td></tr></table></figure>

<p>不过，对于Python来说，我们并不需要 <code>Creator</code> 这一层抽象，因为 Python 可以直接传递类。<br>我们可以直接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略 Creator 的版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotController</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, robot_cls: RobotInterface</span>):</span></span><br><span class="line">        <span class="comment"># 原则1：针对抽象编程</span></span><br><span class="line">        <span class="comment"># 原则2：延后对象实例化</span></span><br><span class="line">        self.robot: RobotInterface = robot_cls() <span class="comment"># 注意这里传递的 class 不是对象</span></span><br><span class="line">        <span class="comment"># 对于 Java 这种类不是一等公民的语言，Creator往往是必须的，因为只能传递对象。</span></span><br><span class="line">        <span class="comment"># 如果使用依赖注入，我们·可以直接传入一个对象，就省略了 （）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Play with <span class="subst">&#123;self.robot&#125;</span>&quot;</span>)</span><br><span class="line">        self.robot.move()</span><br></pre></td></tr></table></figure>

<p>如果我们使用依赖注入，我们可以直接传入Robot对象，而不是类。</p>
<p>当然，并不是说 <code>Creator</code> 这一层抽象是没有意义的，当我们的对象实例化变得比价复杂的时候，即<br>不是一个 <code>class()</code> 可以搞定的时候，Creator 的工厂方法 <code>create</code> 可以做很多复杂的工作。<br>我举个简单的例子，比如我们希望实例化 RobotB 的时候打印一些信息，我们就可以把相应的逻辑放入<br><code>create</code> 内部，而不需要让其他的类负责。</p>
<p>我再举个例子，如果Robot的构造变得更加复杂了，比如需要组装不同的部件才能获得一个实例，Creator<br>这层抽象就显得是必须的。当然，这里不讨论依赖注入，即使使用依赖注入，直接传递实例化以后的对象，<br>实例化这个对象的复杂度仍然需要一个对象来负责。这里就引出了下一个创造模式：抽象工厂。</p>
<h3 id="抽象工厂，Abstract-Factory"><a href="#抽象工厂，Abstract-Factory" class="headerlink" title="抽象工厂，Abstract Factory"></a>抽象工厂，Abstract Factory</h3><p>我们延续上一个例子，现在机器人变得复杂了，我们需要两个部件组装一个机器人：外壳和灵魂。而每种<br>部件还可能存在不同的类型，比如金属、塑料、液体等等，电子灵魂、人类灵魂等等。这时候为了生产<br>不同的外壳和灵魂组合，我们需要抽象工厂。再一次，对于Python这不是最优雅的实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RobotI</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span>(<span class="params">RobotI</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, shell, soul</span>):</span></span><br><span class="line">        self.shell = shell</span><br><span class="line">        self.soul = soul</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Robot with <span class="subst">&#123;self.shell&#125;</span> and <span class="subst">&#123;self.soul&#125;</span> moves&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryI</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_soul</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self</span>):</span></span><br><span class="line">        shell = self.create_shell()</span><br><span class="line">        soul = self.create_soul()</span><br><span class="line">        <span class="keyword">return</span> Robot(shell, soul)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetalDigitalRobotFactory</span>(<span class="params">FactoryI</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_shell</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> MetalShell() </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_soul</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> DigitalSoul()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory: FactoryI</span>):</span></span><br><span class="line">        <span class="comment"># 注意这里依赖被转移到了factory</span></span><br><span class="line">        <span class="comment"># App 中的逻辑代码不再依赖于 Robot 的具体组装和实现</span></span><br><span class="line">        self.robot: RobotI = factory.create()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    factory = MetalDigitalRobotFactory()</span><br><span class="line">    app = App(factory)</span><br></pre></td></tr></table></figure>

<p>这里，我们可以通过增加新的工厂轻松的拓展我们的代码，而不用触碰已有的代码。下游的控制类并不需要<br>知道制造机器人的复杂度，因为他们不负责实例化机器人，也不必知道机器人的类型，因为他们是针对接口<br>编程的。</p>
<p>不过，在Python这类动态语言中，我们可以简化工厂类成几个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_metal_digital_robot</span>() -&gt; RobotI:</span></span><br><span class="line">    shell = MetalShell() </span><br><span class="line">    soul = DigitalSoul()</span><br><span class="line">    <span class="keyword">return</span> Robot(shell, soul)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory: <span class="built_in">callable</span></span>):</span></span><br><span class="line">        self.robot: RobotI = factory()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    factory = MetalDigitalRobotFactory()</span><br><span class="line">    app = App(factory = create_metal_digital_robot)</span><br></pre></td></tr></table></figure>

<h3 id="建造者，Builder"><a href="#建造者，Builder" class="headerlink" title="建造者，Builder"></a>建造者，Builder</h3><p>建造者模式其实与抽象工厂异曲同工，都是把一个复杂的对象实例化过程封装在一个对象里，而这个builder<br>抽象通过他不同的实现，生产不同的对象。</p>
<h3 id="单例，Singleton"><a href="#单例，Singleton" class="headerlink" title="单例，Singleton"></a>单例，Singleton</h3><p>单例其实就是一个特殊的工厂，他的<code>create</code>方法永远返回唯一的一个对象，这里是指在同一个内存地址的<br>同一个对象。只不过，按照惯例，Singleton的创造方法一般被叫做<code>get_instance</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 如果不存在，就创建一个对象</span></span><br><span class="line">            cls._instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="comment"># 永远返回同一对象。</span></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="原型，Prototype"><a href="#原型，Prototype" class="headerlink" title="原型，Prototype"></a>原型，Prototype</h3><p>原型试图解决的是另一个问题：如果复制一个对象。之前的讨论的模式都是如何初始化（实例化）一个对象。<br>即实现一个 <code>clone</code> 方法。这样做的好处是把复制对象的任务交个对象自己完成，不需要暴露内部状态<br>给客户端。</p>
<p>如果是Python实现的话，只需要实现<code>__copy__</code> 和 <code>__deepcopy__</code> 即可。当然也可以使用经典的<br><code>clone</code>接口。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这几个创造模式围绕的核心都是：面向接口编程 和 延迟创建。无论是抽象工厂、单例、原型，他们<br>管理依赖的基石都是通过接口，接口隐藏了细节和复杂度（比如复杂的构造过程、复杂的拷贝过程等等）。<br>也正是因为有了接口，我们就把创建类的任务委托给了其他对象。</p>
<h2 id="结构模式，Structural-Patterns"><a href="#结构模式，Structural-Patterns" class="headerlink" title="结构模式，Structural Patterns"></a>结构模式，Structural Patterns</h2><p>结构模式主要是针对如何把不同的数据（对象）放在一起。我们会分析如下设计模式：</p>
<ul>
<li>组合，Composite</li>
<li>转换器，Adapter</li>
<li>代理，Proxy</li>
<li>装饰器，Decorator</li>
<li>桥接，Bridge</li>
</ul>
<p>随着我们的分析会进一步发现，这些模式可以存在往往是因为原则1，即面向接口编程。</p>
<h3 id="组合，Composite"><a href="#组合，Composite" class="headerlink" title="组合，Composite"></a>组合，Composite</h3><p>在讨论创造模式的时候，我们看到很多模式对于动态语言来说显得过于啰嗦。<br>但是，无论在动态语言，还是静态语言中，组合模式是我认为非常有用且强大的模式。</p>
<p>组合模式适用于组织树状数据结构，组合模式通过结构可以让简单数据和由简单数据复合形成的<br>复杂结构共享同一个结构，实现“一视同仁”。</p>
<p>我们举个简单的例子，假设我们有两种对象：物品和盒子。盒子里面可以包含若干物品，也可以包含<br>更多的盒子。但是物品里面没有盒子，也就是说，物品是我们的最基对象，而盒子是复杂对象。<br>每一个物品都有一个价格，而盒子的价格等于其中物品价格的总和。那么，给出一个对象（盒子或<br>物品），我们需要计算他的价格。如何组织数据结构呢？</p>
<p>一种方式，我们一层一层遍历对象，判断如果是物品，提取价格，如果是盒子，进一步遍历。</p>
<p>另一种方法就是使用组合模式，让基本对象（物品）和复合对象（盒子）共享一个接口，这样我们<br>就不需要判断对象的类型，实现递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThingI</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">ThingI</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, price</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._price = price</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._price</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>(<span class="params">ThingI</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, contents: <span class="type">List</span>[ThingI]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># 假设没有循环出现</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.contents = contents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        sum_price = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.contents:</span><br><span class="line">            sum_price += item.price()</span><br><span class="line">        <span class="keyword">return</span> sum_price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    </span><br><span class="line">    a = Product(<span class="number">1.0</span>)</span><br><span class="line">    b = Product(<span class="number">1.0</span>)</span><br><span class="line">    c = Box(contents=[</span><br><span class="line">        Product(<span class="number">1.0</span>),</span><br><span class="line">        Box(</span><br><span class="line">            contents=[</span><br><span class="line">                Product(<span class="number">1.0</span>)</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">        Box(</span><br><span class="line">            contents=[</span><br><span class="line">                a, b</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    ])</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Price of c is <span class="subst">&#123;c.price()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<p>如上面的例子，我们把计算和遍历对象内部状态的事情留给了对象自己，调用者完全不需要知道对象那种<br>类型，也无需知道内部的状态，它仅仅通过调用接口即可。这种通过接口统一不用对象的方法非常实用。<br>当然传统的设计模式中，复合对象（本例中的盒子）还会有一些特殊的方法，比如用来增加和减少他自己的<br>子对象等等。不过加入这些方法，可能会打破基本类型和复合类型的对称性，在后续的代码编写过程中<br>可能会造成问题。</p>
<h3 id="转换器、桥接、装饰器、代理"><a href="#转换器、桥接、装饰器、代理" class="headerlink" title="转换器、桥接、装饰器、代理"></a>转换器、桥接、装饰器、代理</h3><p>这四种模式其实有类似的地方，他们都是通过在原有的对象之间增加一个兼容两边的接口，实现对不同类型<br>的组合。转换器与桥接的主要区别在于，转换器通常是在软件开发的后续过程中由于增加新的功能，需要<br>协调已经有的部分；而桥接主要是在软件设计阶段。其实某种程度上，我们的机器人例子中的组装工厂就<br>有点桥接的意思了。桥接主要是通过对象面A对其他的对象B的结构编程，从而解耦合A和B的具体实现。</p>
<p>代理和装饰器则是通过实现一个与原对象相同的接口，从而实现对原有功能的一个拓展或者更改。设计模式<br>里面的装饰器模式跟Python的装饰器并不是同一个事情，但是实际上实现的功能非常类似。只不过Python<br>的装饰器主要是针对函数的，而函数本身也确实没有类型（其实有，但是对于Python真的不重要）。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过上述分析，可以发现接口在组织数据结构对象和解耦合方面有奇效。依然贯彻面对接口编程的原则。</p>
<h2 id="行为模式，Behavior-Patterns"><a href="#行为模式，Behavior-Patterns" class="headerlink" title="行为模式，Behavior Patterns"></a>行为模式，Behavior Patterns</h2><p>行为模式强调的是对象之间的计算和互动模式。主要涉及：</p>
<ul>
<li>访问者，Visitor</li>
<li>观察者，Observer</li>
<li>命令，Command</li>
<li>迭代器，Iterator</li>
<li>备忘录，Memento</li>
<li>策略，Strategy</li>
<li>状态机，State</li>
</ul>
<p>这类设计模式比较丰富，不同语言特性实现出来的风格迥异，但是他们蕴含的设计里面才是精华。</p>
<h3 id="访问者，Visitor"><a href="#访问者，Visitor" class="headerlink" title="访问者，Visitor"></a>访问者，Visitor</h3><p>访问者模式强调分离同一个数据对象与他的算法。经典的实现如下代码，其核心部分是 <code>Visitor</code> 这个<br>结构以及每一个被访问的对象的 <code>accept</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Visitor Interface declares a set of visiting methods that correspond to</span></span><br><span class="line"><span class="string">    component classes. The signature of a visiting method allows the visitor to</span></span><br><span class="line"><span class="string">    identify the exact class of the component that it&#x27;s dealing with.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element: ConcreteComponentA</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element: ConcreteComponentB</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Component interface declares an `accept` method that should take the</span></span><br><span class="line"><span class="string">    base visitor interface as an argument.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponentA</span>(<span class="params">Component</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Each Concrete Component must implement the `accept` method in such a way</span></span><br><span class="line"><span class="string">    that it calls the visitor&#x27;s method corresponding to the component&#x27;s class.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        visitor.visit_concrete_component_a(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exclusive_method_of_concrete_component_a</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Concrete Components may have special methods that don&#x27;t exist in their</span></span><br><span class="line"><span class="string">        base class or interface. The Visitor is still able to use these methods</span></span><br><span class="line"><span class="string">        since it&#x27;s aware of the component&#x27;s concrete class.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponentB</span>(<span class="params">Component</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Same here: visitConcreteComponentB =&gt; ConcreteComponentB &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self, visitor: Visitor</span>):</span></span><br><span class="line">        visitor.visit_concrete_component_b(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">special_method_of_concrete_component_b</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor1</span>(<span class="params">Visitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor2</span>(<span class="params">Visitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_a</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.exclusive_method_of_concrete_component_a()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_concrete_component_b</span>(<span class="params">self, element</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.special_method_of_concrete_component_b()&#125;</span> + ConcreteVisitor2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_code</span>(<span class="params">components: <span class="type">List</span>[Component], visitor: Visitor</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The client code can run visitor operations over any set of elements without</span></span><br><span class="line"><span class="string">    figuring out their concrete classes. The accept operation directs a call to</span></span><br><span class="line"><span class="string">    the appropriate operation in the visitor object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> component <span class="keyword">in</span> components:</span><br><span class="line">        component.accept(visitor)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="观察者，Observer"><a href="#观察者，Observer" class="headerlink" title="观察者，Observer"></a>观察者，Observer</h3><p>这种设计模式可以说非常常见了，观察者也就是我们经常听到的广播订阅模式。这种模式如今已经走出了<br>设计模式的范畴，在架构领域也是经常见到，比如我们常见的Kafka就是这种设计模式实现的中间件。</p>
<p>同时，与访问者对比，观察者会被动得到通知，而访问者需要主动要求 (调用<code>accept</code>)。</p>
<p>经典的实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The Subject interface declares a set of methods for managing subscribers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Attach an observer to the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Detach an observer from the subject.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Notify all observers about an event.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span>(<span class="params">Subject</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; The Subject owns some important state and notifies observers when the state</span></span><br><span class="line"><span class="string">    changes.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _state: <span class="built_in">int</span> = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; For the sake of simplicity, the Subject&#x27;s state, essential to all</span></span><br><span class="line"><span class="string">    subscribers, is stored in this variable.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _observers: <span class="type">List</span>[Observer] = []</span><br><span class="line">    <span class="string">&quot;&quot;&quot; List of subscribers. In real life, the list of subscribers can be stored</span></span><br><span class="line"><span class="string">    more comprehensively (categorized by event type, etc.).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Attached an observer.&quot;</span>)</span><br><span class="line">        self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span>(<span class="params">self, observer: Observer</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Trigger an update in each subscriber.  &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Subject: Notifying observers...&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self._observers:</span><br><span class="line">            observer.update(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_business_logic</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nSubject: I&#x27;m doing something important.&quot;</span>)</span><br><span class="line">        self._state = randrange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Subject: My state has just changed to: <span class="subst">&#123;self._state&#125;</span>&quot;</span>)</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; The Observer interface declares the update method, used by subjects.  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Receive update from subject.  &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverA</span>(<span class="params">Observer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> subject._state &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverA: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverB</span>(<span class="params">Observer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, subject: Subject</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> subject._state == <span class="number">0</span> <span class="keyword">or</span> subject._state &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ConcreteObserverB: Reacted to the event&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># The client code.</span></span><br><span class="line"></span><br><span class="line">    subject = ConcreteSubject()</span><br><span class="line"></span><br><span class="line">    observer_a = ConcreteObserverA()</span><br><span class="line">    subject.attach(observer_a)</span><br><span class="line"></span><br><span class="line">    observer_b = ConcreteObserverB()</span><br><span class="line">    subject.attach(observer_b)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br><span class="line">    subject.some_business_logic()</span><br><span class="line"></span><br><span class="line">    subject.detach(observer_a)</span><br><span class="line"></span><br><span class="line">    subject.some_business_logic()</span><br></pre></td></tr></table></figure>

<h3 id="命令，Command"><a href="#命令，Command" class="headerlink" title="命令，Command"></a>命令，Command</h3><p>命令模式在如今的软件工程中也非常常见，它其实是一种对象之间的通讯方式，命令模式会把一个请求<br>转换成包含完成这个命令的信息的独立对象，这个命令对象随后可以被发送给命令的执行对象执行。<br>从而实现了发送者和接受者的解耦合。看起来与观察者有一点类似，命令的执行者可以算是某种命令的<br>观察者。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">ABC</span>):</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, payload: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._payload = payload</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SimpleCommand execute with <span class="subst">&#123;self._payload&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, receiver: Receiver, a, b</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._receiver = receiver</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ComplexCommand execute with <span class="subst">&#123;self._receiver&#125;</span>&quot;</span>)</span><br><span class="line">        self._receiver.do_a(self._a)</span><br><span class="line">        self._receiver.do_b(self._b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 包含了业务逻辑，即知道如何响应命令。 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_a</span>(<span class="params">self, a: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> do a with <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_b</span>(<span class="params">self, b: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> do b with <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_on_start</span>(<span class="params">self, command: Command</span>):</span></span><br><span class="line">        self._on_start = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_on_finish</span>(<span class="params">self, command: Command</span>):</span></span><br><span class="line">        self._on_finish = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something_important</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_start, Command):</span><br><span class="line">            self._on_start.execute()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self._on_finish, Command):</span><br><span class="line">            self._on_finish.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    invoker = Invoker()</span><br><span class="line">    invoker.set_on_start(SimpleCommand(<span class="string">&quot;Say Hi!&quot;</span>))</span><br><span class="line">    receiver = Receiver()</span><br><span class="line">    invoker.set_on_finish(ComplexCommand(</span><br><span class="line">        receiver, <span class="string">&quot;Send email&quot;</span>, <span class="string">&quot;Save report&quot;</span>))</span><br><span class="line">    invoker.do_something_important()</span><br></pre></td></tr></table></figure>

<h3 id="迭代器，Iterator"><a href="#迭代器，Iterator" class="headerlink" title="迭代器，Iterator"></a>迭代器，Iterator</h3><p>迭代器是关于如何遍历数据结构的模式。比如一个树结构，我们可以通过定义迭代器接口方法：<code>iterator</code> 来抽象不同的遍历风格，比如深度优先、广度优先等等。</p>
<h3 id="备忘录，Memento"><a href="#备忘录，Memento" class="headerlink" title="备忘录，Memento"></a>备忘录，Memento</h3><p>备忘录是一种在不打破对象封装的前提下，对对象进行快照的方法，通过快照我们可以方便的进行历史重现。其核心在于把管理快照的功能交给其他对象。在Python中快照可以通过不同的序列化实现。</p>
<h3 id="策略，Strategy"><a href="#策略，Strategy" class="headerlink" title="策略，Strategy"></a>策略，Strategy</h3><p>策略模式其实就是为算法定义一个接口，从而实现随意插入任意具体算法的模式。可以参考机器人的例子。<br>抽象工厂可以理解成某个工厂算法。</p>
<h3 id="状态机，State"><a href="#状态机，State" class="headerlink" title="状态机，State"></a>状态机，State</h3><p>状态机也是非常常见的设计模式，也就是一个对象的行为，取决于它内部的状态；而他对事件的相应，也会<br>影响他内部的状态。我认为是一种与组合模式同样影响深远的模式。状态机会把这些复杂度封装在对象内部<br>而不会让客户端通过一些if语句来控制。同样，这也是一种责任交付。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Context 是包含 State 的对象，也就是 state 的客户端 &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    _state = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, state: State</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.transition_to(state)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transition_to</span>(<span class="params">self, state: State</span>):</span></span><br><span class="line">        self._state = state</span><br><span class="line">        self._state.context = self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._state.handle1()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request2</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._state.handle2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>(<span class="params">ABC</span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">context</span>(<span class="params">self</span>) -&gt; Context:</span></span><br><span class="line">        <span class="keyword">return</span> self._context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @context.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">context</span>(<span class="params">self, context: Context</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self._context = context</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的状态机有两个状态，A 和 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span>(<span class="params">State</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request1.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateB())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateA handles request2.&quot;</span>)    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span>(<span class="params">State</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle1</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle2</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB handles request2.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ConcreteStateB wants to change the state of the context.&quot;</span>)</span><br><span class="line">        self.context.transition_to(ConcreteStateA())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    context = Context(ConcreteStateA())</span><br><span class="line">    context.request1()</span><br><span class="line">    context.request2()</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>可以看出，设计模式主要使用的技巧就是：</p>
<ul>
<li>面对接口编程</li>
<li>延迟执行</li>
<li>依赖注入</li>
<li>组合 而不是 继承</li>
</ul>
<p>在上面的例子中，所有的继承都紧紧是接口的一种实现，并不是真正意义的共享状态，而是共享合同。<br>这种共享接口让程序变更加容易拓展。依赖注入可以看成某种延迟执行。</p>
<p>当然，不同的语言特性会让这些模式实现看起来非常不一样，比如采用鸭子类型的语言，Python或者Go，<br>很多继承是不需要的，我们只需要duck type接口的方法即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://refactoring.guru/design-patterns">https://refactoring.guru/design-patterns</a></li>
<li><a href="https://github.com/faif/python-patterns">https://github.com/faif/python-patterns</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建流计算集群</title>
    <url>/2021/09/04/flink_raspberrypi/</url>
    <content><![CDATA[<h1 id="树莓派搭建流计算集群"><a href="#树莓派搭建流计算集群" class="headerlink" title="树莓派搭建流计算集群"></a>树莓派搭建流计算集群</h1><blockquote>
<p>生活扇了我一巴掌，我能怎么办？擦擦脸，接着与生活同行。:-1</p>
<p>无名 2021</p>
</blockquote>
<p>本篇介绍如何利用（闲置的）树莓派搭设流处理集群。</p>
<p>原材料：树莓派若干。（我有两个ARMv7的树莓派4）</p>
<p>主要用到的技术和软件：</p>
<ul>
<li>Docker, 用来管理集群计算资源</li>
<li>Portainer，集群管理UI</li>
<li>Flink，原生流处理凭条</li>
<li>Redis，缓存+Broker</li>
<li>Prometheus，流监控</li>
<li>Grafana，图形化流监控</li>
</ul>
<p>集群控制没有使用K8s，因为k8s对32位处理器支持一般，而且没有原生的ARM支持，只能用一个API协调的软件叫k3s，后来发现还不如直接用<code>Docker Swarm</code>就行集群资源管理。反正所有的服务都是 docker 容器，后期集群扩容，只需要在新节点上加入集群即可。</p>
<p>最终我的集群包含两个Docker Swarm节点：</p>
<p><img src="https://i.imgur.com/qphWSv6.png" alt=""></p>
<p>集群运行服务：</p>
<p><img src="https://i.imgur.com/evOfMHt.png" alt=""></p>
<h2 id="树莓派设置"><a href="#树莓派设置" class="headerlink" title="树莓派设置"></a>树莓派设置</h2><p>首先，安装操作系统，具体可以<a href="https://www.raspberrypi.org/documentation/computers/getting-started.html">参考</a>。基本的操作就是下载操作系统，烧录在sd卡里，然后把卡查回树莓派。<br>这里注意SD卡烧制系统结束后，在SD卡跟目录里加入一个空的叫<code>ssh</code>的文件，这样树莓派会自动激活ssh服务。默认用户是<code>pi</code>，密码是<code>raspberry</code>。这样就可以实现headless部署。</p>
<p>将多个树莓派通过集线器或者路由器连接起来，然后设置每个树莓派的hostname和静态IP地址。</p>
<p>静态IP地址可以在这里设置：<code>/etc/dhcpcd.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address &#x3D; 192.168.1.xxx</span><br><span class="line">static domain_name_server &#x3D; 192.168.1.1, 8.8.8.8</span><br></pre></td></tr></table></figure>

<h2 id="创建Docker-Swarm集群"><a href="#创建Docker-Swarm集群" class="headerlink" title="创建Docker Swarm集群"></a>创建Docker Swarm集群</h2><p>SSH进入一个树莓派，将它作为集群的主机：</p>
<ol>
<li>安装 Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 Swarm 集群</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-adr 192.168.1.xxx</span><br></pre></td></tr></table></figure>

<p>其中<code>xxx</code>就是当前选定的集群主机静态IP地址。这个命令会生成一个token，记录token用来后续接入其他集群节点。</p>
<p>在其他节点树莓派中同样安装docker，但是输入如下命令连接入集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm join --token 这里是你的token 192.168.1.xxx:2377</span><br></pre></td></tr></table></figure>

<p>所有节点接入集群后，可以在集群主机查看集群状态：<code>docker node ls</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">4588i2fvipv17led4hptn349s *   pi1        Ready     Active         Leader           20.10.8</span><br><span class="line">uvhsalsyo9zfx8z5ny4nfb4ze     pi2        Ready     Active                          20.10.8</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装 Portainer 监控集群状态</li>
</ol>
<p>在主机执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker volume create portainer_data</span><br><span class="line">$ docker run -d -p 8000:8000 -p 9000:9000 --name&#x3D;portainer --restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer-ce</span><br></pre></td></tr></table></figure>

<p>然后就可用过访问<code>192.168.1.xxx:9000</code>访问集群控制界面了。</p>
<h2 id="部署流处理集群服务"><a href="#部署流处理集群服务" class="headerlink" title="部署流处理集群服务"></a>部署流处理集群服务</h2><p>具体的配置文件见这个<a href="https://github.com/wangzhe3224/flink-fog-cluster">repo</a>。</p>
<p>主要的工作在于自己build可用flink镜像，可以clone仓库，然后自己build一个镜像。也可以直接pull我做的好的镜像：<code>docker pull wangzhe3224/flink-1.13.2-armv7:latest</code>，这是针对的arml7处理器的，后期的树莓派应该都是v8版本了，需要另外重新构建。</p>
<p>下一步就是用docker文件配置各项服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jobmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">digitaljazz/flink-1.8.0-armv7:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">jobmanager.sh</span> <span class="string">start-foreground</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">taskmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">digitaljazz/flink-1.8.0-armv7:latest</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">taskmanager.sh</span> <span class="string">start-foreground</span> <span class="string">-Djobmanager.rpc.address=jobmanager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">flinknet</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="type">!=</span> <span class="string">worker04</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="type">!=</span> <span class="string">worker01</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mosquitto:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">eclipse-mosquitto:1.6.5</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1883:1883&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mosquitto</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker01</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:latest</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/prometheus.yaml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:6.1.3</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">flinknet:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GF_SECURITY_ADMIN_PASSWORD=admin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./grafana/provisioning/:/etc/grafana/provisioning/</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname</span> <span class="string">==</span> <span class="string">worker04</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">flinknet:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">overlay</span></span><br></pre></td></tr></table></figure>

<p>然后再集群主机：<code>docker stack deploy --compose-file docker-stack.yaml flink</code> 启动所有服务。</p>
<p>可以通过<code>docker service ls</code> 查看集群运行服务。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>Redis</tag>
        <tag>树莓派</tag>
        <tag>Streaming</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于动态内存分配</title>
    <url>/2021/08/29/malloc_1/</url>
    <content><![CDATA[<h1 id="关于动态内存分配"><a href="#关于动态内存分配" class="headerlink" title="关于动态内存分配"></a>关于动态内存分配</h1><p>动态内存分配通常是指堆内存（Heap，不是数据结构背景下的堆结构）的动态分配和收回。<br>动态内存分配与程序的性能和内存使用情况息息相关。对于性能主要涉及两个方面：<br>分配和释放内存的性能，即吞吐；内存的局部性（与缓存相关），即缓存友好。<br>对于内存的利用率，主要是关于内存碎片的优化。</p>
<h2 id="Mental-Model-心智模型"><a href="#Mental-Model-心智模型" class="headerlink" title="Mental Model (心智模型)"></a>Mental Model (心智模型)</h2><blockquote>
<p>A mental model is an explanation of someone’s thought process<br>about how something works in the real world.<br>– wiki</p>
</blockquote>
<p>在现代操作系统中，每一个进程都具有自己的独立<em>虚拟内存空间</em>。虚拟内存是一个抽象：<br>它隐藏了硬件存储系统的复杂度。存储系统包括：内存、硬盘、网络上其他计算机的存储系统。<br>进程对存储系统的操作就建立在这个抽象上：每个进程（同一个机器或者不同机器）看到的<br>内存地址空间都是一样的！</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在进一步讨论之前，我们还需要了解另外一个<br>概念：内存映射（Memory Mapping）。Linux类系统在初始化虚拟内存空间时，会将这部分<br>内存与硬盘上的一个对象联系起来。内存映射有两种：</p>
<ul>
<li><em>一般文件</em></li>
<li><em>匿名文件</em></li>
</ul>
<p><em>一般文件</em>：一个正常文件中的内容分页（page）被映射到（虚拟）内存地址上。但是，直到CPU<br>主动请求某个页的时候，文件中的内从才会被拷贝进入内存。</p>
<p><em>匿名文件</em>：系统把一部分内存映射到一个匿名文件中，并且用0填充该内存空间，这些页也被称为<br>demand-zero page。</p>
<p>无论是哪种情况，虚拟内存也被初始化后，他就会与一个交换文件（swap file）连接，并与他不断<br>交换数据。(每一个进程都有一个交换文件吗？)</p>
<p><img src="https://i.imgur.com/vRpgBpw.jpg" alt="内存心智模型"></p>
<h3 id="堆内存动态分配"><a href="#堆内存动态分配" class="headerlink" title="堆内存动态分配"></a>堆内存动态分配</h3><p>动态内存分配就是负责管理堆内存空间的，而在内存中申请空间的就是通过内存映射（Demand-zero）。</p>
<p><em>为什么需要动态内存分配</em>？因为程序与在运行过程中不可避免要动态的产生和销毁对象，但是我们不能<br>无限分配内存，而不去回收不再需要的对象，否则内存最终会溢出。</p>
<p>内存分配器主要有两种风格：</p>
<ul>
<li>显式，即应用程序主动申请和释放内存。比如C++中的<code>new</code>和<code>delete</code>，或者C中的<code>malloc</code>和<code>free</code>。</li>
<li>隐式，也成为垃圾回收（GC），即应用程序不主动释放，有分配器自动释放。比如Java、Python、Ocaml都有自己的GC系统</li>
</ul>
<p><strong>显式分配器</strong></p>
<p>显式分配器主要有两个API：alloc和free。alloc返回一个指针指向申请到的空间，<br>free回收某个指针指向的空间。显式分配器需要满足如下设计需求：</p>
<ul>
<li>处理任意组合的alloc和free序列</li>
<li>快速的分配或者释放内存</li>
<li>只使用堆内存</li>
<li>满足特定的对齐标准</li>
<li>不能改变已经分配的内存内容</li>
</ul>
<p>好的分配器需要：</p>
<ul>
<li>高吞吐</li>
<li>高利用率</li>
</ul>
<p>我们会在后面讨论具体的实现，但是分配器的新式模型如下：</p>
<p>在堆内存中构建一系列块（节点、Block等等名字），这些块包含两部分内容：元信息（Meta Data）和数据，这些<br>块有一些写代数据（就是包含了应用程序来的数据），另外一些则是空的，仅仅包含元信息。这些块通过元信息进行<br>连接，从而实现分配和释放。比如，这些块可以是一个链表，也可以是其他更加复杂的数据结构，比如分段链表等等。<br>从概念上，不同的数据结构实现，就会有不同的效率，需要根据具体情况选择。</p>
<p><img src="https://i.imgur.com/lem9r6i.jpg" alt=""></p>
<p><strong>隐式分配器</strong></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://users.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">Dynamic Storage Allocation: A Survey and Critical Review</a></li>
<li><a href="https://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">jemalloc</a></li>
<li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf">mimalloc</a></li>
</ul>
]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>Memory Allocation</tag>
      </tags>
  </entry>
  <entry>
    <title>Bomb Lab</title>
    <url>/2021/08/08/csapp_bomb_lab/</url>
    <content><![CDATA[<h1 id="Bomb-Lab-解析"><a href="#Bomb-Lab-解析" class="headerlink" title="Bomb Lab 解析"></a>Bomb Lab 解析</h1><p>Bomb Lab 实际就是通过反汇编和GDB对一个二进制文件行进分析，寻找每一个阶段需要输入的特定字符串。主要考察对汇编代码、栈帧、寄存器的熟悉程度以及使用GDB的能力。</p>
<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>推荐大家使用docker构建一个环境方便省时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image = <span class="string">&quot;zwang/csapp&quot;</span></span><br><span class="line">path=<span class="string">&quot;/xxx/xxx&quot;</span>  <span class="comment"># 这里修改成你自己的lab目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! docker container rm csapp_env; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;remove old container.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;no old container exist. Create a new one&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker container run -it -v <span class="variable">$&#123;path&#125;</span>:/projects -p 8080:8080 --name=csapp_env --net host wangzhe3224/csapp /bin/bash</span><br></pre></td></tr></table></figure>

<p>上面的命名会直接从远程docker仓库pull一个我设置好的环境，并且进入那个docker的bash。环境中已经装好了：vim, gdb, cgdb 等一些列方便调试的软件和必要的 c 语言相关库。</p>
<h2 id="GDB小抄"><a href="#GDB小抄" class="headerlink" title="GDB小抄"></a>GDB小抄</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- info r, 展示寄存器内容</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://web.stanford.edu/class/cs107/resources/x86-64-reference.pdf">CS107 x86-64 Reference Sheet</a></li>
<li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">x64 Cheat Sheet</a></li>
<li><a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">GDB 参考</a></li>
</ul>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p>首先观察源代码入口 <code>bomb.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">* Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>每一个阶段都是上面的模式，读取输入的字符串，传入每一个阶段的函数体，在函数体中检测输入的字符串是否与程序预设相同，如果相同则进入下一阶段。另外，lab还推荐写一个文本文件作为每一步的结果，这样方便测试，该文件每一行就是每一阶段的答案。本文假设该文件名为<code>psol.txt</code>。</p>
<p>首先，为了更完成的看到反汇编代码，我们做<code>objdump -d bomb &gt; bomb.as</code> 获得二进制炸弹的汇编代码方便查阅。当然，本文使用 cgdb 作为调试工具，可以相对方便的在调试过程看到机器码，也可以不必一直参考汇编代码文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 进入debug模式</span><br><span class="line">cgdb bomb</span><br><span class="line"></span><br><span class="line"># 在phase_1处设置断点</span><br><span class="line">b phase_1</span><br><span class="line">r &lt; psol.txt</span><br></pre></td></tr></table></figure>

<p>得到如下phase_1的汇编：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> 1│ Dump of assembler code for function phase_1:</span><br><span class="line"> 2├──&gt; 0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line"> 3│    0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line"> 4│    0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line"> 5│    0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line"> 6│    0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line"> 7│    0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line"> 8│    0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line"> 9│    0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">10│ End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>我们逐一分析：</p>
<ul>
<li>申请8字节的栈空间</li>
<li>把0x402400放入%esi，我们知道esi会存放接下来函数调用的第二个参数，第一个参数在%edi</li>
<li>然后调用strings_not_equal函数</li>
</ul>
<p>分析到这里已经比较清楚，我们只需要看一下<code>0x402400</code>这个内存地址放了什么东西，我们输入的字符串，应该就是要跟这个东西比较的，因为这是strings_not_equal的第二个参数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>因此，我们只需要把 <code>Border relations with Canada have never been better.</code> 写入 psol.txt 的第一行，作为我们炸弹阶段一的答案。</p>
<p>如果不担心炸弹会爆炸，我们可以试一试：<code>./bomb &lt; psol.txt</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/60237228">https://zhuanlan.zhihu.com/p/60237228</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31269514">https://zhuanlan.zhihu.com/p/31269514</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/57977157">https://zhuanlan.zhihu.com/p/57977157</a></li>
</ul>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能Python编程（2）Profiling寻找性能瓶颈</title>
    <url>/2021/07/22/high_perf_python_2/</url>
    <content><![CDATA[<h1 id="高性能Python编程（2）Profiling寻找性能瓶颈"><a href="#高性能Python编程（2）Profiling寻找性能瓶颈" class="headerlink" title="高性能Python编程（2）Profiling寻找性能瓶颈"></a>高性能Python编程（2）Profiling寻找性能瓶颈</h1><blockquote>
<ul>
<li><a href="https://wangzhe3224.github.io/2021/06/24/high_perform_python/">高性能Python编程（1）：理解Python的“性能”</a></li>
</ul>
</blockquote>
<blockquote>
<p>相关源代码：<a href="https://github.com/wangzhe3224/high_performance_python">https://github.com/wangzhe3224/high_performance_python</a><br>更多学习资源：微信搜索   泛程序员   并添加关注，点击资源按钮。<br>更多学习视频：微信视频号  Python知否</p>
</blockquote>
<p><img src="https://i.imgur.com/sFSXT7N.jpg" alt=""></p>
<p>上一篇我们分析了计算机的三个组成部分，以及对应到Python程序的意义，这一篇我们从比较概括的角度介绍高性能编程的第一步：Profiling。（这个词我也不知道该怎么翻译，程序侧写？）</p>
<p>Profiling可以帮助我们发现：程序的那个部分运行缓慢（计算单元）、哪个部分占用大量内存（存储单元）、那个部分占用了网络、硬盘IO（通信单元）等等。所以Profiling是我们提高运行效率的第一步。</p>
<p><strong>划重点</strong>：</p>
<blockquote>
<ol>
<li>当你想要优化你的程序以前，先Profile！换句话说，不profile不优化。</li>
<li>无论你怎么Profiling你的代码，确保代码有足够的unit test覆盖，避免一些错误，重构代码也更有信心。</li>
</ol>
</blockquote>
<p>记住这两个原则将会在你的编码生涯中为你节约大量时间。而我们接下来要讨论的就是如何高效Profiling。</p>
<p>首先，讨论最基础的Profiling工具：<code>%timeit</code>，<code>time.time()</code> 和time装饰器。然后介绍<code>cProfiler</code>，这个内置包可以帮助我们查看程序中不同函数占用的时间，帮助发现瓶颈。接下来，<code>line_profiler</code> 可以对选中的瓶颈函数进行逐行profile，比如每一个行被调用多少次，每一行花掉时间的百分比等等。最后，我们还需要提一下<code>memory_profiler</code>，它可以用来分析我们的内存使用情况，可以解决诸如为什么这个函数使用过多的内存之类的问题。</p>
<p>上面提到的都属于静态Profile，对于一些长期驻留内存的进程，可以通过<code>py-spy</code>对进程的CPU和内存使用进行实时动态Profile，这类工具对于在线debug非常有帮助。</p>
<p>有了上面的分析后，我们基本可以确定程序的CPU和内存瓶颈，我们就可以对症下药，提高性能，比如编译、查看ByteCode等等。具体方法我们在后面的文章继续说明。</p>
<h2 id="例子：生成Julia集"><a href="#例子：生成Julia集" class="headerlink" title="例子：生成Julia集"></a>例子：生成Julia集</h2><p>为了让讨论更加具体，这个系列会用通过一个实际的例子说明：生成Julia集。这个例子属于计算密集型函数，覆盖了Python常见的一些操作，比如循环、判断等。<a href="https://github.com/wangzhe3224/high_performance_python/blob/master/src/julia_set.py">具体代码</a>在这里。</p>
<p>直接运行的结果为：</p>
<p><img src="https://i.imgur.com/iKTwdN6.png" alt="Julia集"></p>
<p>这一篇我们首先用纯Python实现Julia集，然后以这个函数为例，讲解如何对Python程序Profiling。</p>
<p>下面就是julia集的核心函数，由纯Python实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    output = [<span class="number">0</span>] * <span class="built_in">len</span>(zs)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(zs)):</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        z = zs[i]</span><br><span class="line">        c = cs[i]</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">abs</span>(z)) &lt; <span class="number">2</span> <span class="keyword">and</span> n &lt; max_iter:</span><br><span class="line">            z = z*z + c</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        output[i] = n</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_pure_python</span>(<span class="params">width: <span class="built_in">int</span>, max_iter: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create a list of complex coordinates &quot;&quot;&quot;</span></span><br><span class="line">    x_step = ( x2 - x1 ) / width</span><br><span class="line">    y_step = ( y2 - y1 ) / width</span><br><span class="line">    x, y = [], []</span><br><span class="line">    ycood = y1 </span><br><span class="line">    <span class="keyword">while</span> ycood &lt; y2:</span><br><span class="line">        y.append(ycood)</span><br><span class="line">        ycood += y_step</span><br><span class="line">    xcood = x1</span><br><span class="line">    <span class="keyword">while</span> xcood &lt; x2:</span><br><span class="line">        x.append(xcood)</span><br><span class="line">        xcood += x_step</span><br><span class="line"></span><br><span class="line">    zs = []</span><br><span class="line">    cs = []</span><br><span class="line">    <span class="keyword">for</span> ycoord <span class="keyword">in</span> y:</span><br><span class="line">        <span class="keyword">for</span> xcoord <span class="keyword">in</span> x:</span><br><span class="line">            zs.append(<span class="built_in">complex</span>(xcoord, ycoord)) </span><br><span class="line">            cs.append(<span class="built_in">complex</span>(c_real, c_imag))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Length of x: <span class="subst">&#123;<span class="built_in">len</span>(x)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Total elements: <span class="subst">&#123;<span class="built_in">len</span>(zs)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里我们进行一个简单的计时，来粗略估计函数的运行时间。</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    output = calculate_z_serial_purepython(max_iter, zs, cs)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    secs = end_time - start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;calculate_z_serial_purepython.__name__&#125;</span> took <span class="subst">&#123;secs&#125;</span> seconds.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">sum</span>(output) = &#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>可以看到，在调用<code>calculate_z_serial_purepython</code>后，通过使用<code>start_time</code>和<code>end_time</code>，可以获得函数运行一次消耗的时间。</p>
<p>在我的电脑上输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Length of x: 1000</span><br><span class="line">Total elements: 1000000</span><br><span class="line">calculate_z_serial_purepython took 5.339544057846069 seconds.</span><br><span class="line">sum(output) &#x3D; 33219980</span><br></pre></td></tr></table></figure>

<p><code>calculate_z_serial_purepython</code> 耗时5.34秒，总计计算了3亿个强度值。（CPython3.9，MacBook Pro 16）</p>
<h2 id="CPU和内存Profile方法"><a href="#CPU和内存Profile方法" class="headerlink" title="CPU和内存Profile方法"></a>CPU和内存Profile方法</h2><h3 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a><code>timeit</code></h3><p>最简单的Profile方法是利用<code>time</code>和<code>print</code>，就像我们上一小节做的一样，但是用起来不是很方便，我们可以写一个装饰器来实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timefn</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">fn</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">measure_time</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fn(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;@timefn: <span class="subst">&#123;fn.__name__&#125;</span> took <span class="subst">&#123;t2-t1:<span class="number">.4</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> measure_time</span><br></pre></td></tr></table></figure>

<p>然后我们就可以装饰需要profile的函数，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timefn</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>不过这样profile有一个弊端就是我们只能取一个sample，而好的profile通常需要多次运行，观察统计特征，这样才能排除各种干扰因素。我们可以利用timeit库，然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; python -m timeit -n 5 -r 4 -s &quot;some python code&quot;</span><br><span class="line">&gt; 5 loops, best of 1: 8.45 sec per loop</span><br></pre></td></tr></table></figure>

<p>其中，<code>-n</code> 表示每次运行循环次数，<code>-r</code>表示重复次数，<code>-s</code>后面接测试的代码块。</p>
<p>如果用IPython，可以直接用<code>%timeit</code>。</p>
<h2 id="cProfiler"><a href="#cProfiler" class="headerlink" title="cProfiler"></a><code>cProfiler</code></h2><p>输入如下命令进行Profile，并把结果输出到<code>profile.stats</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m cProfile -o profile.stats src&#x2F;julia_set.py</span><br></pre></td></tr></table></figure>

<p>然后，可以进入Python的Console读取分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line">p = pstats.Stats(<span class="string">&quot;profile.stats&quot;</span>)</span><br><span class="line">p.sort_stats(<span class="string">&quot;cumulative&quot;</span>)</span><br><span class="line">p.print_stats(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tue Jul 20 22:37:12 2021    profile.stats</span><br><span class="line"></span><br><span class="line">         36682126 function calls (36675327 primitive calls) in 10.651 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: cumulative time</span><br><span class="line">   List reduced from 2611 to 10 due to restriction &lt;10&gt;</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">    578&#x2F;1    0.001    0.000   10.652   10.652 &#123;built-in method builtins.exec&#125;</span><br><span class="line">        1    0.032    0.032   10.652   10.652 src&#x2F;julia_set.py:1(&lt;module&gt;)</span><br><span class="line">        1    0.468    0.468    9.979    9.979 src&#x2F;julia_set.py:54(calc_pure_python)</span><br><span class="line">        1    7.072    7.072    9.357    9.357 src&#x2F;julia_set.py:40(calculate_z_serial_purepython)</span><br><span class="line"> 34220076    2.285    0.000    2.285    0.000 &#123;built-in method builtins.abs&#125;</span><br></pre></td></tr></table></figure>

<p>可以很容易识别瓶颈：<code>calculate_z_serial_purepython</code>。不过<code>cProfiler</code>的输出结果非常多，不是很容易读。可是使用<code>snakeviz</code>对profile的结果文件进行可视化：<code>snakeviz profile.stats</code></p>
<p><img src="https://i.imgur.com/rjGz6yO.png" alt=""></p>
<h2 id="line-profiler"><a href="#line-profiler" class="headerlink" title="line_profiler"></a><code>line_profiler</code></h2><p>在识别瓶颈函数后，可以通过<code>line_profiler</code>对该函数进行逐行分析，从而进一步了解计算瓶颈。</p>
<p>安装profiler：<code>pip install line_profiler</code></p>
<p>在需要profile 的函数前加入<code>@profile</code>装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> line_profiler</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_z_serial_purepython</span>(<span class="params">max_iter, zs, cs</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>执行：<code>kernprof -l -v src/julia_set_kernprof.py</code>，结果会被保存在<code>julia_set_kernprof.py.lprof</code>文件中。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 39.3034 s</span><br><span class="line">File: src&#x2F;julia_set_kernprof.py</span><br><span class="line">Function: calculate_z_serial_purepython at line 43</span><br><span class="line"></span><br><span class="line">Line #      Hits         Time  Per Hit   % Time  Line Contents</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    43                                           @profile</span><br><span class="line">    44                                           def calculate_z_serial_purepython(max_iter, zs, cs):</span><br><span class="line">    45         1       4029.0   4029.0      0.0      output &#x3D; [0] * len(zs)</span><br><span class="line">    46   1000001     327962.0      0.3      0.8      for i in range(len(zs)):</span><br><span class="line">    47   1000000     334117.0      0.3      0.9          n &#x3D; 0</span><br><span class="line">    48   1000000     372342.0      0.4      0.9          z &#x3D; zs[i]</span><br><span class="line">    49   1000000     338387.0      0.3      0.9          c &#x3D; cs[i]</span><br><span class="line">    50  34219980   14987467.0      0.4     38.1          while (abs(z)) &lt; 2 and n &lt; max_iter:</span><br><span class="line">    51  33219980   11923257.0      0.4     30.3              z &#x3D; z*z + c</span><br><span class="line">    52  33219980   10647361.0      0.3     27.1              n +&#x3D; 1</span><br><span class="line">    53   1000000     368513.0      0.4      0.9          output[i] &#x3D; n</span><br><span class="line">    54         1          0.0      0.0      0.0      return output</span><br></pre></td></tr></table></figure>

<p>大家可以发现核心的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50  34219980   14987467.0      0.4     38.1          while (abs(z)) &lt; 2 and n &lt; max_iter:</span><br><span class="line">51  33219980   11923257.0      0.4     30.3              z &#x3D; z*z + c</span><br><span class="line">52  33219980   10647361.0      0.3     27.1              n +&#x3D; 1</span><br></pre></td></tr></table></figure>

<p>即进行基本数学运算的内存循环部分，这部分代码我们可以通过Numba或者Cython直接编译成C然后编译成机器码执行，进行加速。</p>
<h2 id="memory-profiler"><a href="#memory-profiler" class="headerlink" title="memory_profiler"></a><code>memory_profiler</code></h2><p>下一步就是对程序的内存使用进行profile，可以使用<code>memory_profiler</code>，安装：<code>pip install memory_profiler</code>。另外建议同时安装：<code>pip install psutil</code>，这样可以加速profile的速度。</p>
<p><code>mprof run src/julia_set_memory_profiler.py</code></p>
<p>在profile结束后，我们可以用<code>mprof plot</code>画出内存增长的趋势图，并且标注目标函数：</p>
<p><img src="https://i.imgur.com/ubbnTIe.png" alt=""></p>
<p>我们发现<code>calculate_z_serial_purepython</code>这段时间内存持续增加，这是由于Python不会断创建新的<code>int</code>和<code>float</code>对象（还记得吗？Python中每一个对象都会占用较大的内存空间，即使是int，因为Python的内存模型就是object，无论是什么对象。）</p>
<p>同样这部分可以通过numba或者cython编译，跳过python解释器执行，降低内存使用。</p>
<h2 id="PySpy"><a href="#PySpy" class="headerlink" title="PySpy"></a><code>PySpy</code></h2><p>最后，介绍一下如何用<code>pyspy</code>对正在运行的Python进程进行实时监测。这种方法可以对进程进行在线debug，工程中非常实用。</p>
<p>安装：<code>pip install py-spy</code></p>
<p>pyspy 主要由两种常用模式：dump和top。dump会为指定的process一个snapshot，然后dump到文件；而top会进行实时采样，或一种类似系统top命名的界面，实时监控进程的内存和CPU使用情况。</p>
<p>也可以通过record获得不同函数的资源图：<code>sudo py-spy record -o profile.svg -- python src/julia_set.py</code></p>
<p><img src="https://i.imgur.com/4OO294A.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了4中主要的profile工具，其中2种是CPU相关的，1种是内存相关的，最后的py-spy是针对长寿命进程的采样分析。</p>
<p><img src="https://i.imgur.com/ctU3xEJ.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>自学计算机书籍和课程推荐</title>
    <url>/2021/07/18/learning_2/</url>
    <content><![CDATA[<blockquote>
<p>转行程序员的精雕细选、诚心推荐。</p>
<p>文末付下载链接和课程链接。</p>
</blockquote>
<h1 id="自学计算机书籍和课程推荐"><a href="#自学计算机书籍和课程推荐" class="headerlink" title="自学计算机书籍和课程推荐"></a>自学计算机书籍和课程推荐</h1><blockquote>
<p>⚠️ 切记<strong>不要</strong>只读书、看视频，不动手做练习、写程序。</p>
<p>⚠️ 切记<strong>不要</strong>求速度，不做练习、不写程序</p>
</blockquote>
<p>这些课程和书籍是我食用后觉得良心且有帮助的资源，他们不仅仅可以帮助你学习计算机科学，也会帮助你领略一点点计算机的优雅和美丽。这些主题可能听起来没有大数据、云计算那么华丽，但却道出了真正理解这些技术的真正要素。计算机科学太年轻了（不到100年历史），学习技术的收益远没有学习基础高</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>计算机入门书籍，我只推荐三本，而这三本 SICP 和 HTDP 可以先选择其中一本必读, CSAPP 是必读的。但是个人建议如果计算机基础差一些，建议HTDP，SICP 可以以后再读。</p>
<h3 id="《Structure-and-Interpretation-of-Computer-Programs》（SICP）"><a href="#《Structure-and-Interpretation-of-Computer-Programs》（SICP）" class="headerlink" title="《Structure and Interpretation of Computer Programs》（SICP）"></a>《Structure and Interpretation of Computer Programs》（SICP）</h3><blockquote>
<p>《计算机程序的构造和解释》</p>
</blockquote>
<p><img src="https://i.imgur.com/rHsSNr8.png" alt="SICP"></p>
<p>这是一本来自麻省理工大学，经历20多年仍然充满活力的好书。这是一本关于计算机程序设计的总体性观念的入门书，书本中采用一种lisp方言 - Scheme作为所有例子和练习的实现语言。作者从基础的程序设计一直讲道了解释器和编译器的实现，编程范式从过程式、函数式到面向对象、面向并发都有涉及，但是讲解非常清晰。小编读完（花了两年时间，期间放弃了无数次）后，只能说：我还想再读一遍。</p>
<blockquote>
<p>小知识：Lisp诞生于1958年，是一个比C和Fortran更古老的函数式编程语言。</p>
</blockquote>
<p>不过，小编的感觉此书当然可以一上来就读，不过如果有了几年的实战经验后重读效果更佳！因为你会有一种这本书中涉及到了你工作中会遇到的大多数事情，比如编程范式、抽象方法等等。</p>
<p>有的小伙伴可能会忧虑：Scheme是个什么鬼？Lisp还活着吗？我不想用这个古老的语言，我要用Python！！好的好的，福音来了：</p>
<p>来自伯克利的同名课程，但是所有课程资料和作业都是Python3！</p>
<p><strong><a href="https://inst.eecs.berkeley.edu/~cs61a/sp12/">CS61A: Structure and Interpretation of Computer Programs</a></strong></p>
<p>如果你对Scheme情有独钟，这里是MIT的原版视频：</p>
<p><strong><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">Structure and Interpretation of Computer Programs</a></strong></p>
<h3 id="《How-to-Design-Programs》"><a href="#《How-to-Design-Programs》" class="headerlink" title="《How to Design Programs》"></a>《How to Design Programs》</h3><blockquote>
<p>《如何设计程序》</p>
</blockquote>
<p><img src="https://i.imgur.com/VMju2ju.png" alt="HTDP"></p>
<p>这是同样是一本经典的计算机程序设计入门书，采用另一个更现代的Lisp方言 - Racket 作为实现语言（是的，又是Lisp，这门古老的语言拥有强大的生命力）。与 SICP 相比，HTDP 更加注重程序设计的基本原则，材料组织更加平易近人，更容易读，难度也更低。小编认为是一本非常好的编程入门书，书中有大量的实例和练习题，从最简单的数据结构、递归讲到各种程序设计的抽象方法。</p>
<p>这本书的在线版本：<a href="https://htdp.org">https://htdp.org</a></p>
<h3 id="《Computer-Systems-A-Programmer’s-Perspective》"><a href="#《Computer-Systems-A-Programmer’s-Perspective》" class="headerlink" title="《Computer Systems: A Programmer’s Perspective》"></a>《Computer Systems: A Programmer’s Perspective》</h3><blockquote>
<p>《深入理解计算机系统》</p>
</blockquote>
<p><img src="https://i.imgur.com/NkjpmYJ.png" alt="CSAPP"></p>
<p>这本书中文被翻译成：深入理解计算机系统，我觉得不妥。原文的意思是给程序员看的计算机系书。这本书与前两本大不相同，他是从计算机硬件的角度切入的；而前两本是从软件和程序设计的角度切入。因此，这本书会解释你写的程序是如何被翻译成指令，如何被计算机执行，读完此书，你会理解：进程、并发、编译、虚拟内存、缓存等等计算机概念。此书采用C语言作为实现语言，总体来说，这是一门很“底层”的计算机入门课。</p>
<p>如果你觉得只读书有点无趣，可以考虑这门课：</p>
<p><strong><a href="https://www.bilibili.com/video/BV1XW411A7fB/">中文字幕的公开课！</a></strong></p>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>网上很多人推荐经典《Introduction to Algorithms》作为算法入门书，我觉得很不妥，特别对于无法进行全职科班教育的人群。这本书太过于理论了，我自己试了几次都放弃了。所以我推荐下面两本，任选其一。</p>
<h3 id="《Algorithms》"><a href="#《Algorithms》" class="headerlink" title="《Algorithms》"></a>《Algorithms》</h3><blockquote>
<p>《算法》</p>
</blockquote>
<p><img src="https://i.imgur.com/g8PPdyW.png" alt=""></p>
<p>此书算是两大算法经典的另一个了，但是内容更加具体和实际一些，Java实现的，全部读完也需要一定的时间和耐心。</p>
<p>可以配合这个Coursera课程：</p>
<p><a href="https://www.coursera.org/learn/algorithms-part1">同名课程</a></p>
<h3 id="《Data-Structures-and-Algorithms-in-Python》"><a href="#《Data-Structures-and-Algorithms-in-Python》" class="headerlink" title="《Data Structures and Algorithms in Python》"></a>《Data Structures and Algorithms in Python》</h3><blockquote>
<p>《数据结构和算法 - Python》</p>
</blockquote>
<p><img src="https://i.imgur.com/T7QHhmB.png" alt="Data Structures and Algorithms in Python"></p>
<p>这一本我觉得更加亲民，特别是如果你已经在使用Python了，这本读起来会非常舒服，而且内容覆盖也比较全面。</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>编程语言书籍的推荐比较困难，因为各人的差异巨大。我的建议是根据自己的工作情况选择一个语言，然后再去选择书籍。</p>
<p>这里只推荐一门非常棒的课程，来自康奈尔的 CS3110。这是一门教你学会如何学会任何编程语言的课程，让你成为一个更好的程序员。</p>
<p><a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/">CS3110 Data Structures and Functional Programming</a></p>
<p>如果时间充裕，可以尝试学习以下几种语言来体验不同的编程体验：</p>
<ul>
<li>C</li>
<li>Ocaml</li>
<li>Go</li>
<li>Lisp的一种：Scheme、Racket、Clojure等等</li>
</ul>
<p>我没有列出Python、Java和C++，因为我猜你们一定已经在工作使用这些语言啦！</p>
<p>推荐他们的原因很简单：这些语言本身很简单，他们代表了不同的范式。我会在后续的文章中对不同的语言进行书籍和资源推荐。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>有了计算机和算法基础，加上对编程语言的熟悉，我们就可以开始更加深入的计算机之旅了。计算机的几大浪漫：</p>
<ul>
<li>操作系统</li>
<li>数据库</li>
<li>计算机网络</li>
<li>编译原理</li>
</ul>
<p>编译原理参考书没有提及，初学计算机的人可以先跳过这门课，因为这门课需要太多其他基础，比如操作系统、计算机语言、词法分析等等，而且编译原理通常只有在特定的工作岗位才会需要，一般的知识在计算机基础中已经有足够的涉猎。</p>
<p>下面这些书籍和课程需要在计算基础、算法、编程语言三项学习完成后食用，否则可能会错过这些资源的精华。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>《Operating Systems: Three Easy Pieces》</strong></p>
<blockquote>
<p>《操作系统：三堂简单的课》</p>
</blockquote>
<p>此书是我认为最适合初学者的操作系统书。课程方面，推荐MIT的经典6.S081，这门课程的Lab有一定难度，都做下来对操作系统的重要概念比如：虚拟内存、中断、并发、文件系统等有更加深刻的理解。这门课对 C 语言有要求。</p>
<p><strong><a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 6.S081</a></strong></p>
<p>更妙的是：<strong>这门课是有视频的</strong></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库只推荐一个课程，CMU 15-445 包括了SQL原理和数据库底层实现，但是这门课需要良好的C++功底。</p>
<p><strong><a href="https://15445.courses.cs.cmu.edu/fall2019/schedule.html">CMU 15-445</a></strong></p>
<p>更妙的是：<strong>这门课是有视频的</strong></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>CMU 15-441 有不错的结构和合理的Lab。</p>
<p><strong><a href="https://computer-networks.github.io/sp19/index.html">CMU 15-441</a></strong></p>
<h2 id="再进阶"><a href="#再进阶" class="headerlink" title="再进阶"></a>再进阶</h2><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>分布式系统近年来大火，但是这是一个交叉学科，学起来并不容易，需要操作系统、计算机网络和数据库等多种知识做背景。</p>
<p>好在这个领域MIT有一门神课，不仅内容充分，而且配有视频和lab，就是</p>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824: Distributed Systems</a></p>
<p>资源下载：搜索微信公众号：泛程序员 。选择：资源 - 计算机。</p>
]]></content>
      <categories>
        <category>FunCoder</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>系统化程序设计 - 函数式</title>
    <url>/2021/07/17/design_1/</url>
    <content><![CDATA[<h1 id="系统化程序设计-函数式"><a href="#系统化程序设计-函数式" class="headerlink" title="系统化程序设计 - 函数式"></a>系统化程序设计 - 函数式</h1><ol>
<li>从问题分析到数据定义</li>
<li>签名、目的和头文件</li>
<li>函数例子</li>
<li>函数模板</li>
<li>函数定义</li>
<li>测试</li>
</ol>
<h2 id="从问题分析到数据定义"><a href="#从问题分析到数据定义" class="headerlink" title="从问题分析到数据定义"></a>从问题分析到数据定义</h2><p>确定哪些信息需要表达，明确在某个计算机语言中如何表达。确定数据结构后，写出实例。</p>
<h2 id="签名、目的和头文件"><a href="#签名、目的和头文件" class="headerlink" title="签名、目的和头文件"></a>签名、目的和头文件</h2><p>说明那种数据设计的函数接受和返回。回答问题：函数计算什么？定义函数签名。</p>
<h2 id="函数例子"><a href="#函数例子" class="headerlink" title="函数例子"></a>函数例子</h2><p>写出几个实例说明函数如何工作</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>把数据定义翻译成函数的骨架</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>根据上述步骤实现函数。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>把例子、场景分析转化成测试函数，并且确保函数通过测试。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>10年自学编程</title>
    <url>/2021/07/17/learn_coding/</url>
    <content><![CDATA[<h1 id="10年自学编程"><a href="#10年自学编程" class="headerlink" title="10年自学编程"></a>10年自学编程</h1><blockquote>
<p>Teach Yourself Programming in Ten Years</p>
<p>By Peter Norvig (真*大神，不认识的可以自行“Google”）</p>
<p>原文链接：<a href="http://norvig.com/21-days.html">http://norvig.com/21-days.html</a></p>
</blockquote>
<h2 id="为什么大家都很心急？"><a href="#为什么大家都很心急？" class="headerlink" title="为什么大家都很心急？"></a>为什么大家都很心急？</h2><p>如果你走进书店，你就会看到这样的书：Java自学一日通或者C、SQL、Ruby、算法自学三月通。如果去Amazon搜索<a href="https://www.amazon.com/s?i=stripbooks&rh=p_28%3Ateach+yourself+hours&s=relevanceexprank&Adv-Srch-Books-Submit.x=16&Adv-Srch-Books-Submit.y=5&field-dateop=After&field-dateyear=2000&unfiltered=1&ref=sr_adv_b">title: teach, youself, hours, since: 2000</a>，你会发现512本书。前10本书中，有9本是编程书籍，还有一个本是关于书籍管理的。如果把自学替换成学习，小时换成天，会得到类似的结果。</p>
<p>结论是：要么人们很急切的想要学习编程，要么学习编程比学习其他技能更加容易。《How to design programs》的作者们“认可”了这个说法，书中提到：“差劲的编程很简单，傻子都能在21天内学会编程，即使他们是傻子”。Abtruse Goose的搞笑漫画持类似<a href="https://abstrusegoose.com/249">观点</a></p>
<p><img src="https://i.imgur.com/SCAQMb5.png" alt="21天学会C++"></p>
<p>我们来分析一下：24小时自学C++：</p>
<ul>
<li><strong>自学</strong>：24小时，你没有时间写出一些有用的程序，并且从这些项目中吸取经验教训。你也没有时间与一个有经验的<code>C++</code>程序员一起工作并且理解真实的<code>C++</code>开发环境。长话短说，你没有时间学很多东西。所以这个本书只能给你一种假的熟悉感，而不是深入理解。就像Alexander Pope说的：学一点点是很危险的！</li>
<li><strong><code>C++</code></strong>：24小时的时间，你可能可以学一点<code>C++</code>的语法（如果你之前接触过其他编程语言），但是你不能学到很多关于如何使用这个语言的内容。总之，假设你是一个Basic程序员，你可能会学会用Basic的模式写<code>C++</code>，但是你不会理解<code>C++</code>实际的长度和弊端。如果这样的话，为什么还要学呢？<a href="http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html">Alan Perlis</a> 说过：“一个计算机语言如果不能影响你思考编程的方式，那么这个语言不值得学习”。还有一个可能的观点是，为了完成一个需要与其他语言交互的任务，你需要学一点点<code>C++</code>（或是 JavaScript 或 Processing）。但是你并没有学习如何编程，而是学习完成一个那个任务。</li>
<li><strong>24小时</strong>：时间不够！下个小节说明</li>
</ul>
<h2 id="10年自学编程-1"><a href="#10年自学编程-1" class="headerlink" title="10年自学编程"></a>10年自学编程</h2><p>研究表明（Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)))：在大多数领域达到专家水平需要大约10年时间，这些领域包括但不完全：象棋、作曲、网球、钢琴、绘画、游泳等等。而成功的关键在于<strong>刻意练习</strong>：不是无意义的重复，而是永远做一些有挑战的事情，并且做得过程中和完成后分析经验教训。然后，需要不断重复这个过程！在成为专家的路上似乎没有捷径：即使是莫扎特也不例外。他4岁就是个音乐奇才了，他仍然花了13年才做出了世界级别的音乐。披头士乐队也是如此，1964年他们在Ed Sullivan秀登台并且带来了一连串的经典歌曲，可是他们从1957年开始就在利物浦和汉堡的小酒吧里演出了，而他们的传奇专辑《Sgt.Peppers》在1967年才问世。</p>
<p><a href="https://www.amazon.com/Outliers-Story-Success-Malcolm-Gladwell/dp/0316017922">Malcolm Gladwell</a>让这个观点更加流行了，尽管他在说中提到的是1万小时而不是10年。Henri Cartier-Bresson (1908-2004) 提到过：“你的前1万张照片是你最差的作品！”（不过在他的时代还没数码相机，现在人们可以在一周实现1万张了）。真正的专业水准需要一生的时间：Samuel Johnson (1709-1784) 说：“在任何领域获得杰出成就的价格都是一生的努力，没有更便宜的价格了”。Chaucer (1340-1400) 抱怨到：“生之有限，学也无涯”。K. Anders Ericsson教授提到：：“在大多数领域中，即使是最有才华的人也需要多少时间才能达到最高水平的表现，这一点很了不起。 1万小时的数字只是让你觉得我们在谈论的是每周 10 到 20 小时，有些人认为这些是最有天赋的人仍然需要达到最高水平。”</p>
<h2 id="所以，你想要成为一个程序员？"><a href="#所以，你想要成为一个程序员？" class="headerlink" title="所以，你想要成为一个程序员？"></a>所以，你想要成为一个程序员？</h2><p>下面我列出成为成功程序员的要素：</p>
<ul>
<li><strong>兴趣</strong>。确保自己对编程有足够的兴趣，因为这样你才愿意话10年或者1万小时编程</li>
<li><strong>程序</strong>。做好的学习就是<a href="https://www.engines4ed.org/hyperbook/nodes/NODE-120-pg.html">实践</a>。从技术角度说，你在某个领域达到的最好程度不一定会随着经验提高，但是通过刻意练习，即使你已经很厉害了，你还是可以获得提高。最有效的学习需要一个明确的、难度合适的任务，同时需要其他人的反馈以及重复和纠错的机会。<a href="https://www.amazon.com/exec/obidos/ASIN/0521357349">Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</a>在这方面很有帮助。</li>
<li><strong>交流</strong>。与其他程序员交流，阅读别人的程序。这一点比任何书籍和课程都重要。</li>
<li>如果你愿意，去大学或者研究生院学习4年。这样你有就会获得一些需要学历的工作，同时你会更加深刻的理解计算机科学。但是如果你不想上学，你也可以通过自学或者工作经验弥补。不论哪种情况，只靠读书是不够的。《The New Hacker’s Dictionary》的作者 Eric Raymond说：“计算机科学教育不可能让每一个学生都成为专家级程序员，就像你不能通过学习画笔和颜料成为一个画家一样”。我（Peter）雇佣过最好的程序员之一只有高中学历，但是他做出了很多出色的<a href="https://www.mozilla.org">软件</a>，他有自己的<a href="http://groups.google.com/groups?q=alt.fan.jwz&meta=site%3Dgroups">新闻组</a>，他甚至得到了足够多的股权去买一个<a href="http://en.wikipedia.org/wiki/DNA_Lounge">夜店</a>。</li>
<li>与其他程序员一起做项目。在一些项目里你是最好的；而另一些里面你是最差的。当你是最好的程序员，你可以测试你的领导能力；当你是最差的，你可以跟那些大师学习，学习他们希望做的和他们不希望做的（因为他们会让你做。。）</li>
<li>追随其他程序员的项目。理解别人写的程序。学会如何理解和修复一个出问题的程序，思考自己的项目怎么写可以让后来的人维护起来更方便，</li>
<li>至少学6个计算机语言。包括一个强调类型抽象的（比如C++，Java），一个强调函数式抽象的（比如Lisp、ML、Haskel），一个支持语法抽象的（比如Lisp），一个支持声明式说明的（比如Prolog或者C++模板），和一个强调并行的（<em>小编：我觉得这里作者可能想说的是并发而不是并行</em>）（比如Clojure或者Go）</li>
<li>记住：计算机科学里面有一个“计算机”。知道你的计算机需要多长时间执行一个指令、从内存读取一个词（有缓存或者没有缓存的情况）、从硬盘读取一个词或者在硬盘寻址。答案在最后一小节 &lt;-</li>
<li>参与一个语言的标准化。可以是ANSI C++委员会，或者是你自己的编码风格是2个还是4个空格。无论哪种方式，你会学习那些东西是其他人喜欢的，以及为什么人们喜欢。</li>
<li>能够感知什么时候放弃语言标准化。</li>
</ul>
<p>说了这么多，我们开始质疑仅仅通过阅读书籍你可以走多远？在我第一个孩子出生以前，我读了各种“如何做”的书，却还是觉得自己是个菜鸟。30个月后，当我的第二个孩子要出生的时候，我回去看那些书了吗？没有！相反，我依靠我的第一个孩子的经验，事实也证明这些经验比那些“专家”给出的建议更有用。</p>
<p>Fred Brooks在他的文章《No Silver Bullet》发现了一个找到好的软件设计者的3步走计划：</p>
<ol>
<li>尽早系统化地识别顶级设计师</li>
<li>指定一个职业导师</li>
<li>提供与其他设计师交流的机会</li>
</ol>
<p>这假设有些人已经具备成为伟大设计师所需的素质； 工作是引导他们前进。 Alan Perlis 更简洁地说：“每个人都可以学会雕刻：米开朗基罗必须学会如何不雕刻。伟大的程序员也是如此”。 玻璃市说，伟人有一些超越他们训练的内在品质。 但是，在没有质量从何而来？ 是天生的吗？ 还是他们通过勤奋来发展它？ 正如 Auguste Gusteau（《料理鼠王》中的虚构厨师）所说，“任何人都可以做饭，但只有无所畏惧的人才是伟大的。” 我认为它更像是愿意将一个人一生的大部分时间用于深思熟虑的实践。 但也许无所畏惧是总结这一点的一种方式。 或者，正如 Gusteau 的评论家 Anton Ego 所说：“不是每个人都能成为伟大的艺术家，但伟大的艺术家可以来自任何地方。”</p>
<p>所以去买那本 Java/Ruby/Javascript/PHP 书吧； 你可能会从中得到一些用处。 但是你不会在 24 小时或 21 天内改变你的生活，或者你作为程序员的真正整体专业知识。努力工作以在 24 个月内持续改进怎么样？好吧，现在开始你的旅程把。。。</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><table>
<thead>
<tr>
<th>任务</th>
<th>时间(纳秒)</th>
</tr>
</thead>
<tbody><tr>
<td>执行一条指令</td>
<td>1</td>
</tr>
<tr>
<td>L1缓存读取</td>
<td>0.5</td>
</tr>
<tr>
<td>分支预测错误</td>
<td>5</td>
</tr>
<tr>
<td>L2缓存读取</td>
<td>7</td>
</tr>
<tr>
<td>互斥锁操作</td>
<td>25</td>
</tr>
<tr>
<td>内存读取</td>
<td>100</td>
</tr>
<tr>
<td>在1Gbps网络发送2kb数据</td>
<td>20000</td>
</tr>
<tr>
<td>从内存顺序读取1MB数据</td>
<td>250000</td>
</tr>
<tr>
<td>从本地磁盘读取一个新的位置（seek）</td>
<td>8毫秒</td>
</tr>
<tr>
<td>从本地磁盘顺序读取1MB数据</td>
<td>20 毫秒</td>
</tr>
<tr>
<td>在美国和欧洲之间传递数据</td>
<td>150 毫秒</td>
</tr>
</tbody></table>
<h2 id="附录：语言选择"><a href="#附录：语言选择" class="headerlink" title="附录：语言选择"></a>附录：语言选择</h2><p>很多人问过：第一个计算机语言应该学什么？没有固定的答案，但是考虑如下三点：</p>
<ul>
<li>选你朋友用的。当被问到：“我该用那个操作系统，Wondows，Unix还是MacOS？” 的时候，我的回答通常是：用你周围朋友用的。您从朋友那里学到的优势将抵消操作系统之间或编程语言之间的任何内在差异。 还要考虑你未来的朋友：如果你继续下去，你将成为其中一员的程序员社区。 你选择的语言有一个庞大的成长社区还是一个正在消亡的小社区？ 是否有书籍、网站和在线论坛可以获取答案？ 你喜欢那些论坛里的人吗？</li>
<li>把事情简单化。 C++ 和 Java 等编程语言是为由关心代码运行时效率的经验丰富的程序员组成的大型团队而设计的。 因此，这些语言具有为这些情况设计的复杂部分。 你关心的是学习编程。 你不需要那种复杂性。 您需要一种设计为易于单个新程序员学习和记忆的语言。</li>
<li>玩。 您更愿意以哪种方式学习弹钢琴：正常的交互式方式，即您在敲击琴键后立即听到每个音符，或“批处理”模式，在这种方式中，您仅在完成一首歌曲后才听到音符 ? 显然，交互模式使钢琴学习和编程更容易。 坚持一种具有交互模式的语言并使用它。</li>
</ul>
<p>鉴于这些标准，我对第一种编程语言的建议是 Python 或 Scheme。 另一个选择是 Javascript，不是因为它非常适合初学者，而是因为它的在线教程太多了，例如可汗学院的教程。 但是您的情况可能会有所不同，还有其他不错的选择。 如果您的年龄是个位数，您可能更喜欢 Alice 或 Squeak 或 Blockly（年龄较大的学习者可能也喜欢这些）。重要的是你选择并开始编程。</p>
<p>欢迎关注 泛程序员 获得更多编程知识：</p>
<p><img src="https://i.imgur.com/5e9RRJy.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能Python编程（1）</title>
    <url>/2021/06/24/high_perform_python/</url>
    <content><![CDATA[<h1 id="高性能Python编程（1）：理解Python的“性能”"><a href="#高性能Python编程（1）：理解Python的“性能”" class="headerlink" title="高性能Python编程（1）：理解Python的“性能”"></a>高性能Python编程（1）：理解Python的“性能”</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>Python的性能常常被人诟病，但是另一方面Python却又常常出现在高性能计算库中，比如tensorflow，numpy等等，这是为什么呢？Python的性能究竟差在哪里？理想的高性能程序应该是什么样的？如何能写出高性能的Python程序？这个系列我们就尝试探索这些问题的答案。</p>
<p>首先我们退一步看一下组成计算机的基本部分，这样我们才能下手分析和提高程序的执行性能。</p>
<h2 id="计算机三大部分"><a href="#计算机三大部分" class="headerlink" title="计算机三大部分"></a>计算机三大部分</h2><p>计算机的设备主要分成三类：<strong>计算单元、存贮单元、通讯单元</strong>。</p>
<p>典型的计算机由计算单元（CPU），CPU会连接两类存贮单元：内存和硬盘，通讯单元（总线）就是连接计算单元和存储单元的桥梁。</p>
<p>你可能会问：显卡呢？键盘呢？显示器呢？？懂行的你可能还会问：南北桥呢？细想一下，显卡其实是计算单元（GPU）和存储单元（显存）的组合体；而键盘、显示器、鼠标、网卡这些基本属于IO设备，所谓IO就是Input，字节写入内存，Output，字节读出内存，这类设备通常通过总线与内存沟通，利用中断与CPU协作。硬盘在这个意义上也是IO设备，因此这些设备我们姑且认为属于存储单元吧。南北桥其实算是通讯单元的司令部，北桥芯片，主要负责控制显卡、内存与CPU之间的数据交换；靠近PCI槽的为南桥芯片，主要负责硬盘、键盘以及附加卡的数据交换。</p>
<p>说到底，计算过程就是：把字节（Byte）从存储单元放进计算单元“计算”，然后把结果放回存储单元，而“计算”就是改变字节。</p>
<p>可以看出，影响程序执行效率的主要有两个因素：<strong>移动字节的速度和计算的速度</strong>。移动字节的速度主要受限于存储介质的读写速度和通讯的速度；计算速度的影响因素主要是计算单元的类型和架构，比如CPU和GPU对不同的指令执行效率不尽相同，而更极端的例子量子计算芯片，QPU，则拥有完全不同的“计算”方式。</p>
<h3 id="计算单元"><a href="#计算单元" class="headerlink" title="计算单元"></a>计算单元</h3><p>计算单元种类繁多，有我们常见的CPU，GPU，也有一些不太常见的，比如TPU（张量处理器）,QPU(量子计算处理器)等等。不过不论是那种计算单元，他们的工作就是输入一串比特，输出另一串比特。计算单元的主要衡量标准就是单位时间内可以进行的计算量。</p>
<p>我们那常见的CPU的性能举例，我们关心两个指标：一个cycle可以执行的指令数量；一秒钟最大的cycle数量。前者我们用IPC（Instruction Per Cycle）衡量，后者我们用时钟频率衡量。不同的CPU架构会有截然不同的特性，比如酷睿处理器的IPC非常高，但是频率较低；而早期的奔腾处理器IPC较低，但是频率非常高。</p>
<p>提高主频对提高计算速度有直接的帮助，而提高IPC则可以有效的提高“向量化”操作的速度，即同时处理多组计算。你可以理解成一个是纵向提升，一个是横向提升。</p>
<p>有时候你的编译器也会分析程序，然后根据CPU指令集做一些优化，进一步提升计算效率。</p>
<p>在多核时代，程序尽可能多的利用多个带来的并行能力也是提升计算效率的常见手段。而且，由于目前CPU工艺经很难进一步提高时钟频率了，计算机更倾向于安装更多处理器核心，而不是主频更高的处理器。</p>
<p>不过，在Python诞生的年代（上个世纪90年代），还是单核的时代，CPython实现引入了GIL，即Global Interpreter Lock，来处理多线程下的同步问题，你可以把他理解成一把大锁，用来保护解释器内部状态。这是设计其实在当年大大提高了单核执行效率，特别后来更新GIL调度方式以后，对IO多线程有巨大的贡献。然鹅，进入20世纪后，多核处理器成为了主流，Python的GIL导致解释器不能有效利用多核进行并行计算，不过Python社区也提出了多种方法解决这个问题，比如<code>multiprocessing</code>库，一些第三方库，比如<code>numpy</code>, <code>numexpr</code>等等，<code>Cython</code>编译器，以及利用计算集群进行计算。</p>
<p>以上这些方法，我们在后续的文章中逐步介绍。</p>
<h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>存储单元主要负责储存比特，这些比特可以是计算的输入，也可以是计算的输出。衡量存储单元的指标主要有三个：容量、读写速度、寻址速度。</p>
<p>通常存储单元是分层的，容量从低到高，读写、寻址速度从高到低：</p>
<ul>
<li>CPU缓存L1、L2、L3</li>
<li>内存</li>
<li>固态硬盘</li>
<li>机械硬盘</li>
<li>网络</li>
</ul>
<p>为了提高计算的性能，我们应该尽可能多的使用读写速度更快的单元作为缓存，减少不同层次之间存储单元的数据移动，因为这种数据的时间成本非常高，而且约下层越高。这也是为什么编程时，Locality特别的重要，Locality不但可以降低寻址的时间，还可以最大程度的利用高速缓存。</p>
<p>对于Python而言，Locality通常是被破坏的，这是CPython的实现机制导致的，不过我们也有办法克服。</p>
<h3 id="通讯单元"><a href="#通讯单元" class="headerlink" title="通讯单元"></a>通讯单元</h3><p>典型计算机的通讯是通过某类总线（Bus）实现的，比如前端总线负责L1L2缓存和内存的通讯；而网卡可以认为是机器和机器之间存储单元的通讯。</p>
<p>衡量总线性能指标主要由两个：一次移动比特的数量，即带宽；移动比特的频率，即总线频率。</p>
<h2 id="理想的高性能程序"><a href="#理想的高性能程序" class="headerlink" title="理想的高性能程序"></a>理想的高性能程序</h2><p>现在我们了解了计算机计算的三个组成部分，下面我们用一个检测素数的小程序来说明如何构造一个“完美”的高效程序。</p>
<p>首先我们写一段Python伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_prime</span>(<span class="params">number</span>):</span></span><br><span class="line">    sqrt = math.sqrt(number)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (number / i).is_integer():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">check_prime(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>我们抛开Python的实现机制，看看上面的程序是如何执行的。</p>
<p>首先，为了计算<code>sqrt</code>，我们需要把<code>number</code>的值从内存送往CPU，理想情况下<code>number</code>会驻留在CPU的缓存。CPU计算<code>sqrt</code>后把值送回内存。然后我们进入循环，理想情况我们会一次性把<code>number</code>和<code>i</code>同时送往CPU，然后检查是否整除。</p>
<p>如何进一步优化程序？第一个方法就是利用CPU的向量化能力，一次计算多组<code>number</code>和<code>i</code>。在这过过程中，充分利用缓存来存储尽可能多的i值和结果，这样就可以减少数据传输的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_prime</span>(<span class="params">number</span>):</span></span><br><span class="line">    sqrt_number = math.sqrt(number) </span><br><span class="line">    numbers = <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt_number)+<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(numbers), <span class="number">5</span>):</span><br><span class="line">        result = (number / numbers[i:(i + <span class="number">5</span>)]).is_integer() </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(result):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Python慢在哪里"><a href="#Python慢在哪里" class="headerlink" title="Python慢在哪里"></a>Python慢在哪里</h2><p>好了，下面我们来说说Python究竟慢在哪里了。Python的解释器（虚拟机）是非常好的抽象，程序员不太需要考虑我们上面提到的三种计算单元，比如绝大多数情况下，Python程序员不需要考虑如何分配内存，如何优化缓存，或者如何把变量送到CPU。这是Python的优势，但是这些抽象会损害程序的执行效率。话句话说，Python的执行循环中有很多指令都是为了支持这些抽象的。</p>
<p>当我们谈到Python的性能，其实有不同的维度。</p>
<p>首先，Python代码的性能不容易直接推断，如果你恰好知道一些小技巧，你的程序就会快很多，而同样的业务逻辑其他的实现方法就会慢一些。我举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_unknown1</span>(<span class="params">haystack, needle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>((item == needle <span class="keyword">for</span> item <span class="keyword">in</span> haystack))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_unknown2</span>(<span class="params">haystack, needle</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">any</span>([item == needle <span class="keyword">for</span> item <span class="keyword">in</span> haystack])</span><br></pre></td></tr></table></figure>

<p>你觉得上面两个函数那个运行更快？？所以，Python这类语言提升性能之前，更应该首先进行Profiling，来确定性能瓶颈。</p>
<p>其次，Python（CPython）的Object内存规划并没有很高效，这与Python的GC和内存池有关。但是这种内存使用和回收机制会破坏缓存，也会导致不能充分利用总线带宽。</p>
<p>另外，Python语言灵活性的代价就是动态类型，解释器需要花费大量时间弄清楚对象的类型，寻找正确的函数等等。不过这个问题其实容易解决，只要我们可以识别性能瓶颈，就可以采用Cython这样的工具突破瓶颈。</p>
<p>最后，就是GIL。上文已经提到了，GIL限制了并行计算能力，但是这个问题其实也很容易解决。</p>
<h2 id="那为啥Python还是这么火？"><a href="#那为啥Python还是这么火？" class="headerlink" title="那为啥Python还是这么火？"></a>那为啥Python还是这么火？</h2><p>既然Python这么“慢”，为啥Python还是这么火？？网上已经很多讨论了，我就说几个：</p>
<p>1、近乎完美的生态。从大数据、机器学习、数值计算到Web，再到量子计算。<br>2、对非计算机科学的小伙伴极度友好<br>3、计算机专业的人用起来真的很舒服，抽象能力还是很不错<br>4、大觉部分性能问题可以很轻松地解决（哈哈哈，这就是这个系列的重点）</p>
<p>OK，下一篇我们来谈谈如何Profiling程序，这是提高执行效率的第一步！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《High Performance Python》</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Profiling</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 12 并发编程 2</title>
    <url>/2021/06/20/csapp_12_2/</url>
    <content><![CDATA[<h1 id="CSAPP-12-并发编程-2"><a href="#CSAPP-12-并发编程-2" class="headerlink" title="CSAPP 12 并发编程 2"></a>CSAPP 12 并发编程 2</h1><p>并发可以增加系统的吞吐量，充分利用多核性能，但是并发系统带来的复杂度也需要额外的注意，以免出现不容易debug的bug。</p>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>并发执行的程序访问<strong>栈外</strong>共享内存，往往不是由一个CPU指令完成，而是一系列指令。这时，这一些列指令就形成了一个 critical section 。如果不对这些critical section进行处理，就会出现并发bug。</p>
<p>为了避免并发bug，Edsger Dijkstra 提出了 Semaphores ，即信号量来保护 critical section 的指令。Semaphore本质上是一个全局变量，类型为正整数，有两个对应的函数来操作Semaphore：P和V：</p>
<ul>
<li><code>P(s)</code> 如果s不为0，P会将s减一，然后返回让线程继续执行；如果s为0，P会阻塞，当前线程挂起直到s为正，线程继续执行。</li>
<li><code>V(s)</code> 会将s加一，如果有其他进程等待s为正，V操作会unblock<strong>一个</strong>等待的线程，被释放的线程的P操作会立刻将s减一。</li>
</ul>
<p>值得注意的是，P和V操作都是不可分的，即PV相关的CPU指令执行不会被中断。另外需要注意的是V操作不能确定哪一个等待的线程会被释放。</p>
<p>Posix定义了如下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="number">0</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *s)</span></span>; <span class="comment">/* V(s) */</span></span><br></pre></td></tr></table></figure>

<p>Semaphore 非常有用，常见的用法有 binary semaphore（BS） 和 counting semaphore （CS）。BS就是我们常说的互斥锁，而CS可以用来控制资源访问。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> niters;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">2</span> * niters)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread routine */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, niters = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin goodcntthread */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) &#123;</span><br><span class="line">	P(&amp;mutex);</span><br><span class="line">	cnt++;</span><br><span class="line">	V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* $end goodcntthread */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end goodcnt */</span></span><br></pre></td></tr></table></figure>

<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><p>信号量是很多并发数据结构的基础，比如bounded buffer queue就是通过计数信号量实现的一种资源调度数据结构。</p>
<p>H文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SBUF_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SBUF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> front;   <span class="comment">/* buf[(front+1)%n] is first item */</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">/* buf[rear%n] is last item */</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex; <span class="comment">/* Protect access to buf */</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots; <span class="comment">/* Counts available slots */</span></span><br><span class="line">    <span class="keyword">sem_t</span> items; <span class="comment">/* Counts available items */</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>C文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Heap allocation dynamic</span></span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Sem will make sure inc/dec or P/V is atomic action.</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);  <span class="comment">// wait for slot, if slots &gt; 0, dec it. else wait</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// lock buffer</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;</span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// release buffer</span></span><br><span class="line">    V(&amp;sp-&gt;items);  <span class="comment">// inc item in the buffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);  <span class="comment">// wait for item</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// lock buffer</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];</span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// unlock the buffer</span></span><br><span class="line">    V(&amp;sp-&gt;slots);  <span class="comment">// update slot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，利用Semaphore还可以实现其他的并发控制方式，比如 reader-writer 模式。下面的例子是一个有限reader的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> readcnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> mutex, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) </span><br><span class="line">            <span class="comment">/* 只要有一个reader在等待，就尝试获得写入锁 </span></span><br><span class="line"><span class="comment">             * 这时，如果有正在进行的写入线程获得锁，read阻塞</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Critical Section: read */</span> </span><br><span class="line"></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* 只有没有reader在等待才会释放写入锁 */</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line"></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Semaphore是并发控制的基本模块，不过一般我们也不会直接使用他们，而是使用高级一点的API，比如Mutex和Condition，或者go中的chan，不过他们基本都可以通过Semaphore实现。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>正确的并发程序运行在多核处理器机器上，Kernel会自动将不同的thread调度在不同的CPU核心，从而获得并行能力，提高计算效率。</p>
<h2 id="多线程编程的一些问题"><a href="#多线程编程的一些问题" class="headerlink" title="多线程编程的一些问题"></a>多线程编程的一些问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数，如果在多个线程并发调用的情况下仍然可以输出预期的结果，那么这个函数就是<strong>线程安全</strong>函数。我们也可以看看那些函数不是线程安全的：</p>
<ul>
<li>类型1：函数内部修改全局变量</li>
<li>类型2：函数具有自己内部状态。比如伪随机数函数</li>
<li>类型3：函数返回一个全库变量的指针</li>
<li>类型4：函数调用其他非线程安全函数</li>
</ul>
<p>类型1最简单的方法是给全局变量加锁，保证线程安全，但是锁这类同步操作也会影响函数运行性能。</p>
<p>类型2最简单的解决方案是把内部变量转换成函数输入参数，不过这样的函数需要函数的调用者负责传入正确的状态参数。</p>
<p>类型3有两种主要的处理方法。第一，重写函数让他接受一个存储结果的指针，这样就可以避免不同线程同时修改全局变量。第二，在不重写函数的情况下，可以做一个线程安全的wrapper函数，调用非安全函数的时候，加锁，并复制结果，然后作为wrapper的返回值。</p>
<p>类型4的处理类似类型3。</p>
<p>还有一类函数值得指出，就是Reentrant（可重入）函数，他是线程安全函数的子集。可重入函数内部没有私有状态，也没有同步操作（比如锁），所以他们的运行效率更高。但是这类函数可以接受指针作为输入，如果指针指向了一个共享内存，那么他们在多线程情况下可能会导致问题，但是函数本身却是线程安全的。</p>
<h3 id="Races"><a href="#Races" class="headerlink" title="Races"></a>Races</h3><p>Race，竞争，是指程序的正确依赖于特定的线程执行顺序，而这种顺序并没有在程序编写阶段加以保证。</p>
<p>比如如下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)                       </span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i); </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中，12行，启动线程时传入了局部变量i的指针，但是如果线程函数，20行，没有在12行执行后立刻执行，而是等待到了下一次12行执行，20行则会错误的接受其他线程的i值，造成竞争错误。</p>
<h3 id="Dead-lock"><a href="#Dead-lock" class="headerlink" title="Dead lock"></a>Dead lock</h3><p>Dead lock，死锁，是指在多线程执行情况下，两个或多个进程依赖同一个同步实体（比如信号量）才能继续执行，出现的互相等待导致锁死的现象。</p>
<p>死锁的检测和避免并不容易，但是有一个有用的规则可以避免大部分死锁：每一个对mutex，（s，t），每一个线程持有s和t，以相同的顺序加锁。</p>
<p>TODO: </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发编程的基本抽象其实是逻辑执行顺序，CPU在不同执行context下切换，具体实现方法包括：进程、IO复用和线程。</p>
<p>并发编程的基本同步工具是Semaphore，利用Semaphore可以构造其他并发控制结构，比如bufferd queue、互斥锁等等。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程、进程debug技巧</title>
    <url>/2021/06/16/python_debug/</url>
    <content><![CDATA[<h1 id="Python多线程、进程debug技巧"><a href="#Python多线程、进程debug技巧" class="headerlink" title="Python多线程、进程debug技巧"></a>Python多线程、进程debug技巧</h1><ul>
<li>使用 <code>py-spy</code></li>
<li>利用 <code>/proc/&#123;pid&#125;/</code> 中的信息</li>
</ul>
<p>比如查看进程环境变量: <code>cat /proc/&#123;pid&#125;/environ</code></p>
<p>查看实时进程内部线程的CPU和内存状态：<code>py-spy --nonblocking -p &#123;pid&#125;</code></p>
<p>查看线程dump：<code>py-spy dump --nonbloacking -p &#123;pid&#125;</code></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 12 并发编程 1</title>
    <url>/2021/06/15/csapp_12_1/</url>
    <content><![CDATA[<h1 id="CSAPP-12-并发编程-1"><a href="#CSAPP-12-并发编程-1" class="headerlink" title="CSAPP 12 并发编程 (1)"></a>CSAPP 12 并发编程 (1)</h1><p>一般来说，应用级别的并发主要由三种方式实现：</p>
<ul>
<li>进程</li>
<li>I/O多路复用</li>
<li>线程</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是构建并发程序最简单和直接的方式，主要是通过fork, exec, waitpid等系统函数联合实现，而进程间是通过socket两端的文件标识符进行通讯。</p>
<p>以经典的服务器-客户端模式为例，首先服务器端启动主进程（p1），unix系统默认会开放三个文件标识符，即fd0，fd1，fd2，分别对应标准输入、输出、和异常。为了接受其他进程的连接，p1开放一个新的socket标识符，listenfd。由于文件标识符通常是按照顺序取最小的一个可用数字，因此一般系统会分配标识符3给listenfd，但是这个并不重要，我们只需要知道listenfd即可。</p>
<p>在客户端进程中，通过socket连接服务端端口，获得一个客户端的文件标识符，clientfd，这个socket的另一端的是服务器端的一个新的、由accept返回的标识符，connfd，需要注意的是connfd与listenfd是不同的标识符。在服务端，主进程会通过fork得到一个新的子进程来负责与client通讯，而connfd本来是属于主进程，在fork的过程中被子进程获得，而主进程则关闭其对应的connfd，子进程关闭无用的listenfd（从主进程拷贝获得）。至此，客户端与服务端的连接由子进程完成，而主进程已经准备好下一个连接，如下图所示：</p>
<p><img src="https://i.imgur.com/RwdRovf.png" alt=""></p>
<p><img src="https://i.imgur.com/GXjP3yy.png" alt=""></p>
<p><img src="https://i.imgur.com/OHpPbxU.png" alt=""></p>
<p>需要注意的是，子进程结束后会变成僵尸进程，需要由主进程进行清理（reap），否则就会造成内存泄漏。回收工作是通过SIGCHLD信号量的处理函数完成的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 清理所有目前看到的僵尸进程</span></span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程并发的优势很明显，即主进程和子进程不共享虚拟内存地址空间，可以有效的避免意外的内存问题。但是，另一方面，进程间共享数据变得困难，需要额外的跨进程通讯机制，这个过程开销较大。</p>
<h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><p>IO复用是进行并发的另一种方法，基本原理是通过select函数实现。select函数会阻塞程序，直到它监控的一系列标识符中的一个或者多个处于可用状态。</p>
<p><code>int select(int n, fd_set *fdset, NULL, NULL, NULL);</code></p>
<p>其中<code>fd_set</code>就是监控的文件标识符集合，Unix还提供了四个宏对集合进行控制：</p>
<ul>
<li>FD_ZERO，初始化flag为0</li>
<li>FD_CLR，清空某一个标识符</li>
<li>FD_SET，激活某一个标识符</li>
<li>FD_ISSET，查看某一个标识符是否激活</li>
</ul>
<p>我们可以通过select在同一个进程中实现一个并发echo服务器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define a pool of connected descriptors */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;  <span class="comment">// largest fd in set</span></span><br><span class="line">    fd_set read_set;  <span class="comment">// all active descriptors</span></span><br><span class="line">    fd_set ready_set;  <span class="comment">// subset of descriptors that ready to be read</span></span><br><span class="line">    <span class="keyword">int</span> nready;  <span class="comment">// number of ready descriptors from select</span></span><br><span class="line">    <span class="keyword">int</span> maxi;    <span class="comment">// highwater index into client array</span></span><br><span class="line">    <span class="keyword">int</span> clientfd[FD_SETSIZE];     <span class="comment">// set of active descriptors, default 1024</span></span><br><span class="line">    <span class="keyword">rio_t</span> clientrio[FD_SETSIZE];  <span class="comment">// set of active read buffers</span></span><br><span class="line">&#125; pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> byte_cnt = <span class="number">0</span>;  <span class="comment">// counts total bytes received by server</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">static</span> pool pool;  <span class="comment">// private variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// server loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// why get ready set and read_set</span></span><br><span class="line">        <span class="comment">// here is a re-initialization copy</span></span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd+<span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) </span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);  <span class="comment">// add client into pool to be handled</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pool</span><span class="params">(<span class="keyword">int</span> listenfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// initialized to -1 </span></span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initially, listenfd is the only fd of select read set</span></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_client</span><span class="params">(<span class="keyword">int</span> connfd, pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    p-&gt;nready--; <span class="comment">// ? we didn&#x27;t initialize this ...</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// assign fd and its buffer</span></span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Turn on fd</span></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update pool status</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// find an available slot</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients. Run out of descriptor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_clients</span><span class="params">(pool *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, connfd, n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++) &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n=Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>,</span><br><span class="line">                       n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);  <span class="comment">// echo back the received info..</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// EOF detected, remove fd from pool</span></span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>; <span class="comment">// do we need clear related io buffer?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// report pool</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pool:\n    maxfd: %d\n    nready: %d\n    maxi: %d\n&quot;</span>,</span><br><span class="line">           p-&gt;maxfd, p-&gt;nready, p-&gt;maxi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IO复用可以用作事件驱动编程模式，更好的控制不同的逻辑控制流，同时没有切换进程的开销。缺点也比较明显，首先，代码量更大，其次没有任何并行，即使CPU有多核，颇有一些Python AsyncIO 的感觉。。。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（Thread）的执行模式跟进程很像，每一个进程启动的时候，都会启动一个线程，即主线程。主线程可以设置其他线程，他们可以并发执行。线程与IO复用不同之处在于，线程的调度是Kernel自动完成的，不需要用户程序进行干预；线程与进程也不同，主线程和其他线程没有从属关系，这些线程也共享虚拟内存地址空间，包括code, data, heap, shared library以及文件！这让共享信息变得简单和高效。</p>
<p>一个简单的线程例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello thread!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，现在我们可以尝试采用线程实现并发的echo服务器了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, *connfdp;  <span class="comment">// note: a pointer here..</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">        <span class="comment">// why just use connfd and &amp;connfd?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self()); <span class="comment">// let kernel to reap this thread</span></span><br><span class="line">    Free(vargp); <span class="comment">// free memory</span></span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE]; </span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, n);</span><br><span class="line">	Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序有一些很有意思的地方：</p>
<p>首先22-23行，我们使用了一个指针，而不是直接传递fd数值。这是为了避免race condition造成的bug。因为在多线程执行过程中，我们不确定22行和31行那个先执行，如果在第一个连接以后，对应的31行还没执行之前，另一个连接发生了，就会导致连个线程操作同一个fd。因此，我们通过指针和动态内存分配避免这个问题。</p>
<p>另一个值得注意的地方是，在thread的执行函数中，我们需要自己释放内存，因为vargp是指针传入，对应的内存空间是堆分配的（是吗？）而不是栈分配，因此需要手动回收，否则就会出现内存泄漏。</p>
<h2 id="多线程变量共享"><a href="#多线程变量共享" class="headerlink" title="多线程变量共享"></a>多线程变量共享</h2><p>共享变量是一个很方便，但是容易出问题的技术。要弄清一个变量是不是被共享，需要回答如下几个问题：</p>
<ul>
<li>线程的内存模型是什么样的？</li>
<li>在上述模型中，变量实例是如何被映射到内存的？</li>
<li>有多少线程引用了这个变量实例？</li>
</ul>
<p>我们说一个变量是共享变量意味着：这个变量的内存实例被多个线程引用。</p>
<p>（什么是变量的实例？）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **ptr;  <span class="comment">/* Global variable */</span> <span class="comment">//line:conc:sharing:ptrdec</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> *msgs[N] = &#123;</span><br><span class="line">        <span class="string">&quot;Hello from foo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hello from bar&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="keyword">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = (<span class="keyword">int</span>)vargp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">// static make a static memory allocation in 1 adress.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)]\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ .&#x2F;share                                                </span><br><span class="line">[0]: Hello from foo (cnt&#x3D;1)]</span><br><span class="line">[1]: Hello from bar (cnt&#x3D;2)]</span><br></pre></td></tr></table></figure>
<p>注意到其中 cnt 被不同的线程共享。更有意思的是，主线程的ptr也被共享了。下面我们深入看看线程的内存模型，以便可以理解上述现象。</p>
<h3 id="线程的内存模型"><a href="#线程的内存模型" class="headerlink" title="线程的内存模型"></a>线程的内存模型</h3><p>由于线程是在进程的context运行的，每个线程共享进程的一部分内存，包括：read-only text (code), data, heap, shared libraries code，files。另一方面，线程具有独立的：id, stack, stack point, program counter, condition code, register values。</p>
<p>如此我们就可以理解上面为什么不同线程可以访问ptr了，因为全局变量位于内存的data部分，可以被线程共享。</p>
<p>逐一分析下列变量的引用情况：</p>
<table>
<thead>
<tr>
<th>Variable Instance</th>
<th>Ref. main</th>
<th>Ref. t0</th>
<th>Ref. t1</th>
</tr>
</thead>
<tbody><tr>
<td>myid.p1</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>myid.p0</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>msgs.m</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>i.m</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>cnt</td>
<td><strong>Y</strong> (NP!)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>ptr</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 11 网络编程</title>
    <url>/2021/06/06/csapp_11/</url>
    <content><![CDATA[<h1 id="CSAPP-11-网络编程"><a href="#CSAPP-11-网络编程" class="headerlink" title="CSAPP 11 网络编程"></a>CSAPP 11 网络编程</h1><p>网络编程基于之前看到的一些基本概念和抽象：进程、信号、内存映射、内存动态分配。</p>
<p>几乎所有的网络应用程序都基于服务器-客户端模式，即几个或者多个服务度进程和一个或者多个客户端进程，这些进程可以在同一个机器上，也可以分布在其他被网络连接的机器上。</p>
<p>计算机网络包含众多不同类型的机器，这些机器和设备是通过一些列“协议”进行交流的，每一个协议都包含两个基本部分：命名规则和传输规则。</p>
<p><strong>TCP/IP协议</strong></p>
<p>IP协议提供了基本的命名规则和传输规则，但是IP传输过程中会出现破损的包或者重复的包（packet），被称为<code>datagram</code>，而TCP协议则是建立在IP协议的基础上，提供可靠的双向通讯。UDP协议也是IP协议基础上的一个支持进程和进程通讯的协议。</p>
<p>在程序员的视角中，Internet可以认为是一个集合了多个主机的网络，这个网络具有如下属性：</p>
<ul>
<li>主机地址都是32位IP地址（IPv6协议是128位地址）</li>
<li>IP地址可以被映射成域名（domain names）</li>
<li>不同主机的进程可以通过Connection通讯</li>
</ul>
<p><strong>socket</strong></p>
<p>Socket是Connection的一端，每一个socket都有一个地址和一个端口。不过通常客户端的端口是有kernel自动指定的，而服务端口则是通常是程序指定的。一般unix类机器可以在<code>/etc/services</code>目录下找到各种服务。</p>
<p>所以一个Connection可以被一对独特的socket（地址和端口）识别出来。</p>
<h2 id="Sockets-Interface"><a href="#Sockets-Interface" class="headerlink" title="Sockets Interface"></a>Sockets Interface</h2><p>在系统内核的角度，socket是一个Connection的一端，而在程序的角度，socket是一个文件标识符（IO的File）。</p>
<ul>
<li><code>int socket(int domain, int type, int protocal)</code></li>
<li><code>int connect(int sockfd, struct sockaddr *serv_addr, int addlen)</code></li>
<li><code>int bind(int sockfd, struct sockaddr *my_addr, int addrlen)</code></li>
<li><code>int listen(int sockfd, int backlog)</code></li>
<li><code>int accept(int listenfd, struct sockaddr *addr, int *addrlen)</code></li>
</ul>
<h2 id="Web-Servers"><a href="#Web-Servers" class="headerlink" title="Web Servers"></a>Web Servers</h2><p><strong>CGI,Common Gateway Interface</strong></p>
<p>TODO: TINY server!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Socket是网络通讯的核心抽象，而socket在用户程序看来就是一个文件标识符。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 10 系统IO</title>
    <url>/2021/06/05/csapp_10/</url>
    <content><![CDATA[<h1 id="CSAPP-10-系统IO"><a href="#CSAPP-10-系统IO" class="headerlink" title="CSAPP 10 系统IO"></a>CSAPP 10 系统IO</h1><p>Unix系统中的IO，即Input和Output是指从“文件”读入数据到内存和从内存输出数据到“文件”。“文件”是Unix的一个抽象，即一串字节。在概念上所有IO设备都可以抽象成文件，比如网络、硬盘、各种外设等等。这样系统就可以统一接口来操作外设。</p>
<p>Unix系统提供了四个基本的IO API：</p>
<ul>
<li><code>int open(char *filename, int flags, mode_t mode)</code></li>
<li><code>int close(int fd)</code></li>
<li><code>ssize_t read(int fd, void *buf, size_t n)</code></li>
<li><code>ssize_t write(int fd, void *buf, size_t n)</code></li>
</ul>
<p>其实这四个api的道理非常简单，<code>open</code>会返回一个文件标识符，就是打开了一个内存和文件的通道，<code>read</code>就是把文件标识符指向的文件中的字节输入到buf指向的内存空间，而<code>write</code>刚好相反，把buf指向的内存空间的字节输入到文件中。</p>
<h2 id="RIO库"><a href="#RIO库" class="headerlink" title="RIO库"></a><code>RIO</code>库</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file rio.c</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2021-06-05</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2021</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Robustly read n bytes (unbufferred)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf; <span class="comment">// create a new point to manipulate user buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// something wrong branch</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// errno will get updated by the kernel</span></span><br><span class="line">                <span class="comment">// get interrupted, reset readn to read again later</span></span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if it is other reason failure, return -1 for failure</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Robustly write n bytes (unbuffered)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n-nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Associate a file descriptor with a read buffer and reset buffer </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param fd </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t , -1 for failed, 0 for EOF, positive bytes of read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if buffer empty, refill buffer with read */</span></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * read failed, handle interrupt case only</span></span><br><span class="line"><span class="comment">             * if interrupted, do nothing go to next loop</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf;  <span class="comment">// reset buffer pointer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy min(n, rp-&gt;rio_cnt) bytes from internal buffer to user buffer</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -=cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param rp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readnb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nleft = n;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rio_read handle interrupt and other -1 cases</span></span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft) &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// EOF</span></span><br><span class="line"></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief read a text line ( buffered )</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param tp </span></span><br><span class="line"><span class="comment"> * @param usrbuf </span></span><br><span class="line"><span class="comment"> * @param maxlen </span></span><br><span class="line"><span class="comment"> * @return ssize_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">rio_readlineb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, rc;</span><br><span class="line">    <span class="keyword">char</span> c, *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)  <span class="comment">// EOF</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// no data read yet</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;   <span class="comment">// some data read already</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;  <span class="comment">// append &#x27;\0&#x27; at the end of char buffer</span></span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>Unix系统的文件标识符主要由三种数据结构维护：</p>
<ul>
<li>Descriptor table（DT）：每个进程有单独的标识符表</li>
<li>File table（FT）：多个进程共享</li>
<li>v-node table（VT）：多个进程共享</li>
</ul>
<p>这三种结构分别包含一个指针：DT -&gt; FT -&gt; VT。</p>
<p><img src="https://i.imgur.com/2jUJ9Lx.png" alt=""></p>
<p>值得注意的是，fork后的父进程和子进程由于共享文件标识符，所以两个进程打开的文件共享file table entry（FTE），因此两个进程共享该文件的读取位置。而同一个进程通过两个<code>open</code>打开同一个文件获得两个标识符，不共享file table entry，因此两个文件标识符的读取和写入是独立的。</p>
<h2 id="IO重新定向"><a href="#IO重新定向" class="headerlink" title="IO重新定向"></a>IO重新定向</h2><p>IO重新定向的秘密在于系统函数：<code>dup2</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup2会把oldfd对应的FTE拷贝到newfd，这样newfd和oldfd都会指向之前的FTE，而newfd如果已经对应了某个FTE，kernel会减少一个引用，如果引用归零，kernel会删除该FTE。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 9 虚拟内存</title>
    <url>/2021/06/03/csapp_9/</url>
    <content><![CDATA[<h1 id="CSAPP-9：虚拟内存"><a href="#CSAPP-9：虚拟内存" class="headerlink" title="CSAPP 9：虚拟内存"></a>CSAPP 9：虚拟内存</h1><p>虚拟内存的三个重要功能：</p>
<ul>
<li>将物理内存作为一种缓存，缓存硬盘上的一个私有内存地址空间</li>
<li>让每一个进程拥有独立的内存地址空间</li>
<li>确保进程之间的内存不会互相影响</li>
</ul>
<p>理解虚拟内存的关键在于意识到：一个数据对象（字节）可以有多个属性（地址）。话句话说，一个内存对象可以有两个地址，一个物理地址，一个虚拟内存地址。</p>
<h2 id="虚拟内存：缓存"><a href="#虚拟内存：缓存" class="headerlink" title="虚拟内存：缓存"></a>虚拟内存：缓存</h2><p>概念上，虚拟内存是硬盘上一串连续的字节空间。一般会规定 m 个字节为一个分页，分页只有三种状态：</p>
<ul>
<li>未分配</li>
<li>缓存</li>
<li>未缓存</li>
</ul>
<h2 id="Linux中的虚拟内存"><a href="#Linux中的虚拟内存" class="headerlink" title="Linux中的虚拟内存"></a>Linux中的虚拟内存</h2><p>Linux Kernel 通常把进程的虚拟内存空间用一系列的 Segment (Area) 表达。Kernel会管理这些segment，进程也只能引用segment指向的内存空间。</p>
<p><img src="https://i.imgur.com/ks7WKIw.png" alt=""></p>
<p><strong>demand paging</strong>：只有在需要的时候，硬盘上内容才会被读入物理内存。</p>
<p><strong>copy-on-write</strong>：共享的可写内容，只有在需要写入的时候，才会只做副本。</p>
<p>Linux初始化虚拟内存空间是通过Memory Mapping进行的，kernel会把硬盘上某个文件的内容与该内存空间联系起来。一旦虚拟内存<strong>分页</strong>初始化结束，kernel会在内存和一个特殊的 swap 文件中进行 paging 操作。</p>
<p><strong>Practical Problem 9.5</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapcopy</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bufp;</span><br><span class="line">    <span class="comment">// mmap will ask the kernel to link a VM area with given fd.</span></span><br><span class="line">    bufp = Mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Here we are writing from VM to std 1 </span></span><br><span class="line">    Write(<span class="number">1</span>, bufp, size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Use: mapcopy &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = Open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    fstat(fd, &amp;stat);</span><br><span class="line">    mapcopy(fd, stat.st_size);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memory-Allocator"><a href="#Memory-Allocator" class="headerlink" title="Memory Allocator"></a>Memory Allocator</h2><p>未完待续</p>
<h2 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h2><p>未完待续</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>信息爆炸，炸毁了我</title>
    <url>/2021/05/30/admin2/</url>
    <content><![CDATA[<h2 id="信息爆炸，炸毁了我"><a href="#信息爆炸，炸毁了我" class="headerlink" title="信息爆炸，炸毁了我"></a>信息爆炸，炸毁了我</h2><p>最近发现了一个现象，我似乎没有办法坚持做一件事情很长时间了，而且这个“很长时间”变得原来越短了！</p>
<p>上一次我自发的坚持一件事情很长时间应该是考研。那已经是10年前的事情了，那时候我坚持每天去自习室学习超过6小时，持续了将近9个月时间，几乎没有间断过。再上一次可能是高考，算是坚持了三年学习，但那已经是13年前的事情了。</p>
<p>读博士以后，我集中精力做一件事情的能力就慢慢变弱了，那是大概6年前。比如做实验加写论文有时候可以到3个月左右。参加工作后，业余时间我还是想多学点东西或者做一些工作之外的事情，但是我渐渐发现我很难坚持了！开始的时候仅仅是不能坚持学完一门公开课（大概需要3个月左右），后面变成不能完整的阅读一本书（大概1个月左右），目前已经慢慢出现不能完整地读完一篇论文了（大概需要几天到1周时间）。更可怕的，我甚至难以完整的阅读一篇报道或者博客了（十几分钟到几小时），经常是读了一半就是去兴趣或者被其他信息拉走了。比如，我会在上网阅读书籍的时候，不定期的打开知乎、youtube、股票报价、微信等等，浏览一些信息，甚至有时候我会完全无目地滑动网页、切换窗口等等，然后回到我刚才在做的事情上，如此循环。到头来往往是时间过去了，什么都没得到。</p>
<p>短短十几年时间，我坚持做一件事情的能力从3年下降到了30分钟，甚至3分钟。(比如，你可以坚持读完这篇博客吗？)</p>
<p>我发现的一些现象：</p>
<ul>
<li>在做一件事情过程中，不定时、无意识的打开其他网站开始浏览。比如知乎、领英、视频、股票报价、微信等等。</li>
<li>很少能完成一个系列性的事情，比如关于某个主题的多篇博客</li>
<li>很少能保证质量的完成一个公开课（作业），经常是只完成了前几个</li>
<li>经常搜集各种学习网站资料等等，但是每一个都只是展开一点点，然后就会被新的东西吸引而停止已有的学习</li>
<li>经常被新的问题吸引，而停止解决就的问题，然后旧的问题被永远忘记</li>
<li>很容易被打断，即使发生的事情并没有非常重要，仍然被轻易打断</li>
<li>无法完成“大”一点的项目</li>
<li>经常是微信或者其他手机通知一出现，立刻中断手头的事情</li>
<li>长期如此的状态让我充满挫败感，挫败感让上面的问题更加严重了</li>
</ul>
<h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>其实发现这些问题，我想过并做过一些措施来避免，比如</p>
<ul>
<li>告诉自己不要分心，集中注意力</li>
<li>强迫自己不要打开无关的网站</li>
<li>写博客，强迫自己关注手头的东西</li>
<li>隐藏浏览器的书签栏，防止自己无目的的打开其他网站</li>
</ul>
<p>但是仍然没有改变现状，过去的很长时间里，我还是没有办法做更“大”事情，最多就是写了一些“粗制滥造”的博客（比如这一篇哈哈）。我甚至没有办法构思和写出关于某个主题的一系列日志，常常是半途而废。</p>
<h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>因此，我决定对这个问题进行进一步的思考。首先是确定问题。现在问题的症状是：不能长期坚持做一件事情，这个长期甚至是1小时。<br>那么，问题本身到底是什么呢？我写下我的思考过程：</p>
<h3 id="简单的“快乐”"><a href="#简单的“快乐”" class="headerlink" title="简单的“快乐”"></a>简单的“快乐”</h3><p>首先我想到的是，这可能是现有主体（一个）和新的主体（多个）之间的矛盾。我会轻易被新的主体吸引，而放弃现有的主体，所以才会出现不能坚持做一件事情的问题。</p>
<p>但是为什么我会轻易的放弃现有的主体呢？我想到两个原因：</p>
<ul>
<li>坚持现有主体更困难。因为更加深入学习，而深入学习往往意味着需要更多脑力，更加困难</li>
<li>转向新的主体更轻松。因为任何一个事情刚开始读到的内容或者练习都是相对简单的</li>
<li>坚持现有主题缺乏新鲜感，而新主题充满新鲜感</li>
</ul>
<p>这比较显然，一个“无趣”又困难，一个“新鲜”又简单，大脑自然而然的选择了简单的东西。</p>
<blockquote>
<p>假设1：大脑更愿意尝试<strong>简单且新鲜</strong>的活动。</p>
</blockquote>
<p>这个假设看起来是对的，确实符合观察到的现象。但是，为什么会这样？我想到了“贪心算法”。</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>所谓贪心算法就是在解决问题的时候采用的一种策略，即选择局部最优解。</p>
<blockquote>
<p>假设2：大脑（人）倾向正向的反馈，比如满足感、成就感。</p>
</blockquote>
<p>提出上面的假设，当大脑（我）处理问题的时候是为了最终获得正向反馈，比如满足感、成就感等等。</p>
<blockquote>
<p>假设3：大脑（人）倾向采用贪心算法获得正向反馈。</p>
</blockquote>
<p>这个假设可以解释为什么我选择新的东西，因为新的主体会在更短时间内、用最少的努力，换来正相反馈。</p>
<p>我举个例子，比如我在正在写博客，已经过去一段时间了，我仍然没有获得任何满足感，因为还没写完或者遇到了困难，这时候我会想打开知乎看看是不是有新的点赞或者关注，如果有会产生短期的满足感；在比如我正在写关于量子计算的作业遇到了困难，已经两天了也没啥进展，我会打开youtube观看一些量子计算的介绍性视频，因为我能听懂他们，看起来我也获得了“更多”知识，产生了短期的满足感；在比如我在学习分布式计算的公开课，听了两次了，感觉有点无聊，我会搜索另一门类似的课程，然后打开相关的视频或者课件查看，因为是新的，且比较入门的部分，我可以看懂，看起来我也获得了“更多”知识。</p>
<p>如此，我们可以归纳假设1-3：</p>
<blockquote>
<p><strong>公理：大脑（人）倾向采用贪心算法获得正向反馈。</strong></p>
</blockquote>
<p>我认为这是导致无法长期坚持的主要原因，因为贪心算法不会尝试远期最优解。大脑总是希望获得短期的正相反馈。</p>
<p>即便如此，长期坚持所获的正向反馈比短期反馈更加强大，持久，且有意义。举个弹吉他的例子，刚开始学习的几周时间往往是痛苦的，不过很快你就能弹几个曲子了，很开心！再往后事情变得不太顺利了，有几首曲子总是弹不出。这时你的大脑会希望放弃弹吉他，尝试其他的东西，比如箱鼓看起来不错！你开始学了几次，哈哈，确实很好玩儿！不过很快他就变得像弹吉他一样。如此循环。</p>
<p>进一步引申，贪心算法的另一个体现就是停留在舒适圈。</p>
<h3 id="价值认知"><a href="#价值认知" class="headerlink" title="价值认知"></a>价值认知</h3><p>继续思考，贪心算法可能不是问题的全部。我发现还有一个潜在的问题，导致我们放弃目前的主题，就是对当前主题的价值认同度降低。<br>比如我在学习一门新的课程的初期会认为内容很有意义、很重要。但是随着深入，这种认同会逐渐降低，这可能跟自己无法全面认识该课程的内容有关系，特别是在一半的时候。<br>由于自发的学习没有强迫的考试和作业来增加这种价值认知，自发的价值认知很快消退了。加上“贪心算法”，我很快就会决定放弃当前主题。</p>
<h3 id="“一心一意”"><a href="#“一心一意”" class="headerlink" title="“一心一意”"></a>“一心一意”</h3><p>继续思考，我发现最后一个原因是：不能一心一意的同一时间只想做一件事情！这种倾向很可能跟贪心算法有关系，大脑希望在同一时间获得更多的正反馈。如何获得？最简单的办法，同时开始很多“简单”的事情。</p>
<h3 id="懒惰的大脑"><a href="#懒惰的大脑" class="headerlink" title="懒惰的大脑"></a>懒惰的大脑</h3><p>我发现大脑比较懒惰，他更喜欢做自己会做的，或者短期内容易理解和学习的事情。因此大脑产生的懒惰情绪也会导致不能长期坚持。</p>
<h2 id="为什么十年前没有这些问题？"><a href="#为什么十年前没有这些问题？" class="headerlink" title="为什么十年前没有这些问题？"></a>为什么十年前没有这些问题？</h2><blockquote>
<p>公理：大脑（人）倾向采用贪心算法获得正向反馈，而贪心算法带来的往往只能是“简单的快乐”。</p>
</blockquote>
<p>由上面的公理推论：</p>
<ul>
<li>价值认同度降低</li>
<li>不能一心一意的同一时间只想做一件事情</li>
</ul>
<p>那我不禁要问：为什么十年前我没有这个问题？其实，我不觉得我的大脑变了，变化的是周围的环境。</p>
<blockquote>
<p>十年前，信息还没有爆炸。</p>
</blockquote>
<p>十年前，我获取信息和资源的难度比现在大得多。比如我很难获得很多线上的公开课，想要学习新的知识和技能，我必须参加学校设置的、有限的几门课。而且我需要按照学校的计划完成它。虽然我的大脑仍然是“贪婪”的，但是我并没有很多选择。因此，我只能“专注”更长的时间，才能获得正反馈。</p>
<p>十年前，我接触到各种信息的渠道也有限，被分心的可能性也比较低。我还没开始玩知乎、炒股票，我不需要看赞、看股票收益，我获得正反馈的途径非常有限。</p>
<h2 id="再一次的尝试"><a href="#再一次的尝试" class="headerlink" title="再一次的尝试"></a>再一次的尝试</h2><p>所以，整件事情的原因我归纳为：</p>
<blockquote>
<p>信息爆炸的背景下，我大脑的“贪心算法”导致了不能长期有计划地做一件事情。</p>
</blockquote>
<p>因此，解决方案从两方面入手</p>
<ul>
<li>信息爆炸</li>
<li>贪心算法</li>
</ul>
<p>具体方案：</p>
<ul>
<li>减少一段时间的信息摄入量<ul>
<li>如果没有任何目的，不打开知乎、股票等信息</li>
<li>定时查看信息，而不是实时响应信息</li>
<li>不要因为临时看到的一个信息改变计划</li>
</ul>
</li>
<li>制定计划，并无条件执行</li>
<li>一次只做一件事情，并做完</li>
<li>暗示自己长期获得正反馈更加有效，避免短期正反馈<ul>
<li>暗示自己不要从社交媒体中获得正反馈</li>
</ul>
</li>
<li>刻意练习，突破懒惰的舒适圈</li>
</ul>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
  </entry>
  <entry>
    <title>量子计算索引</title>
    <url>/2021/05/23/qc_index/</url>
    <content><![CDATA[<h1 id="量子计算索引"><a href="#量子计算索引" class="headerlink" title="量子计算索引"></a>量子计算索引</h1><h2 id="公开课程"><a href="#公开课程" class="headerlink" title="公开课程"></a>公开课程</h2><ul>
<li><a href="http://theory.caltech.edu/~preskill/ph219/ph219_2020-21.html">Ph219/CS219 Quantum Computation (加州理工)</a> by John Preskill (with <a href="https://www.youtube.com/channel/UCeq4xfwNE6eDK3k1vTfZK8g/playlists">video</a> on Youtube)</li>
<li><a href="https://cs269q.stanford.edu/index.html">CS269Q Quantum Computer Programming (斯坦福)</a> by Dan Boneh</li>
<li><a href="http://www.lassp.cornell.edu/mermin/qcomp/CS483.html">Phys481-681-CS483, Quantum Computation (康奈尔)</a> by David Mermin</li>
<li><a href="https://www.scottaaronson.com/democritus/">PHYS771 Quantum Computing Since Democritus (University of Waterloo)</a> by Scott Aaronson</li>
<li><a href="https://qiskit.org/learn/intro-qc-qh/">Introduction to Quantum Computing and Quantum Hardware</a> by IBM (with <a href="https://www.youtube.com/watch?v=Rs2TzarBX5I&list=PLOFEBzvs-VvrXTMy5Y2IqmSaUjfnhvBHR">video</a> on Youtube)</li>
<li><a href="https://csferrie.medium.com/introduction-to-quantum-computing-df9e1182a831">Introduction to Quantum Computing</a> by Chris Ferrie</li>
<li><a href="https://web.mit.edu/8.371/www/index.html">6.443/8.371/18.436 Quantum Information Science</a></li>
<li><a href="https://learning.edx.org/course/course-v1:MITx+8.371.1x+2T2018/home">Quantum Information Science II, Part 1 - Quantum states, noise and error correction</a></li>
</ul>
<p><strong>其他人整理的资源</strong></p>
<ul>
<li><a href="https://www.cs.umd.edu/~xwu/mini_lib.html">Mini-Library on Quantum Information and Computation</a></li>
<li><a href="https://www.amarchenkova.com/posts/best-quantum-computing-courses-online">Best-quantum-computing-courses-online</a></li>
</ul>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p><strong>硬件公司</strong></p>
<ul>
<li><a href="https://quantum-computing.ibm.com/">IBM Quantum</a></li>
<li><a href="https://www.dwavesys.com/">D-Wave</a></li>
<li><a href="https://www.rigetti.com/">Rigetti</a></li>
<li><a href="https://ionq.com/">IonQ</a></li>
<li><a href="https://quantumai.google/">Google Quantum</a></li>
<li><a href="https://www.honeywell.com/us/en/company/quantum">Honeywell</a></li>
</ul>
<p><strong>软件、研究公司</strong></p>
<ul>
<li><a href="https://cambridgequantum.com/">Cambridge Qauntum Computing (CQC)</a></li>
<li><a href="https://pennylane.ai/">Pennylane</a></li>
<li><a href="https://qcware.com/">QC Ware</a></li>
<li><a href="https://www.xanadu.ai/">Xanadu</a></li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><a href="https://github.com/manjunath5496/Quantum-Computing-Books">量子计算书单</a></p>
<h2 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h2><p><a href="https://github.com/qosf/awesome-quantum-software">量子计算开源软件</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://algassert.com/quirk">Quirk, 量子电路模拟器</a></li>
<li><a href="https://javafxpert.github.io/grok-bloch/">Bloch Sphare 模拟器</a></li>
</ul>
]]></content>
      <categories>
        <category>Quantum Computing</category>
      </categories>
      <tags>
        <tag>Qauntum Computing</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 8 异常控制流</title>
    <url>/2021/05/21/csapp_8/</url>
    <content><![CDATA[<h1 id="CSAPP-8-异常控制流（ECF）"><a href="#CSAPP-8-异常控制流（ECF）" class="headerlink" title="CSAPP 8 异常控制流（ECF）"></a>CSAPP 8 异常控制流（ECF）</h1><p>异常控制流，Exception Control Flow，是操作系统实现IO、进程、虚拟内存、并发等等功能的的重要基础工具。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>这里提到的异常不是通常意义的异常，而是分成四类：Interrupt, faults, aborts, and trap.</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>异常机制是操作系统提供下一个重要抽象，进程，的基石。</p>
<blockquote>
<p>进程就是一个正在执行的程序实例</p>
</blockquote>
<p>每一个进程都包含了程序运行的全部上下文（context），这个context包含：程序代码、数据、栈、寄存器状态、程序指针、环境变量、打开的文件标识符等等。</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p><strong>并发</strong></p>
<p>两个任务A和B，如果我们说AB是并发执行的，等价于说：A在B开始后，B结束前，开始；或者反过来B在A开始后，A结束前，开始。</p>
<p><em>Problem 8.1</em></p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Start</th>
<th>End</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>C</td>
<td>3</td>
<td>5</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A: - -</span><br><span class="line">B:   - - -</span><br><span class="line">C:     - - -</span><br></pre></td></tr></table></figure>

<p>从上面的图可以看出，AB，BC分别是并发的，而AC则不是。</p>
<p><strong>User and Kernel Mode</strong></p>
<p>Linux系统通过CPU上的一个特殊的寄存器来识别那些进程是系统进程，哪些是用户进程。系统进程可以执行一些高权限的指令。</p>
<p><strong>Contex Switch</strong></p>
<p>值得注意的是，系统缓存通常跟ECF相关的操作相互冲突。换句话说，ECF相关的活动，比如异常或者切换上下文，都会造成缓存污染。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>API：</p>
<ul>
<li><code>int getpid(void)</code></li>
<li><code>int getppid(void)</code></li>
<li><code>pid_t fork(void)</code></li>
<li><code>waitpid</code></li>
<li><code>execve</code></li>
</ul>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h3><p><code>fork</code>会产生一个内存内容跟父进程一样的子进程，镜像的内容包括：text, data, bss segments, heap, user stack以及父进程的拥有的所有文件标识符（file discriptors)。</p>
<p><strong>Practice Problem 8.2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;printf1: x=%d\n&quot;</span>, ++x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printf2: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf2: x&#x3D;0   # From parent</span><br><span class="line">printf1: x&#x3D;2   # From child </span><br><span class="line">printf2: x&#x3D;1   # From child </span><br></pre></td></tr></table></figure>

<p><strong>zombie</strong></p>
<p>当子进程结束时，kernel不会立刻移除该子进程，而是将它的状态改成 <code>terminated</code>，等待父进程 reap 它。一旦父进程收割了终止的子进程，kernel会把子进程的退出状态传递给父进程，然后从系统中移除该子进程。暂时还未被移除的子进程就叫做僵尸进程。</p>
<p>如果父进程在收割子进程前以外终结了，kernel会使用<code>init</code>进程终结僵尸进程。init 进程的 Pid 为 1，是kernel启动的第一个进程。（这个进程会终结吗？他是干啥的？）</p>
<p>收割子进程是通过 <code>pid_t waitpid</code> 系统函数实现的，该函数会挂起调用进程（option=1），直到子进程被收割。这个函数还有一些其它选项，可以调整行为。</p>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a><code>waitpid</code></h3><p><strong>Practice Problem</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Only child process goes here.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// pid = -1 means wait set consists all child processes</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<code>acbc</code>。</p>
<p><strong>Practice Problem 8.4</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !pid);  <span class="comment">// make it 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// only parent process goes here</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, WEXITSTATUS(pid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            | - parent -&gt; 0 -&gt; 2 -&gt; Bye</span><br><span class="line">&quot;Hell0&quot; -&gt;  |</span><br><span class="line">            | - child  -&gt; 1 -&gt; Bye</span><br></pre></td></tr></table></figure>

<p><strong>Practice Problem 8.5</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">snooze</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rc = sleep(secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %u of %u secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    snooze(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a><code>execve</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"><span class="comment">// Dose NOT return if OK, else return -1 on error.</span></span><br></pre></td></tr></table></figure>

<p>与 fork 不同（调用一次，返回两次），execve 调用后不返回。在execve将目标文件的程序读入内存，就会为它分配栈，并把执行权限交给该目标程序。</p>
<p><img src="https://i.imgur.com/oK74LQj.png" alt="新的目标程序的内存配置"></p>
<p><strong>Practice Problem 8.6</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix&gt; .&#x2F;myecho arg1 arg2 </span><br><span class="line">Command line arguments:</span><br><span class="line">    argv[ 0]: myecho</span><br><span class="line">    argv[ 1]: arg1</span><br><span class="line">    argv[ 2]: arg2</span><br><span class="line">Environment variables:</span><br><span class="line">    envp[ 0]: PWD&#x3D;&#x2F;usr0&#x2F;droh&#x2F;ics&#x2F;code&#x2F;ecf</span><br><span class="line">    envp[ 1]: TERM&#x3D;emacs</span><br><span class="line">...</span><br><span class="line">    envp[25]: USER&#x3D;droh</span><br><span class="line">    envp[26]: SHELL&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;tcsh</span><br><span class="line">    envp[27]: HOME&#x3D;&#x2F;usr0&#x2F;droh</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line arguments: \n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    argv[%2d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Environment variables: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; envp[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    envp[%2d]: %s\n&quot;</span>, i, envp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fork-execve"><a href="#fork-execve" class="headerlink" title="fork + execve"></a><code>fork</code> + <code>execve</code></h3><p>= shell ….</p>
<p><code>waitpid</code>可以用于shell执行阻塞任务。</p>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal是一种另个进程或者kernel中断另一个进程的方式。通常signal是有kernel发送给用户进程的，比如，如果一个进程尝试0除法，内核会发送<code>SIGFPE (8)</code>信号给该进程，而该信号的默认行为是终结进程并且dump core。</p>
<p>什么是发送信号？Sending a Signal。Kernel发送signal给某个进程，意味着更新该进程的context中的某些状态。有两种情况Kernel会发送Signal给进程：</p>
<ul>
<li>发现了一些系统事件，比如0除、分页错误、子进程终结等等</li>
<li><code>kill</code>程序</li>
</ul>
<p>什么是接受信号？进程收到信号后会进行相应的处理，比如忽略、结束、或者捕捉信号（Signal handling）。</p>
<p>Signal在还没有被接受的情况下，叫做Pending Signal，挂起信号。一个进程，最多只能有一个同类型的挂起信号。</p>
<h3 id="Send-Signal"><a href="#Send-Signal" class="headerlink" title="Send Signal"></a>Send Signal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> beeps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BEEP\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (++beeps &lt; <span class="number">5</span>) </span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, handler);</span><br><span class="line">    alarm(<span class="number">1</span>);  <span class="comment">// arange kernel to send alarm to this process </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// signal hander will return to here, which is the next instruction</span></span><br><span class="line">        <span class="comment">// after the interupt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Never reach here. Because program exit in the handler...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-Signal"><a href="#Receive-Signal" class="headerlink" title="Receive Signal"></a>Receive Signal</h3><p>进程可以选择修改Signal的默认行为，除了SIGSTOP and SIGKILL。</p>
<p><strong>Pratical Problem 8.7</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">snooze</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rc = sleep(secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %u of %u secs.\n&quot;</span>, secs-rc, secs);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;secs&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, handler) == SIG_ERR)</span><br><span class="line">        <span class="comment">// install a hander for SIGINT</span></span><br><span class="line">        <span class="comment">// once catched, program return to the next instruction</span></span><br><span class="line">        <span class="comment">// which is printf in this case</span></span><br><span class="line">        unix_error(<span class="string">&quot;signal error\n&quot;</span>);</span><br><span class="line">    (<span class="keyword">void</span>)snooze(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Signal-Handling-Issues"><a href="#Signal-Handling-Issues" class="headerlink" title="Signal Handling Issues"></a>Signal Handling Issues</h3><blockquote>
<p>signals can block, but only 1 signal will be queued, following signal is discarded.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler2</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid=waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child %d\n&quot;</span>, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler2) == SIG_ERR)</span><br><span class="line">        unix_error(<span class="string">&quot;signal error.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        pid = Fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">            Sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> ( errno != EINTR )</span><br><span class="line">            unix_error(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该格外注意signal和他们的handler之间的并发问题，fork会让问题变得更加困难。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 10的新特性</title>
    <url>/2021/05/15/python310/</url>
    <content><![CDATA[<h1 id="Python3-10的新特性！"><a href="#Python3-10的新特性！" class="headerlink" title="Python3.10的新特性！"></a>Python3.10的新特性！</h1><p>新版本的Python 3.10主要有三个大变化：</p>
<ul>
<li>增加模式匹配</li>
<li>更好的错误提示</li>
<li>更好的类型检查</li>
</ul>
<h2 id="结构化模式匹配"><a href="#结构化模式匹配" class="headerlink" title="结构化模式匹配"></a>结构化模式匹配</h2><p>模式匹配主要通过<code>mathc</code>和<code>case</code>关键字，具有如下实现方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match subject:</span><br><span class="line">    case &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    case &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    case &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    case _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure>

<p>模式匹配大大增加了控制流的清晰度和表达能力:</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">command = <span class="built_in">input</span>()</span><br><span class="line">match command.split():</span><br><span class="line">    case [<span class="string">&quot;quit&quot;</span>]:</span><br><span class="line">        quit()</span><br><span class="line">    case [<span class="string">&quot;load&quot;</span>, filename]:</span><br><span class="line">        load_from(filename)</span><br><span class="line">    case [<span class="string">&quot;save&quot;</span>, filename]:</span><br><span class="line">        save_to(filename)</span><br><span class="line">    case _:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;Command &#x27;<span class="subst">&#123;command&#125;</span>&#x27; not understood&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以匹配类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">match media_object:</span><br><span class="line">    case Image(<span class="built_in">type</span>=media_type):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">f&quot;Image of type <span class="subst">&#123;media_type&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>还可以配合守卫使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">match point:</span><br><span class="line">    case Point(x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The point is located on the diagonal Y=X at <span class="subst">&#123;x&#125;</span>.&quot;</span>)</span><br><span class="line">    case Point(x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Point is not on the diagonal.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="更好的错误提示"><a href="#更好的错误提示" class="headerlink" title="更好的错误提示"></a>更好的错误提示</h2><p>Python3.9采用了新的Parser，这给3.10更加人性的错误提示奠定了基础。</p>
<p>比如在3.8，如下代码的错误提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print (&quot;Hello&quot;</span><br><span class="line">print (&quot;What&#39;s going on?&quot;)</span><br><span class="line"></span><br><span class="line">  File &quot;.\test.py&quot;, line 2</span><br><span class="line">    print (&quot;What&#39;s going on?&quot;)</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>而在3.10中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  File &quot;.\test.py&quot;, line 1</span><br><span class="line">    print (&quot;Hello&quot;</span><br><span class="line">          ^</span><br><span class="line">SyntaxError: &#39;(&#39; was never closed</span><br></pre></td></tr></table></figure>

<p>在比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;x,y for x,y in range(100)&#125;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    &#123;x,y for x,y in range(100)&#125;</span><br><span class="line">     ^</span><br><span class="line">SyntaxError: did you forget parentheses around the comprehension target?</span><br></pre></td></tr></table></figure>

<h2 id="更好的类型检查支持"><a href="#更好的类型检查支持" class="headerlink" title="更好的类型检查支持"></a>更好的类型检查支持</h2><p>增加了ParamSpec和TypeVar，可以让函数的类型检查再有装饰器的情况下正常工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Awaitable, <span class="type">Callable</span>, ParamSpec, TypeVar</span><br><span class="line"></span><br><span class="line">P = ParamSpec(<span class="string">&quot;P&quot;</span>)</span><br><span class="line">R = TypeVar(<span class="string">&quot;R&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_logging</span>(<span class="params">f: <span class="type">Callable</span>[P, R]</span>) -&gt; <span class="type">Callable</span>[P, Awaitable[R]]:</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args: P.args, **kwargs: P.kwargs</span>) -&gt; R:</span></span><br><span class="line">    <span class="keyword">await</span> log_to_database()</span><br><span class="line">    <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@add_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takes_int_str</span>(<span class="params">x: <span class="built_in">int</span>, y: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> takes_int_str(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>) <span class="comment"># Accepted</span></span><br><span class="line"><span class="keyword">await</span> takes_int_str(<span class="string">&quot;B&quot;</span>, <span class="number">2</span>) <span class="comment"># Correctly rejected</span></span><br></pre></td></tr></table></figure>

<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><ul>
<li>新的union type表达：<code>A|B</code></li>
<li>多重上下文</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html">https://docs.python.org/3.10/whatsnew/3.10.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 7 连接</title>
    <url>/2021/05/08/csapp_7/</url>
    <content><![CDATA[<h1 id="CSAPP-7-连接，Linking"><a href="#CSAPP-7-连接，Linking" class="headerlink" title="CSAPP 7 连接，Linking"></a>CSAPP 7 连接，Linking</h1><p>连接是将程序的不同部分（指令和数据）组合成一个二进制文件，该文件可以被读入内存并被CPU执行。连接可以发生在编译时，即程序从源代码转换成机器码的过程中（Static Linking）；也可以发生在装载阶段，即程序被读入内存的阶段（Dynamic Linking）；甚至可以在运行时，即程序已经被读入内存且已经开始执行的时候。</p>
<p>连接器操作的对象被称为目标文件：<code>Relocatable object file</code>, <code>Executable object file</code>, <code>Shared object file</code>。</p>
<p>目标文件的格式是约定俗成的，最常见的是<code>ELF</code>, Executable and Linkable Format。</p>
<blockquote>
<p>在C语言中，<code>static</code> 关键字通常用来隐藏变量或者函数。</p>
</blockquote>
<p><strong>Practice Problem 7.1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *bufp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">    temp = *bufp0;</span><br><span class="line">    *bufp0 = *bufp1;</span><br><span class="line">    *bufp1 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>Symbol</th>
<th>.symtab?</th>
<th>Symbol type</th>
<th>Module defined</th>
<th>Section</th>
</tr>
</thead>
<tbody><tr>
<td>buf</td>
<td>yes</td>
<td>extern</td>
<td>main.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp0</td>
<td>yes</td>
<td>global</td>
<td>swap.o</td>
<td>.data</td>
</tr>
<tr>
<td>bufp1</td>
<td>yes</td>
<td>global</td>
<td>swap.o</td>
<td>.bss</td>
</tr>
<tr>
<td>swap</td>
<td>yes</td>
<td>global</td>
<td>swap.0</td>
<td>.text</td>
</tr>
<tr>
<td>temp</td>
<td>no</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p><code>buf</code>由于有extern关键字，内存分配实在调用文件中完成的，而<code>temp</code>是局部变量，是运行时栈分配。</p>
<blockquote>
<p>连接器在处理多个静态库文件的时候，即symbol resolve stage，是从左向右扫描进行归档。</p>
</blockquote>
<p>连接的步骤：</p>
<ul>
<li>Symbole Resolution</li>
<li>Relocation</li>
</ul>
<p>程序连接完成后，就可以被系统从硬盘读入内存了，并且系统找到程序的“入口”指令并开始执行。每一个程序开始执行后，都有如下虚拟内存配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------    &lt;- high addres</span><br><span class="line">Kernel Memory</span><br><span class="line">--------------</span><br><span class="line">User Stack</span><br><span class="line">--------------    &lt;- %esp (stack pointer)</span><br><span class="line">|</span><br><span class="line">| ( grow )</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">-------------</span><br><span class="line">Share lib</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">-------------    &lt;- brk</span><br><span class="line">Runtime Heap</span><br><span class="line">by &#96;malloc&#96;</span><br><span class="line">-------------</span><br><span class="line">R&#x2F;W segment</span><br><span class="line">(.data, .bss)</span><br><span class="line">-------------</span><br><span class="line">RO segment</span><br><span class="line">(.init, .text)</span><br><span class="line">-------------    &lt;- 0x08048000</span><br><span class="line"></span><br><span class="line">-------------    &lt;- 0x0</span><br></pre></td></tr></table></figure>

<p><strong>Practice Problem 7.5</strong></p>
<ul>
<li>为什么每一个C程序都需要一个main函数？</li>
<li>为什么当main函数没有调用return或者exit，程序也会自然结束？</li>
</ul>
<p>main函数的程序被载入内存后的执行入口。<code>_exit</code> 都会被调用，然后把执行权交还给OS。</p>
<p><strong>Runtime动态连接</strong></p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>874. Walking Robot Simulation</title>
    <url>/2021/04/27/leetcode_robot/</url>
    <content><![CDATA[<h1 id="874-Walking-Robot-Simulation"><a href="#874-Walking-Robot-Simulation" class="headerlink" title="874. Walking Robot Simulation"></a>874. Walking Robot Simulation</h1><ul>
<li><a href="https://leetcode.com/problems/walking-robot-simulation/">874. Walking Robot Simulation</a></li>
</ul>
<p>这是一个简单，但是设计的很好的面试题。并没有困难的算法，考验的是一个软件工程师能都写出清晰、简洁代码的能力，以及一些细节问题。</p>
<p><strong>问题</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A robot on an infinite XY-plane starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands:</span><br><span class="line"></span><br><span class="line">-2: turn left 90 degrees,</span><br><span class="line">-1: turn right 90 degrees, or</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 9: move forward k units.</span><br><span class="line">Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] &#x3D; (xi, yi).</span><br><span class="line"></span><br><span class="line">If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</span><br><span class="line"></span><br><span class="line">Return the maximum Euclidean distance that the robot will be from the origin squared (i.e. if the distance is 5, return 25).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">North means +Y direction.</span><br><span class="line">East means +X direction.</span><br><span class="line">South means -Y direction.</span><br><span class="line">West means -X direction.</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: commands &#x3D; [4,-1,3], obstacles &#x3D; []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: The robot starts at (0, 0):</span><br><span class="line">1. Move north 4 units to (0, 4).</span><br><span class="line">2. Turn right.</span><br><span class="line">3. Move east 3 units to (3, 4).</span><br><span class="line">The furthest point away from the origin is (3, 4), which is 32 + 42 &#x3D; 25 units away.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: commands &#x3D; [4,-1,4,-2,4], obstacles &#x3D; [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: The robot starts at (0, 0):</span><br><span class="line">1. Move north 4 units to (0, 4).</span><br><span class="line">2. Turn right.</span><br><span class="line">3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).</span><br><span class="line">4. Turn left.</span><br><span class="line">5. Move north 4 units to (1, 8).</span><br><span class="line">The furthest point away from the origin is (1, 8), which is 12 + 82 &#x3D; 65 units away.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>我是这样想这个题的，为了模拟机器人行动，我们需要一对坐标记录机器人的位置，需要一个方向状态跟踪路径，最后计算长度。首先肯定要遍历所有的指令，而指令分三种：前进、左转和右转。那么程序的基本架构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">robotSim</span>(<span class="params">self, commands: <span class="type">List</span>[<span class="built_in">int</span>], obstacles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    </span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    direction = <span class="string">&#x27;n&#x27;</span>  <span class="comment"># 这里可一个是一个 Enum，分别代表四个方向</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">        <span class="keyword">if</span> c == -<span class="number">2</span>:  <span class="comment"># 左转</span></span><br><span class="line">           <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> c == -<span class="number">1</span>:  <span class="comment"># 右转</span></span><br><span class="line">           <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 前进</span></span><br><span class="line">           <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>现在我们只需要分别应对三种不同的命令。对于，左右转我们需要弄清执行指令后的方向，即需要一个<code>(当前方向，行动) -&gt; 新方向</code>的映射，我们可以写函数，或者直接用字典，总共是8中情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步就是前进的部分。这部分有两个问题：xy方向的变化，处理障碍物。xy的方向变化其实是一个<code>(方向) -&gt; (dx, dy)</code>的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">step = &#123;</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="string">&#x27;s&#x27;</span>: (<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">    <span class="string">&#x27;w&#x27;</span>: (-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span>: (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果dx dy 让我们移动到了障碍物，则这个移动不能完成。</p>
<p>最终我们得到如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span>(<span class="params">self, commands: <span class="type">List</span>[<span class="built_in">int</span>], obstacles: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 0. </span></span><br><span class="line">        direction = <span class="string">&#x27;n&#x27;</span> <span class="comment"># s e w</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 1.</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;w&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;l&#x27;</span>): <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            (<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;r&#x27;</span>): <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 2.</span></span><br><span class="line">        step = &#123;</span><br><span class="line">            <span class="string">&#x27;n&#x27;</span>: (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;s&#x27;</span>: (<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;w&#x27;</span>: (-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">&#x27;e&#x27;</span>: (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 这个部分是为了增加检测存在的效率，使用set</span></span><br><span class="line">        obstacles = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, obstacles))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> c == -<span class="number">2</span>:  <span class="comment"># left turn</span></span><br><span class="line">                direction = state[(direction, <span class="string">&#x27;l&#x27;</span>)]</span><br><span class="line">            <span class="keyword">elif</span> c == -<span class="number">1</span>: <span class="comment"># right turn</span></span><br><span class="line">                direction = state[(direction, <span class="string">&#x27;r&#x27;</span>)]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># move</span></span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                    dx, dy = step[direction]</span><br><span class="line">                    <span class="keyword">if</span> (x+dx, y+dy) <span class="keyword">not</span> <span class="keyword">in</span> obstacles:</span><br><span class="line">                        x += dx</span><br><span class="line">                        y += dy</span><br><span class="line">                        <span class="comment"># 3. dont want to go back...</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, x*x+y*y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode"><a href="#tags-Leetcode" class="headerlink" title="tags: Leetcode"></a>tags: <code>Leetcode</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Dict</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 6 存储的层次</title>
    <url>/2021/04/24/csapp_6/</url>
    <content><![CDATA[<h1 id="CSAPP-6-存储的层次"><a href="#CSAPP-6-存储的层次" class="headerlink" title="CSAPP 6 存储的层次"></a>CSAPP 6 存储的层次</h1><p>本书之前讨论的模型注重CPU执行程序的过程和方式，而其中内存被当做一个简单的byte array，可以实现O(1)访问。但是，这个内存模型是简化的，实际计算的内存是一个层状模型，每一层都有不同的承载力和访问开销。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p><strong>Temporal Locality</strong>：一个内存地址如果被引用了一次，那么它很可能在将来还会被引用。<strong>Spatial Locality</strong>：一个地址如果被引用，那么它周围的地址也能被引用。</p>
<p>现代计算机和操作系统都会做上述假设，如果程序可以满足上述假设，那么程序的运行速度就会提升。</p>
<p>因此：</p>
<ul>
<li>反复访问同一个内存地址效率更高</li>
<li>多维数组row基更快，因为内存连续</li>
<li>多维数组，<code>a[][][]</code> 将最后一个index作为变化最快的index</li>
<li>循环最好是大量的短代码块</li>
</ul>
<p><strong>Problem 6.9</strong></p>
<p>定义如下结构体，注意结构体在C中其实也是一段连续的内存，循环赋值的时候如果关注效率，应该采用<code>clear1</code>的方法。结构体其实相当于多维数组，只不过第二维度是一个field，而不是index。因此 j 应该是变化最快的index，而且不宜把vel和acc放在同一个loop里面，这样写起来方便，但是 Locality 不好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> vel[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> acc[<span class="number">3</span>];</span><br><span class="line">&#125; point;</span><br><span class="line"></span><br><span class="line">point p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear1</span><span class="params">(point *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">            p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">            p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储的层次"><a href="#存储的层次" class="headerlink" title="存储的层次"></a>存储的层次</h2><p>从寄存器到硬盘，再到网络服务器，计算机系统的存储系统是一个层状结构。越往上读写速度越快，但是价格也越高，相应的存储空间也越小。所以上一层的内存通常是作为下一层内存的<strong>缓存（Cache）</strong> 使用。</p>
<p><img src="https://i.imgur.com/8BRKwX4.png" alt=""></p>
<p>通常k和k+1的缓存关系具有固定的block大小。如果程序想要读取k+1的信息，会搜索k中k+1的缓存block，如果找到（cache hit）读取，如果没找到（cache miss）则会从K+1读取，并放入k层缓存，不过放入缓存的具体方式跟不同的缓存策略有关。</p>
<p>Cache hit 大家都开心，如果出现 Cache miss，我们需要分析原因。一般miss可以分成：</p>
<ul>
<li>cold miss</li>
<li>confilt miss</li>
<li>capacity miss</li>
</ul>
<p>既然每一层都是下一层的缓存，那么谁来负责管理每一层之间的数据流动呢？存储的最顶层是寄存器，这部分内存由编译器负责管理；而L1-3缓存则是由硬件负责管理；而主内存，在有虚拟内存的情况下，是有操作系统和硬件共同完成管理的，</p>
<p>正是因为存储的这种层状缓存关系，程序的Locality才对提升性能格外重要：</p>
<ul>
<li>Temporal Locality，可以提高cache hit</li>
<li>Spatial Locality，可以提高一个block空间的利用率</li>
</ul>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>如果系统的地址宽度为$m$ bits，则系统可以寻址$M=s^m$，那么缓存一般被划分成 $S=2^s$ 个缓存集（Cache set），每一个缓存集包含 $E$ 调缓存记录，而每一个缓存记录的宽度恰好是系统地址宽度 $m$。每个缓存记录包含：</p>
<ul>
<li>数据块，$B=2^b$ 字节；</li>
<li>valid bit，1 bit，用来表明该记录是否存有可用信息；</li>
<li>Tag，$t=m-(b+s)$，这部分是当前内存块地址的一个子集。</li>
</ul>
<p>由此得出缓存的大小：$C=B<em>E</em>S$，我们可以用一个4维元组定义一个缓存：$(S, E, B, m)$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 0, cache line 0</span><br><span class="line"></span><br><span class="line">| valid bit | -- t bits -- | --  b blocks  -- |</span><br><span class="line">   Valid          Tag          B &#x3D; 2^b bytes</span><br></pre></td></tr></table></figure>

<p>那么缓存是如何寻址的呢？假设我们要看缓存是否包含地址A对应的数据。首先我们把地址划分成三个部分：</p>
<ul>
<li>tag</li>
<li>set index</li>
<li>block offset</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         m-1                                    0</span><br><span class="line">address: |-- t bits --|-- s bits --|-- b bits --|</span><br><span class="line">              tag       set index   block offset</span><br></pre></td></tr></table></figure>

<p>首先，set index 部分指明缓存集（cache set）位置，然后 Tag 部分会指明那个缓存记录包含该地址的内容；最后，通过 block offset 找到读取的缓存的最终位置。</p>
<h4 id="Problem-6-10"><a href="#Problem-6-10" class="headerlink" title="Problem 6.10"></a>Problem 6.10</h4><ul>
<li>$S = C / (B * E)$</li>
<li>$s = log_2(S)$</li>
<li>$b = log_2(B)$</li>
<li>$t = m - (s+b)$</li>
</ul>
<table>
<thead>
<tr>
<th>Cache</th>
<th>m</th>
<th>C</th>
<th>B</th>
<th>E</th>
<th>S</th>
<th>t</th>
<th>s</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>2.</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>3.</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody></table>
<h3 id="直接映射缓存"><a href="#直接映射缓存" class="headerlink" title="直接映射缓存"></a>直接映射缓存</h3><p>直接映射缓存就是 $E=1$ 的缓存，即每一个缓存集只有一条缓存记录。缓存的读取分成三部：</p>
<ul>
<li>选取set</li>
<li>匹配line</li>
<li>抽取word</li>
</ul>
<p>跟上上面练习的表格，可以知道 s 的宽度是 5 比特，也就是我们需要抽取读取地址中的5位，换算成无符号整数，作为cache set索引。比如如下示意，我们的地址中 s 的部分是<code>00001</code>就会对应cache set索引1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m-1                                        0</span><br><span class="line">|--  t bits -- | 0 0 0 0 1 | --  b bits -- |</span><br></pre></td></tr></table></figure>

<p>找到 cache set 的位置后，我们需要找到对应的 cache line，由于选择了E=1，每一个 cache set 都只有一个 cache line，这一步就没什么好选择的了。</p>
<p>最后一步就是抽取数据。</p>
<ol>
<li>检查 vilid bit 是否是1，</li>
<li>检查 tag 部分（0110）是否与缓存tag部分相等，</li>
<li>继续读取offset的部分（本例子中是二进制100，即十进制4）找到对应的数据。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache set 的结构</span><br><span class="line"></span><br><span class="line">| valid bit | Tag | Block </span><br><span class="line">    &#x3D;1 ?     0110   </span><br><span class="line">    </span><br><span class="line">m-1                                        0</span><br><span class="line">|--  t bits -- | 0 0 0 0 1 | --  b bits -- |</span><br><span class="line">|   0 1 1 0    |     i     |     1 0 0     |</span><br></pre></td></tr></table></figure>

<p>如果步骤1、2都满足，成为 cache hit，即命中。否则为cache miss，这时系统需要继续访问内存读取数据，然后将数据按照规则写入cache。这时候，如果缓存已经满了，就需要一些evicted策略。对于直接映射缓存，情况比较简单，就是直接用新的数据替换该cache line。</p>
<p><strong>值得注意的是，如果一个cache line出现cache miss，系统会直接读取所有的block进入缓存，而不是只读取请求的部分。</strong></p>
<p><strong>由于缓存较小，同一个cache line会被映射到不同的内存地址，这就可能导致Conflit miss，即一个cache line被返回的清除，或交替出现cache miss</strong>。</p>
<p><strong>为什么采用中间的bit作为set索引，而不是高位的bit？因为我们希望连续的内存被映射到不同的set区间，增加连续访问的cache hit</strong></p>
<h4 id="Problem-6-11"><a href="#Problem-6-11" class="headerlink" title="Problem 6.11"></a>Problem 6.11</h4><p>padding后，75%的访问会命中。</p>
<h4 id="Problem-6-13"><a href="#Problem-6-13" class="headerlink" title="Problem 6.13"></a>Problem 6.13</h4><table>
<thead>
<tr>
<th>Cache</th>
<th>m</th>
<th>C</th>
<th>B</th>
<th>E</th>
<th>S</th>
<th>t</th>
<th>s</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>13</td>
<td>32</td>
<td>4</td>
<td>1</td>
<td>8</td>
<td>8</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tag: 8 bit</span><br><span class="line">index: 3 bits</span><br><span class="line">offset: 2 bits</span><br></pre></td></tr></table></figure>

<h4 id="Problem-6-14"><a href="#Problem-6-14" class="headerlink" title="Problem 6.14"></a>Problem 6.14</h4><p><code>0x0E34</code> -&gt; <code>0111000110100</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache block offset (CO)   0x00</span><br><span class="line">Cache set index (CI)      0x05</span><br><span class="line">Cache tag (CT)            0x71</span><br><span class="line">Cache Hit?                Yes</span><br><span class="line">Cache byte return         0x0B</span><br></pre></td></tr></table></figure>

<h4 id="Problem-6-15"><a href="#Problem-6-15" class="headerlink" title="Problem 6.15"></a>Problem 6.15</h4><p><code>0x0DD5</code> -&gt; <code>110111010101</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache block offset (CO)   0x01</span><br><span class="line">Cache set index (CI)      0x05</span><br><span class="line">Cache tag (CT)            0x6E</span><br><span class="line">Cache Hit?                No</span><br><span class="line">Cache byte return         -</span><br></pre></td></tr></table></figure>



<h3 id="写入缓存的问题"><a href="#写入缓存的问题" class="headerlink" title="写入缓存的问题"></a>写入缓存的问题</h3><p>上述方法用于读取缓存没有问题，当程序想要向缓存写入数据的时候，系统需要考虑不同的方案。我们有两种情况：Write hit 和 Write miss。</p>
<p>Write hit 的情况下，我们有两种方案：<code>write-though</code>和<code>write-back</code>。前一种方案会在写入缓存的同事，更新对应的内存空间；后一种方案，只有在该缓存被清除的时候，才会向对应内存写入更新的数值。</p>
<p>Write miss 的情况下，也是两种方案：<code>write-allocate</code>和<code>no-write-allocate</code>。前一种方案会读取数据到缓存，然后写入缓存；后一种会直接写入内存或下一层缓存。</p>
<h3 id="i-cache-和-d-cache"><a href="#i-cache-和-d-cache" class="headerlink" title="i-cache 和 d-cache"></a>i-cache 和 d-cache</h3><p>缓存不仅会存储数据，也会存储CPU指令。</p>
<h3 id="缓存参数对性能影响指标"><a href="#缓存参数对性能影响指标" class="headerlink" title="缓存参数对性能影响指标"></a>缓存参数对性能影响指标</h3><p>我们有如下指标评估缓存的性能：</p>
<ul>
<li>Miss Rate</li>
<li>Hit Rate</li>
<li>Hit time</li>
<li>Miss penalty</li>
</ul>
<h2 id="如何利用缓存特性写更快的程序？"><a href="#如何利用缓存特性写更快的程序？" class="headerlink" title="如何利用缓存特性写更快的程序？"></a>如何利用缓存特性写更快的程序？</h2><ol>
<li>让公共代码跑的更快</li>
<li>减少内层循环的cache miss</li>
<li>再循环中不断访问局部变量（编译器会优化到寄存器）</li>
<li>把变化最快层放在最内层索引</li>
</ol>
<p>概念上：</p>
<ul>
<li>关注程序的最内层循环</li>
<li>为了最大化空间局部性，stride 1 模式读取对象</li>
<li>为了最大化临时局部性，反复使用已经从内存读取的对象</li>
</ul>
<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>1192 Critical Connections in a Network</title>
    <url>/2021/04/24/leetcode_graph/</url>
    <content><![CDATA[<h1 id="1192-Critical-Connections-in-a-Network"><a href="#1192-Critical-Connections-in-a-Network" class="headerlink" title="1192. Critical Connections in a Network"></a>1192. Critical Connections in a Network</h1><ul>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/">1192. Critical Connections in a Network</a></li>
<li><a href="https://leetcode.com/problems/all-paths-from-source-to-target/">797. All Paths From Source to Target</a></li>
</ul>
<h2 id="1192-Critical-Connections-in-a-Network-1"><a href="#1192-Critical-Connections-in-a-Network-1" class="headerlink" title="1192. Critical Connections in a Network"></a>1192. Critical Connections in a Network</h2><p><strong>问题</strong></p>
<blockquote>
<p>There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.A critical connection is a connection that, if removed, will make some server unable to reach some other server.<br>Return all critical connections in the network in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 4, connections &#x3D; [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">Output: [[1,3]]</span><br><span class="line">Explanation: [[3,1]] is also accepted.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>思路1：暴力破解</p>
<p>按照循序分别移除一个边，然后dfs剩下的图，如果DFS的深度小于节点数，说明移除的边是关键路线。这个思路简单，一旦边数量多起啦，就会超时。</p>
<p>思路2：找循环</p>
<p>关键路线其实就是不在 cycle 中的 edge，我们只需要找到所有不在循环中边，就是此题答案。</p>
<p>下一个问题是：如何找到循环？无论哪种方法，我们需要遍历图，为了找到循环，最好的办法是DFS。DFS的过程中，需要一个特殊标记表明节点的深度，因为如果我们发现循环，等价于发现了一个节点，两次访问他深度不相同！</p>
<p>现在还有一个问题，我们可以用标记在当前的搜索层发现循环，但是上一个层并不知道这个信息，我们需要把这个信息返回到上一层，其实就是回溯（backtraking）。</p>
<p>我们的DFS函数永远返回当前节点的最小深度。</p>
<p>假设我们在一个长度（深度）为<code>k</code>的DFS路径上（<code>dfs(node, k)</code>），看到了节点<code>node</code>，如果这个节点没有见过，标记他的深度；然后遍历他的相邻节点，如果发现相邻节点的深度刚好是k-1，说明这是他的父节点，跳过避免循环搜索；如果不是父节点，进入下一层搜索，<code>k+1</code>。</p>
<p>然后我们分析回溯的部分，<code>back_depth = dfs(adj, depth+1)</code>。比较当前深度<code>k</code>和下一层回溯回来的深度<code>back_depth</code>，如果回溯回来的深度<code>dfs(adj)</code>小于<code>dfs(k)</code>，则<code>k</code>发现他的邻居<code>adj</code>找到了一个可以回到<code>k</code>或者<code>k</code>的祖先的循环，则边<code>(k, adj)</code>一定属于某个循环，移除。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">connections, n</span>):</span></span><br><span class="line">    graph = build(connections, n)</span><br><span class="line">    mark = [-<span class="number">2</span>] * n</span><br><span class="line">    connections = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, (<span class="built_in">map</span>(<span class="built_in">sorted</span>, connections))))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, depth</span>):</span></span><br><span class="line">        <span class="keyword">if</span> mark[node] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># visited already!</span></span><br><span class="line">            <span class="keyword">return</span> mark[node]</span><br><span class="line">        </span><br><span class="line">        mark[node] = depth</span><br><span class="line">        min_back_depth = n</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> mark[adj] == depth - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># visited from prev level</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            back_depth = dfs(adj, depth+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> back_depth &lt;= depth:  <span class="comment"># found cycle</span></span><br><span class="line">                connections.discard(<span class="built_in">tuple</span>(<span class="built_in">sorted</span>((node, adj))))</span><br><span class="line">            </span><br><span class="line">            min_back_depth = <span class="built_in">min</span>(back_depth, min_back_depth)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> min_back_depth</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(connections)</span><br></pre></td></tr></table></figure>

<h2 id="797-All-Paths-From-Source-to-Target"><a href="#797-All-Paths-From-Source-to-Target" class="headerlink" title="797. All Paths From Source to Target"></a>797. All Paths From Source to Target</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1, and return them in any order.</p>
<p>The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1],[]]</span><br><span class="line">Output: [[0,1]]</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1,2,3],[2],[3],[]]</span><br><span class="line">Output: [[0,1,2,3],[0,2,3],[0,3]]</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: graph &#x3D; [[1,3],[2],[3],[]]</span><br><span class="line">Output: [[0,1,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>基本的DFS回溯问题，我们套用模板。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        <span class="comment"># backtrack</span></span><br><span class="line">        res = []</span><br><span class="line">        path = [<span class="number">0</span>]</span><br><span class="line">        N = <span class="built_in">len</span>(graph) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="comment"># 模板：结束条件</span></span><br><span class="line">            <span class="keyword">if</span> node == N:</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 模板：遍历所有下一个步骤</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">                path.append(i)</span><br><span class="line">                <span class="comment"># 模板：走向更深</span></span><br><span class="line">                _dfs(i)</span><br><span class="line">                <span class="comment"># 模板：恢复状态，继续循环</span></span><br><span class="line">                path.pop()</span><br><span class="line">                </span><br><span class="line">        _dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution">https://leetcode.com/problems/critical-connections-in-a-network/discuss/382638/DFS-detailed-explanation-O(orEor)-solution</a></li>
</ul>
<h6 id="tags-Leetcode-Graph-BFS-DFS"><a href="#tags-Leetcode-Graph-BFS-DFS" class="headerlink" title="tags: Leetcode Graph BFS DFS"></a>tags: <code>Leetcode</code> <code>Graph</code> <code>BFS</code> <code>DFS</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree层遍历</title>
    <url>/2021/04/20/leetcode_tree1/</url>
    <content><![CDATA[<h1 id="Tree层遍历"><a href="#Tree层遍历" class="headerlink" title="Tree层遍历"></a>Tree层遍历</h1><ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102 Binary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107 Binary Tree Level Order Traversal II</a></li>
<li><a href="https://leetcode.com/problems/deepest-leaves-sum/">1302. Deepest Leaves Sum</a></li>
<li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637 Average of Levels in Binary Tree</a></li>
</ul>
<h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102 Binary Tree Level Order Traversal"></a>102 Binary Tree Level Order Traversal</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题属于比较常见的BFS遍历，即通过一个队列将同一层的节点遍历一遍，然后入列下一层的节点，循环。不过需要注意一些 None 的conner case处理。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    tmp.append(node.val)</span><br><span class="line">                    <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            </span><br><span class="line">            res.append(tmp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107 Binary Tree Level Order Traversal II"></a>107 Binary Tree Level Order Traversal II</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p>
</blockquote>
<p><strong>思路</strong></p>
<p>此题是上一题的倒叙模式。最直接的方法是采用上题的解法，然后reverse结果。或者我们也可以直接采用queue进行，不过需要多一个状态记录层数。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dfs recursively</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom1</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    self.dfs(root, <span class="number">0</span>, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, level, res</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level + <span class="number">1</span>:</span><br><span class="line">            res.insert(<span class="number">0</span>, [])</span><br><span class="line">        res[-(level+<span class="number">1</span>)].append(root.val)</span><br><span class="line">        self.dfs(root.left, level+<span class="number">1</span>, res)</span><br><span class="line">        self.dfs(root.right, level+<span class="number">1</span>, res)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># dfs + stack</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom2</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    stack = [(root, <span class="number">0</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, level = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>, [])</span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            stack.append((node.right, level+<span class="number">1</span>))</span><br><span class="line">            stack.append((node.left, level+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line"><span class="comment"># bfs + queue   </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    queue, res = collections.deque([(root, <span class="number">0</span>)]), []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node, level = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>, [])</span><br><span class="line">            res[-(level+<span class="number">1</span>)].append(node.val)</span><br><span class="line">            queue.append((node.left, level+<span class="number">1</span>))</span><br><span class="line">            queue.append((node.right, level+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    deque, ret = collections.deque(), []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        deque.append(root)</span><br><span class="line">    <span class="keyword">while</span> deque:</span><br><span class="line">        level, size = [], <span class="built_in">len</span>(deque)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        ret.append(level)</span><br><span class="line">    <span class="keyword">return</span> ret[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637 Average of Levels in Binary Tree"></a>637 Average of Levels in Binary Tree</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,15,7]</span><br><span class="line">Output: [3.00000,14.50000,11.00000]</span><br><span class="line">Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.</span><br><span class="line">Hence return [3, 14.5, 11].</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>简单说这题就是求每一层的平均数。同样的思路，用一个queue包括所有的该层节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">        q, res  = collections.deque(), []</span><br><span class="line">        </span><br><span class="line">        q.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            size = <span class="built_in">len</span>(q)</span><br><span class="line">            _s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    _s += node.val</span><br><span class="line">                    <span class="keyword">if</span> node.left: q.append(node.left) </span><br><span class="line">                    <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">                    </span><br><span class="line">            res.append(_s/size)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1302-Deepest-Leaves-Sum"><a href="#1302-Deepest-Leaves-Sum" class="headerlink" title="1302. Deepest Leaves Sum"></a>1302. Deepest Leaves Sum</h2><p><strong>题目</strong></p>
<blockquote>
<p>Given the root of a binary tree, return the sum of values of its deepest leaves.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root &#x3D; [1,2,3,4,5,null,6,7,null,null,null,null,8]</span><br><span class="line">Output: 15</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root &#x3D; [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]</span><br><span class="line">Output: 19</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题仍然是安层遍历，只不过我们只关心最后一层的数据。因此我们写一个循环，每一次搜集所有该层的节点，直到没有节点为止，此时queue剩下的元素就是我们需要的。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepestLeavesSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            q_new = [ x.left <span class="keyword">for</span> x <span class="keyword">in</span> q <span class="keyword">if</span> x.left ] </span><br><span class="line">            q_new += [ x.right <span class="keyword">for</span> x <span class="keyword">in</span> q <span class="keyword">if</span> x.right ] </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q_new:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            q = q_new</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([ node.val <span class="keyword">for</span> node <span class="keyword">in</span> q ])</span><br></pre></td></tr></table></figure>


<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://leetcode.com/problems/deepest-leaves-sum/discuss/499023/Two-python-O(n)-sol.-by-level-order-traversal.-93%2B-With-explanation">https://leetcode.com/problems/deepest-leaves-sum/discuss/499023/Two-python-O(n)-sol.-by-level-order-traversal.-93%2B-With-explanation</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的算术 LL1 Parser</title>
    <url>/2021/04/19/parser/</url>
    <content><![CDATA[<h1 id="一个简单的算术-LL-1-Parser"><a href="#一个简单的算术-LL-1-Parser" class="headerlink" title="一个简单的算术 LL(1) Parser"></a>一个简单的算术 LL(1) Parser</h1><p>这篇文章探索如何手写一个简单的算术表达式 Parser。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们要解决的问题是把一个算术表达式字符串转化成语法树（Abstract Syntax Tree，AST），就像通用计算机语言一样，然后evaluate该AST。算术表达式包含：<code>+ - * / ( )</code> 以及数字。</p>
<h2 id="LL-1-Parsing"><a href="#LL-1-Parsing" class="headerlink" title="LL(1) Parsing"></a>LL(1) Parsing</h2><p>这里我们采用LL(1）parsing。LL(1) parser 属于自顶向下的分析器，分析时不断用当前匹配的规则对分析器栈顶的元素进行替换。我们需要如下两个信息来进行分析：</p>
<ul>
<li>分析器栈顶的词法单元（token），要么是终端字符（Terminal），要么是非终端字符（Non-Terminal）。比如 <code>+</code> 就是终端字符，而非终结字符就是语法规则左手侧的，比如 <code>Exp</code>。</li>
<li>当前正在处理的终结词法单元</li>
</ul>
<p>比如当前的栈顶单元是<code>S</code>，而当前处理的终结字符是<code>a</code>，同时我们以这样一个语法规则：<code>S -&gt; a P</code>。这时，我们需要将<code>S</code>替换成<code>a P</code>，其中<code>S</code>和<code>P</code>都是非终端字符，而<code>a</code>是终端。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Exp -&gt; Exp [ + | - ] Exp2</span><br><span class="line">2. Exp -&gt; Exp2</span><br><span class="line">3. Exp2 -&gt; Exp2 [ * | &#x2F; ] Exp3</span><br><span class="line">4. Exp2 -&gt; Exp3</span><br><span class="line">5. Exp3 -&gt; ( Exp )</span><br><span class="line">6. Exp3 -&gt; Num</span><br></pre></td></tr></table></figure>

<p>按照上述语法，我们展开<code>2+3*4</code>： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exp</span><br><span class="line">1. Exp + Exp2</span><br><span class="line">2. Exp2 + Exp2</span><br><span class="line">3. Exp3 + Exp2</span><br><span class="line">6. Num + Exp2</span><br><span class="line">3. Num + Exp2 * Exp3</span><br><span class="line">4. Num + Exp3 * Exp3</span><br><span class="line">6. Num + Num * Exp3</span><br><span class="line">6. Num + Num * Num</span><br></pre></td></tr></table></figure>

<p>不过目前这个语法，我们还不能用<code>LL(1)</code>分析器分析，因为 LL1 要求只能每次看一个词法单元，而我们的语法的右手侧不是唯一的。我们需要重写语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. S      -&gt; Exp $</span><br><span class="line">2. Exp    -&gt; Exp2 Exp&#39;</span><br><span class="line">3. Exp&#39;   -&gt; [ + | - ] Exp2 Exp&#39;</span><br><span class="line">4. Exp&#39;   -&gt; none</span><br><span class="line">5. Exp2   -&gt; Exp3 Exp2&#39;</span><br><span class="line">6. Exp2&#39;  -&gt; [ * | - ] Exp3 Exp2&#39;</span><br><span class="line">7. Exp2&#39;  -&gt; none</span><br><span class="line">8. Exp3   -&gt; num</span><br><span class="line">9. Exp3   -&gt; ( Exp )</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先定义词法单元，和AST节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenT</span>(<span class="params">enum.Enum</span>):</span></span><br><span class="line">    T_NUM = <span class="number">0</span></span><br><span class="line">    T_PLUS = <span class="number">1</span></span><br><span class="line">    T_MINUS = <span class="number">2</span></span><br><span class="line">    T_MULT = <span class="number">3</span></span><br><span class="line">    T_DIV = <span class="number">4</span></span><br><span class="line">    T_LPAR = <span class="number">5</span></span><br><span class="line">    T_RPAR = <span class="number">6</span></span><br><span class="line">    T_END = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, token_t, value=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.token_t = token_t</span><br><span class="line">        self.value = value </span><br><span class="line">        self.children = []</span><br></pre></td></tr></table></figure>

<p>然后我们写词法器，Lexer：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lex</span>(<span class="params">exp</span>):</span></span><br><span class="line">    mapping = &#123;</span><br><span class="line">        <span class="string">&quot;+&quot;</span>: TokenT.T_PLUS,</span><br><span class="line">        <span class="string">&quot;-&quot;</span>: TokenT.T_MINUS,</span><br><span class="line">        <span class="string">&quot;*&quot;</span>: TokenT.T_MULT,</span><br><span class="line">        <span class="string">&quot;/&quot;</span>: TokenT.T_DIV</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> exp:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> mapping:</span><br><span class="line">            token_t = mapping[c]</span><br><span class="line">            token = Node(token_t=token_t, value=c)</span><br><span class="line">        <span class="keyword">elif</span> re.match(<span class="string">r&quot;\d&quot;</span>, c):</span><br><span class="line">            token = Node(TokenT.T_NUM, value=<span class="built_in">int</span>(c))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknow token <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        tokens.append(token)</span><br><span class="line"></span><br><span class="line">    tokens.append(Node(TokenT.T_END))</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br></pre></td></tr></table></figure>

<p>然后我们按照上面的语法写分析器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">tokens, token</span>):</span></span><br><span class="line">    <span class="keyword">if</span> tokens[<span class="number">0</span>].token_t == token:</span><br><span class="line">        <span class="keyword">return</span> tokens.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_e</span>(<span class="params">tokens</span>):</span>  <span class="comment"># + -</span></span><br><span class="line">    left_node = parse_e2(tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> tokens[<span class="number">0</span>].token_t <span class="keyword">in</span> [TokenT.T_PLUS, TokenT.T_MINUS]:</span><br><span class="line">        node = tokens.pop(<span class="number">0</span>)</span><br><span class="line">        node.children.append(left_node)</span><br><span class="line">        node.children.append(parse_e2(tokens))</span><br><span class="line">        left_node = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_e2</span>(<span class="params">tokens</span>):</span>  <span class="comment"># * /</span></span><br><span class="line">    left_node = parse_num(tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> tokens[<span class="number">0</span>].token_t <span class="keyword">in</span> [TokenT.T_MULT, TokenT.T_DIV]:</span><br><span class="line">        node = tokens.pop(<span class="number">0</span>)</span><br><span class="line">        node.children.append(left_node)</span><br><span class="line">        node.children.append(parse_num(tokens))</span><br><span class="line">        left_node = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left_node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_num</span>(<span class="params">tokens</span>):</span>  <span class="comment"># num</span></span><br><span class="line">    <span class="keyword">if</span> tokens[<span class="number">0</span>].token_t == TokenT.T_NUM:</span><br><span class="line">        <span class="keyword">return</span> tokens.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    match(tokens, TokenT.T_LPAR)</span><br><span class="line">    expression = parse_e(tokens)</span><br><span class="line">    match(tokens, TokenT.T_RPAR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">inputs</span>):</span></span><br><span class="line">    <span class="comment"># 返回语法树</span></span><br><span class="line">    tokens = lex(inouts)</span><br><span class="line">    ast = parse_e(tokens)</span><br><span class="line">    match(tokens, TokenT.T_END)</span><br><span class="line">    <span class="keyword">return</span> ast</span><br></pre></td></tr></table></figure>

<p>当我们得到语法树后，就可以实现计算了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ops = &#123;</span><br><span class="line">    TokenT.T_PLUS: <span class="keyword">lambda</span> x,y: x+y,</span><br><span class="line">    TokenT.T_MINUS: <span class="keyword">lambda</span> x,y: x-y,</span><br><span class="line">    TokenT.T_MULT: <span class="keyword">lambda</span> x,y: x*y,</span><br><span class="line">    TokenT.T_DIV: <span class="keyword">lambda</span> x,y: <span class="built_in">int</span>(x/y),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node.token_t == TokenT.T_NUM:</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    </span><br><span class="line">    left = compute(node.children[<span class="number">0</span>])</span><br><span class="line">    right = compute(node.children[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> ops[node.token_t](left, right)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = <span class="string">&quot;1+2*(3-5)&quot;</span></span><br><span class="line">ast = parse(strings)</span><br><span class="line">res = compute(ast)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># output: -3</span></span><br></pre></td></tr></table></figure>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://github.com/gnebehay/parser/blob/master/parser.py">https://github.com/gnebehay/parser/blob/master/parser.py</a></li>
</ul>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>LL1</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯 DFS</title>
    <url>/2021/04/18/leetcode_dfs/</url>
    <content><![CDATA[<h1 id="回溯，DFS"><a href="#回溯，DFS" class="headerlink" title="回溯，DFS"></a>回溯，DFS</h1><ul>
<li><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></li>
<li><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></li>
<li><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466. Reorder Routes to Make All Paths Lead to the City Zero</a></li>
<li><a href="https://leetcode.com/problems/24-game/submissions/">679. 24 Game</a></li>
<li><a href="https://leetcode.com/problems/expression-add-operators/">282. Expression Add Operators</a></li>
</ul>
<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>还是从简单的思考过程出发，假设给出 <code>[1,2,3]</code> 我们如何写出全排列呢？一个方法可以是：<code>1 ? ?？</code>，第一个？可以选择2或者3，然后会影响？？的选择。这种思路是典型的回溯，即穷举每一个位置的可能性，然后继续下一个选择，直到结束，回退一层，换一个选择。</p>
<p>实现起来就是一个深度优先搜索，但是所搜一层结束后，要回档当前层的状态。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, track</span>):</span></span><br><span class="line">            <span class="comment"># end condition</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(track):</span><br><span class="line">                res.append(track[:])  <span class="comment"># take a copy...</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 穷举</span></span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">in</span> track:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 选择</span></span><br><span class="line">                track.append(n)</span><br><span class="line">                <span class="comment"># 递归进入下一层选择</span></span><br><span class="line">                backtrack(nums, track)</span><br><span class="line">                <span class="comment"># 回档</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrack(nums, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题与上一题的思路是一致的，只不过由于重复的存在，我们需要穷举不同的数字，而且应该记录该数字当前可用的数量（这只一个状态），并且在回档的时候记得补回使用的数量。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">path, counter</span>):</span></span><br><span class="line">            <span class="comment"># 结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> counter:</span><br><span class="line">                <span class="keyword">if</span> counter[num] &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 增加路径</span></span><br><span class="line">                    path.append(num)</span><br><span class="line">                    <span class="comment"># 改变状态</span></span><br><span class="line">                    counter[num] -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># DFS</span></span><br><span class="line">                    backtrack(path, counter)</span><br><span class="line">                    <span class="comment"># 回滚</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                    counter[num] += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        backtrack([], Counter(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>


<h2 id="466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="466. Reorder Routes to Make All Paths Lead to the City Zero"></a>466. Reorder Routes to Make All Paths Lead to the City Zero</h2><p><strong>问题</strong></p>
<blockquote>
<ul>
<li><a href="https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">1466. Reorder Routes to Make All Paths Lead to the City Zero</a></li>
</ul>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 6, connections &#x3D; [[0,1],[1,3],[2,3],[4,0],[4,5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>首先把图改造成 undirected，同时标记那些路径是新加入的，那些是原有的。然后从0点出发做 DFS 搜索，如果途中经历了原有的路线，计数器加一。因为这些路线是需要改造的路线。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 转化成 undirected graph，并记录那些路径是原始路径，0，那些是增加路径，+1</span></span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># 构造无方向图</span></span><br><span class="line">        <span class="keyword">for</span> s, d <span class="keyword">in</span> connections:</span><br><span class="line">            graph[s].append((d, <span class="number">1</span>))  <span class="comment"># 这是s-&gt;d的原有路线，需要+1</span></span><br><span class="line">            graph[d].append((s, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur, parent, graph</span>):</span></span><br><span class="line">            <span class="keyword">for</span> node, cost <span class="keyword">in</span> graph[cur]:</span><br><span class="line">                <span class="comment"># node != parent 为了防止往回走。。</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> node != parent:</span><br><span class="line">                    self.res += cost</span><br><span class="line">                    visited.add(node)</span><br><span class="line">                    dfs(node, cur, graph)</span><br><span class="line">                    </span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>, graph) </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<p>当然这题也可以用 BFS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minReorder</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># 构造无方向图</span></span><br><span class="line">        <span class="keyword">for</span> s, d <span class="keyword">in</span> connections:</span><br><span class="line">            graph[s].append((d, <span class="number">1</span>))  <span class="comment"># 这是s-&gt;d的原有路线，需要+1</span></span><br><span class="line">            graph[d].append((s, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = [<span class="number">0</span>]</span><br><span class="line">        visited = <span class="built_in">set</span>([<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> n, cost <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visted:</span><br><span class="line">                    visited.add(n)</span><br><span class="line">                    res += cost</span><br><span class="line">                    queue.append(n)</span><br><span class="line">                    </span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="679-24-Game"><a href="#679-24-Game" class="headerlink" title="679. 24 Game"></a>679. 24 Game</h2><p><strong>问题</strong></p>
<blockquote>
<p>You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [4, 1, 8, 7]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: (8-4) * (7-1) &#x3D; 24</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1, 2, 1, 2]</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>基本问题是给出四个数和四则运算，搜索满足条件的数字组合。典型的搜索问题。对于没两个数字，我们需要尝试四种运算，得到结果A，然后再A和剩下的三个数字里继续搜索。</p>
<p>这题被划分成困难，但是其实代码非常简单和清楚，就是典型的DFS通过递归实现。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">round</span>(nums[<span class="number">0</span>], <span class="number">4</span>) == <span class="number">24</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                first, second = nums[i], nums[j]</span><br><span class="line">                left = nums[:i] + nums[i+<span class="number">1</span>: j] + nums[j+<span class="number">1</span>: ]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first+second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first*second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[first-second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> self.judgePoint24(left+[second-first]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> second <span class="keyword">and</span> self.judgePoint24(left+[first/second]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> first <span class="keyword">and</span> self.judgePoint24(left+[second/first]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-DFS"><a href="#tags-Leetcode-DFS" class="headerlink" title="tags: Leetcode DFS"></a>tags: <code>Leetcode</code> <code>DFS</code></h6><h2 id="282-Expression-Add-Operators"><a href="#282-Expression-Add-Operators" class="headerlink" title="282. Expression Add Operators"></a>282. Expression Add Operators</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a string num that contains only digits and an integer target, return all possibilities to add the binary operators ‘+’, ‘-‘, or ‘*’ between the digits of num so that the resultant expression evaluates to the target value.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;123&quot;, target &#x3D; 6</span><br><span class="line">Output: [&quot;1*2*3&quot;,&quot;1+2+3&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;232&quot;, target &#x3D; 8</span><br><span class="line">Output: [&quot;2*3+2&quot;,&quot;2+3*2&quot;]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;105&quot;, target &#x3D; 5</span><br><span class="line">Output: [&quot;1*0+5&quot;,&quot;10-5&quot;]</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;00&quot;, target &#x3D; 0</span><br><span class="line">Output: [&quot;0*0&quot;,&quot;0+0&quot;,&quot;0-0&quot;]</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: num &#x3D; &quot;3456237490&quot;, target &#x3D; 9191</span><br><span class="line">Output: []ing</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题显然是一个搜索问题，或者说回溯问题。基本思路是深度优先搜索，从左向右读取字符，组成数字（不同位数），然后分别尝试三种运算，并组合得出可以得到target的组合字符串。递归是写起来最方便的方法了，下一步就是确定递归携带的状态参数。</p>
<p>首先，我们需要记录当前截取的字符串位置，需要两个参数：<code>l</code>和<code>r</code>，分别代表当前截取的左右索引值；然后，需要记录当前的表达式，<code>expr</code>，即当前路径上目前的表达式；当前的计算结果，<code>cur</code>；上一步的计算结果，<code>last</code>；最后需要记录已经取得的结果，<code>res</code>，这是一个结果表达式的列表。</p>
<p>搜索过程是：从左边的0开始不断向右r搜索，终结条件是：</p>
<ul>
<li>l == r，即已经搜索了全部字符串</li>
<li>cur == target，即结果等于目标值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">l, r, expr, cur, last, res</span>):</span></span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> l == r <span class="keyword">and</span> cur == target:</span><br><span class="line">        res.append(expr)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">1</span>, r+<span class="number">1</span>): <span class="comment"># why l+1? r+1?</span></span><br><span class="line">        <span class="keyword">if</span> i == l+<span class="number">1</span> <span class="keyword">or</span> (i &gt; l+<span class="number">1</span> <span class="keyword">and</span> num[l] != <span class="string">&quot;0&quot;</span>):  <span class="comment"># avoid start with 0</span></span><br><span class="line">            s, x = num[l:i], <span class="built_in">int</span>(num[l:i])  <span class="comment"># from l to i !</span></span><br><span class="line">            <span class="keyword">if</span> last <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                dfs(i, r, s, x, x, res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;+&quot;</span> + s, cur+x, x, res)</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;-&quot;</span> + s, cur-x, -x, res)</span><br><span class="line">                dfs(i, r, expr + <span class="string">&quot;*&quot;</span> + s, cur-last+last*x, res)</span><br></pre></td></tr></table></figure>

<p>如果没有乘法，即不改变结合优先级，我们不需要<code>last</code>状态来复原。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap 使用</title>
    <url>/2021/04/18/leetcode_heap1/</url>
    <content><![CDATA[<h1 id="Heap（堆）的使用"><a href="#Heap（堆）的使用" class="headerlink" title="Heap（堆）的使用"></a>Heap（堆）的使用</h1><ul>
<li><a href="https://leetcode.com/problems/last-stone-weight/">1046. Last Stone Weight</a></li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">703. Kth Largest Element in a Stream</a></li>
<li><a href="https://leetcode.com/problems/maximum-average-pass-ratio/">1792. Maximum Average Pass Ratio</a></li>
<li><a href="https://leetcode.com/problems/task-scheduler/">621. Task Schedule</a></li>
</ul>
<h2 id="1046-Last-Stone-Weight"><a href="#1046-Last-Stone-Weight" class="headerlink" title="1046. Last Stone Weight"></a>1046. Last Stone Weight</h2><p><strong>思路</strong></p>
<p>此题比较直接，直接采用heap来维护最重的数值在头部，需要注意的是 Python 的 heap 都是 min heap，所以需要取负数来实现此题。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        h = [-s <span class="keyword">for</span> s <span class="keyword">in</span> stones]</span><br><span class="line">        heapify(h)</span><br><span class="line">        <span class="built_in">print</span>(h)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(h) &gt;= <span class="number">2</span>:</span><br><span class="line">            fst = heappop(h)</span><br><span class="line">            snd = heappop(h)</span><br><span class="line">            <span class="keyword">if</span> fst != snd:</span><br><span class="line">                heappush(h, fst-snd)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="built_in">sum</span>(h)</span><br></pre></td></tr></table></figure>


<h2 id="703-Kth-Largest-Element-in-a-Stream"><a href="#703-Kth-Largest-Element-in-a-Stream" class="headerlink" title="703. Kth Largest Element in a Stream"></a>703. Kth Largest Element in a Stream</h2><p><strong>思路</strong><br>这题的要点在于维护一个固定长度的heap。可以采用 <code>heapreplace</code> 函数实现 push和pop 的组合操作。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.k = k</span><br><span class="line">        heapify(self.nums)</span><br><span class="line">        <span class="comment"># 保持头部是 kth largest </span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.nums) &gt; k:</span><br><span class="line">            heappop(self.nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.nums) &lt; self.k:</span><br><span class="line">            heappush(self.nums, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.nums[<span class="number">0</span>]:</span><br><span class="line">            heapreplace(self.nums, val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>


<h2 id="1792-Maximum-Average-Pass-Ratio"><a href="#1792-Maximum-Average-Pass-Ratio" class="headerlink" title="1792. Maximum Average Pass Ratio"></a>1792. Maximum Average Pass Ratio</h2><p><strong>思路</strong></p>
<p>这道题的关键在于想要找到最大平均数，需要把好学生分配到改变通过率最大的班级，即 delta 最大的班级。根据这个特征，我们需要一个堆来决绝，按照每个班增加一个好学生后的 delta 作为 Priority。永远把好学生分配到怼的头部。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAverageRatio</span>(<span class="params">self, classes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], extraStudents: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        h = [((x/t - (x+<span class="number">1</span>)/(t+<span class="number">1</span>)), x, t) <span class="keyword">for</span> x, t <span class="keyword">in</span> classes]</span><br><span class="line">        heapify(h)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> extraStudents:</span><br><span class="line">            v, x, t = heappop(h)</span><br><span class="line">            x, t = x+<span class="number">1</span>, t+<span class="number">1</span></span><br><span class="line">            heappush(h, (x/t-(x+<span class="number">1</span>)/(t+<span class="number">1</span>), x, t))</span><br><span class="line">            extraStudents -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([x/t <span class="keyword">for</span> _,x,t <span class="keyword">in</span> h]) / <span class="built_in">len</span>(h)</span><br></pre></td></tr></table></figure>

<h2 id="621-Task-Schedule"><a href="#621-Task-Schedule" class="headerlink" title="621. Task Schedule"></a>621. Task Schedule</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        h = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> Counter(tasks).items():</span><br><span class="line">            heappush(h, (-<span class="number">1</span>*v, k))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            tmp =  []</span><br><span class="line">            <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> h:</span><br><span class="line">                    left, task = heappop(h)</span><br><span class="line">                    <span class="keyword">if</span> left != -<span class="number">1</span>:</span><br><span class="line">                        tmp.append((left+<span class="number">1</span>, task))</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> h <span class="keyword">and</span> <span class="keyword">not</span> tmp:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> tmp:</span><br><span class="line">                heappush(h, item)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode-Heap"><a href="#tags-Leetcode-Heap" class="headerlink" title="tags: Leetcode Heap"></a>tags: <code>Leetcode</code> <code>Heap</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Palindrome Pairs and the Trie</title>
    <url>/2021/04/17/leetcode_trie_tree/</url>
    <content><![CDATA[<h1 id="Prefix-tree"><a href="#Prefix-tree" class="headerlink" title="Prefix tree"></a>Prefix tree</h1><ul>
<li><a href="https://leetcode.com/problems/stream-of-characters/">208. Implement Trie (Prefix Tree)</a> </li>
<li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">1032. Stream of Characters</a></li>
<li><a href="https://leetcode.com/problems/palindrome-pairs/">336. Palindrome Pairs</a></li>
</ul>
<p>这两个题都提到了一种树：Trie，也叫做 prefix tree 或者 digital tree，属于所搜树的一种。通常用于字符串的分段搜索，也可以用来做输入提示，即给出一些字母，搜索后续可用的路径。搜索方式属于 DFS，每个节点可以通过带有一些属性，从而实现其他功能，比如不同的action等等。</p>
<p>第三题呢，乍一看跟 Trie 没关系但是，用 Trie 可以大大提高效率。</p>
<p>第一个题是中等，后两个都是困难题。</p>
<h2 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h2><p><strong>问题</strong></p>
<blockquote>
<p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.<br>Implement the Trie class:<br>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题就是实现一个<code>prefix tree</code>。我们采用字典构造树，基本插入算法是：对每一个词，构建一个path，path上的节点就是词内的字母，这些字母节点可以被很多词共享。搜索操作就是按照字母顺序遍历树的path，如果遍历成功到达一个leaf节点，搜索成功，否则失败，中途一旦发现不能继续，直接失败。对于 prefix 操作，思路与搜索类似，只不过不需要到达一个leaf节点，只要所有的字母都在某一个path即可。</p>
<p>其实，此题就算不清楚prefix tree的存在也是可以思考的。因为这个问题明显是一个搜索问题，搜索无非就是线性、树状或者图三种。这题由于涉及路径搜索，即给出一个字母序列，能在已有的结构中找到一个路径吗？找路径就是搜索树。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.children = collections.defaultdict(Node)</span><br><span class="line">                self.end = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.tree = Node()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        cur.end = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> cur.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.children[c]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur.end</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> cur.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.children[c]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="1032-Stream-of-Characters"><a href="#1032-Stream-of-Characters" class="headerlink" title="1032. Stream of Characters"></a>1032. Stream of Characters</h2><p><strong>问题</strong></p>
<blockquote>
<p>Implement the StreamChecker class as follows:</p>
<p>StreamChecker(words): Constructor, init the data structure with the given words.<br>query(letter): returns true if and only if for some k &gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StreamChecker streamChecker &#x3D; new StreamChecker([&quot;cd&quot;,&quot;f&quot;,&quot;kl&quot;]); &#x2F;&#x2F; init the dictionary.</span><br><span class="line">streamChecker.query(&#39;a&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;b&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;c&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;d&#39;);          &#x2F;&#x2F; return true, because &#39;cd&#39; is in the wordlist</span><br><span class="line">streamChecker.query(&#39;e&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;f&#39;);          &#x2F;&#x2F; return true, because &#39;f&#39; is in the wordlist</span><br><span class="line">streamChecker.query(&#39;g&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;h&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;i&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;j&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;k&#39;);          &#x2F;&#x2F; return false</span><br><span class="line">streamChecker.query(&#39;l&#39;);          &#x2F;&#x2F; return true, because &#39;kl&#39; is in the wordlist</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>此题的关键在于我们不断读入新的字母，形成一个字母序列，我们需要反向搜索当前stream形成的path是不是在我们的树上。所以，对于给出的词，我们需要逆向构造。而且我们需要每个节点包含一个<code>is_end</code>flag用来表明当前这个节点是不是一个词。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">&quot;children&quot;</span>, <span class="string">&quot;is_end&quot;</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = defaultdict(Node)</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">words</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给出一个词的列表，我们需要构造一个搜索树</span></span><br><span class="line">    root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">        cur = root </span><br><span class="line">        w = w[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> w:</span><br><span class="line">            cur = cur.children[c]</span><br><span class="line">        <span class="comment"># cur is now the end of the path</span></span><br><span class="line">        cur.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Build a trie for each word in reversed order</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment"># for user query record, init as empty string</span></span><br><span class="line">        self.prefix = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># for root node of trie, init as empty Trie</span></span><br><span class="line">        self.trie = build_tree(words)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, letter: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Search user input in trie with reversed order</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">		</span><br><span class="line">        self.prefix += letter</span><br><span class="line">        </span><br><span class="line">        cur_node = self.trie</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">reversed</span>(self.prefix):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> cur_node.children:</span><br><span class="line">                <span class="comment"># current char not in Trie, impossible to match words</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            cur_node = cur_node.children[char]</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> cur_node.is_end:</span><br><span class="line">                <span class="comment"># user input match a word in Trie</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># No match</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-Tree"><a href="#tags-Leetcode-Tree" class="headerlink" title="tags: Leetcode Tree"></a>tags: <code>Leetcode</code> <code>Tree</code></h6><h2 id="336-Palindrome-Pairs"><a href="#336-Palindrome-Pairs" class="headerlink" title="336. Palindrome Pairs"></a>336. Palindrome Pairs</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span><br><span class="line">Output: [[0,1],[1,0],[3,2],[2,4]]</span><br><span class="line">Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br><span class="line">Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: words &#x3D; [&quot;a&quot;,&quot;&quot;]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>我们可以暴力解，即<code>O(k*n^2)</code>，反复遍历检查。k 是词的长度，如果 n 远远大于 k，这个算法的效率就会非常低。</p>
<p>假设我们考虑两个词，A和B。检查 A+B 是否形成回文，怎么办呢？首先，我们看 <code>A[0] ?= B[-1]</code>，如果是，继续看；如果不是，即可确定他们不能形成回文。所以，当我们再检查一个词是否可以与给出词组形成回文的时候，我们可以只看那些词头和词尾相同的词，缩小所搜范围。同样的思路可以进一步延伸☞倒数第二个，倒数第三个。。。字母。</p>
<p>实际上这就形成了一个多级的map，用来缩小搜索范围。这个多级map也就是 Trie 的数据结构。</p>
<p>我们反向构造一个 Trie，每个节点有一个flag表示到这个node为止是否形成了一个词。当我们拿到以一个词A，需要与 trie 路径上的词匹配的时候，有两种情况：</p>
<ol>
<li>匹配词长度 &lt;= A的长度</li>
<li>匹配词长度 &gt;  A的长度</li>
</ol>
<p>假设我们有一个 word list： <code>[&#39;acbe&#39;, &#39;ca&#39;, &#39;bca&#39;, &#39;bbac&#39;]</code>，反向可以形成如下 Trie：</p>
<p><img src="https://i.imgur.com/wn2uMo1.jpg" alt=""></p>
<p>现在我们看情况1：匹配词长度 &lt;= A的长度，假设我们搜索 <code>acbe</code> 可以匹配出回文的词。首先，我们选择 <code>a</code> 开头的path，因为其他path没有可能。然后看 <code>c</code>，也发现了一个路径，而且c有index标记，是一个终端词。这时候，我们检查余下的部分be是否是回文（也就是看这个组合<code>acbe + ac</code>），发现不是回文，继续看下一个字母b，又发现了一个路径，且是终端词，检查余下的部分，<code>e</code>，是回文（只有一个字母），此时我们就发现了一组，即<code>acbe + bca</code>（记得我们的Trie是逆向构建的，acb就是词bac）。</p>
<p>继续看情况2：匹配词长度 &gt;  A的长度，假设我们搜索<code>ca</code>的可能匹配。选择了上图中间的路径，不过因为ca短，没有到达任何一个词，但是这样也意味着，ca可能跟这个路径上剩下词形成回文，只要剩下的部分是回文。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> w == w[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = defaultdict(Trie1)</span><br><span class="line">        self.index = -<span class="number">1</span></span><br><span class="line">        self.palindrome_below = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_word</span>(<span class="params">self, word, index</span>):</span></span><br><span class="line">        trie = self</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(word)):</span><br><span class="line">            <span class="keyword">if</span> is_palindrome(word[<span class="number">0</span>:<span class="built_in">len</span>(word)-i]):</span><br><span class="line">                trie.palindrome_below.append(index)</span><br><span class="line">            trie = trie.children[c]</span><br><span class="line">        trie.index = index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_trie</span>(<span class="params">words</span>):</span></span><br><span class="line">    trie = Trie1()</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">        trie.add_word(word, i)</span><br><span class="line">    <span class="keyword">return</span> trie</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span>(<span class="params">trie, word, index</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> word:</span><br><span class="line">        <span class="keyword">if</span> trie.index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> is_palindrome(word):</span><br><span class="line">                res.append(trie.index)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word[<span class="number">0</span>] <span class="keyword">in</span> trie.children:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        trie = trie.children[word[<span class="number">0</span>]]</span><br><span class="line">        word = word[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trie.index &gt;= <span class="number">0</span>:</span><br><span class="line">        res.append(trie.index)</span><br><span class="line">    res.extend(trie.palindrome_below)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">words</span>):</span></span><br><span class="line">    trie = make_trie(words)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">        selected = get_palindrome(trie, word, i)</span><br><span class="line">        res.extend([i, c] <span class="keyword">for</span> c <span class="keyword">in</span> selected <span class="keyword">if</span> i!=c)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://fizzbuzzed.com/top-interview-questions-5/">https://fizzbuzzed.com/top-interview-questions-5/</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 4 处理器架构</title>
    <url>/2021/04/16/csapp_4/</url>
    <content><![CDATA[<h1 id="CSAPP-4-处理器架构"><a href="#CSAPP-4-处理器架构" class="headerlink" title="CSAPP 4 处理器架构"></a>CSAPP 4 处理器架构</h1><p>CPU Pipeline 的基本原理，通过将任务拆解成不同的阶段，并行执行多个任务，增加 throughput，相应的会提高延迟。不过这样可以提高CPU的时钟频率，降低延迟。</p>
<p>这是比指令集更低一个的一个层次，每一个指令集指令都被分解成多个不同的阶段，由对应的硬件分别执行。分解后，为并行提供了可能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A B C</span><br><span class="line">  A B C</span><br><span class="line">    A B C</span><br></pre></td></tr></table></figure>

<p>Pipeline 的复杂度在于错误处理、每个阶段的延迟等等。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 5 程序的优化</title>
    <url>/2021/04/16/csapp_5/</url>
    <content><![CDATA[<h1 id="CSAPP-5-程序的优化"><a href="#CSAPP-5-程序的优化" class="headerlink" title="CSAPP 5 程序的优化"></a>CSAPP 5 程序的优化</h1><p>优化方式：</p>
<ul>
<li>程序层面<ul>
<li>loop unrolling</li>
<li>减少内存renference</li>
<li>减少函数调用</li>
<li>分支优化</li>
</ul>
</li>
<li>内存优化<ul>
<li>读写循环优化</li>
</ul>
</li>
</ul>
<p>现代CPU都有独立的功能组件进行内存的读取和写入，这些组件通常都有自己的缓存。比如Intel i7处理器的读取单元可以缓存48个读取指令，他们通常可以在一个cycle内完成一个操作。</p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 3 程序的机器层面表达</title>
    <url>/2021/04/15/csapp_3/</url>
    <content><![CDATA[<h1 id="CSAPP-3-程序的机器层面表达"><a href="#CSAPP-3-程序的机器层面表达" class="headerlink" title="CSAPP 3 程序的机器层面表达"></a>CSAPP 3 程序的机器层面表达</h1><p>这一章主要从汇编程序和机器码的角度看程序。包括<code>call stack</code>, <code>local variable</code>, 以及一些基本的数据结构，比如<code>array</code>, <code>structure</code>, <code>union</code> 等等。</p>
<blockquote>
<p>Fun fact: 64位寻址空间是<code>2**48</code> 而不是 <code>2**64</code>。为什么？</p>
</blockquote>
<p>IA32机器码与C语言代码不同，可以接触到一些CPU 的计算状态：</p>
<ul>
<li>程序指针，PC</li>
<li>寄存器文件，regiester file</li>
<li>条件寄存器，</li>
<li>浮点数寄存器</li>
</ul>
<p>机器码层面，类型已经不能存在了，一切都是内存上的字节。</p>
<p>指令集中操作包括：</p>
<ul>
<li>访问内存地址</li>
<li>计算</li>
<li>控制</li>
<li>Procedures</li>
</ul>
<h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><p>寄存器的使用规则一般是依靠规定，比如<code>eax</code>, <code>edx</code>,<code>ecx</code> 是调用者（caller）保留使用的。<code>ebx</code> <code>esi</code> <code>edi</code> 是被调用函数（callee）保留使用的。换句话说，callee必须在执行其他操作前，将 <code>eax</code>, <code>edx</code>,<code>ecx</code> 进栈保存，然后再返回以前，恢复这三个寄存器的值。</p>
<h2 id="Array-Allocation"><a href="#Array-Allocation" class="headerlink" title="Array Allocation"></a>Array Allocation</h2><p>我们需要两个寄存器来进行 Arrary 的读取，一个用来存储Array的地址，另一个用来存储index，例如 <code>(%edx,%ecx,4)</code> 就是一个<code>char *D[5]</code>数列的读取命令，edx存储D的位置，ecx存储需要访问的index，而4就是<code>char *</code>的长度（32位内存地址）。</p>
<h2 id="Structure-和-Union"><a href="#Structure-和-Union" class="headerlink" title="Structure 和 Union"></a>Structure 和 Union</h2><p>一般栈内存分配都是 4 byte 为单位的。Structure就是每个格子长度大小不一致的Array，也是一块连续的内存空间。而union则会划分一块类型不确定的内存空间，可以存储任意类型（长度允许的情况下）。</p>
<p>Union会容易导致bug，但是可以有效的节约内存。比如如下二叉树节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> &#123;</span></span><br><span class="line">    <span class="comment">// 4+4+8 = 16 bytes memory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE_S</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> &#123;</span></span><br><span class="line">    <span class="comment">// max(8, 4+4) = 8 bytes</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> *<span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">NODE_U</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125; inernel;</span><br><span class="line">    <span class="keyword">double</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> N_LEAF, N_INTERNAL &#125; <span class="keyword">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> &#123;</span></span><br><span class="line">    <span class="comment">// 12 bytes</span></span><br><span class="line">    <span class="keyword">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">NODE_T</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="keyword">double</span> data;</span><br><span class="line">    &#125; info</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="Problem-3-1"><a href="#Problem-3-1" class="headerlink" title="Problem 3.1"></a>Problem 3.1</h3><p>值包括三种：register, memory, immediate.</p>
<ul>
<li><code>%eax</code>: 0x100，register</li>
<li><code>0x104</code>: 0xAB, memory</li>
<li><code>$0x108</code>: 0x108, Immediate</li>
<li><code>(%eax)</code>: 0xFF，Memory，Address 0x100</li>
<li><code>4(%eax)</code>: 0xAB，偏移量 4 byte, Address 0x104</li>
<li><code>9(%eax,%edx)</code>: 0x11, EAX + 9 + EDX</li>
<li><code>260(%ecx,%edx)</code>: 0xAB, ECX + 260 + EDX，260是十进制的</li>
<li><code>0xFC(,%ecx,4)</code>: 0xFF, 0xFC + ECX * 4, 0x4 + 0xFC = 0x100</li>
<li><code>(%eax,%edx,4)</code>: 0x11, address of 0x10C</li>
</ul>
<h3 id="Problem-3-2"><a href="#Problem-3-2" class="headerlink" title="Problem 3.2"></a>Problem 3.2</h3><p><img src="https://i.imgur.com/yJpWTI9.png" alt="寄存器分布"></p>
<p>1 word = 2 byte = 16 bits，所以一个32位寄存器包含4个byte或者2个word或者32bit。</p>
<p>一个16进制的单位，包含4个bit。所以16进制经常是两个两个写在一起，代表一个byte的宽度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl %eax, (%esp)       将 EAX 寄存器的内容移动到 ESP 指向的内存空间</span><br><span class="line">movw (%eax), %dx        将 EAX 寄存器指向的内存空间内容移动到 DX 寄存器，</span><br><span class="line">movb $0xFF, %bl         bl 是特殊寄存器，可以分别单独访问低位的两个byte空间</span><br><span class="line">movb (%esp,%edx,4)     </span><br><span class="line">pushl $0xFF</span><br><span class="line">movw %dx, (%eax)        dx 是高位的两个byte，即 1 word</span><br><span class="line">popl %edi</span><br></pre></td></tr></table></figure>

<p>例子：栈操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subl $4, %esp</span><br><span class="line">movl %ebp, (%esp)       一般采用 pushl ebp 到 栈顶（指向的内存空间）</span><br><span class="line"></span><br><span class="line">movl (%esp),%eax</span><br><span class="line">addl $4,%esp            pop %exa</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-3"><a href="#Problem-3-3" class="headerlink" title="Problem 3.3"></a>Problem 3.3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movb $0xF, (%bl)        bl 只有 8 bit，不能作为 32 bit 内存地址</span><br><span class="line">movl %ax, (%esp)        ax 是高位 2 byte，应该是 movw, movl 需要 4 byte</span><br><span class="line">movw (%eax), (%esp)     不能直接做内存 对 内存 的移动。 （为啥？）</span><br><span class="line">movb %ah,%sh            sh不存在</span><br><span class="line">movl %eax,$0x123        目标不能是 immediate</span><br><span class="line">movl %eax,%dx           dx 长度不够</span><br><span class="line">movb %si, 8(%ebp)       si 长度不够</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-4"><a href="#Problem-3-4" class="headerlink" title="Problem 3.4"></a>Problem 3.4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stc_t</span> v;</span><br><span class="line"><span class="keyword">dest_t</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出下面语句的汇编程序</span></span><br><span class="line">*p = (<span class="keyword">dest_t</span>) v;</span><br><span class="line"><span class="comment">// 指针 p 的寄存器是 %edx</span></span><br><span class="line"><span class="comment">// v 的寄存器可以根据数据宽度选择 %eax</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>src_t</th>
<th>dest_t</th>
<th>指令</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>int</td>
<td>movl %eax,(%edx)</td>
</tr>
<tr>
<td>char</td>
<td>int</td>
<td>movsbl %al,(%edx)</td>
</tr>
<tr>
<td>char</td>
<td>unsigned</td>
<td>movsbl %al,(%edx)</td>
</tr>
</tbody></table>
<h3 id="Problen-3-5"><a href="#Problen-3-5" class="headerlink" title="Problen 3.5"></a>Problen 3.5</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode1</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> *yp, <span class="keyword">int</span> *zp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = *xp;  <span class="comment">// %ebx</span></span><br><span class="line">    <span class="keyword">int</span> y = *yp; <span class="comment">// %ebi</span></span><br><span class="line">    <span class="keyword">int</span> z = *zp;<span class="comment">// %eax</span></span><br><span class="line">    </span><br><span class="line">    *yp = x;</span><br><span class="line">    *zp = y;</span><br><span class="line">    *xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-6"><a href="#Problem-3-6" class="headerlink" title="Problem 3.6"></a>Problem 3.6</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leal 6(%eax),%edx         6+x</span><br><span class="line">leal (%eax,%ecx),%edx     x+y</span><br><span class="line">leal (%eax,%ecx,4), %edx  x+4y</span><br><span class="line">leal 7(%eax,%eax,8), %edx 7+8x</span><br><span class="line">leal 0xA(,%ecx,4), %edx   10+4y</span><br><span class="line">leal 9(%eax,%ecx,2), %edx 9+x+2y</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-7"><a href="#Problem-3-7" class="headerlink" title="Problem 3.7"></a>Problem 3.7</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addl  %ecx,(%eax)           0x100    0x100</span><br><span class="line">subl  %edx,4(%eax)          0x104    0xAB - 0x3&#x3D;0xA8</span><br><span class="line">imull $16,(%eax,%edx,4)     0x10C    16 * 0x11&#x3D;0x110</span><br><span class="line">incl  8(%eax)               0x108    0x14</span><br><span class="line">decl  %ecx                  %ecx     0x0</span><br><span class="line">subl  %edx,%eax             %eax     0xFD</span><br></pre></td></tr></table></figure>

<h3 id="Problem-3-30"><a href="#Problem-3-30" class="headerlink" title="Problem 3.30"></a>Problem 3.30</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  call next</span><br><span class="line">next:</span><br><span class="line">  popl %eax</span><br></pre></td></tr></table></figure>

<p><code>%eax</code> 的值应该是栈顶刚被推出的值，而<code>call</code>会首先将返回地址压进栈顶，所以<code>%eax</code>应该是函数的返回值地址。但是这不是一个Procedure call，也没有对应的<code>ret</code>指令。这是一个IA32指令集的trick，用来获取 PC 的地址。</p>
<h3 id="Problem-3-32"><a href="#Problem-3-32" class="headerlink" title="Problem 3.32"></a>Problem 3.32</h3><p><code>*p</code> 是第3个参数，<code>d</code> 是第二个参数，</p>
<p><code>short c, char d, int *p, int x</code></p>
<h3 id="Problen-3-43"><a href="#Problen-3-43" class="headerlink" title="Problen 3.43"></a>Problen 3.43</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在第七行：</span><br><span class="line">        80 04 86 43          返回值地址</span><br><span class="line">%ebp -&gt; bf ff fc 94          存储%ebp，push %ebp -&gt; mov %esp,%ebp</span><br><span class="line">        00 00 00 03          存储%edi</span><br><span class="line">        00 00 00 02          存储%exi</span><br><span class="line">        00 00 00 01          %ebx</span><br><span class="line">                             buff[4-7]</span><br><span class="line">                             buff[0-3]</span><br><span class="line">SP   -&gt;</span><br></pre></td></tr></table></figure>


<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculator 123</title>
    <url>/2021/04/15/leetcode_calculator/</url>
    <content><![CDATA[<h1 id="Calculator-I-II-III"><a href="#Calculator-I-II-III" class="headerlink" title="Calculator I,II,III"></a>Calculator I,II,III</h1><ul>
<li><a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a></li>
</ul>
<p>问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s which represents an expression, evaluate this expression and return its value. </span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>这道题检测的是栈的使用，基本策略是一个一个的过char，如果看见数字，就累加数字（考虑进位），如果看见操作符号：比如 + -，就把当前结果进栈；如果看见 * / 就从栈顶取出一个数字，操作后进栈。过程中需要保存的状态：上一个符号，当前的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        idx, stack = <span class="number">0</span>, []</span><br><span class="line">        res = <span class="number">0</span>     <span class="comment"># 当前的数字</span></span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span>  <span class="comment"># 前一个符号</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">op, v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>: stack.append(v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;-&quot;</span>: stack.append(-v)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>: stack.append(stack.pop() * v)           <span class="comment">#for BC II and BC III</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;/&quot;</span>: stack.append(<span class="built_in">int</span>(stack.pop() / v))      <span class="comment">#for BC II and BC III</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[idx].isdigit():</span><br><span class="line">                res = res*<span class="number">10</span>+<span class="built_in">int</span>(s[idx])</span><br><span class="line">                <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="keyword">elif</span> s[idx] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                update(sign, res)</span><br><span class="line">                <span class="built_in">print</span>(res, sign)</span><br><span class="line">                res, sign = <span class="number">0</span>, s[idx]</span><br><span class="line">                <span class="built_in">print</span>(res, sign)</span><br><span class="line">                <span class="built_in">print</span>(stack)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里不要忘记，因为还有最后一个符号没有处理</span></span><br><span class="line">        update(sign, res)</span><br><span class="line">        <span class="built_in">print</span>(stack)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>

<p>对于有括号的情况，我们需要用到递归，把括号内部的表达式当做一个子问题处理。当遇到左括号的时候，递归计算后面的表达式；遇到右括号的时候，update 函数，然后返回结果以及下一个步的index。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> s[it] == <span class="string">&quot;(&quot;</span>:                                        <span class="comment"># For BC I and BC III</span></span><br><span class="line">    num, j = self.calculate(s[it + <span class="number">1</span>:])</span><br><span class="line">    it = it + j</span><br><span class="line"><span class="keyword">elif</span> s[it] == <span class="string">&quot;)&quot;</span>:                                        <span class="comment"># For BC I and BC III</span></span><br><span class="line">    update(sign, num)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(stack), it + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="tags-Leetcode-Stack"><a href="#tags-Leetcode-Stack" class="headerlink" title="tags: Leetcode Stack"></a>tags: <code>Leetcode</code> <code>Stack</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Jump Game (1-3)</title>
    <url>/2021/04/13/leetcode_jump_game/</url>
    <content><![CDATA[<h1 id="Leetcode-Jump-Game-1-3"><a href="#Leetcode-Jump-Game-1-3" class="headerlink" title="Leetcode Jump Game (1-3)"></a>Leetcode Jump Game (1-3)</h1><p>这个系列的三个题虽然名字很像，但是第一和第二个思路类似，属于贪心问题，而第三题其实是搜索问题。</p>
<h2 id="55-Jump-Game-I"><a href="#55-Jump-Game-I" class="headerlink" title="55. Jump Game I"></a>55. Jump Game I</h2><p><strong>问题</strong></p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
</blockquote>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line"> </span><br><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">index.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>给出一个非负数组，要求判断从数组 0 下标开始，能否到达数组最后一个位置。<br>这个题采用贪心算法，在每一个节点都选择跳最远的距离，如果遇到一个点的index超过了能跳的最大距离，则不能到达，否则可以到达。</p>
<p>原理就是在每一个 index 的地方重新评估我们能到达的最远距离，如果 index 已经超过这个最远距离，就断开了。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">nums</span>):</span></span><br><span class="line">    longest = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> i &gt; longest:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    longest = <span class="built_in">max</span>(longest, i+v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>


<h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h2><blockquote>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.<br>Your goal is to reach the last index in the minimum number of jumps.<br>You can assume that you can always reach the last index.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [2,3,0,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>这道题跟上一道题类似，不过是求到达最后一个index的最小步数。还是采用贪心算法，在每一个index地方选择最大的跳跃。如果我们还没有到达最后，就继续跳跃（增加一步）。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        jumps = <span class="number">0</span></span><br><span class="line">        longest = <span class="number">0</span></span><br><span class="line">        cur_pos = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[:-<span class="number">1</span>]):</span><br><span class="line">            longest = <span class="built_in">max</span>(longest, i+v)</span><br><span class="line">            <span class="keyword">if</span> i == cur_pos:</span><br><span class="line">                jumps += <span class="number">1</span></span><br><span class="line">                cur_pos = longest</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure>

<h2 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a>1306. Jump Game III</h2><blockquote>
<p>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.<br>Notice that you can not jump outside of the array at any time.</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line"></span><br><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">Output: true </span><br><span class="line">Explanation: </span><br><span class="line">One possible way to reach at index 3 with value 0 is: </span><br><span class="line">index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>这题看起来跟前两个很像，但是其实一个搜索问题。即从 start 开始跳出，每次有两个选择：向左或者向右。具有递归的性质，我们可以做 DFS，需要设置一个 visited 的 set 确保我们不会循环搜索。思路比较清楚：start 点进栈，判断结束条件，然后分别向左、向右所搜，进栈。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        stack, visited = [start], <span class="built_in">set</span>()</span><br><span class="line">        nums = arr</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            idx = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[idx] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            left = idx - nums[idx]</span><br><span class="line">            right = idx + nums[idx]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                stack.append(left)</span><br><span class="line">                visited.add(left)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                stack.append(right)</span><br><span class="line">                visited.add(right)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-DP-Greedy"><a href="#tags-Leetcode-DP-Greedy" class="headerlink" title="tags: Leetcode DP Greedy"></a>tags: <code>Leetcode</code> <code>DP</code> <code>Greedy</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>DP</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 1 概览</title>
    <url>/2021/04/09/csapp1/</url>
    <content><![CDATA[<h1 id="CSAPP-1-概览"><a href="#CSAPP-1-概览" class="headerlink" title="CSAPP 1 概览"></a>CSAPP 1 概览</h1><p>这本书之前非常简略的阅读过一次，过了这么一年多，重新拿起这本书反倒有了更多理解。可能这就是一本好书的特点把，他随着你的经验增加，提供给你更多的信息。给人的感觉就是，第一次读醍醐灌顶，第二次读，还是醍醐灌顶。。。</p>
<p>作者首先描述了一个 <code>hello</code> 程序是如何从源代码变成可以被执行的机器码，然后通过简单介绍计算机的硬件组成说明了程序是如何被执行的。在这个过程中有几个比较重要的点：</p>
<ul>
<li>编译器就是一个把一段程序（源代码）翻译成另一种程序（机器码）一个程序（机器码）</li>
<li>计算机的主要操作就是读取指令（数据），运算，输出数据</li>
<li>由于不同数据存储介质的读取速度和容量负相关，缓存机制尤其重要</li>
</ul>
<p>随后引入了操作系统的三个重要抽象：</p>
<ul>
<li>进程、线程</li>
<li>文件</li>
<li>虚拟内存</li>
</ul>
<p>作者高度概括了计算机系统设计的两个基本概念：</p>
<ul>
<li>并发和并行</li>
<li>抽象</li>
</ul>
<h2 id="操作系统抽象"><a href="#操作系统抽象" class="headerlink" title="操作系统抽象"></a>操作系统抽象</h2><p><strong>进程</strong></p>
<p>进程，是一个运行的程序的抽象。是实现并发的基本元素，操作系统通过上下文（context）切换让 CPU 在不同进程之间交替执行，从而实现多个程序的并发执行。Context 包括寄存器、内存、程序指针（PC）等。</p>
<p><strong>线程</strong></p>
<p>线程，是存在于进程内部的更小的运行的程序。他们共享父进程的内存空间，但是切换更加迅速。（他们共享 stack 吗？共享 heap 吗？）</p>
<p><strong>虚拟内存</strong></p>
<p>虚拟内存，是一个进程的内存空间抽象。每一个进程虽然都共享主内存，因为有这个抽象，每个进程拥有独立的内存空间。而操作系统和硬件负责虚拟内存和物理内存的映射。</p>
<blockquote>
<p>The basic idea is to store the contents of a process’s virtual memory on disk, and then use the main memory as a <strong>cache</strong> for the disk. </p>
</blockquote>
<p><strong>文件</strong></p>
<p>文件，就是一段连续的字节（byte）。所有的 IO 设备都被抽象成文件。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发和并行是提高运行效率的主要手段，他们体现在不同的层次上，从 CPU 层次，到操作系统，最后是应用程序。</p>
<ul>
<li><strong>线程级别并发</strong></li>
<li>指令级别并行</li>
<li>Single-Instruction, Multiple-Data (SIMD) </li>
<li>green thread</li>
</ul>
<h6 id="tags-CSAPP"><a href="#tags-CSAPP" class="headerlink" title="tags: CSAPP"></a>tags: <code>CSAPP</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 2 信息的表达和操作</title>
    <url>/2021/04/09/csapp_2/</url>
    <content><![CDATA[<h1 id="CSAPP-2-信息的表达和操作"><a href="#CSAPP-2-信息的表达和操作" class="headerlink" title="CSAPP 2 信息的表达和操作"></a>CSAPP 2 信息的表达和操作</h1><p>目前的计算机技术存储信息是二进制的，我们用0和1表达信息。最基本的信息有两种：整数和浮点数。字符串也会被编码成整数表达。从根本上说，我们规定了一些规则（向下文）来解释这些0和1。通过基本的代数法则就可以实现运算了。</p>
<p>为了方便人类阅读，常用的编码进制包括8进制和16进制。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;int: %d\n&quot;</span>, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dbl</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;double: %g\n&quot;</span>, x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int_arr</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int array: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=(<span class="keyword">sizeof</span>(a))/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_default</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;unknown argument&quot;</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(X) _Generic((X), \</span></span><br><span class="line">        <span class="keyword">int</span>: print_int, \</span><br><span class="line">        <span class="keyword">double</span>: print_dbl, \</span><br><span class="line">        <span class="keyword">int</span>*: print_int_arr, \</span><br><span class="line">        <span class="keyword">default</span>: print_default)(X)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> problem(x) printf(<span class="meta-string">&quot;\n * Problem %s: \n&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> comment(x) printf(<span class="meta-string">&quot;%s\n&quot;</span>, x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span>* x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    *y = *x^*y;</span><br><span class="line">    *x = *x^*y; <span class="comment">/*Step2*/</span></span><br><span class="line">    *y = *x^*y; <span class="comment">/*Step3*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1,2,3  -&gt; 3,2,1</span></span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="keyword">for</span> (first=<span class="number">0</span>, last=cnt<span class="number">-1</span>;</span><br><span class="line">        first &lt; last;</span><br><span class="line">        first++, last--) &#123;</span><br><span class="line">            swap(&amp;a[first], &amp;a[last]);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> y = <span class="number">1.0</span>;</span><br><span class="line">    show_int(x);</span><br><span class="line">    show_float(y);</span><br><span class="line">    show_pointer(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof float is %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof int is %lu \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">// Problem 2.6</span></span><br><span class="line">    problem(<span class="string">&quot;2.6&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3510593</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3510593.0</span>;</span><br><span class="line">    show_int(b);   <span class="comment">// ? why this shows as same as a?</span></span><br><span class="line">    show_int(a);   <span class="comment">//        1101011001000101000001</span></span><br><span class="line">    show_float(b); <span class="comment">// 1001010010101100100010100000100</span></span><br><span class="line">    <span class="comment">// Problem 2.7</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    show_bytes((byte_pointer)s, <span class="built_in">strlen</span>(s)); <span class="comment">//  61 62 63 64 65 66</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    a = 110</span></span><br><span class="line"><span class="comment">    b = 001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    b = a ^ b  -&gt; b = 110 ^ 001 = 111</span></span><br><span class="line"><span class="comment">    a = a ^ b  -&gt; a = 110 ^ 111 = 001</span></span><br><span class="line"><span class="comment">    b = a ^ b  -&gt; b = 001 ^ 111 = 110</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    problem(<span class="string">&quot;2.10&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bb = <span class="number">2</span>;</span><br><span class="line">    swap(&amp;aa, &amp;bb);</span><br><span class="line">    print(aa);</span><br><span class="line">    print(bb);</span><br><span class="line"></span><br><span class="line">    problem(<span class="string">&quot;2.11&quot;</span>);</span><br><span class="line">    comment(<span class="string">&quot;Note that a ^ a = 0&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> a2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    print(a2);</span><br><span class="line">    reverse_array(a2, <span class="number">3</span>);</span><br><span class="line">    print(a2);</span><br><span class="line"></span><br><span class="line">    problem(<span class="string">&quot;2.12&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> x12 = <span class="number">0x87654321</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, x12 &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, ~( x12 ^ <span class="number">0xFF</span> ));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, x12 | <span class="number">0xFF</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, ~( <span class="number">0x11</span> ^ <span class="number">0xFF</span> ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>nSum 问题</title>
    <url>/2021/04/09/leetcode_nSum/</url>
    <content><![CDATA[<h1 id="nSum-问题"><a href="#nSum-问题" class="headerlink" title="nSum 问题"></a>nSum 问题</h1><h2 id="2-Sum"><a href="#2-Sum" class="headerlink" title="2 Sum"></a>2 Sum</h2><p>方法1：去重、排序、字典、穷举</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            residual = target - nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> residual <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> [cache[residual], i]</span><br><span class="line">            </span><br><span class="line">            cache[nums[i]] = i</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="3-Sum"><a href="#3-Sum" class="headerlink" title="3 Sum"></a>3 Sum</h2><p>方法1：去重、排序、字典、穷举</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">sum</span>(nums)!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        counter = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            counter[i] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        nums = <span class="built_in">sorted</span>(counter.keys())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            a = nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="number">3</span>*a == <span class="number">0</span> <span class="keyword">and</span> counter[a] &gt;= <span class="number">3</span>:</span><br><span class="line">                res.append([a,a,a])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                b = nums[j]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span>*b + a == <span class="number">0</span> <span class="keyword">and</span> counter[b] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res.append([a, b, b])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="number">2</span>*a + b == <span class="number">0</span> <span class="keyword">and</span> counter[a] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res.append([a, a, b])</span><br><span class="line">                    </span><br><span class="line">                c = -a-b</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> c &gt; b <span class="keyword">and</span> counter[c] &gt;= <span class="number">1</span>:</span><br><span class="line">                    res.append([a, b, c])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h6 id="tags-Leetcode-nSum"><a href="#tags-Leetcode-nSum" class="headerlink" title="tags: Leetcode nSum"></a>tags: <code>Leetcode</code> <code>nSum</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>nSum</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划问题</title>
    <url>/2021/04/08/leetcode_dp/</url>
    <content><![CDATA[<h1 id="动态规划问题"><a href="#动态规划问题" class="headerlink" title="动态规划问题"></a>动态规划问题</h1><p>动态规划问题最鲜明的特点是求最值，问题本身一般可以用重复的、更小的子问题解决（递归特性）。解决方法通常是：递归、备忘录递归、迭代、备忘录迭代。要素是找到：</p>
<ul>
<li>重复子问题</li>
<li>最优子结构</li>
<li>状态转移方程</li>
</ul>
<p>基本套路：<code>写出 base -&gt; 明确所有状态 -&gt; 明确每个状态的选择 -&gt; 定义 dp 数组</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<p>当然也会有一些问题没有明显的求最值的要求，比如 62 Unique Path，但是该问题可以用递归解决，同样的分析也可以用 DP 进行穷举。</p>
<p>问题举例：</p>
<ul>
<li>简单题：<ul>
<li><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></li>
<li><a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></li>
</ul>
</li>
<li>中度题：<ul>
<li><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://leetcode.com/problems/coin-change-2/submissions/">518. Coin Change 2</a></li>
<li><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/combination-sum-iv">377. Combination Sum IV</a></li>
</ul>
</li>
</ul>
<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber</span><br></pre></td></tr></table></figure>

<p>要点在于不能抢隔壁，获得最大收益。最大值是典型的动态规划问题，首先明确状态。面对一个房子（i），我们有两种选择：抢或者不抢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max(抢， 不抢)   # 找到最大值</span><br><span class="line">抢就意味着前一个不能抢，所以抢的收益是： dp[i-2] + num[i]</span><br><span class="line">不抢的收益： dp[i-1]</span><br><span class="line">所以：</span><br><span class="line">max(dp[i-1], dp[i-2]+num[i])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        prev2, prev1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tmp = prev1</span><br><span class="line">            prev1 = <span class="built_in">max</span>(prev2+num, prev1)</span><br><span class="line">            prev2 = tmp</span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure>

<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;best-time-to-buy-and-sell-stock</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>这个问题跟上面的问题其实类似，目标是求最大值。接下来分析状态，可以发现除了 index 以外，我们其实有两个状态：买卖次数 k 和持股状态（0代表持币，1代表持股）。然后可以据此构造 DP 数组：<code>dp[i][k][0|1]</code>，例如 <code>dp[1][1][0]</code> 的意思就是，第一天，还可以交易1次，当前持币。</p>
<p>那么每一天我们的最优解是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + price[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>有了个这个，我们现在只需要搞清楚 base：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][0][0] &#x3D; 0</span><br><span class="line">dp[i][0][1] &#x3D; -inf   # 这种不可能存在，因为 k &#x3D; 0 意味着不能买入，则不可能持有股票</span><br></pre></td></tr></table></figure>

<p>再具体到我们这个问题，k=1，<code>dp[i-1][0][0] = 0</code> 不能交易，又持币，显然不可能有收益。而且注意到 k 其实不能影响状态方程了，也可以省略。我们的 dp 数组就退化成二维了。继续观察，其实只有i 和 i-1 两个状态相关，不需要记录所有的 i，数组就变成 1 维。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        dp_i_0, dp_i_1 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, -prices[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure>

<p>你可能已经发现了，这两个题的解法和代码几乎是一样的。</p>
<p>在 II 的题中，去掉了 <code>k = 1</code> 约束，k 可以无限大，我们只需要稍微更改上面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        dp_i_0, dp_i_1 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            temp = dp_i_0</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, temp-prices[i])  <span class="comment"># 这里 dp[i-1][k-1][0] - prices[i]</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure>


<h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure>

<p>首先这也是个最值问题：最少几个硬币。怎么分析这个问题呢？采用穷举的思想，假设我们需要换 10 元，比较复杂。但是如果我们换 1 元，就很简单，知道了 1 元的方法，2元的最少硬币个数 = min(用这个硬币，不用这个硬币）。对于每一个数量，每一个硬币，我们有两个选择：用这个硬币 和 不用这个硬币。</p>
<p>我们根据这个关系，可以写出如下算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coin_change_322</span>(<span class="params">coins: [<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line">    dp = [amount+<span class="number">1</span>] * ( amount+<span class="number">1</span> )  <span class="comment"># 初始化成最大值，+1 用来标记无解。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 状态1 是总共换钱的数量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 状态2 是硬币的种类</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= c:  <span class="comment"># 只有总量大于该硬币的时候才有意义。</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != amount+<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h3 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a>509. Fibonacci Number</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br><span class="line">给你 n ，请计算 F(n)</span><br></pre></td></tr></table></figure>

<p>这个题其实不属于 DP 问题，因为并不涉及最值求解，但是思路确实非常类似，代码看起来也很类似，只不过去掉了最值的部分，状态只有一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        n_1 = <span class="number">0</span></span><br><span class="line">        n_2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            temp = n_2</span><br><span class="line">            n_2 = n_2 + n_1</span><br><span class="line">            n_1 = temp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> n_2</span><br></pre></td></tr></table></figure>


<h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><p>上面的问题多数都有对应的中难度版本，但是只要按照这个框架，也很容易解答。</p>
<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p>这个题的区别在于，头尾相接了。我们只需要重复简单题的算法，然后注意 coner case 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">simple_rob</span>(<span class="params">nums</span>):</span></span><br><span class="line">            prev2, prev1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                tmp = prev1</span><br><span class="line">                prev1 = <span class="built_in">max</span>(prev2+num, prev1)</span><br><span class="line">                prev2 = tmp</span><br><span class="line">            <span class="keyword">return</span> prev1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(simple_rob(nums[<span class="number">1</span>:]), simple_rob(nums[:-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>


<h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure>
<p>这道题难度在于 k=2，不是 1 也不是无穷，更加泛化了。对应到 DP 问题比前两个位多了一个维度，k。回顾我们的状态方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][k][0] &#x3D; max(dp[i-1][k][0], dp[i-1][k][1] + price[i])</span><br><span class="line">dp[i][k][1] &#x3D; max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>现在我们需要两层循环来体现两个状态了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i10, i11 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        i20, i21 = <span class="number">0</span>, -<span class="number">1e10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 因为k只有两个状态，我们这里直接展开写了</span></span><br><span class="line">            i20 = <span class="built_in">max</span>(i20, i21+prices[i])</span><br><span class="line">            i21 = <span class="built_in">max</span>(i21, i10-prices[i])</span><br><span class="line">            i10 = <span class="built_in">max</span>(i10, i11+prices[i])</span><br><span class="line">            i11 = <span class="built_in">max</span>(i11, -prices[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> i20</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h3><p>此题存疑，为什么一定要 coin 在外层，而 amoung 在内层才能得到正确答案？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= c:</span><br><span class="line">                    dp[i] = dp[i] + dp[i-c]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Path"><a href="#62-Unique-Path" class="headerlink" title="62. Unique Path"></a>62. Unique Path</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">                <span class="comment"># 注意这里，i j 是两个状态，到达这个状态 有两个子情况</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &lt;= i: </span><br><span class="line">                    dp[i] += dp[i-num]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, N: <span class="type">List</span>[<span class="built_in">int</span>], T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (T + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> N:</span><br><span class="line">                <span class="keyword">if</span> num + i &lt;= T: dp[i+num] += dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[T]</span><br></pre></td></tr></table></figure>

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul>
<li><a href="https://bbs.cvmart.net/topics/1232">https://bbs.cvmart.net/topics/1232</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349940945">https://zhuanlan.zhihu.com/p/349940945</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349591952">一个大龄博士的刷题转码之路</a></li>
<li><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie">https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie</a></li>
<li><a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems">https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems</a>.</li>
</ul>
<h6 id="tags-Leetcode-DP"><a href="#tags-Leetcode-DP" class="headerlink" title="tags: Leetcode DP"></a>tags: <code>Leetcode</code> <code>DP</code></h6>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记 Memory Access Synchronization</title>
    <url>/2021/04/05/go_sync/</url>
    <content><![CDATA[<h1 id="Go-学习笔记-Memory-Access-Synchronization"><a href="#Go-学习笔记-Memory-Access-Synchronization" class="headerlink" title="Go 学习笔记 Memory Access Synchronization"></a>Go 学习笔记 Memory Access Synchronization</h1><p>Go 对并发有良好的支持，主要支持两种模式：CSP 和 MAS。前一种是大家熟知的Go常用模式（<code>goroutine</code> + <code>chan</code>），后面一种其实就是传统的带锁的并发编程（<code>sync</code> 包）。Go 对这两种并发都有良好的支持，同时也提倡在合适的时候混合使用他们，因为这两种并发的应用场景不太一样。</p>
<p>但是总体老说，MAS 不是 Go 并发的首选模式，应该在谨慎考虑后使用，尽量多使用 CSP 构造函数。Go 的基本哲学是：</p>
<blockquote>
<p>在可能的场景下使用 channel，将 goroutine 视为非常廉价的操作。</p>
</blockquote>
<h2 id="何时（不）选择-MAS"><a href="#何时（不）选择-MAS" class="headerlink" title="何时（不）选择 MAS"></a>何时（不）选择 MAS</h2><p>MAS实际上就是通过共享内存实现通讯，而CSP正好相反，通过通信实现共享内存。那么他们的应用场景是什么呢？</p>
<p><strong>传递值的所有者</strong></p>
<p>这种场景通常是把一个函数产生的结果（值），传递给另一个函数作为输入。为了确保并发安全，我们需要确保同一时间只有一个 goroutine拥有这个值。<strong>这种场景应该使用 <code>chan</code> 而不是共享内存</strong>，因为通过 channel 可以解耦两个函数，同时确保并发安全。而且，如果使用 buffer channel 还可以实现生产者-消费者模式。</p>
<p><strong>保护某个结构体内部的状态</strong></p>
<p>这种场景锁，即MAS，是最好的工具。因为当出现这种需求的时候，应该用锁把细节隐藏起来，这样调用者不需要担心破坏内部状态。换句话说，用锁控制的 critical section 被很好的局部化了。当你发现你想要传递一个锁来实现某些功能的时候，就应该小心，因为这通常意味着你应该使用 channel 而不是 锁。因为这时候，状态不再是内部状态，破坏了封装特性。</p>
<p><strong>需要协调多个函数的逻辑</strong></p>
<p>这时候应该使用 <code>chan</code>，因为 channel 的组合性更好。Go 通过 select 语句可以很好的支持组合、协作不同的 channle。</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a><code>WaitGroup</code></h2><p><code>WaitGroup</code> 的使用场景：需要等待多个 goroutine 完成，但是不在乎结果，或者有其他的 goroutine 处理结果。如果不符合这个场景，应该考虑使用 <code>chan</code> 和 <code>select</code> 来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Hello from %v\n&quot;</span>, id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> numGreeters = <span class="number">5</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(numGreeters)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGreeters; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> hello(&amp;wg, i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// wait</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的例子，我们启动了5个 goroutine，然后通过 wg 的计数器识别是否所有的 goroutine 已经完成。</p>
<h2 id="Mutex-和-RWMutex"><a href="#Mutex-和-RWMutex" class="headerlink" title="Mutex 和 RWMutex"></a><code>Mutex</code> 和 <code>RWMutex</code></h2><p><code>Mutex</code> 其实就是互斥锁，用来确保内存数据的并发安全。常见的应场景如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span> <span class="comment">// 共享内存</span></span><br><span class="line">	<span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">	increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这是一个常用模式，用来确保锁被释放</span></span><br><span class="line">		<span class="comment">// 因为即使函数 panic 了，defer 也会被执行</span></span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		count++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;增加： %d\n&quot;</span>, count)</span><br><span class="line">	&#125;</span><br><span class="line">	decreament := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">		count--</span><br><span class="line">		fmt.Printf(<span class="string">&quot;减小： %d\n&quot;</span>, count)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> arithmetic sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">			increment()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		arithmetic.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> arithmetic.Done()</span><br><span class="line">			decreament()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arithmetic.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序最终输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加： 1</span><br><span class="line">减小： 0</span><br><span class="line">减小： -1</span><br><span class="line">减小： -2</span><br><span class="line">减小： -3</span><br><span class="line">减小： -4</span><br><span class="line">减小： -5</span><br><span class="line">增加： -4</span><br><span class="line">增加： -3</span><br><span class="line">增加： -2</span><br><span class="line">增加： -1</span><br><span class="line">增加： 0</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>如果，我们不用锁来保护共享内存 <code>count</code>，可以发现输出结果是错的。</p>
<p>不过，critical section 的存在影响并发性能，因为这部分的代码是不允许并发的。但是如果仔细思考，如果在没有写入的情况下，read是不需要锁的，可以支持任意数量的并发。因此，引入了 <code>RWMutex</code> 锁，理论上 RW 锁的效率应该更高，但是我们作如下试验：通过增加 observer 协程的数量来观察两种锁的性能区别。结果却不如所料。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">5</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			l.Lock()</span><br><span class="line">			l.Unlock()</span><br><span class="line">			time.Sleep(<span class="number">100</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	observer := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, l sync.Locker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		l.Lock()</span><br><span class="line">		<span class="keyword">defer</span> l.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	test := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="keyword">int</span>, mutex, rwMutex sync.Locker)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		wg.Add(count + <span class="number">1</span>)</span><br><span class="line">		begineTime := time.Now()</span><br><span class="line">		<span class="keyword">go</span> producer(&amp;wg, mutex)</span><br><span class="line">		<span class="keyword">for</span> i := count; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">go</span> observer(&amp;wg, rwMutex)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> time.Since(begineTime)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tw := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">defer</span> tw.Flush()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m sync.RWMutex</span><br><span class="line">	fmt.Fprintf(tw, <span class="string">&quot;Reader\tRWMutex\tMutex\n&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">		count := <span class="keyword">int</span>(math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(i)))</span><br><span class="line">		fmt.Fprintf(</span><br><span class="line">			tw,</span><br><span class="line">			<span class="string">&quot;%d\t%v\t%v\n&quot;</span>,</span><br><span class="line">			count,</span><br><span class="line">			test(count, &amp;m, m.RLocker()),</span><br><span class="line">			test(count, &amp;m, &amp;m),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察程序输出，并没有发现明显的效率提升，猜测 Go 的编译器应该是进行了相关的优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reader  RWMutex       Mutex</span><br><span class="line">1       31.407µs      2.889µs</span><br><span class="line">2       9.281µs       28.884µs</span><br><span class="line">4       16.783µs      5.699µs</span><br><span class="line">8       18.108µs      29.188µs</span><br><span class="line">16      17.546µs      21.928µs</span><br><span class="line">32      37.897µs      46.451µs</span><br><span class="line">64      138.729µs     59.443µs</span><br><span class="line">128     84.53µs       84.29µs</span><br><span class="line">256     162.436µs     134.7µs</span><br><span class="line">512     257.119µs     177.244µs</span><br><span class="line">1024    498.188µs     421.574µs</span><br><span class="line">2048    638.593µs     688.569µs</span><br><span class="line">4096    1.282961ms    1.181315ms</span><br><span class="line">8192    2.411899ms    2.194452ms</span><br><span class="line">16384   4.324171ms    4.209515ms</span><br><span class="line">32768   8.863672ms    8.364724ms</span><br><span class="line">65536   17.675036ms   16.549381ms</span><br><span class="line">131072  36.074797ms   32.332008ms</span><br><span class="line">262144  71.848213ms   63.451094ms</span><br><span class="line">524288  146.209094ms  122.38836ms</span><br></pre></td></tr></table></figure>

<p>不过结果仍然可以看出，Go 的运行时在家用机上处理5百万个 goroutine 是非常轻松的。</p>
<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a><code>Cond</code></h2><p><code>Cond</code> 的应用场景是：当一个任务需要等待另一个任务给他信号才能继续的时候，我们需要 Cond 作为信号。换句话说，我们希望等待某个条件成立后，再继续执行后面的指令。</p>
<p>假设我们现在有一个队列，长度限制为2，我们有10个任务需要入列，我们希望一旦队列允许（长度小于2），就马上放入新的任务等待处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	queue := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">	removeFromQueue := <span class="function"><span class="keyword">func</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">		time.Sleep(delay * time.Second)</span><br><span class="line">		c.L.Lock()</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		fmt.Println(<span class="string">&quot;remove from queue&quot;</span>)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">        <span class="comment">// 发送信号</span></span><br><span class="line">		c.Signal()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		c.L.Lock()</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(queue) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 queue 慢了就等待，阻塞，直到收到信号</span></span><br><span class="line">			c.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;adding to queue&quot;</span>)</span><br><span class="line">		queue = <span class="built_in">append</span>(queue, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> removeFromQueue(<span class="number">1</span>)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Cond</code> 还有非常有用的函数：<code>Broadcast</code>。这个函数会像所有等待条件的 goroutine 发送信号！<code>signal</code> 功能可以轻松采用 <code>chan</code> 来模拟，但是 <code>broadcast</code> 就不那么容易，而且它的效率很高。</p>
<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a><code>Once</code></h2><p><code>Once</code> 其实是一个比较常用的抽象，他确保一个函数只会被调用一次，无论有多少个并发的 goroutine 在执行这个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> one sync.Once</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			one.Do(increment)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Count is %d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序会打印 1，而不是100。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">increment := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count++ &#125; </span><br><span class="line">decrement := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; count-- &#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once </span><br><span class="line">once.Do(increment) </span><br><span class="line">once.Do(decrement)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Count: %d\n&quot;</span>, count)</span><br></pre></td></tr></table></figure>

<p>但是 有个地方需要注意 Once，就是 <code>Once.Do</code> 不会关心调用的函数是不是一样，他只确保 Do 被调用一次！</p>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a><code>Pool</code></h2><p>Pool 是一个并发安全的对象池，主要是用来维护一些开销较大且数量有新的资源，比如数据库连接等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myPool := &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Creating new instance.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;, <span class="comment">// hmm 这是个必要的逗号，但是感觉好多鱼</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inst := myPool.Get()</span><br><span class="line">	myPool.Put(inst)</span><br><span class="line">	myPool.Get()</span><br><span class="line">	<span class="comment">// 这段程序只会维护一个 instance，即使反复的 Get，因为我们 Put</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，Pool 维护的对象是不会被垃圾回收的，这也是我们用 Pool 的主要原因。我们希望维持这些对象，而不是被回收。而且在一些需要性能场景，我们还会提前创立很多对象，形成一个 Pool，以便在需要的时候节约时间，提高吞吐量。</p>
<p>举个网络连接的例子，一下的代码是不采用 pool 的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectToService</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;cannot listen: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> server.Close()</span><br><span class="line">		wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := server.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;cnanot accept connection: %v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			connectToService()</span><br><span class="line">			fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	daemonStarted := startNetworkDaemon()</span><br><span class="line">	daemonStarted.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkNetworkRequest</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;cannot dial host: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := ioutil.ReadAll(conn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.Fatalf(<span class="string">&quot;cannot read: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行： <code>go test -benchtime=10s -bench=.</code> 得到测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: gopl.io&#x2F;ch8</span><br><span class="line">BenchmarkNetworkRequest-12            10        1004815055 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      gopl.io&#x2F;ch8     11.255s</span><br></pre></td></tr></table></figure>

<p>下面我们看一下 Pool 的版本，我们只需要改动两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">warmServiceConnCache</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line">	p := &amp;sync.Pool&#123;</span><br><span class="line">		New: connectToService,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		p.Put(p.New())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNetworkDaemon</span><span class="params">()</span> *<span class="title">sync</span>.<span class="title">WaitGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		connPool := warmServiceConnCache()</span><br><span class="line"></span><br><span class="line">		server, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;cannot listen: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">		wg.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := server.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;cannot accept connection: %v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			svcConn := connPool.Get()</span><br><span class="line">			fmt.Fprintln(conn, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			connPool.Put(svcConn)</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> &amp;wg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: gopl.io&#x2F;ch8</span><br><span class="line">BenchmarkNetworkRequest-12          1822           7720869 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok      gopl.io&#x2F;ch8     32.769s</span><br></pre></td></tr></table></figure>

<p>注意到 ns/op 降低到了 7，000，000 ns， 对比之前的版本是性能提高了约100倍！</p>
<p>但是使用 Pool 也应该注意：</p>
<ul>
<li>New 函数调用时线程安全的！</li>
<li>Get 返回的对象的状态是不完全确定的</li>
<li>记得用 Put 返回对象，不然 Pool 就没有意义了！</li>
<li>一个 Pool 只有一类对象。。。很专一</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/">Concurrency in Go</a></li>
</ul>
<h6 id="tags-Go-Sync"><a href="#tags-Go-Sync" class="headerlink" title="tags: Go Sync"></a>tags: <code>Go</code> <code>Sync</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Sync</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python重建Go并发模型 1</title>
    <url>/2021/04/04/go_python_1/</url>
    <content><![CDATA[<h1 id="用Python重建Go并发模型-1"><a href="#用Python重建Go并发模型-1" class="headerlink" title="用Python重建Go并发模型 1"></a>用Python重建Go并发模型 1</h1><blockquote>
<p>主要译自<a href="http://www.doxsey.net/blog/go-concurrency-from-the-ground-up">Go Concurrency from the Ground Up</a></p>
</blockquote>
<p>通过实现 Go 的并发模型增加对并发的理解和使用。</p>
<p>本文一共四个部分，部分1 针对前两个，后面两个在部分2：</p>
<ul>
<li><a href="#设计">设计</a>：介绍 Go 的并发模型基本API</li>
<li><a href="#实现1：非抢占调度">实现1</a>：实现一个非抢占、单线程的 goroutine 调度器</li>
<li>实现2：带缓冲的 Channel</li>
<li>实现3：Async/Await 范式实现</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>我们的设计主要包含三个主要部分：调度器、channel和select操作。有了这几个东西，我们就可以重建 go 的并发模型。</p>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><p>考虑如下简单程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125; <span class="comment">// prevent the program from terminating, ignore for now</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> aa()</span><br><span class="line">	<span class="keyword">go</span> ab()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aa</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;aa&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ab</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;ab&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> ba()</span><br><span class="line">	<span class="keyword">go</span> bb()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ba</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;ba&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bb</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;bb&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>go run main.go</code> 会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ go run main.go</span><br><span class="line">bb</span><br><span class="line">ba</span><br><span class="line">ab</span><br><span class="line">aa</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">        mani.go:6 +0x52</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>程序首先启动两个 goroutine，<code>a</code> 和 <code>b</code>，然后他们分别会启动两个给子的子协程。这里需要注意，goroutine 本身是没有父子关系的（对吗？）。程序的执行情况如下所示：</p>
<p><img src="https://i.imgur.com/TKxKBUK.png" alt="并行执行"></p>
<p>每一个 goroutine 会占据一个线程，实现了并行并发。但是执行顺序也是随机的，我们看到 <code>bb</code> 比 <code>ab</code> 更先被打印了。</p>
<p>但是，我们也观察到程序出现了 fatal error，因为 select 是阻塞操作，为了让方便观察结果，但是由于 runtime 已经没有任何活跃的 goroutine 了，程序就会报错。（当然，main goroutine 仍然是活跃的）。</p>
<p>当然，我们也可以通过同步操作，让所有 goroutine 在一个线程中执行。</p>
<p><img src="https://i.imgur.com/YbRfzzW.png" alt="顺序执行"></p>
<p>这两种调度方式都可以，但是为了简化我们后面的实现，我们选择后者，即单线程并发。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Go 通过 Chan 实现并发通讯。考虑如下程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> a(ch)</span><br><span class="line">	<span class="keyword">go</span> b(ch)</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125; <span class="comment">// prevent the program from terminating, ignore for now</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;a before&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="number">5</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;a after&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;b before&quot;</span>)</span><br><span class="line">	<span class="built_in">println</span>(&lt;-ch)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;b after&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ch</code> 对象，我们可以确保 “b after” 一定会在 “a before” 以后执行。这就是所谓的同步，而两个 goroutine 就是在 <code>ch</code> 发生连接。</p>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ go run main.go</span><br><span class="line">b before</span><br><span class="line">a before</span><br><span class="line">5</span><br><span class="line">b after</span><br><span class="line">a after</span><br></pre></td></tr></table></figure>

<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>Go  的 <code>select</code> 语句可以用来等待多个 Chan，然后处理第一个被释放的 Chan。</p>
<p>看如下程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1, ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> a(ch2)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch1:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;1:&quot;</span>, value)</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch2:</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;2:&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select 会同时等待 ch1 和 ch2，由于 a 会向 ch2 传递值，select 选择第二个branch，打印 <code>2：</code>。</p>
<h2 id="实现1：非抢占调度"><a href="#实现1：非抢占调度" class="headerlink" title="实现1：非抢占调度"></a>实现1：非抢占调度</h2><p>我们首先来看下 Go 的并发 API：</p>
<table>
<thead>
<tr>
<th></th>
<th>Python</th>
<th>Go</th>
</tr>
</thead>
<tbody><tr>
<td><code>go</code></td>
<td><code>go(lambda: print(&quot;in py routine&quot;))</code></td>
<td><code>go println(&quot;in py routine&quot;)</code></td>
</tr>
<tr>
<td><code>make</code></td>
<td><code>ch = make()</code></td>
<td><code>ch := make(chan int)</code></td>
</tr>
<tr>
<td><code>len</code></td>
<td><code>len(ch)</code></td>
<td><code>len(ch)</code></td>
</tr>
<tr>
<td><code>cap</code></td>
<td><code>cap(ch)</code></td>
<td><code>cap(ch)</code></td>
</tr>
<tr>
<td><code>send</code></td>
<td><code>send(ch, 5, lambda: print(&quot;sent&quot;))</code></td>
<td><code>ch &lt;- 5</code></td>
</tr>
<tr>
<td><code>recv</code></td>
<td><code>recv(ch, lambda value, ok: pass)</code></td>
<td><code>value, ok := &lt;- ch</code></td>
</tr>
<tr>
<td><code>close</code></td>
<td><code>close(ch)</code></td>
<td><code>close(ch)</code></td>
</tr>
<tr>
<td><code>select</code></td>
<td><code>select([(), ()])</code></td>
<td><code>select &#123;case ..&#125;</code></td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>run()</code></td>
<td>在主函数自动执行</td>
</tr>
</tbody></table>
<p>我们看到 Python 版本的 API 中 send 和 recv 函数都有带有一个回调函数，这些是为了在阻塞之后可以继续执行回调函数。这种方式比较容易实现调度，但是看起来有点不舒服，在最后一个部分，我们会采用 python 的 <code>async</code> 和 <code>await</code> 语法去掉回调函数。</p>
<p>API 有了，我们还需要实现一些数据结构，比如 Channel。Channel 的本质其实就是阻塞队列。我们采用如下实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.closed = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 这里是两个队列用来存放发送和接受的信息</span></span><br><span class="line">        self.waiting_to_send = WaitingQueue()</span><br><span class="line">        self.waiting_to_recv = WaitingQueue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingQueue</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        self.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self, x=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x = self.pop(<span class="number">0</span>)</span><br><span class="line">            WaitingQueue.total -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = self.index(x)</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.pop(idx)</span><br><span class="line">                WaitingQueue.total -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>接下来我们实现调度相关的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">execution_queue = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span>(<span class="params">callback</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>:</span><br><span class="line">        execution_queue.appendc(callback)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    WaitingQueue.total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> execution_queue:</span><br><span class="line">        <span class="comment"># 进入执行循环</span></span><br><span class="line">        f = execution_queue.pop(<span class="number">0</span>)</span><br><span class="line">        f()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> WaitingQueue.total &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果执行队列已经空了，但是还有在等待的任务，就会形成 deadlock</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;fatal error: all goroutines are asleep - deadlock&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Channel Methods</strong></p>
<p>相关的解释直接放在代码注释，目的就是模拟 Go 对 API 的各种 spec。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span>():</span></span><br><span class="line">    <span class="keyword">return</span> Channel()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">chan</span>):</span></span><br><span class="line">    <span class="comment"># unbuffered channel 长度永远是0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cap</span>(<span class="params">chan</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">chan, value, callback</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Go&#x27;s Spec: </span></span><br><span class="line"><span class="string">    Communication blocks until the send can proceed.</span></span><br><span class="line"><span class="string">    A send on an unbuffered channel can proceed if a receiver is ready.</span></span><br><span class="line"><span class="string">    [...] A send on a closed channel proceeds by causing a run-time panic. </span></span><br><span class="line"><span class="string">    A send on a nil channel blocks forever.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Nil chan 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> chan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># chan 关闭，panic</span></span><br><span class="line">    <span class="keyword">if</span> chan.closed:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;panic: send on closed channel&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 有接受请求，处理</span></span><br><span class="line">    <span class="keyword">if</span> chan.waiting_to_recv:</span><br><span class="line">        receiver = chan.waiting_to_recv.dequeue()</span><br><span class="line">        go(callback)</span><br><span class="line">        go(<span class="keyword">lambda</span>: receiver(value, <span class="literal">True</span>))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无接收请求，入队，阻塞</span></span><br><span class="line">    chan.waiting_to_send.enqueue((value, callback))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">channel, callback</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Go&#x27;s Spec:</span></span><br><span class="line"><span class="string">    The expression blocks until a value is available. </span></span><br><span class="line"><span class="string">    Receiving from a nil channel blocks forever.</span></span><br><span class="line"><span class="string">    A receive operation on a closed channel can always proceed immediately, </span></span><br><span class="line"><span class="string">     yielding the element type&#x27;s zero value after any previously sent values have been received.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># &quot;Receiving from a nil channel blocks forever.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        WaitingQueue.total += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;if anything is currently blocked on sending for this channel, receive it&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel.waiting_to_send:</span><br><span class="line">        value, sender = channel.waiting_to_send.dequeue()</span><br><span class="line">        go(<span class="keyword">lambda</span>: callback(value, <span class="literal">True</span>))</span><br><span class="line">        go(sender)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># &quot;A receive operation on a closed channel can always proceed immediately,</span></span><br><span class="line">    <span class="comment"># yielding the element type&#x27;s zero value after any previously sent values have been received.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> channel.closed:</span><br><span class="line">        go(<span class="keyword">lambda</span>: callback(<span class="literal">None</span>, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    channel.waiting_to_recv.enqueue(callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">channel</span>):</span></span><br><span class="line">    <span class="comment"># if the channel is already closed, we panic</span></span><br><span class="line">    <span class="keyword">if</span> channel.closed:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;close of closed channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">    channel.closed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># complete any senders</span></span><br><span class="line">    <span class="keyword">while</span> channel.waiting_to_send:</span><br><span class="line">        value, callback = channel.waiting_to_send.dequeue()</span><br><span class="line">        send(channel, value, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># complete any receivers</span></span><br><span class="line">    <span class="keyword">while</span> channel.waiting_to_recv:</span><br><span class="line">        callback = channel.waiting_to_recv.dequeue()</span><br><span class="line">        recv(channel, callback)</span><br></pre></td></tr></table></figure>

<p><code>select</code> API 实现相对复杂，我们的目的是如下使用场景：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select(</span><br><span class="line">  [</span><br><span class="line">    (recv, ch1, <span class="keyword">lambda</span> v1, ok: <span class="built_in">print</span>(<span class="string">&quot;received!&quot;</span>, v1, ok)),</span><br><span class="line">    (send, ch2, v2, <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;sent!&quot;</span>)),</span><br><span class="line">    (default, <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;default!&quot;</span>))</span><br><span class="line">  ],</span><br><span class="line">  <span class="keyword">lambda</span>: <span class="built_in">print</span>(<span class="string">&quot;after select&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对应的 Go 程序为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v1, ok := &lt;-ch1:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;received!&quot;</span>, v1, ok)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- v2:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;sent!&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;default!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;after select&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>根据 Spec，select的行为如下：</p>
<ul>
<li>如果有一个或以上 case 可以执行，随机选择一个执行</li>
<li>如果没有 case 可以执行，执行 default</li>
<li>如果内有 case 可以执行，也没有 default，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line"><span class="comment"># used to indicate the default case in a select</span></span><br><span class="line">default = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span>(<span class="params">cases, callback=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_ready</span>(<span class="params">case</span>):</span></span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            <span class="keyword">return</span> case[<span class="number">1</span>].closed <span class="keyword">or</span> case[<span class="number">1</span>].waiting_to_recv</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            <span class="keyword">return</span> case[<span class="number">1</span>].closed <span class="keyword">or</span> case[<span class="number">1</span>].waiting_to_send</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == default:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first see if any of the cases are ready to proceed</span></span><br><span class="line">    ready = [case <span class="keyword">for</span> case <span class="keyword">in</span> cases <span class="keyword">if</span> is_ready(case)]</span><br><span class="line">    <span class="keyword">if</span> ready:</span><br><span class="line">        <span class="comment"># pick a random one</span></span><br><span class="line">        case = ready[randint(<span class="number">0</span>, builtins.<span class="built_in">len</span>(ready)-<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            send(case[<span class="number">1</span>], case[<span class="number">2</span>], case[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            recv(case[<span class="number">1</span>], case[<span class="number">2</span>])</span><br><span class="line">        go(callback)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># next see if there&#x27;s a default case</span></span><br><span class="line">    defaults = [case <span class="keyword">for</span> case <span class="keyword">in</span> cases <span class="keyword">if</span> case[<span class="number">0</span>] == default]</span><br><span class="line">    <span class="keyword">if</span> defaults:</span><br><span class="line">        defaults[<span class="number">0</span>]()</span><br><span class="line">        go(callback)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># finally we will enqueue each case into the waiting queues</span></span><br><span class="line">    <span class="comment"># we also update each callback so it will cleanup all the</span></span><br><span class="line">    <span class="comment"># other cases so only one is fired</span></span><br><span class="line"></span><br><span class="line">    wrapped = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanup</span>():</span></span><br><span class="line">        <span class="keyword">for</span> case <span class="keyword">in</span> wrapped:</span><br><span class="line">            <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">                case[<span class="number">1</span>].waiting_to_send.dequeue((case[<span class="number">2</span>], case[<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">                case[<span class="number">1</span>].waiting_to_recv.dequeue(case[<span class="number">2</span>])</span><br><span class="line">        go(callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overwrite all the callbacks and enqueue into the waiting queues</span></span><br><span class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> cases:</span><br><span class="line">        <span class="keyword">if</span> case[<span class="number">0</span>] == send:</span><br><span class="line">            new_case = (case[<span class="number">0</span>], case[<span class="number">1</span>], case[<span class="number">2</span>],</span><br><span class="line">                        <span class="keyword">lambda</span>: (cleanup(), case[<span class="number">3</span>]()))</span><br><span class="line">            case[<span class="number">1</span>].waiting_to_send.enqueue((new_case[<span class="number">2</span>], new_case[<span class="number">3</span>]))</span><br><span class="line">            wrapped.append(new_case)</span><br><span class="line">        <span class="keyword">elif</span> case[<span class="number">0</span>] == recv:</span><br><span class="line">            new_case = (case[<span class="number">0</span>], case[<span class="number">1</span>],</span><br><span class="line">                        <span class="keyword">lambda</span> value, ok: (cleanup(), case[<span class="number">2</span>](value, ok)))</span><br><span class="line">            case[<span class="number">1</span>].waiting_to_recv.enqueue(new_case[<span class="number">2</span>])</span><br><span class="line">            wrapped.append(new_case)</span><br></pre></td></tr></table></figure>

<h2 id="一个例子-Concurrent-Merge-Sort"><a href="#一个例子-Concurrent-Merge-Sort" class="headerlink" title="一个例子 Concurrent Merge Sort"></a>一个例子 Concurrent Merge Sort</h2><p>一下是一个 go 版本的并发排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(l, r []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(l)+<span class="built_in">len</span>(r))</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(l) &gt; <span class="number">0</span> || <span class="built_in">len</span>(r) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">len</span>(l) == <span class="number">0</span>:</span><br><span class="line">			m = <span class="built_in">append</span>(m, r[<span class="number">0</span>])</span><br><span class="line">			r = r[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">len</span>(r) == <span class="number">0</span>:</span><br><span class="line">			m = <span class="built_in">append</span>(m, l[<span class="number">0</span>])</span><br><span class="line">			l = l[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> l[<span class="number">0</span>] &lt;= r[<span class="number">0</span>]:</span><br><span class="line">			m = <span class="built_in">append</span>(m, l[<span class="number">0</span>])</span><br><span class="line">			l = l[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">case</span> l[<span class="number">0</span>] &gt; r[<span class="number">0</span>]:</span><br><span class="line">			m = <span class="built_in">append</span>(m, r[<span class="number">0</span>])</span><br><span class="line">			r = r[<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMergSort</span><span class="params">(xs []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(xs) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> merge(xs[:<span class="number">1</span>], xs[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		lc, rc := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lc &lt;- ConcurrentMergSort(xs[:<span class="built_in">len</span>(xs)/<span class="number">2</span>])</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			rc &lt;- ConcurrentMergSort(xs[<span class="built_in">len</span>(xs)/<span class="number">2</span>:])</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> merge(&lt;-lc, &lt;-rc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	b := ConcurrentMergSort(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用对应的Python API 实现为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">l, r</span>):</span></span><br><span class="line">    m = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(l) &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(r) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">0</span>:</span><br><span class="line">            m.append(r[<span class="number">0</span>])</span><br><span class="line">            r = r[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(r) == <span class="number">0</span>:</span><br><span class="line">            m.append(l[<span class="number">0</span>])</span><br><span class="line">            l = l[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> l[<span class="number">0</span>] &lt;= r[<span class="number">0</span>]:</span><br><span class="line">            m.append(l[<span class="number">0</span>])</span><br><span class="line">            l = l[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m.append(r[<span class="number">0</span>])</span><br><span class="line">            r = r[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concurrent_merge_sort</span>(<span class="params">xs, callback</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(xs) &lt;= <span class="number">1</span>:</span><br><span class="line">        callback(xs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lc, rc = make(), make()</span><br><span class="line">        go(<span class="keyword">lambda</span>: concurrent_merge_sort(xs[:<span class="built_in">len</span>(xs)//<span class="number">2</span>], <span class="keyword">lambda</span> l:</span><br><span class="line">                                         send(lc, l, <span class="keyword">lambda</span>: <span class="literal">None</span>)))</span><br><span class="line">        go(<span class="keyword">lambda</span>: concurrent_merge_sort(xs[<span class="built_in">len</span>(xs)//<span class="number">2</span>:], <span class="keyword">lambda</span> r:</span><br><span class="line">                                         send(rc, r, <span class="keyword">lambda</span>: <span class="literal">None</span>)))</span><br><span class="line">        recv(lc, <span class="keyword">lambda</span> l, ok:</span><br><span class="line">             recv(rc, <span class="keyword">lambda</span> r, ok:</span><br><span class="line">                  callback(merge(l, r))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># example usage:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_concurrent_merge_sort</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">result</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> result == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    concurrent_merge_sort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>], callback)</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>


<h6 id="tags-Go-Python"><a href="#tags-Go-Python" class="headerlink" title="tags: Go Python"></a>tags: <code>Go</code> <code>Python</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
        <tag>Go</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记5 并发编程</title>
    <url>/2021/04/02/go_5/</url>
    <content><![CDATA[<h1 id="Go-学习笔记5-并发编程"><a href="#Go-学习笔记5-并发编程" class="headerlink" title="Go 学习笔记5 并发编程"></a>Go 学习笔记5 并发编程</h1><p>Go 的一个主要的特征是对多核并发的支持，特别是 CSP（Communicating Sequential Processes） 模型。Go 主要支持两类并发模型：CSP 和 共享内存。</p>
<h2 id="CSP-模型"><a href="#CSP-模型" class="headerlink" title="CSP 模型"></a>CSP 模型</h2><p>Go 的 CSP 模型主要是通过 goroutine 和 channel 两个基本模块完成的。</p>
<h3 id="Goroutine-（协程）"><a href="#Goroutine-（协程）" class="headerlink" title="Goroutine （协程）"></a>Goroutine （协程）</h3><p>goroutine 本质上属于协程，即可以多次中断和重启的函数。而当go执行进入main函数的时候，都会启动一个 goroutine，即 main goroutine。值得注意的是，一旦主协程结束，Go 会结束其他一切协程。后文中协程和goroutine取相同的意思。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// spinner 会跟 fib 函数“同时”进行</span></span><br><span class="line">	<span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">	fibN := fib(n)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\rFib(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">			time.Sleep(delay)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个简单的例子，一个普通函数在调用时加入 go 关键字后，runtime会启动一个新的协程运行该函数。Goroutine 是可以nested的，即可以在goroutine内部启动其他的协程。</p>
<h3 id="Chan"><a href="#Chan" class="headerlink" title="Chan"></a>Chan</h3><p>Goroutine 实现了任务的并发执行，而任务之间的沟通是通过 <code>channel</code> 完成的。一个 goroutine 可以通过 channel 发送信息给其他 goroutine 或者接受信息。我们可以通过<code>make(chan [T])</code> 来获得一个类型为 T 的 chan 的指针。 chan 类型支持两个通讯操作：<code>ch &lt;- x</code> 和 <code>&lt;-ch</code>，分别代表发送和接受。支持一个 close 函数来关闭Chan。Chan还有自己的承载能力（capacity）。</p>
<h4 id="无缓冲-Chan"><a href="#无缓冲-Chan" class="headerlink" title="无缓冲 Chan"></a>无缓冲 Chan</h4><p>Chan 的通讯操作都是阻塞的，无缓冲管道也叫做同步管道。因为这种管道可以保证信息的读取和发送顺序。</p>
<p>Chan 可以用来连接多个 goroutine 形成一个 pipeline。这种模式形成了有趣的编程模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">			naturals &lt;- x</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// without this, dead lock , guess why?</span></span><br><span class="line">		<span class="built_in">close</span>(naturals)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			x, ok := &lt;-naturals</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			squares &lt;- x * x</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(squares)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">		fmt.Println(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向-Chan"><a href="#单向-Chan" class="headerlink" title="单向 Chan"></a>单向 Chan</h4><p>上面提到的 Chan 是双向，我们也可以指定单向 Chan。上面的管道程序可以重写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">		out &lt;- x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		out &lt;- v * v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> counter(naturals)</span><br><span class="line">	<span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">	printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓冲-Chan"><a href="#缓冲-Chan" class="headerlink" title="缓冲 Chan"></a>缓冲 Chan</h4><p>缓冲 Chan 某种程度解除了同步性。</p>
<p>Chan 与 Go 的调度器有紧密的联系，应该谨慎使用，特别是应该确保他们有接收端和发送端。如果一个 goroutine 永远无法从 chan 获得信息，或造成 goroutine 泄漏，即使 GC 也无法回收他们。</p>
<p>选择缓冲 Chan 的 capacity 也很重要，如果缓冲值不够，会造成 deadlock。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们举个例子，我们有10个计算任务，但是每个任务的执行时间随机，我们希望并发执行，并且搜集结果。</p>
<p>首先，我们通过一个缓冲 Chan 存储计算结果并且确定何时全部任务完成。然后，我们把任务包裹进入 goroutine进行执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n := rand.Intn(<span class="number">5</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Executing task, need %d second\n&quot;</span>, n)</span><br><span class="line">	time.Sleep(time.Duration(n) * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Done.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	number <span class="keyword">int</span></span><br><span class="line">	err    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">var</span> tasksNum <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> finalRes []result</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> result, tasksNum)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">var</span> res result</span><br><span class="line">			res.number, res.err = task()</span><br><span class="line">			ch &lt;- res</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">		res := &lt;-ch</span><br><span class="line">		finalRes = <span class="built_in">append</span>(finalRes, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(finalRes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存模型"><a href="#共享内存模型" class="headerlink" title="共享内存模型"></a>共享内存模型</h2><p>讨论了半天并发，究竟什么是并发？假设我们有两个任务，A 和 B，什么叫 AB 的并发执行？其实，并发这个概念是针对事件，event，的发生顺序定义的。当我们可以确定的知道两个事件的发生顺序，那么这两个事件就是顺序的，反之就是并发的。</p>
<p>共享内存模型有一个常见且严重的问题：race condition，RC。RC是指一个内存区域（变量）被两个或以上线程/协程/进程并发访问且其中至少一个是写入操作的状态。根据定义，我们有三种方式避免RC：</p>
<ul>
<li>不要写入内存</li>
<li>不要并发访问内存，比如通过使用 Chan</li>
<li>并发访问内存，但是一次只允许一个线程访问，mutual exclusion</li>
</ul>
<p>第三种其实就是锁。Go 可以使用 buffer 为 1 的 Chan 模拟，或者直接使用 <code>sync.Mutex</code>。</p>
<p>使用锁或者 Chan 也会影响到内存的同步。现代的 CPU 一般都有内存缓存，CPU核心不会直接把内容写入内存，而是先写入缓存，然后再特定的时间Commit到内存上。这个过程commit的顺序不一定与写入的顺序的同步的。</p>
<p>常用的模式就是：在可能地方，把变量控制在同一个协程内部，对于其他变量采用锁控制访问。</p>
<p>Go 提供了 <code>-face</code> flag 来帮助检测 RC。</p>
<h2 id="Goroutine-和-线程-的异同"><a href="#Goroutine-和-线程-的异同" class="headerlink" title="Goroutine 和 线程 的异同"></a>Goroutine 和 线程 的异同</h2><p>最大的区别在于 call stack 的大小。线程根据系统不同，通常分配一个固定大小的 call stack ，通常是 2MB。而 Goroutine 的 call stack 大小是可变的，初始值只有 2KB，而通常可以增大到 1GB。</p>
<p>第二个区别在于调度。线程由系统负责调度，每个几百ms，会通过触发中断将CPU的执行权交还给 kernel，而 kernel 需要一些列的操作完成线程切换：保存用户线程状态，读取下一个线程的状态，更新调度器数据结构。而 Go 的运行时则不是完全抢占式调度，它会根据 goroutine 执行的指令进行灵活调度，比如一个 goroutine 调用 sleep，Go 会中断他执行另一个协程，而在苏醒的时候唤醒之前的进程。而且切换过程不涉及 kernel 的一系列转换。</p>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记3 程序的构成</title>
    <url>/2021/03/30/go_3/</url>
    <content><![CDATA[<h1 id="Go-学习笔记3-程序的构成"><a href="#Go-学习笔记3-程序的构成" class="headerlink" title="Go 学习笔记3 程序的构成"></a>Go 学习笔记3 程序的构成</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>Go 采用驼峰命名：<code>thisVarIsGood</code>。如果一个 package 中的函数采用大写字母开头，这个函数可以被外界调用，否则隐藏，比如 <code>fmt.Println</code>。</p>
<p>Go 的声明语句主要有四种：<code>var</code>, <code>const</code>, <code>type</code>, <code>func</code>。</p>
<p><code>var</code>，变量声明：<code>var name type = expression</code>。如果省略 expression 的部分，Go 会给变量合法的初始值。<code>:=</code> 表达式，是简化的声明。</p>
<p>指针是变量的地址，并不是每一个值都有地址，但是每一个变量都有地址。<code>new</code> 函数会返回该类型的指针。</p>
<p>Go 的编译器会根据变量的具体生命周期决定是堆分配还是栈分配，生命周期也会影响垃圾回收的效率，如果一个局部变量被外部变量引用，那么即使函数已经返回，这个局部变量也不会被回收，同时编译器也会对他进行堆分配，而不是栈分配。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Go 的类型系统相对比较简单（简陋？），主要类型包括四种：基本类型、组合类型、引用类型和接口类型。</p>
<p>基本类型主要包括：</p>
<ul>
<li>整数, int8, int16, int32, int64, 还有无符号版本，uintptr</li>
<li>浮点数, float16, float32</li>
<li>复数, complex(r, i)</li>
<li>布尔, true, false</li>
<li>字符串, an immutable sequence of bytes. 可以是任何byte，通常是可读的字符串</li>
</ul>
<h2 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h2><ul>
<li>Array</li>
<li>Slice</li>
<li>Map</li>
<li>Struct</li>
</ul>
<p>Array 是长度固定、类型固定的连续内存空间。Array 初始化方式比较丰富：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Array 也可以用指针访问（就像 C 一样，<code>[]</code> 仅仅是指针的语法糖）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Slice 是长度可变的、类型固定的连续内存空间。一个 Slice 包含三个部分：头指针、长度、长度极限。Slice 与 Array 不同，是不可比的。但是，可以测试 Slice 是否是 Nil。</p>
<p>Maps 是哈希表，可以nest。</p>
<p>Struct 类似 C 的结构体，是一个多种类型的组合类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>整体感觉 Go 的程序构成与 C 语言非常类似。看起来就像带有 GC 和 并发内置的现代版本的 C 语言。</p>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记4 抽象方法</title>
    <url>/2021/03/30/go_4/</url>
    <content><![CDATA[<h1 id="Go-学习笔记4-抽象模式"><a href="#Go-学习笔记4-抽象模式" class="headerlink" title="Go 学习笔记4 抽象模式"></a>Go 学习笔记4 抽象模式</h1><p>Go 的抽象方法主要通过函数、方法和接口三种方式。</p>
<h2 id="函数，Function"><a href="#函数，Function" class="headerlink" title="函数，Function"></a>函数，Function</h2><p>Go 中函数是一等公民，可以被传递、返回，具有类型，是组织程序的基本元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func name(params-list) (returns-list) &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>returns-list 是可选的，但是如果写明，则函数内部构造局部变量，并且会被返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">funcsub(x,yint)(zint) &#123;z=x-y;<span class="keyword">return</span>&#125;  <span class="comment">// 注意这里需要 return 关键字，但是不需要 z</span></span><br></pre></td></tr></table></figure>

<p>Go 的函数参数没有默认值，参数的名字也不重要。（ hmm 会不会很不方便？）函数全部是 call by value，即复制传入参数。</p>
<p>Go 递归函数的深度可以非常深，call stack 可以达到几个G大小。</p>
<p>Go 的函数支持多值返回。（很方便，而且返回值和状态是常用模式）</p>
<p>Go 的函数没有异常捕捉机制，而是显式采用 error 处理，如果真的出现异常，程序会直接 panic 终止，以避免进一步的问题。（ 有意思，不知道工程特性如何。好处是可以尽早的发现bug地点 ）</p>
<p>Go 支持参数可变函数。</p>
<p><code>defer</code> 很特别，可以延迟调用函数，有点类似 Python 的上下文管理。但是可能有更多的使用场景。</p>
<p><code>panic</code> 以后，defer 的函数仍然会执行！</p>
<p>panic 之后一般程序就会放弃执行，但是可以通过 recover 恢复执行。</p>
<h2 id="组合和封装"><a href="#组合和封装" class="headerlink" title="组合和封装"></a>组合和封装</h2><h3 id="绑定类型和函数"><a href="#绑定类型和函数" class="headerlink" title="绑定类型和函数"></a>绑定类型和函数</h3><p>Go 的面向对象功能主要是通过 Method 实现封装和组合。我们可以为结构体类型指定相应的方法。所以在 Go 中并不强制绑定类型和方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// &quot;5&quot;, function call</span></span><br><span class="line">fmt.Println(p.Distance(q))  <span class="comment">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>

<p>按照如下语法定义方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Path []Point</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里直接传入Path的拷贝，（path Path）叫做 receiver argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过传入指针避免拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(path *Path)</span> <span class="title">Distance</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该注意的是，如果一个对象的方法是指针传入，那么按照传统，所有的其他方法都应该是指针传入，即使某些方法并不需要指针。</p>
<h3 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h3><p>组合类型主要是通过重复使用struct。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可一个 unnamed strcut 使用 method</span></span><br><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125; &#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loopup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>Go 通过首字母大小写区分是否 export 该变量或者函数。大写首字母会被export，小写则被封装。</p>
<h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口, Interface"></a>接口, Interface</h2><p>Go 的接口与其他语言类型，但是是隐式满足的，即一个类型不需要实现全部接口。（这是一个好主意么？）</p>
<p>接口类型与之前提到的concrete类型不用，一个实类型会明确数据结构以及该类型支持的具体函数（方法）。换句话说，当我们看到一个实类型，我们明确的知道这个类型可以做什么。而 Interface 类型属于抽象类型，他们仅仅确定该类型应该支持的操作函数的签名，但是不知道他具体会做什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们还可以组合 interface</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让函数接受任意类型，我们可以传入 <code>interface&#123;&#125;</code> 类型。编译器会负责检查结构是否满足。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>

<p>Go 的 interface 可以有两种不同的使用范式：subtype polymorphism 和 ad hoc polymorphism。</p>
<p>后续专门讨论。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记2 语法、语义</title>
    <url>/2021/03/28/go_2/</url>
    <content><![CDATA[<h1 id="Go-学习笔记2：语法和语义"><a href="#Go-学习笔记2：语法和语义" class="headerlink" title="Go 学习笔记2：语法和语义"></a>Go 学习笔记2：语法和语义</h1><p>这个部分主要总结 Go 涉及的基本语法和语义，即之前提到的前两个角度。</p>
<h2 id="整体印象"><a href="#整体印象" class="headerlink" title="整体印象"></a>整体印象</h2><ul>
<li>语法简单</li>
<li>过程式语言 + 函数一等公民</li>
<li>通过结构体 + 接口实现抽象</li>
<li>协程并发</li>
<li>GC，value-oriented language</li>
<li>FFI支持很好</li>
</ul>
<p>Go 的语法比较简单，涉及到的关键字大约只有27个，对比 Python 大概有33个，而 Rust 则超过40个，Java 保留了约52个关键字，而 C++ 则保留了超过90个关键字。</p>
<p>Go 语法比较简洁，看起来像是加了大括号的 Python，比如 <code>for</code> 语句；继承了 C 的很多表达方式，比如指针、结构体等（但是去掉了分号，简直不能太舒服）。</p>
<p>从编程范式的角度看，属于过程式语言，但是支持高阶函数，支持闭包、多值函数等等，大大增加了语言的灵活性。没有复杂的“面向对象”支持，比如继承，语言的抽象是通过结构体和接口实现的。</p>
<p>Go的运行时有两个主要的任务，一个是GC，另一个就是携程调度。通常 Go 可以支持超过10万协程的调度工作。</p>
<p>协程原生支持，即 <code>goroutine</code>。协程的通讯是通过 <code>channel</code> 完成的，由于 channel 是一个阻塞的、有类型的数据管道，大大提高了通讯的可靠性（不过这个部分将来可能需要花更多精力去了解）。</p>
<p>最后就是 Go 是 GC 语言，由于 Go 语言本身运行时比较简单，所以GC也应该不像Java那么复杂，性能方面已经将延迟降低到1ms以下。（这个部分也可以详细了解一下）。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键词分成四类：声明、数据结构、控制流、函数控制和构造函数。</p>
<p><strong>声明</strong> 6 个</p>
<p><code>const</code>, <code>var</code>, <code>func</code>, <code>type</code>, <code>import</code>, <code>package</code></p>
<p><strong>数据结构</strong> 4 个</p>
<p><code>chan</code>, <code>interface</code>, <code>map</code>, <code>struct</code></p>
<p><strong>控制流</strong> 13 个</p>
<p><code>break</code>, <code>case</code>, <code>continue</code>, <code>default</code>, <code>if</code>, <code>else</code>, <code>fallthrough</code>, <code>for</code>, <code>goto</code>, <code>range</code>, <code>return</code>, <code>select</code>, <code>switch</code></p>
<p><strong>函数控制</strong> 2 个</p>
<p><code>defer</code>, <code>go</code></p>
<p><strong>构造函数</strong> 2 个</p>
<p><code>make</code>, <code>new</code></p>
<h2 id="语法、语义"><a href="#语法、语义" class="headerlink" title="语法、语义"></a>语法、语义</h2><p>一个简单的 Go 程序看起来如下，乍一看像 C + Python（带类型注释）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Create a huge number by shifting a 1 bit left 100 places.</span></span><br><span class="line">	<span class="comment">// In other words, the binary number that is 1 followed by 100 zeroes.</span></span><br><span class="line">	Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">	<span class="comment">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.</span></span><br><span class="line">	Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(needInt(Small))</span><br><span class="line">	fmt.Println(needFloat(Small))</span><br><span class="line">	fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct 和 interface</li>
<li>数据结构</li>
<li>高阶函数</li>
<li>控制语句</li>
<li>指针</li>
<li>goroutines</li>
<li>error处理</li>
</ul>
<h3 id="struct-和-interface"><a href="#struct-和-interface" class="headerlink" title="struct 和 interface"></a>struct 和 interface</h3><p>结构体也基本上维持了 C 的语法和语义，只不过所有的类型都变成了后缀，而不是前缀，比较现代，Python 的类型注释也是后缀的。访问方式也是通过 <code>.</code> 运算符。还有一个不一样的地方是，<code>.</code> 运算符不仅可以用在结构体本身，也可以直接用在结构体的指针上。</p>
<p>Go 不支持“面向对象”，是通过接口实现抽象的。Go 的接口实现是隐式的，不是显式的。</p>
<p>关于这个部分需要专门的展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">1e9</span>  <span class="comment">// 注意这里， p 是 Vertex 的指针</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>主要的数据结构有：</p>
<ul>
<li>Array，<code>[n]T</code>，固定长度</li>
<li>Slice，<code>[]T</code>，即长度可变的 Array</li>
<li>Map, <code>map[T1]T2</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">    <span class="comment">// array</span></span><br><span class="line">	primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(primes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(q)</span><br><span class="line">    </span><br><span class="line">    s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		i <span class="keyword">int</span></span><br><span class="line">		b <span class="keyword">bool</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// make 函数可以构造数据结构的本身</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Map</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">	m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个部分需要专门的展开。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>Go 里面函数是一等公民，可以作为值来传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(compute(hypot))</span><br><span class="line">	fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个部分需要专门的展开。</p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>循环的语法其实跟Python很像。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针这块 Go 基本继承了 C 的语法和语义，采用 <code>*</code> 和 <code>&amp;</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">	p := &amp;i         <span class="comment">// point to i</span></span><br><span class="line">	fmt.Println(*p) <span class="comment">// read i through the pointer</span></span><br><span class="line">	*p = <span class="number">21</span>         <span class="comment">// set i through the pointer</span></span><br><span class="line">	fmt.Println(i)  <span class="comment">// see the new value of i</span></span><br><span class="line"></span><br><span class="line">	p = &amp;j         <span class="comment">// point to j</span></span><br><span class="line">	*p = *p / <span class="number">37</span>   <span class="comment">// divide j through the pointer</span></span><br><span class="line">	fmt.Println(j) <span class="comment">// see the new value of j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="goroutines"><a href="#goroutines" class="headerlink" title="goroutines"></a>goroutines</h3><p>协程是 Go 实现并发的手段，需要配合 channel 进行通讯。这里需要以后展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Error处理"><a href="#Error处理" class="headerlink" title="Error处理"></a>Error处理</h3><p>Go 的异常处理比较独特，需要进一步展开。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	When time.Time</span><br><span class="line">	What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">		e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">		time.Now(),</span><br><span class="line">		<span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇快速的浏览了一些 Go 的基本语法和语义。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://medium.com/wesionary-team/know-about-25-keywords-in-go-eca109855d4d">https://medium.com/wesionary-team/know-about-25-keywords-in-go-eca109855d4d</a></li>
<li><a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a></li>
<li><a href="https://tour.golang.org/list">https://tour.golang.org/list</a></li>
</ul>
<h6 id="tags-Go-Go学习"><a href="#tags-Go-Go学习" class="headerlink" title="tags: Go Go学习"></a>tags: <code>Go</code> <code>Go学习</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（8）PyObject</title>
    <url>/2021/03/26/python_8/</url>
    <content><![CDATA[<h1 id="重新认识-Python（8）PyObject"><a href="#重新认识-Python（8）PyObject" class="headerlink" title="重新认识 Python（8）PyObject"></a>重新认识 Python（8）PyObject</h1><blockquote>
<p>开发环境设置和入门请看：<a href="https://zhuanlan.zhihu.com/p/358690339">https://zhuanlan.zhihu.com/p/358690339</a></p>
</blockquote>
<p>本片主要介绍 Python 对象的内存构成，以及如何组织对象的方法。更多内容可以看： <a href="https://wangzhe3224.github.io/">https://wangzhe3224.github.io/</a></p>
<h2 id="PyObject-和-PyTypeObject"><a href="#PyObject-和-PyTypeObject" class="headerlink" title="PyObject 和 PyTypeObject"></a><code>PyObject</code> 和 <code>PyTypeObject</code></h2><p><code>PyObject</code> 可说是 CPython 最核心的数据结构了，在 Python 的世界里，几乎任何元素都是 PyObject 的指针（注意这里是指针，不是实际内存空间）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>

<p>所有分配在堆内存中的python对象都具有上述结构：</p>
<ul>
<li><code>_PyObject_HEAD_EXTRA</code> 包含两个指向前后对象的指针，这样堆内存中的对象就会连接成为链表，以便进行内存管理。</li>
<li><code>ob_refcnt</code> 是对象的引用计数器，是GC的一部分，refcnt归零，该对象内存被回收。<code>Py_INCREF</code> 和 <code>Py_DECREF</code> 两个宏操作。</li>
<li><code>*ob_type</code> 是对象的类型指针，决定了这个对象是什么类型，比如 int 或者 其他自定义类型。</li>
</ul>
<p>实际上，<strong>所有</strong> Python 在内存中的头部都是一个 <code>PyObject</code> 结构，如下图所示。</p>
<p><img src="https://i.imgur.com/qBt3pvW.png" alt="对象的内存分布"></p>
<p>让我们继续看 <code>PyTypeObject</code> 这个结构体，内部定义了类型支持的操作的<em>指针</em>。举个例子，<code>*tp_as_number</code> 是一个指向 <code>PyNumberMethod</code> 结构体的指针。这个结构体包含了一系列函数指针，这些函数就是数字类型支持的计算，比如 <code>nb_add</code>, <code>nb_and</code> 等等。这里也包含了指向魔法函数的指针，比如 <code>tp_new</code> 指向的就是 <code>__new__</code> 的函数代码。这个类型结构体囊括了python类型可能支持的所有功能，其中有些其他类型是强制必须实现的，比如 <code>tp_new</code>，有些则是可选的，比如 <code>tp_init</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/cpython/object.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    Py_ssize_t tp_vectorcall_offset;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line">    </span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//此处省略</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    binaryfunc nb_add;</span><br><span class="line">    binaryfunc nb_subtract;</span><br><span class="line">    binaryfunc nb_multiply;</span><br><span class="line">    binaryfunc nb_remainder;</span><br><span class="line">    binaryfunc nb_divmod;</span><br><span class="line">    ternaryfunc nb_power;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">    <span class="comment">//此处省略</span></span><br><span class="line">    &#125; PyNumberMethods;</span><br></pre></td></tr></table></figure>

<p>你可能已经发现，<code>PyTypeObject</code> 其实就是定义一个接口，所有对象必须满足这个接口。其中有几个值得注意的子接口：</p>
<ul>
<li><code>PyNumberMethods</code>，定义了数字相关的结构，比如 +,-,&gt;，等等。换句话说，一个类型要向支持这些运算符，就必须实现这个接口</li>
<li><code>PySequenceMethods</code>，定义了序列相关的函数，比如 len, in 等等</li>
<li><code>PyMappingMethods</code>，定义了一些字典类的函数</li>
</ul>
<p>总结一下 Python 内存中的对都拥有类似的头部和组织结构：</p>
<p><img src="https://i.imgur.com/D3euvFc.png" alt=""></p>
<h2 id="tuple-类"><a href="#tuple-类" class="headerlink" title="tuple 类"></a><code>tuple</code> 类</h2><p>我们来看一个具体的例子，<code>tuple</code>。这里先介绍语言的内建类型，对于自定义类型（自己写的类）的说明，放在后面说。</p>
<p><code>PyTuple_Type</code> 就是 <code>PyTypeObject</code> 的一个实例：</p>
<p>首先，第一个 field 是 tuple 的基类：<code>PyType_Type</code>，其实在 python 解释器中就是 <code>type</code> 。第二个 field 是这个类打印出来的名字，这里就是 tuple，也就是解释器中 <code>type(a_tuple)</code> 的返回值。接下来就是tuple对象的大小和其内部元素的大小。注意到其中很多 0，这就表示这个类型没有实现哪些接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyTuple_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;tuple&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyTupleObject) - <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    <span class="keyword">sizeof</span>(PyObject *),</span><br><span class="line">    (destructor)tupledealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    (reprfunc)tuplerepr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;tuple_as_sequence,                         <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;tuple_as_mapping,                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)tuplehash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    tuple_new__doc__,                           <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)tupletraverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    tuplerichcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    tuple_iter,                                 <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    tuple_methods,                              <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    tuple_new,                                  <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">    .tp_vectorcall = tuple_vectorcall,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="实例化-type"><a href="#实例化-type" class="headerlink" title="实例化 type"></a>实例化 type</h2><p>接下来我们看当我们在python里创建一个 tuple 的时候发生了什么？构造函数会被调用，比如 <code>tuple_new</code>。也就是 pytype 里面的 <code>tp_new</code> 指针指向的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/tupleobject.c</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">tuple_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *return_value = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *iterable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((type == &amp;PyTuple_Type) &amp;&amp;</span><br><span class="line">        !_PyArg_NoKeywords(<span class="string">&quot;tuple&quot;</span>, kwargs)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_PyArg_CheckPositional(<span class="string">&quot;tuple&quot;</span>, PyTuple_GET_SIZE(args), <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyTuple_GET_SIZE(args) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> skip_optional;</span><br><span class="line">    &#125;</span><br><span class="line">    iterable = PyTuple_GET_ITEM(args, <span class="number">0</span>);</span><br><span class="line">skip_optional:</span><br><span class="line">    return_value = tuple_new_impl(type, iterable);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造函数会返回一个 <code>PyTupleObject</code>，正是这个结构包含了一个指向 tuple 内部真正元素的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* ob_item contains space for &#x27;ob_size&#x27; elements.</span></span><br><span class="line"><span class="comment">       Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">       the tuple is not yet visible outside the function that builds it. */</span></span><br><span class="line">    PyObject *ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure>

<p><strong>这里需要注意</strong>：<code>PyTupleObject</code> 是实际被分配在堆内存的对象，我们可以创建很多对象，但是他们对应的函数都被包含在 <code>PyTuple_Type</code> 中，而这个对象是唯一的，所有 tuple 对象都会指向他。</p>
<p><img src="https://i.imgur.com/LxvTRK4.png" alt=""></p>
<h2 id="实例化自定义类型"><a href="#实例化自定义类型" class="headerlink" title="实例化自定义类型"></a>实例化自定义类型</h2><p>那么当我们实例化自定义类型的时候，发生了什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure>

<p>这里 A 是我们的自定义类，它默认继承了 <code>type</code>。当我们写 <code>()</code> 这个语法的时候，实际上会触发 <code>tp_call</code> 指向的函数，即 type 的 call 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *obj;</span><br><span class="line">    PyThreadState *tstate = _PyThreadState_GET();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line">    obj = type-&gt;tp_new(type, args, kwds);  <span class="comment">// 注意这里调用了 new 方法</span></span><br><span class="line">    obj = _Py_CheckFunctionResult(tstate, (PyObject*)type, obj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the returned object is not an instance of type,</span></span><br><span class="line"><span class="comment">       it won&#x27;t be initialized. */</span></span><br><span class="line">    <span class="keyword">if</span> (!PyType_IsSubtype(Py_TYPE(obj), type))</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    type = Py_TYPE(obj);</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;tp_init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = type-&gt;tp_init(obj, args, kwds);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert(_PyErr_Occurred(tstate));</span><br><span class="line">            Py_DECREF(obj);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(!_PyErr_Occurred(tstate));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 学习笔记 1</title>
    <url>/2021/03/25/go_study_1/</url>
    <content><![CDATA[<h1 id="Go-学习笔记-1"><a href="#Go-学习笔记-1" class="headerlink" title="Go 学习笔记 1"></a>Go 学习笔记 1</h1><p>我是一个有5年 Python 开发经验的混迹在量化交易行业的后端程序员，这个系列开个坑学习 Golang。为什么选择 Go？</p>
<blockquote>
<p>“A language that doesn’t affect the way you think about programming is not worth knowing.” —Alan J. Perlis (1922-1990)</p>
</blockquote>
<p>图灵奖的第一任得主，图灵说如是：一个语言如果不能影响你对编程的看法，那么这个语言不值得学习。所以这些年接触了奇奇怪怪的语言：Clojure，Ocaml，Erlang等等。Go 我刚开始看到的时候觉得另类：看起来是 C 系的，不赶时髦，支持的功能异常少。但是有理由相信这是一个工程导向的，年轻的语言，没有沉重的历史包袱，出生在多核并发时代。</p>
<p>我觉得他会改变我对并发和现代软件工程的看法。</p>
<p>这是第一篇，主要记录一下我学习语言的几个角度：</p>
<ul>
<li>语法</li>
<li>语义</li>
<li>该语言的最佳实践</li>
<li>标准库</li>
<li>工具链</li>
<li>语言实现细节</li>
</ul>
<p><strong>语法</strong>，这是最基础的层面，即写出合法的表达式。这其实也是不同计算机语言中最千差万别的部分，即 Lexer 部分。想想看 Clojure 的满屏括号对比 C 的满屏分号可见一斑。</p>
<p><strong>语义</strong>，是下一个层次即符合语法的表达式的意义。通常对于静态类型语言，可以分成动态语义和静态语义。动态语义即程序在运行时的行为；而静态语义通常就是编译阶段的类型检查。</p>
<p><strong>最佳实践</strong>，在熟悉上面两个的基础上，还应该学习该门语言的业界最佳实践。即给出一个逻辑，在该语言下的通常写法。</p>
<p><strong>标准库</strong>，避免重复造轮子，同时也熟悉他们的工程性能。</p>
<p><strong>工具链</strong>，包括编译器、编辑器、测试环境、部署环境等等。</p>
<p><strong>语言实现细节</strong>，包括编译器、运行时、垃圾回收机制等等。</p>
<h6 id="tags-Go"><a href="#tags-Go" class="headerlink" title="tags: Go"></a>tags: <code>Go</code></h6>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Python 加速飞</title>
    <url>/2021/03/21/python_spped/</url>
    <content><![CDATA[<h1 id="让-Python-加速飞"><a href="#让-Python-加速飞" class="headerlink" title="让 Python 加速飞"></a>让 Python 加速飞</h1><p>Python 是一个开发很快的语言，相应的他不是一个运行速度很快的语言。原因呢，主要是动态类型设计，导致类型需要在运行时检查。在一般的应用中，特别是 IO 密集应用里，性能往往构不成问题。</p>
<p>对于 CPU 密集问题，Python 的科学计算生态其实非常好，得益于 CPython 的 C API，numpy, scipy 已经把科学计算性能提升了一个档次，深度学习基本也是python API的天下了。这些库已经把性能瓶颈从 Python 中剥离了。</p>
<p>其实 Python 最致命的性能问题在于循环，一旦代码中出现了大量循环计算，又没有现成的 numpy 函数可以用，性能往往就会成问题。今天我们介绍两个主要的方法，让 Python 的循环飞起来。这两个工具是：<code>Cython</code> 和 <code>Numba</code>。</p>
<h2 id="Cython"><a href="#Cython" class="headerlink" title="Cython"></a>Cython</h2><p><a href="https://cython.org/">Cython</a> 包含两个部分：语言和编译器。Cython 从概念上说是一门新的语言，但是他是 Python 语言的超集，即合法的 Python 代码（大部分）都是合法的 Cython 代码。第二个部分是 <code>cython</code> 编译器，这个编译器会把 Cython 代码编译成相应的 C 代码，这些 C 代码会调用 CPython 的 C API。编译后会直接生成 Python 的 extension，并且可以直接被其他纯 Python 代码引入和调用。</p>
<blockquote>
<p>Cython is a programming language that makes writing C extensions for the Python language as easy as Python itself.</p>
</blockquote>
<p>原理上，Cython 是通过编译出来的 C 目标文件直接编程 Python 拓展，被Python调用的方式来提升速度。因为编译出来的拓展函数，与 C 语言写的函数性能一致。换句话说， Cython 产生的代码会具备 c 的性能，同时可以与 Python 的 runtime 通过 C API 互动实现兼容。</p>
<h3 id="安装-Cython"><a href="#安装-Cython" class="headerlink" title="安装 Cython"></a>安装 Cython</h3><p><code>pip install cython</code></p>
<p>建议安装 0.29 版本。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>举个求质数的函数作为例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes_python</span>(<span class="params">nb_primes</span>):</span></span><br><span class="line">    p = []</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; nb_primes:</span><br><span class="line">        <span class="comment"># Is n prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If no break occurred in the loop</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>我们存储文件为：<code>python_prime.py</code>。这个函数的主体是一个循环。</p>
<p>我们说过 Cython 是 Python 的超集，cython 编译器可以直接编译上述函数。我们拷贝文件存储成：<code>cython_python_prime.py</code>，一会儿我们编译这个文件。</p>
<p>我们也可以通过加入类型声明，进一步提升性能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span>(<span class="params"><span class="built_in">int</span> nb_primes</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> n, i, len_p</span><br><span class="line">    cdef <span class="built_in">int</span> p[<span class="number">1000</span>]</span><br><span class="line">    <span class="keyword">if</span> nb_primes &gt; <span class="number">1000</span>:</span><br><span class="line">        nb_primes = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    len_p = <span class="number">0</span></span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len_p &lt; nb_primes:</span><br><span class="line">        <span class="comment"># is n a prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p[: len_p]:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p[len_p] = n </span><br><span class="line">            len_p += <span class="number">1</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    result = [prime <span class="keyword">for</span> prime <span class="keyword">in</span> p[:len_p]]</span><br><span class="line">    <span class="keyword">return</span> resul</span><br></pre></td></tr></table></figure>

<p>我们把上述文件存储为：<code>cython_primer.pyx</code>。这里 pyx 就是 cython 的拓展名。这时候，我们根目录目前有三个文件：</p>
<ul>
<li><code>python_prime.py</code></li>
<li><code>cython_python_prime.py</code></li>
<li><code>cython_primer.pyx</code></li>
</ul>
<p>为了编译 cpython 目标文件，我们还需要创建一个 <code>setup.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;Hello world app&#x27;</span>,</span><br><span class="line">    ext_modules=cythonize([<span class="string">&quot;cython_primer.pyx&quot;</span>, <span class="string">&quot;cython_python_prime.py&quot;</span>],</span><br><span class="line">                          annotate=<span class="literal">True</span>),</span><br><span class="line">    zip_safe=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>好，准备就绪。编译：<code>python setup.py build_ext --inplace</code>。编译完成后，根目录会生成一个 <code>.so</code> 文件，就是我们 Python 拓展的目标文件。</p>
<p>我们来测试一下三个函数的性能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; python -m timeit -s &#39;from python_prime import primes&#39; &#39;primes(1000)&#39;</span><br><span class="line">10 loops, best of 5: 22.9 msec per loop</span><br><span class="line">&gt; python -m timeit -s &#39;from cython_python_prime import primes&#39; &#39;primes(1000)&#39;</span><br><span class="line">20 loops, best of 5: 11 msec per loop</span><br><span class="line">&gt; python -m timeit -s &#39;from cython_primer import primes&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">200 loops, best of 5: 1.36 msec per loop</span><br></pre></td></tr></table></figure>

<p>可以看出，即使直接编译纯 Python 文件，性能也提升近2倍，而使用 Cython 语法后，性能提升约20倍。而且，这个函数比较简单，大部分代码的都在与 CPython 运行时互动，如果是复杂的函数，性能提升更加明显。</p>
<p>编译器还会生成一个函数与Cpython互动的 html 文件用来检查：</p>
<p><img src="https://i.imgur.com/n1GILGd.png" alt=""></p>
<h2 id="Numba"><a href="#Numba" class="headerlink" title="Numba"></a>Numba</h2><p>Numba 走的是 JIT 的路线，不需要 Cython 哪样提前编译。使用起来非常简单！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes_python</span>(<span class="params">nb_primes</span>):</span></span><br><span class="line">    p = []</span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; nb_primes:</span><br><span class="line">        <span class="comment"># Is n prime?</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If no break occurred in the loop</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<p>只需要加一个 <code>@jit</code> 的装饰器，性能就达到了 Cython 的水平。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">❯ python -m timeit -s &#39;from numba_primer import primes_python&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">1 loop, best of 5: 1.99 msec per loop</span><br><span class="line">❯ python -m timeit -s &#39;from numba_primer import primes_python&#39; &#39;primes_python(1000)&#39;</span><br><span class="line">200 loops, best of 5: 1.45 msec per loop</span><br></pre></td></tr></table></figure>

<p>不过可以看到，由于是 JIT，函数需要一些预热，第一次测试性能不如后面的好。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Cython</tag>
        <tag>Numba</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（7）CPython初探</title>
    <url>/2021/03/20/python_6/</url>
    <content><![CDATA[<h1 id="重新认识-Python（7）CPython初探"><a href="#重新认识-Python（7）CPython初探" class="headerlink" title="重新认识 Python（7）CPython初探"></a>重新认识 Python（7）CPython初探</h1><p>CPython 是 Python 社区的标准，其他版本的 Python，比如 pypy，都会遵行 CPython 的标准API实现。想要更深入的认识 Python，就需要了解 CPython 实现。这一期，我就带大家认识一下 CPython 源代码，为日后改造 Python 做准备。首先，展示如何本地编译最新的 CPython代码。然后，展示如何 debug 编译好的解释器。最后我们会利用 CPython 实现简单的函数调用。</p>
<p>本文会为你揭开 CPython 的面纱，带你进入 C + Python 的世界。文章的最后，你也会对 Python 中最重要的概念：一切皆对象（object）有更深刻的认识；你还会发现一点点线索，为什么Python用起来比其他语言，比如 C 慢很多。</p>
<p>请打开编辑器和命令行，我们开始。（本文主要使用MacOS，Windows 不一定可以直接实现）。</p>
<h2 id="当我们再说-Python，我们在说什么？"><a href="#当我们再说-Python，我们在说什么？" class="headerlink" title="当我们再说 Python，我们在说什么？"></a>当我们再说 Python，我们在说什么？</h2><p>在我还是小小白的时候，我经常会想：当我们说 Python 的时候，我们到底在说什么？后来当我学了编译原理，我变成了一个小白，我知道了，当我们说 Python 的时候，我们其实再说两个东西：语言的语法和语言的运行时。</p>
<p>语法主要规定了如何表达程序，比如我们写 <code>a = 1</code> 是合法的，且有语义；而当我写 <code>for i in 1:</code> 的时候，是不合法的，语义也就无法确定。运行时（run time）是指运行我们写好的代码的另一个“程序”。也就是当我们输入 <code>python test.py</code> 的时候，这里面的 python 就是我们的“程序”，这个运行时负责执行我们的代码。</p>
<p>而这个 runtime，可以有很多不同的实现，比如 CPython 实现就是一个用 C 语言实现运行时，而 pypy 则是用 RPython 实现的运行时等等。这个 runtime 可以理解我们写的 python 代码，并且把它编译成 python 的字节码，然后执行。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>上面的代码在屏幕打印1。如何实现的呢？其实是我们的运行时“程序” <code>python</code> 实现的。首先，python 会把上面的源代码翻译成字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import dis</span><br><span class="line"></span><br><span class="line">dis.dis(&quot;a&#x3D;1;print(1)&quot;)  # 这一行会把源代码编译成字节码，就是 python 认识的操作。</span><br><span class="line"></span><br><span class="line">## 结果</span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              2 STORE_NAME               0 (a)</span><br><span class="line">              4 LOAD_NAME                1 (print)</span><br><span class="line">              6 LOAD_NAME                0 (a)</span><br><span class="line">              8 CALL_FUNCTION            1</span><br><span class="line">             10 POP_TOP</span><br><span class="line">             12 LOAD_CONST               1 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>上面的字节码，背后就是 python 程序提供的一些基本操作。比如 <code>LOAD_CONST</code>，加载常数 1 进入内存。你可以在<a href="https://github.com/python/cpython/blob/master/Include/opcode.h">这里</a>找到所有的字节码。</p>
<p>一句话总结，<code>CPython</code> 就是一个可以执行你写的python代码的另一个由 C 语言写的程序。</p>
<h2 id="编译-CPython"><a href="#编译-CPython" class="headerlink" title="编译 CPython"></a>编译 CPython</h2><p>首先，我们要去 github fork CPython 的代码到自己的账户下：<a href="https://github.com/python/cpython">https://github.com/python/cpython</a> 。然后我们作如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br><span class="line">brew install git</span><br><span class="line">brew install openssl</span><br><span class="line">brew install readline</span><br><span class="line"></span><br><span class="line"><span class="comment"># mac 需要 xcode 才能编译</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:&#123;你的账户。。&#125;/cpython.git</span><br><span class="line"><span class="built_in">cd</span> cpython</span><br><span class="line">git remote add upstream git@github.com:python/cpython.git</span><br><span class="line"><span class="comment"># 把原始仓库加入</span></span><br><span class="line"><span class="comment"># 编译 python，加入debug选项，方便我们后面进一步探索。</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="string">&quot;<span class="subst">$(brew --prefix openssl)</span>/lib/pkgconfig&quot;</span> \</span><br><span class="line">CPPFLAGS=<span class="string">&quot;-I<span class="subst">$(brew --prefix readline)</span>/include&quot;</span> \</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L<span class="subst">$(brew --prefix readline)</span>/lib&quot;</span> \</span><br><span class="line">./configure --with-pydebug \</span><br><span class="line">&amp;&amp; make</span><br></pre></td></tr></table></figure>

<p>很快编译就会成功，此时你的当前目录下会出现一个 <code>python.exe</code> 的可执行文件，这就是我们编译好的 Python！</p>
<p>输入 <code>./python.exe</code> 就会看见熟悉的python解释器了提示符了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 3.10.0a6+ (heads&#x2F;master:f00e82f8b8, Mar 13 2021, 23:26:48) [Clang 11.0.3 (clang-1103.0.32.59)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Debug-CPython"><a href="#Debug-CPython" class="headerlink" title="Debug CPython"></a>Debug CPython</h2><p>编译完成后，我们就可以来看看 CPython 内部的“秘密”了。这里我用的 <code>lldb</code> 因为 Mac 的安装 gdb 比较复杂。基本步骤是一样的。</p>
<p>输入 <code>lldb python.ext</code>。接下来，我们需要在 <code>Programs/python.c</code> 的 main 函数处设置一个断点。这个函数就整个解释器的入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b main</span><br><span class="line">Breakpoint 1: where &#x3D; python.exe&#96;main + 22 at python.c:15:25, address &#x3D; 0x0000000100000856</span><br><span class="line">(lldb) r</span><br><span class="line">Process 43373 launched: &#39;&#x2F;Users&#x2F;zhewang&#x2F;Projects&#x2F;cpython&#x2F;python.exe&#39; (x86_64)</span><br><span class="line">Process 43373 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">    frame #0: 0x0000000100000856 python.exe&#96;main(argc&#x3D;1, argv&#x3D;0x00007ffeefbff330) at python.c:15:25</span><br><span class="line">   12  	int</span><br><span class="line">   13  	main(int argc, char **argv)</span><br><span class="line">   14  	&#123;</span><br><span class="line">-&gt; 15  	    return Py_BytesMain(argc, argv);</span><br><span class="line">   16  	&#125;</span><br><span class="line">   17  	#endif</span><br></pre></td></tr></table></figure>

<p>好，现在我们就停留在了 CPython 世界的入口了！</p>
<h2 id="简单的加法！"><a href="#简单的加法！" class="headerlink" title="简单的加法！"></a>简单的加法！</h2><p>现在我们在 debug 环境下，用 CPython 来实现一个整数的加法。</p>
<p>首先，我们来看一下 int 这个 object。我把部分 int object 的代码放在下面。可以看出，python 里面连最基本的 int 对象都别有洞天！要知道python运行的时候，每一个整数在内存里其实都包含了下面结构体所有的变量。具体文件可以在 <code>Objects/longobject.c</code> 找到。</p>
<p><code>PyVarObject_HEAD_INIT</code> 定义了 int 的类型，int 的类型其实叫 <code>PyLong_Type</code>，他的基类是一个叫 <code>PyType_Type</code> 的类型。比如在python中，<code>type(1)</code> 会返回 <code>int</code>，即下面的 tp_name，而 <code>type(type(1))</code> 则返回 <code>type</code>，即<code>PyType_Type</code>。当然 python 的整数做的这么复杂主要是为了保持所有对象类型协调统一，即无论是复杂的类型还是简单的类型，他们的内存结构都是样的！（ 这里插一嘴，python的int是long，也就是说可以是任意大的整数，不会溢出！）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;int&quot;</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_vectorcall_offset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_async */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS |</span><br><span class="line">        _Py_TPFLAGS_MATCH_SELF,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们现在在debug 环境里面可以尝试创造一个 int 对象！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) b pymain_import_readline</span><br><span class="line">Breakpoint 1: where &#x3D; python.exe&#96;pymain_import_readline + 12 at main.c:205:9, address &#x3D; 0x000000010032ad1c</span><br><span class="line">(lldb) r</span><br><span class="line">Process 54697 launched: &#39;&#x2F;Users&#x2F;zhewang&#x2F;Projects&#x2F;cpython&#x2F;python.exe&#39; (x86_64)</span><br><span class="line">Python 3.10.0a6+ (heads&#x2F;master:f00e82f8b8, Mar 20 2021, 21:50:27) [Clang 11.0.3 (clang-1103.0.32.59)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Process 54697 stopped</span><br><span class="line">* thread #1, queue &#x3D; &#39;com.apple.main-thread&#39;, stop reason &#x3D; breakpoint 1.1</span><br><span class="line">    frame #0: 0x000000010032ad1c python.exe&#96;pymain_import_readline(config&#x3D;0x00000001007503d0) at main.c:205:9</span><br><span class="line">   202 	static void</span><br><span class="line">   203 	pymain_import_readline(const PyConfig *config)</span><br><span class="line">   204 	&#123;</span><br><span class="line">-&gt; 205 	    if (config-&gt;isolated) &#123;</span><br><span class="line">   206 	        return;</span><br><span class="line">   207 	    &#125;</span><br><span class="line">   208 	    if (!config-&gt;inspect &amp;&amp; config_run_code(config))</span><br></pre></td></tr></table></figure>

<p>我们停在这里，Python已经完成一些初始化设置，但是还没有进入 &gt;&gt;&gt; 交互环境。这时，我们使用 CPython 的底层函数创建两个 int 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) call PyLong_FromLong(10)</span><br><span class="line">(PyObject *) $0 &#x3D; 0x00000001007a8500</span><br><span class="line">(lldb) call PyLong_FromLong(20)</span><br><span class="line">(PyObject *) $1 &#x3D; 0x00000001007a8780</span><br></pre></td></tr></table></figure>

<p>可以看到，返回的是一个指向 <code>PyObject</code> 的指针。其实这个就是一切皆对象中的对象啦，就是这个 <code>PyObject</code>，Python中所有类型实例化后都是这个这个 PyObject。来看一下这两对象的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *$0</span><br><span class="line">(PyObject) $2 &#x3D; &#123;</span><br><span class="line">  ob_refcnt &#x3D; 10</span><br><span class="line">  ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p *$1</span><br><span class="line">(PyObject) $3 &#x3D; &#123;</span><br><span class="line">  ob_refcnt &#x3D; 8</span><br><span class="line">  ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，他们有两个field，一个是 refcnt 用来管理垃圾回收，另一个是 ob_type 指向对象类型的内存。通过访问 ob_type 可以看到该类型的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *$1-&gt;ob_type</span><br><span class="line">(PyTypeObject) $5 &#x3D; &#123;</span><br><span class="line">  ob_base &#x3D; &#123;</span><br><span class="line">    ob_base &#x3D; &#123;</span><br><span class="line">      ob_refcnt &#x3D; 68</span><br><span class="line">      ob_type &#x3D; 0x000000010049a620</span><br><span class="line">    &#125;</span><br><span class="line">    ob_size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  tp_name &#x3D; 0x0000000100407b51 &quot;int&quot;</span><br><span class="line">  tp_basicsize &#x3D; 24</span><br><span class="line">  tp_itemsize &#x3D; 4</span><br><span class="line">  tp_dealloc &#x3D; 0x00000001001707c0 (python.exe&#96;object_dealloc at typeobject.c:4062)</span><br><span class="line">  tp_vectorcall_offset &#x3D; 0</span><br><span class="line">  。。。省略</span><br></pre></td></tr></table></figure>

<p>接下来我们看看我们的 PyLong_Type 支持哪些运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *PyLong_Type-&gt;tp_as_number</span><br><span class="line">(PyNumberMethods) $9 &#x3D; &#123;</span><br><span class="line">  nb_add &#x3D; 0x000000010011b180 (python.exe&#96;long_add at longobject.c:3065)</span><br><span class="line">  nb_subtract &#x3D; 0x000000010011ae00 (python.exe&#96;long_sub at longobject.c:3099)</span><br><span class="line">  nb_multiply &#x3D; 0x000000010011dac0 (python.exe&#96;long_mul at longobject.c:3533)</span><br><span class="line">  nb_remainder &#x3D; 0x000000010011dda0 (python.exe&#96;long_mod at longobject.c:3966)</span><br><span class="line">  nb_divmod &#x3D; 0x000000010011dee0 (python.exe&#96;long_divmod at longobject.c:3982)</span><br><span class="line">  nb_power &#x3D; 0x000000010011e0b0 (python.exe&#96;long_pow at longobject.c:4098)</span><br><span class="line">  nb_negative &#x3D; 0x000000010011aca0 (python.exe&#96;long_neg at longobject.c:4318)</span><br><span class="line">  nb_positive &#x3D; 0x000000010011c570 (python.exe&#96;long_long at longobject.c:4692)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>我们来试一下加法！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *PyLong_Typp.tp_as_number-&gt;nb_add</span><br><span class="line">(PyObject *(*)(PyObject *, PyObject *)) $10 &#x3D; 0x000000010011b180 (python.exe&#96;long_add at longobject.c:3065)</span><br></pre></td></tr></table></figure>

<p>可以看到，加法的函数签名是：<code>(PyObject *(*)(PyObject *, PyObject *))</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p PyLong_Type.tp_as_number-&gt;nb_add((PyObject *) 0x00000001007a8500,(PyObject *) 0x00000001007a8780)</span><br><span class="line">(PyObject *) $15 &#x3D; 0x00000001007a8a00</span><br></pre></td></tr></table></figure>

<p>我们得到了另一个 PyObject 的指针，0x00000001007a8a00。这个理论上就是 10+20 的结果，30。我们来验证一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p *(PyLongObject *) 0x00000001007a8a00</span><br><span class="line">(PyLongObject) $30 &#x3D; &#123;</span><br><span class="line">  ob_base &#x3D; &#123;</span><br><span class="line">    ob_base &#x3D; &#123;</span><br><span class="line">      ob_refcnt &#x3D; 8</span><br><span class="line">      ob_type &#x3D; 0x00000001004936f0</span><br><span class="line">    &#125;</span><br><span class="line">    ob_size &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">  ob_digit &#x3D; ([0] &#x3D; 30)  # &lt;--- 这里就是我们的答案。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇 CPython 初探就到这里，我们学会了如何编译、debug我们的Python解释器，用CPython的API实现了简答的加法。有了这些基础知识我们就可以开始进一步探索CPython的世界了！</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（5）再谈并发</title>
    <url>/2021/03/11/python_5/</url>
    <content><![CDATA[<h1 id="重新认识-Python（5）：再谈并发"><a href="#重新认识-Python（5）：再谈并发" class="headerlink" title="重新认识 Python（5）：再谈并发"></a>重新认识 Python（5）：再谈并发</h1><p>之前写了一个关于<a href="https://zhuanlan.zhihu.com/p/354982602">Python并发模型</a>的小文，主要讨论利用协程实现并发的一些基本方法和规则，文章的重点是 coroutine 的使用。这两天琢磨了一下为什么 Python 要提出基于协程的并发模型，以及跟线程、进程实现的并发有什么区别和联系？最后，我还想简单讨论一下这三种并发模型是否协调在一起工作。</p>
<h2 id="进程、线程、协程并发的特点"><a href="#进程、线程、协程并发的特点" class="headerlink" title="进程、线程、协程并发的特点"></a>进程、线程、协程并发的特点</h2><p>首先明确明确一点，Python一般的协程库，比如 <code>asyncio</code> ，不存在任何并行，即一个时间只有一个任务（协程或者普通函数）在运行。而线程和进程在多核CPU的情况下通常是存在并行的，不过由于Python的GIL，Python的线程不存在并行计算，即使运行在多核CPU上。</p>
<p>我们再来看这三个模型的特点。</p>
<p><strong>进程</strong>：在 Python 的世界里，如果想实现并行计算，进程应该是唯一的选择了，通常进程池数量不会超过CPU的核心数量，以免频繁的进行切换。所以，采用进程实现并发，可以实现并行计算，但是并发任务的数量非常有限。</p>
<p><strong>线程</strong>：Python 的线程直接调用OS提供的线程，并没有特别的处理。所以，线程的调度是由OS主要负责的，属于抢占式。线程的开销比进程更低，所以一般一个应用有上百线程问题不大。但是线程的两个主要问题：抢占，程序基本不能控制OS会给那个线程执行权；race condition，当有并行的时候，由于共享内存，需要锁来控制共享内存。关于线程调度，其实Python的运行时有自己的调度，但是CPython的调度也是依赖于OS的，Python 只能告诉OS这个现在需要被抢占了，如果有还有其他等待的线程，它会让OS来分配下一个执行的线程。</p>
<p><strong>协程</strong>：协程并发最主要的特点是合作式调度，不是抢占式。程序主动控制执行权的交接，而不是OS控制。这样就给调度器提供了非常强的定制性，可以根据具体需求进行调度。另外，协程基本上全部运行于一个OS线程内部，切换开销非常小，创建、销毁协程的开销也非常小。所以协程特别适合数量庞大、寿命较短的任务。通常一个线程可以轻松处理超过1万个协程，所以对于高并发场景，协程并发非常合适。</p>
<p>但是协程并发也有一些局限性：对于 CPU 计算密集或者一些阻塞的任务会让整个调度器卡在这个任务，直到计算结束。真正的解决方案只能是借助其他线程或者进程。还有一个问题就是生态的问题，Python的很多库其实对协程并发没有支持，容易出现处理不良的阻塞任务。这就导致了在采用协程编写并发系统时候，需要造轮子。</p>
<p>下面这个表格大致总结一下三个模型的特征：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>内存</th>
<th>CPU</th>
<th>开销</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>不共享内存</td>
<td>多核并行</td>
<td>大</td>
<td>~ 10</td>
</tr>
<tr>
<td>线程</td>
<td>共享内存</td>
<td>Python不支持并行</td>
<td>中</td>
<td>~ 100</td>
</tr>
<tr>
<td>协程</td>
<td>共享内存</td>
<td>一般无并行</td>
<td>小</td>
<td>~ 1000+</td>
</tr>
</tbody></table>
<p>对于具体的内存和CPU开销，总结如下：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>内存</th>
<th>CPU</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>线程</td>
<td>~ 8MB</td>
<td>-</td>
</tr>
<tr>
<td>协程</td>
<td>&lt; 0.8kb</td>
<td>~ 100 ns</td>
</tr>
</tbody></table>
<p>我没统计全，如果有知道的朋友请留言，我会补上。谢谢</p>
<h2 id="为什么加入协程"><a href="#为什么加入协程" class="headerlink" title="为什么加入协程"></a>为什么加入协程</h2><p>从上面的讨论也可以看出，协程无论实在内存和CPU的开销都有明显的优势，在一个OS进程中可以轻松孵化超过1万个协程进行并发计算，用完后这些协程可以被轻松回收，基本上不需要协程池。而进程和线程的并发，基本都会建立一个数量有限的线程或者进程池，能够并发的任务数量始终有限。协程的另一个好处在于，由于是单线程，本身不存在竞争。综合上面这些因素，协程并发很适合高并发 IO 开发。对于 CPU 密集的任务，或者需要 Blocking 的任务，线程或者进程仍然是首选。当然如果可以融合三种模型在同一个套API下就更好了。</p>
<p>对于 Python，由于GIL的存在，处理高并发最好的选择应该是协程，而不是线程。因为线程本来的优势在于有一定的并行能力，但是GIL剥夺了这个优势。</p>
<p>本质上协程并发就是把调度工作从OS中抽离，由应用端实现，增加了效率和可定制性。但是，协程的复杂度在于调度器的编写，以及执行权的移交等等。</p>
<h2 id="如何融合三种并发基本工具"><a href="#如何融合三种并发基本工具" class="headerlink" title="如何融合三种并发基本工具?"></a>如何融合三种并发基本工具?</h2><p>从 Python 的角度说，并发模型目前主要由两个阵营：<code>concurrent.future</code> 和 <code>asyncio</code>，前者主要针对线程和进程并发，后者针对协程并发。当然新的协程语法 <code>async/await</code> 是 3.5 以后才加入，协程并发慢慢进入更多开发者的视野。对于协程并发，<code>curio</code> 这个库也很值得关注，它提供了一套不同于 <code>asyncio</code> 的API，但是基本原理都是提供了一个调度器来实现并发功能的封装。</p>
<p>本质上，进程、线程、协程都是实现并发的基本工具，并发编程的核心在于<strong>通讯</strong>方式。通讯模式通常分成三种：</p>
<ul>
<li>队列, <code>A ----&gt; 队列 ----&gt; B</code></li>
<li>Actor，<code>A &lt;---- ?</code></li>
<li>Pub/Sub，<code>A &lt;---&gt; 网关 &lt;---&gt; B</code></li>
</ul>
<p>只要我们搞清楚这几种模型，就有希望提供一个融合三种工具的并发编程API。下面我们用线程举例说明每一个模型，原因是比较简单，因为我们不需要操心调度的事情。然后我们可以探索一下用协程来实现，不过我们需要自己造点轮子，比如异步队列、调度器等等。</p>
<h3 id="队列通讯"><a href="#队列通讯" class="headerlink" title="队列通讯"></a>队列通讯</h3><p><code>A ----&gt; 队列 ----&gt; B</code></p>
<p>原理非常简单，A B 两个线程通过队列进行沟通，A 向队列写入，B 从队列读取。最基本的操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">out_q</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 放入数据</span></span><br><span class="line">        out_q.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;放入数据&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>(<span class="params">in_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = in_q.get(timeout=<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;读取数据&#x27;</span>, d)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;队列超时，退出&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    t1 = Thread(target=A, args=(q,))</span><br><span class="line">    t2 = Thread(target=B, args=(q,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p>Python中的 <code>Queue</code> 是线程安全的，而且可以保证数据的顺序，因此是很好的沟通工具。需要注意的是，这里 get 和 put 都是阻塞函数。</p>
<p>当然，除了通过 get 和 put 通讯，还有一些基本的信号工具，比如 <code>Event</code> 。比如如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">out_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ...</span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((<span class="string">&#x27;data&#x27;</span>, evt))</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 等待B的信号</span></span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>(<span class="params">in_q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 给A信号</span></span><br><span class="line">        evt.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>值得注意的是，队列通讯传递的是数据的reference，因此数据是可变且共享的，实际使用应该注意，避免改写数据。</p>
<h3 id="Actor通讯"><a href="#Actor通讯" class="headerlink" title="Actor通讯"></a>Actor通讯</h3><p><code>A &lt;---- ?</code></p>
<p>上面看到队列通讯的特点是<em>共享内存</em>加<em>阻塞</em>。A 和 B 是事实上通过队列偶合在一起。而 Actor通讯中，A 不再与队列耦合，而是从外部接收消息，然后进行计算。当然他也可以给其他 Actor发送消息。类似于一种点对点的通讯，根据内部实现的不同，发送和接受信息可以是阻塞的，也可以是非阻塞的。</p>
<p>下面举个例子说明<a href="https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/">参考</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActorExit</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line">        self._terminated = <span class="literal">None</span>  <span class="comment"># type: Event</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        <span class="comment"># 发送信息给 Actor</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Actor 读取信息</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit(<span class="string">&#x27;Actor exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 阻塞等待完成</span></span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这个函数包含了 Actor 的处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Processing &quot;</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintActor</span>(<span class="params">Actor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Got:&#x27;</span>, msg)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = PrintActor()</span><br><span class="line">    p.start()</span><br><span class="line">    p.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Got: Hello</span></span><br><span class="line"><span class="comment"># Got: World</span></span><br></pre></td></tr></table></figure>

<p>上述实现是通过队列完成的， send 和 recv 都是阻塞的。其实，这个Actor的行为跟协程已经很像了，比如我们可以用携程重新实现上面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_actor</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = <span class="keyword">yield</span>   <span class="comment"># 等待接收信息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Got:&quot;</span>, msg)</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Actor terminated&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = print_actor()</span><br><span class="line">    <span class="built_in">next</span>(p)  <span class="comment"># 开始，函数执行到yield部分</span></span><br><span class="line">    p.send(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    p.send(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>

<p>效果是完全一样的，只不过前一个是通过线程和队列完成，后面的是通过协程，背后的调度的机制不同，但是通讯方式都是点对点的通讯。</p>
<p>Actor 是一个独立个体，他不与其他 Actor 共享内存，通讯接口只有一个 send 函数。这种模式给出了统一不同并发组件（线程、进程、协程）的可能性，即 Actor 的实现可以是上述任意一种，用来因对不同的任务类型。比如 CPU 密集的任务可以通过 Process Actor 完成，而 IO 密集任务则可以通过 Coroutine Actor 处理。</p>
<h3 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h3><p><code>A &lt;---&gt; 网关 &lt;---&gt; B</code></p>
<p>最后这个模式综合了前两种，把 队列 换成了网关，就是一个交换信息的地方，而 A 和 B 都是 Actor。网关的好处在于，Actor 之间不会产生直接的联系，因此各项业务逻辑被很好的分离开来。而且网关还具有一些额外的功能，比如广播，把同一个消息发送给多个 Actor。各种复杂的路由逻辑可以被封装在 网关 里进行处理，而其他 Actor 就实现了并发。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>实现高并发需要三个基本组件：调度器、任务、通讯。而任务的实现可以有不同的方法，比如线程、进程或者协程。通讯通常是通过队列或者网关，而调度器需要另外实现，负责只能依赖操作系统的线程调度。在很多高并发的场景下并不理想。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/55761652/what-is-the-overhead-of-an-asyncio-task">https://stackoverflow.com/questions/55761652/what-is-the-overhead-of-an-asyncio-task</a></li>
<li><a href="https://effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently">https://effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently</a></li>
<li><a href="https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/">https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Concurrent</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS 3</title>
    <url>/2021/03/07/pyos_3/</url>
    <content><![CDATA[<blockquote>
<p>PyOS 0.3</p>
</blockquote>
<h1 id="PyOS-一个Python写的OS（3）"><a href="#PyOS-一个Python写的OS（3）" class="headerlink" title="PyOS - 一个Python写的OS（3）"></a>PyOS - 一个Python写的OS（3）</h1><p>目录：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/355189750">PyOS - 一个Python写的OS（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/355297680">PyOS - 一个Python写的OS（2）</a></li>
</ul>
<h2 id="实现子函数"><a href="#实现子函数" class="headerlink" title="实现子函数"></a>实现子函数</h2><p>在之前实现的OS中，我们的任务存在一个问题，就是不能进行非阻塞子函数调用。为啥呢？看如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> a + b</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    y = <span class="keyword">yield</span> add(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    m      = main()       </span><br><span class="line">    sub    = m.send(<span class="literal">None</span>)             </span><br><span class="line">    result = sub.send(<span class="literal">None</span>)</span><br><span class="line">    m.send(result)</span><br><span class="line">    </span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>上面这段函数的调用过程如下图：</p>
<p><img src="https://i.imgur.com/WBtCFuj.png" alt="Copyright (C) 2009, David Beazley, http://www.dabeaz.com"></p>
<p>问题出在我们的 Task 的结构，如果我们想要进行子函数调用，我们就需要一个 栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line">        self.stack   = []            <span class="comment"># Call stack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加入 栈 后我们需要更新 task 的运行</span></span><br><span class="line">    <span class="comment"># 之前我们只需要直接通过send 触发 协程，现在我们需要考虑函数栈的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 执行到下一个 yield</span></span><br><span class="line">                result = self.target.send(self.sendval)</span><br><span class="line">                <span class="comment"># 检查结果</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall): <span class="keyword">return</span> result</span><br><span class="line">                <span class="comment"># 我们关心返回值为协程的调用，意味着发生了子函数调用</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, types.GeneratorType):</span><br><span class="line">                    <span class="comment"># 我们需要把 主函数 进栈，把执行对象换成 子函数</span></span><br><span class="line">                    self.stack.append(self.target)</span><br><span class="line">                    self.sendval = <span class="literal">None</span></span><br><span class="line">                    self.target  = result</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果返回值不是协程，说明子函数已经返回了</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.stack: <span class="keyword">return</span></span><br><span class="line">                    <span class="comment"># 这时，我们把子函数的返回值发送给 主函数，并把当前执行对象换成主函数</span></span><br><span class="line">                    self.sendval = result</span><br><span class="line">                    self.target  = self.stack.pop()</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.stack: <span class="keyword">raise</span></span><br><span class="line">                self.sendval = <span class="literal">None</span></span><br><span class="line">                self.target = self.stack.pop()</span><br></pre></td></tr></table></figure>

<p>具体解释在注释里。</p>
<h2 id="封装一些IO操作"><a href="#封装一些IO操作" class="headerlink" title="封装一些IO操作"></a>封装一些IO操作</h2><p>有了子函数后，我们就可以对之前的一些 IO 操作进行封装，隐藏 具体的 yield 信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Library Functions ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Accept</span>(<span class="params">sock</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">    <span class="keyword">yield</span> sock.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Send</span>(<span class="params">sock,buffer</span>):</span></span><br><span class="line">    <span class="keyword">while</span> buffer:</span><br><span class="line">        <span class="keyword">yield</span> WriteWait(sock)</span><br><span class="line">        <span class="built_in">len</span> = sock.send(buffer)</span><br><span class="line">        buffer = buffer[<span class="built_in">len</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recv</span>(<span class="params">sock,maxbytes</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">    <span class="keyword">yield</span> sock.recv(maxbytes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如上面就是三个Socket相关的函数，现在我们可以用这些系统库重写我们上一次的 Echo Server。</p>
<h2 id="重写-Echo-Server"><a href="#重写-Echo-Server" class="headerlink" title="重写 Echo Server"></a>重写 Echo Server</h2><p>这里我们不再需要直接OS call，而是使用一些封装的库函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> coroutine.os.pyos1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span>(<span class="params">client, addr</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from &#x27;</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># OS call： read</span></span><br><span class="line">        <span class="comment"># 注意这里不再是OS call， 而是一个OS 的library call</span></span><br><span class="line">        data = <span class="keyword">yield</span> Recv(client,<span class="number">65536</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server receive &#x27;</span>, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># FD 已经关闭了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># Echo</span></span><br><span class="line">        <span class="comment"># 注意这里不再是OS call， 而是一个OS 的library call</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server echo back&#x27;</span>, data)</span><br><span class="line">        <span class="keyword">yield</span> Send(client,data)</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Client closed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">port</span>):</span></span><br><span class="line">    <span class="comment"># 这是一个支持并发的 echo server</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Server start..&#x27;</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">&quot;&quot;</span>,port))</span><br><span class="line">    sock.listen(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        <span class="keyword">yield</span> NewTask(handle_client(client, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sched = Scheduler()</span><br><span class="line">sched.schedule(Task(server(<span class="number">45000</span>)))</span><br><span class="line"><span class="comment"># 启动系统</span></span><br><span class="line">sched.mainloop()</span><br></pre></td></tr></table></figure>


<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这个系列就高于段落了，我们的PyOS停留在了0.3，其实还有很多东西可以考虑，比如：</p>
<ul>
<li>任务之间的通讯</li>
<li>阻塞任务，比如数据库读取</li>
<li>任务和线程结合</li>
<li>异常处理</li>
</ul>
<h2 id="最后最后"><a href="#最后最后" class="headerlink" title="最后最后"></a>最后最后</h2><p>其实，这个系列主要是想探索Python的协程并发编程，Python 3.5 以后引入了 <code>async/await</code> 关键字和一个相关的异步IO库 <code>asyncio</code>，这些内容都跟这个系列有些许的联系。</p>
<p>关于Python的并发，如果感兴趣还可以看：</p>
<ul>
<li>Stackless Python</li>
<li>Greenlet</li>
<li>Eventlet</li>
<li>Cogen</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS</title>
    <url>/2021/03/06/pyos_1/</url>
    <content><![CDATA[<h1 id="PyOS-一个Python写的OS（1）"><a href="#PyOS-一个Python写的OS（1）" class="headerlink" title="PyOS - 一个Python写的OS（1）"></a>PyOS - 一个Python写的OS（1）</h1><blockquote>
<p>引用自David Beazley的视频PPT</p>
</blockquote>
<p>PyOS 这个系列，我们进一步利用协程的特性，一步一步的构建一个多任务操作系统。系列的最后，我们会在我们自己写的PyOS上实现一个 Web Client/Server。</p>
<p>当然，这不是真正的操作系统，而是一个操作系统上的操作系统。。哈哈。完成这个系列可以对并发编程、协程、操作系统多任务管理、IO有更深刻的认识。当然，你还会收货成就感。</p>
<p>对协程不太了解的同学请看：<a href="https://zhuanlan.zhihu.com/p/354982602">https://zhuanlan.zhihu.com/p/354982602</a></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>需要指出的是，当CPU（假设只有一个核心）运行你的代码时，OS自己的代码就不可能被执行。那么，操作系统是如何拿回控制权的呢？通常，操作系统有两种方式拿回CPU的控制权：Interrupt和Traps。Interrupt通常是IO或者计时器发出的，而Trap是其他软件生成的给CPU的信号。当CPU收到这两种信号后，会挺会手上的活，移交执行权给OS代码。当应用程序调用OS提供的底层函数时，通常会产生Trap，从而把执行权交还OS。</p>
<p>所以，某种程度上说，OS的一个重要的组成部分就是多任务切换和管理，充分利用有限的CPU资源。</p>
<p><img src="https://i.imgur.com/pYNOZgW.png" alt="OS多任务"></p>
<h2 id="用-协程-构建OS"><a href="#用-协程-构建OS" class="headerlink" title="用 协程 构建OS"></a>用 协程 构建OS</h2><p>如果你还记得上一次我们讲到的<code>yield</code>关键字，你会发现他就是一个Trap，一个协程会在 yield的时候交出执行权！利用这点，我们就可以用 协程 构建一个多任务操作系统！不需要线程、进程。</p>
<p>首先，既然是多任务系统，我们首先要抽象一个Task对象出来，代表任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple generator/coroutine function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span> ( <span class="string">&quot;Part 1&quot;</span> )</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span> ( <span class="string">&quot;Part 2&quot;</span> )</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">t1 = Task(foo())</span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot;Running foo()&quot;</span> )</span><br><span class="line">t1.run()</span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot;Resuming foo()&quot;</span> )</span><br><span class="line">t1.run()</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>foo</code> 是一个 协程，然后被放入Task中，foo 会在 yield 的地方把执行权交还系统。接下来，我们需要实现一个 调度器，对任务进行管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">           <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            result = task.run()</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Two tasks</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span> ( <span class="string">&quot;I&#x27;m foo&quot;</span> )</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span> ( <span class="string">&quot;I&#x27;m bar&quot;</span> )</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Run them</span></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>上面的例子中，foo bar程序会在调度器的控制下交替执行，直到永远。。对应的代码即见注释。简单来说，就是系统会不断轮训任务队列，并执行任务，直到任务的下一个 yield，系统进入新的循环。</p>
<p>现在有一个问题，就是我们的 任务其实是协程，Python的协程在执行接触后，会抛出<code>StopIteration</code> 异常，我们的系统主循环就会crash。所以，我们需要一个优雅的结束任务的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 优雅的结束任务！</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.taskid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.taskid]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m bar&quot;</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br></pre></td></tr></table></figure>

<h2 id="OS-call"><a href="#OS-call" class="headerlink" title="OS call"></a>OS call</h2><p>是不是很有成就感？我们的多任务OS已经基本可以运行了！其实，这里的 Scheduler 就是我们的OS，而Task就是跑在系统中的一个个进程。现在，我们给我们的OS提供一些基本的 System Call。因为在现实的OS中，应用程序需要 system call 来操作系统资源。为了请求系统资源，任务会用到带值的 yield 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>首先，我们 写一个 system call 的基类作为其他 OS call 的接口。然后，我们需要修改OS 的循环来处理 OS call。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这里仅给出了 mainloop 部分。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br></pre></td></tr></table></figure>

<p>ok，框架搭好了，我们来实现第一个 OS call： GetTid，向系统请求任务ID。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;I&#x27;m foo&quot;</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        mytid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;I&#x27;m bar&quot;</span>, mytid</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(foo())</span><br><span class="line">    sched.new(bar())</span><br><span class="line">    sched.mainloop()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m bar 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">I&#x27;m foo 1</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>恭喜你！PyOS 0.1 已经实现了！</p>
<p>接下来我们会增加更多的 OS call，然后我们会进入 I/O 相关的任务，最后，我们会在PyOS上跑一个web server。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>编程101 PyOS 一个Python写的OS 2</title>
    <url>/2021/03/06/pyos_2/</url>
    <content><![CDATA[<h1 id="PyOS-一个Python写的OS（2）"><a href="#PyOS-一个Python写的OS（2）" class="headerlink" title="PyOS - 一个Python写的OS（2）"></a>PyOS - 一个Python写的OS（2）</h1><p><a href="https://zhuanlan.zhihu.com/p/355189750">上文</a>我们的PyOS已经可以处理多任务了，而且加入了第一个 OS call：<code>GetTid</code> 来获取任务ID。今天，我们继续开发我们的OS，增加更多的 OS call。</p>
<h2 id="更多-OS-call"><a href="#更多-OS-call" class="headerlink" title="更多 OS call"></a>更多 OS call</h2><p>我们需要增加两个基本的系统函数：<code>NewTask</code> 和 <code>KillTask</code> 让操作系统进行基本的任务管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了基本的任务管理功能，尝试下面的程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        pid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>, pid)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        child = <span class="keyword">yield</span> NewTask(foo())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> KillTask(child)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Main task done.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(main())</span><br><span class="line">    sched.mainloop()</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">Main task done.</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们在主进程里面启动了一个子任务，并且实现了并发和任务结束。</p>
<h2 id="实现-WaitTask"><a href="#实现-WaitTask" class="headerlink" title="实现 WaitTask"></a>实现 WaitTask</h2><p>WaitTask 这个功能相对复杂一点，我们想实现一个费阻塞的等待功能。这个需要修改一下我们的 调度器。实现原理不复杂，当一个任务A请求等待另一个任务B退出后再继续执行的时候，调度器首先检查B任务是否存在，如果B不存在，立即返回。如果B存在，我们把A放入B的等待退出队列中，然后交出执行权。然后，在调度器的 <code>exit</code> 函数中增加一个检查，当一个任务结束时会将等待它退出的任务重新放入执行队列。完整程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 用来记录等待退出的任务</span></span><br><span class="line">        self.exit_waiting = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.tid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">        <span class="comment"># 通知其他等待退出的任务，这个任务结束了，可以恢复执行了</span></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> self.exit_waiting.pop(task.tid,[]):</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforexit</span>(<span class="params">self, task, waittid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> waittid <span class="keyword">in</span> self.taskmap:</span><br><span class="line">            self.exit_waiting.setdefault(waittid, []).append(task)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    <span class="comment"># task 和 sched 都是调用OS call 的任务的信息</span></span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                   === System Calls ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a task to exit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">        pid = <span class="keyword">yield</span> GetTid()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m foo&quot;</span>, pid)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        child = <span class="keyword">yield</span> NewTask(foo())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Waiting for child task exit&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> WaitTask(child)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Child task terminated.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    sched.new(main())</span><br><span class="line">    sched.mainloop()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Waiting for child task exit</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">I&#x27;m foo 2</span></span><br><span class="line"><span class="string">Task 2 terminated</span></span><br><span class="line"><span class="string">Child task terminated.</span></span><br><span class="line"><span class="string">Task 1 terminated</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>目前我们的OS可以：</p>
<ul>
<li>并发运行多任务</li>
<li>启动、终结任务</li>
<li>基本的任务管理，比如等待</li>
</ul>
<h2 id="实现-非阻塞IO"><a href="#实现-非阻塞IO" class="headerlink" title="实现 非阻塞IO"></a>实现 非阻塞IO</h2><p>由于我们的PyOS运行在真正的OS上，OS的IO操作会挂起整个Python解释器，我们需要实现一个费阻塞IO的功能。为了实现这个功能，需要用到Python的 <code>select</code> 模块。完整代码如下，注释会解释新增的部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                      === Scheduler ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    taskid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        <span class="comment"># class variable</span></span><br><span class="line">        Task.taskid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># object</span></span><br><span class="line">        self.tid     = Task.taskid   <span class="comment"># Task ID</span></span><br><span class="line">        self.target  = target        <span class="comment"># Target coroutine</span></span><br><span class="line">        self.sendval = <span class="literal">None</span>          <span class="comment"># Value to send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run a task until it hits the next yield statement</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.target.send(self.sendval)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ready 就是 任务 队列</span></span><br><span class="line">        self.ready   = Queue()</span><br><span class="line">        <span class="comment"># taskmap 是一个字典，用来记录任务ID 和 任务实例</span></span><br><span class="line">        self.taskmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 用来记录等待退出的任务</span></span><br><span class="line">        self.exit_waiting = &#123;&#125;</span><br><span class="line">        <span class="comment"># IO 队列</span></span><br><span class="line">        self.read_waiting = &#123;&#125;</span><br><span class="line">        self.write_waiting = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="comment"># 向系统增加新的任务，并返回生成的任务ID</span></span><br><span class="line">        newtask = Task(target)</span><br><span class="line">        self.taskmap[newtask.tid] = newtask</span><br><span class="line">        self.schedule(newtask)</span><br><span class="line">        <span class="keyword">return</span> newtask.tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exit</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task %d terminated&#x27;</span> % task.tid)</span><br><span class="line">        <span class="keyword">del</span> self.taskmap[task.tid]</span><br><span class="line">        <span class="comment"># 通知其他等待退出的任务，这个任务结束了，可以恢复执行了</span></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> self.exit_waiting.pop(task.tid,[]):</span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforexit</span>(<span class="params">self, task, waittid</span>):</span></span><br><span class="line">        <span class="keyword">if</span> waittid <span class="keyword">in</span> self.taskmap:</span><br><span class="line">            self.exit_waiting.setdefault(waittid, []).append(task)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># IO 功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforread</span>(<span class="params">self,task,fd</span>):</span></span><br><span class="line">        self.read_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitforwrite</span>(<span class="params">self,task,fd</span>):</span></span><br><span class="line">        self.write_waiting[fd] = task</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iopoll</span>(<span class="params">self, timeout</span>):</span></span><br><span class="line">        <span class="comment"># io poll 返回当前可用的文件标识符，然后把等待它的任务，重新放入执行队列，等待执行</span></span><br><span class="line">        <span class="keyword">if</span> self.read_waiting <span class="keyword">or</span> self.write_waiting:</span><br><span class="line">            r, w, e = select.select(self.read_waiting,</span><br><span class="line">                                    self.write_waiting,[],timeout)</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> r:</span><br><span class="line">                self.schedule(self.read_waiting.pop(fd))</span><br><span class="line">            <span class="keyword">for</span> fd <span class="keyword">in</span> w:</span><br><span class="line">                self.schedule(self.write_waiting.pop(fd))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iotask</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># IO 任务队列循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ready.empty():</span><br><span class="line">                self.iopoll(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.iopoll(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self, task</span>):</span></span><br><span class="line">        <span class="comment"># 将任务放入执行队列等待执行</span></span><br><span class="line">        self.ready.put(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mainloop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里加入一个 IO 自己的 任务循环</span></span><br><span class="line">        self.new(self.iotask())</span><br><span class="line">        <span class="keyword">while</span> self.taskmap:</span><br><span class="line">            <span class="comment"># 系统的主循环，不断轮训任务队列，并执行直到任务的下一个yield（ trap ）</span></span><br><span class="line">            task = self.ready.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = task.run()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, SystemCall):</span><br><span class="line">                    <span class="comment"># task 和 sched 都是调用OS call 的任务的信息</span></span><br><span class="line">                    result.task  = task</span><br><span class="line">                    result.sched = self</span><br><span class="line">                    result.handle()</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self.exit(task)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.schedule(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#                   === System Calls ===</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    task: Task</span><br><span class="line">    sched: Scheduler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return a task&#x27;s ID number</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetTid</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.task.sendval = self.task.tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,target</span>):</span></span><br><span class="line">        self.target = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        tid = self.sched.new(self.target)</span><br><span class="line">        self.task.sendval = tid</span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KillTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        task = self.sched.taskmap.get(self.tid,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            task.target.close()</span><br><span class="line">            self.task.sendval = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.task.sendval = <span class="literal">False</span></span><br><span class="line">        self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for a task to exit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitTask</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tid</span>):</span></span><br><span class="line">        self.tid = tid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.sched.waitforexit(self.task, self.tid)</span><br><span class="line">        self.task.sendval = result</span><br><span class="line">        <span class="comment"># If waiting for a non-existent task,</span></span><br><span class="line">        <span class="comment"># return immediately without waiting</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            self.sched.schedule(self.task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for reading</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWait</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,f</span>):</span></span><br><span class="line">        <span class="comment"># 这里的 f 就是 fd</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforread(self.task,fd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for writing</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteWait</span>(<span class="params">SystemCall</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,f</span>):</span></span><br><span class="line">        <span class="comment"># 这里的 f 就是 fd</span></span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        fd = self.f.fileno()</span><br><span class="line">        self.sched.waitforwrite(self.task,fd)</span><br></pre></td></tr></table></figure>


<h2 id="我们的第一个应用程序！"><a href="#我们的第一个应用程序！" class="headerlink" title="我们的第一个应用程序！"></a>我们的第一个应用程序！</h2><p>现在我们的PyOS已经可以支持IO了，让我们来写第一个应用程序：Echo Server！这是一个支持并发的server！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_client</span>(<span class="params">client, addr</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from &#x27;</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># OS call： read</span></span><br><span class="line">        <span class="keyword">yield</span> ReadWait(client)</span><br><span class="line">        data = client.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server receive &#x27;</span>, data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="comment"># FD 已经关闭了</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Echo</span></span><br><span class="line">        <span class="keyword">yield</span> WriteWait(client)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Server echo back&#x27;</span>, data)</span><br><span class="line">        client.send(data)</span><br><span class="line"></span><br><span class="line">    client.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Client closed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">port</span>):</span></span><br><span class="line">    <span class="comment"># 这是一个支持并发的 echo server</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Server start..&#x27;</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">&quot;&quot;</span>,port))</span><br><span class="line">    sock.listen(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> ReadWait(sock)</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        <span class="keyword">yield</span> NewTask(handle_client(client, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sched = Scheduler()</span><br><span class="line">sched.schedule(Task(server(<span class="number">45000</span>)))</span><br><span class="line"><span class="comment"># 启动系统</span></span><br><span class="line">sched.mainloop()</span><br></pre></td></tr></table></figure>

<p>运行上述程序后，会看到 <code>Server start..</code>。这是后你可以打开 terminal，输入：<code>telnet localhost 45000</code> 来建立连接。然后你就可以看到 server echo 你输入的信息了。是不是很有成就感！！</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前PyOS还有一个比较致命的问题：任务不能 yield 到另一个任务，只能把执行权交还给操作系统，而不能交给其他任务。。下一篇我们看如何解决这个问题。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Python</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（4）并发模型</title>
    <url>/2021/03/05/python_concurrent/</url>
    <content><![CDATA[<h1 id="重新认识-Python（4）并发模型"><a href="#重新认识-Python（4）并发模型" class="headerlink" title="重新认识 Python（4）并发模型"></a>重新认识 Python（4）并发模型</h1><h2 id="并发是什么？"><a href="#并发是什么？" class="headerlink" title="并发是什么？"></a>并发是什么？</h2><p>并发一般是指多个计算在时间上无固定先后顺序的执行。并发程序不一定存在并行。举个例子<a href="https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/#message_passing_example">reference</a>: </p>
<p><img src="https://i.imgur.com/LG0PL9t.png" alt="并发实例"></p>
<p>上面的例子中我们有三个任务，T1~3，这三个任务就属于并发执行，而且因为有两个CPU，所以存在一定的并行。左图是每一个任务在CPU核心的执行情况，而右图是从任务自身的时间线角度表达任务的执行情况。可以看到任务通常不是连续执行，而是根据调度情况间断执行。</p>
<p>并发编程的一个好处就是可以让数量有限的CPU核心，“看起来”同时执行数量远远大于核心数量的任务，换句话说，增加系统的对请求的响应程度。</p>
<p>并发模型最常见的程序其实就是操作系统，一个普通的操作系统运行在一个8核CPU上，却可以“看起来”同时执行成千上万个任务，这就是并发模型的效果。</p>
<p>如果不谈操作系统，而是其他基于操作系统的应用的例子，比如Web 服务器，需要同时对众多请求作出回应。</p>
<h2 id="Python怎么搞并发？"><a href="#Python怎么搞并发？" class="headerlink" title="Python怎么搞并发？"></a>Python怎么搞并发？</h2><p>Python提供了三种并发的工具：多线程（threading）、多进程（process）和协程（Coroutine）。前两种其实就是利用了操作系统提供的并发模型。</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>CPython的Thread其实就是操作系统的线程，基本没有overhead。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_POSIX_THREADS)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PYTHREAD_NAME <span class="meta-string">&quot;pthread&quot;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(NT_THREADS)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PYTHREAD_NAME <span class="meta-string">&quot;nt&quot;</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_nt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> <span class="meta-string">&quot;Require native threads. See https://bugs.python.org/issue31370&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码可见，Python会根据操作系统调用对应系统的线程API，然后把调度工作移交OS。这里需要注意的是，由于GIL的存在，每一个Python解释器进程中，同一时间只能有一个线程执行。这意味着，在这种情况下，利用线程实现的并发模型中，不存在并行。</p>
<p>线程实现的并发模型比较容易理解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    target = <span class="keyword">lambda</span> : <span class="built_in">print</span>(<span class="string">&#x27;Hello from NEW thread\n&#x27;</span>)</span><br><span class="line">    my_thread = threading.Thread(target=target)</span><br><span class="line">    my_thread.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello from MAIN thread\n&#x27;</span>)</span><br><span class="line">    my_thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>开进程，指定任务，执行就可以了。其余的调度工作完全移交操作系统统一管理。当然，这样做的弊端也很明显：</p>
<ul>
<li>线程创建和切换的开销都比较大，数量有限</li>
<li>移交操作系统调度后，程序员基本失去了对任务的控制，属于抢占式</li>
</ul>
<h3 id="协程，Coroutine"><a href="#协程，Coroutine" class="headerlink" title="协程，Coroutine"></a>协程，Coroutine</h3><p>为了解决上面的弊端，Python也给出了协程的方案。协程跟线程的最大区别就是：协程是协作式的，线程是抢占式的。具体讲就是一个协程会在预订的位置让出执行权，并且主动的移交给其他协程，而线程则是抢占式的，一个线程会在任意时间被夺去执行权。</p>
<p>协程可以理解成是一般函数的泛化。一般的函数只有一个入口和若干个出口，协程具有多个入口和出口。</p>
<p>在Python中主要涉及到<code>yield</code> 和 <code>yield from</code> 关键字。</p>
<p>下面举几个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Hello &quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;World!&quot;</span></span><br><span class="line"></span><br><span class="line">hw = hello_world()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(hw))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Hello </span></span><br><span class="line"><span class="comment"># World!</span></span><br><span class="line"><span class="comment"># Finished</span></span><br></pre></td></tr></table></figure>

<p><code>next</code> 函数会逐一访问到每一个yield点，知道没有其他 yield 为止。而 yield 的功能就是让函数交出执行权，知道下一次被调用，他会从上一个yield点开始执行。严格来讲，上面这个 hello_world 还不是完整的协程，因为 yield 仅仅把执行权交还给调用方，而不是任意其它协程。我们看下一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">co1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;co1&#x27;</span></span><br><span class="line"></span><br><span class="line">c1 = co1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">co2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> c1</span><br><span class="line"></span><br><span class="line">c2 = co2()</span><br><span class="line"><span class="built_in">next</span>(c2)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># World</span></span><br><span class="line"><span class="comment"># co1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，协程 co2 把执行权主动交给 co1 而不是交还给调用方。</p>
<p>不过，Python 3.5以后引入了<code>asnyc/await</code> 作为协程的原生支持。其实就是是避免写 <code>yield</code> 与 生成器混淆，如果你trace down代码的话，所有的 await 最后都会在某处出现 <code>yield</code> 关键字。我们举个例子就会发现其实 async/await 就是 yield 的语法糖，表明函数时协程，而不是普通函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awaitable</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__await__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_</span>():</span></span><br><span class="line">    <span class="keyword">return</span> Awaitable()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">a1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> yield_()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = a1()</span><br><span class="line">a.send(<span class="literal">None</span>)</span><br><span class="line">a.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># World!</span></span><br></pre></td></tr></table></figure>

<p>可以看出，async 定义的函数就是一个协程。</p>
<p>至此，我们已经了解协程的基本原理，下面我们来看一下如何利用协程实现并发。</p>
<h3 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h3><p>假设我们有两个任务需要并发执行，一个向上数，一个向下数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">countdown(<span class="number">5</span>)</span><br><span class="line">countup(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>运行上面程序肯定无法实现并发，而是顺序执行。由于loop和sleep的存在程序也会block。那么我们如何实现并发？</p>
<p>首先，我们需要把函数改写成 协程 ，这样这两个任务就可以主动交出执行权。然后需要我们自己写一个 调度器 来实现不同任务的并发调度。最后我们还需要处理一下sleep的block问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 这样，函数就可以在loop的途中交出执行权</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 这样，函数就可以在loop的途中交出执行权</span></span><br><span class="line">        x += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过加入 yield，这两个任务现在会在每一次loop的时候主动交出控制权。接下来，我们来实现一个简单的调度器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.current = <span class="literal">None</span>  <span class="comment"># 当前任务的指针</span></span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span>(<span class="params">self, coro</span>):</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.ready:</span><br><span class="line"></span><br><span class="line">            self.current = self.ready.popleft()</span><br><span class="line">            <span class="comment"># 执行下一步</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current.send(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> self.current:</span><br><span class="line">                    self.ready.append(self.current)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sched = Scheduler1()</span><br><span class="line">sched.new_task(countdown(<span class="number">5</span>))</span><br><span class="line">sched.new_task(countup(<span class="number">5</span>))</span><br><span class="line">sched.run()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Down 5</span></span><br><span class="line"><span class="string">Up 0</span></span><br><span class="line"><span class="string">Down 4</span></span><br><span class="line"><span class="string">Up 1</span></span><br><span class="line"><span class="string">Down 3</span></span><br><span class="line"><span class="string">Up 2</span></span><br><span class="line"><span class="string">Down 2</span></span><br><span class="line"><span class="string">Up 3</span></span><br><span class="line"><span class="string">Down 1</span></span><br><span class="line"><span class="string">Up 4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，通过简单的调度，我们就实现了两个任务的并发执行。调度器本身的原理非常简单，就是一个循环，不断检查是否有活跃的任务，如果有，就通过 send 执行任务，如果没有异常，就说明任务没有完成，再把任务放回队列。循环。</p>
<p>现在我们还有一个问题，就是sleep的问题，现在sleep还是block的。我们需要在 调度器 中处理这种情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ready = deque()</span><br><span class="line">        self.sleeping = []</span><br><span class="line">        self.current = <span class="literal">None</span>  <span class="comment"># 当前任务的指针</span></span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self, delay</span>):</span></span><br><span class="line">        deadline = time.time() + delay</span><br><span class="line">        self.sequence += <span class="number">1</span>  <span class="comment"># 这个是为了 heap 排序</span></span><br><span class="line">        heapq.heappush(self.sleeping, (deadline, self.sequence, self.current))</span><br><span class="line">        self.current = <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 交出控制权限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_task</span>(<span class="params">self, coro</span>):</span></span><br><span class="line">        self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> self.ready <span class="keyword">or</span> self.sleeping:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.ready:</span><br><span class="line">                deadline, _, coro = heapq.heappop(self.sleeping)</span><br><span class="line">                delta = deadline - time.time()</span><br><span class="line">                <span class="keyword">if</span> delta &gt; <span class="number">0</span>:</span><br><span class="line">                    time.sleep(delta)</span><br><span class="line">                self.ready.append(coro)</span><br><span class="line"></span><br><span class="line">            self.current = self.ready.popleft()</span><br><span class="line">            <span class="comment"># 执行下一步</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.current.send(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> self.current:</span><br><span class="line">                    self.ready.append(self.current)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Down&#x27;</span>, n)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> sched.sleep(<span class="number">1</span>)  <span class="comment"># 注意这里，协程主动把执行权交给 sleep，就是另一个协程</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span>(<span class="params">stop</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Up&#x27;</span>, x)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> sched.sleep(<span class="number">0.2</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Down 5</span></span><br><span class="line"><span class="string">Up 0</span></span><br><span class="line"><span class="string">Down 4</span></span><br><span class="line"><span class="string">Up 1</span></span><br><span class="line"><span class="string">Up 2</span></span><br><span class="line"><span class="string">Up 3</span></span><br><span class="line"><span class="string">Up 4</span></span><br><span class="line"><span class="string">Up 5</span></span><br><span class="line"><span class="string">Down 3</span></span><br><span class="line"><span class="string">Up 6</span></span><br><span class="line"><span class="string">Up 7</span></span><br><span class="line"><span class="string">Up 8</span></span><br><span class="line"><span class="string">Up 9</span></span><br><span class="line"><span class="string">Up 10</span></span><br><span class="line"><span class="string">Down 2</span></span><br><span class="line"><span class="string">Up 11</span></span><br><span class="line"><span class="string">Up 12</span></span><br><span class="line"><span class="string">Up 13</span></span><br><span class="line"><span class="string">Up 14</span></span><br><span class="line"><span class="string">Up 15</span></span><br><span class="line"><span class="string">Down 1</span></span><br><span class="line"><span class="string">Up 16</span></span><br><span class="line"><span class="string">Up 17</span></span><br><span class="line"><span class="string">Up 18</span></span><br><span class="line"><span class="string">Up 19</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，调度器通过一个 sleep 协程实现了非阻塞的睡眠。<code>yield from</code> 可以把执行权交给另一个协程，而不是调度器。</p>
<p>其实，如果你用过 <code>asyncio</code> 库，就会发现这个库的核心就是一个类似的调度器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>这里面的 <code>await</code> 就是 <code>yield from</code> 的功能，即把执行权移交另一个协程。而 <code>async</code> 的主要目的是规范化协程语法，与一般函数进行区别。当然，Python内部有后来慢慢加入了不同的类型。比如 <code>async</code> 定义的协程的类型是： async_generator， 而 yield 定义的类型为： generator。</p>
<h2 id="Python并发还能怎么搞？"><a href="#Python并发还能怎么搞？" class="headerlink" title="Python并发还能怎么搞？"></a>Python并发还能怎么搞？</h2><p>上面提到的都是一些比较常见的方法。当然Python里面还有一些不太常用到的模型。比如</p>
<ul>
<li>Actor Model</li>
<li>CSP</li>
<li>Multiple Interpreters，<a href="https://www.python.org/dev/peps/pep-0554/#id56">https://www.python.org/dev/peps/pep-0554/#id56</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=Y4Gt3Xjd7G8">https://www.youtube.com/watch?v=Y4Gt3Xjd7G8</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Concurrent</tag>
        <tag>Async</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>关于类型系统的一些思考</title>
    <url>/2021/02/20/type_system/</url>
    <content><![CDATA[<h2 id="类型系统是什么"><a href="#类型系统是什么" class="headerlink" title="类型系统是什么"></a>类型系统是什么</h2><blockquote>
<p>类型系统是一个有多个规则组成的逻辑系统，系统内的规则会给程序中的每一个组成部分，包括变量、表达式、函数、甚至模块等等，制定一个 类型 属性。</p>
</blockquote>
<p>通俗的讲，类型系统是为了赋予程序或者数据意义。因为任何值或者一个函数，在内存里面都只是一串bits，而类型就是要给这串bits意义。例如，<code>10</code> 是的类型是一个奇怪的 int 类型，这个int只有两位。类型系统会给你加额外的信息让他变成一个 int，<code>01|10</code>，这里我们假设类型占两位，01就是int的bit表达，| 用来区分类型和值。这是，10就有了意义，而且程序在编译阶段或者运行时就可以通过这个类型标识确保采用合法的操作来操作这个值。</p>
<p>换句话说，类型系统形成了一个除了语法（syntax）和语义（semantic）以外的另一套可以用来分析代码的系统。刚才我们也提到了，类型系统属于逻辑系统，就是通过规则（rule）可以进行推到和证明。所以我们可以肯定的说，好的类型系统可以帮助我们从逻辑角度分析程序，减少bug。因为语法和语义其实并没有办法从逻辑层面表达任何关于程序本身要做的事情。而类型系统可以发现一些逻辑错误，至少在他的rule可以推导的范围内。</p>
<p>有些语言只会给变量制定类型，而表达式、函数则没有类型。比如 Python 中，<code>if a == 1: 1 else: 2</code> 这个表达式是没有类型的概念的。而在 Ocaml 中，<code>if a=1 then 1 else 2</code> 这个表达式有类型 int。事实上一般函数式语言的类型覆盖会更加广泛，而过程式语言覆盖则低很多，比如表达式基本都是没有类型的。显然，类型覆盖约广泛，这个逻辑系统能提供的帮助就越多。</p>
<p>在实际工程中，好的类型系统会提高编译优化能力，甚至对代码重构、测试都有重要的作用。简单来讲，类型系统不但可以减少运行时的bug，还可以协助程序员进行开发。</p>
<p>当然，设计好的类型系统比较复杂，类型系统设计的有问题，反而会增加程序员的负担。</p>
<h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><p>当我们从类型系统的角度讨论计算机语言的时候，可以从如下四个维度看：</p>
<ul>
<li>类型安全(type safe)，分为强和弱</li>
<li>类型表达(type expression), 分为显式和隐式</li>
<li>类型比较(type compatibility)， 一般可以有结构式(structural)和Norminal</li>
<li>类型检查(type checking), 分为静态和动态</li>
</ul>
<p>我举几个例子帮助大家对上面四点有个感性的认知：</p>
<p>语言 | 类型安全 | 类型表达 | 类型比较 | 类型检查 |<br>| ——– | ——– | ——– | ——– | ——- |<br>| C        | 弱       | 显式       | Nominal  | 静态  |<br>| Python   | 强       | 隐式或者显式 | Structural       | 动态  |<br>| Java     | 强       | 显式      | Nominal  | 静态 |<br>| Ocaml    | 强       | 隐式或者显式 | Nominal/Structural | 静态 |</p>
<p>为了进一步理解，我们需要知道这四个维度的定义。</p>
<p><strong>类型安全</strong></p>
<p>一个语言是强类型安全，必须保证代码只能读取自己可以读取的内存区域，并且类型安全的代码不能对一个对象进行不合法的操作。这种保证可以是静态的，即在编译阶段，也可以是动态的，即在运行时。换个说法，类型</p>
<p>C语言的大部分代码是类型安全的，但是C语言的运行时不能保证类型安全，主要是因为可以进行cast操作。比如，要把指针放入array的时候，需要将指针cast成 <code>void*</code>，但是这个操作会丢失所有类型信息，当取回时，有需要 cast 回到原来的类型。由于这些cast的存在，系统运行时可能会出现意想不到的的行为。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = <span class="string">&quot;37&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* z = x + y;</span><br></pre></td></tr></table></figure>

<p>这段c代码中，<code>z</code> 会指向一个内存地址，这个地址是比 <code>y</code> 地址+5 char的一个位置，这个位置可能是任何数据，但是程序本身不会直接崩溃，直到使用z的时候导致更加严重的问题，导致崩溃。而在Java中上述代码会在编译阶段报错。Python属于动态类型，类型安全也只能在运行时抛出异常。</p>
<p>当然这只是很简单的情况，Ocaml其实有用更加的强大的类型系统，能发现比上面这种明显问题更加不显然的逻辑错误。我们后面举例。</p>
<p><strong>类型表达</strong></p>
<p>所谓显示，就是指必须在代码中现实的写出变量的类型，比如C语言中，需要 <code>int a = 1;</code>；而在隐式语言中，比如Python，可以直接写 <code>a = 1</code>。当然对于带有类型推断的语言，比如Ocaml也可以写 <code>let a = 1</code>，不过Ocaml的类型系统已经推断出a的类型是int。Python的情况，只有在运行时才能解释器才能确定a的类型。</p>
<p><strong>类型比较</strong></p>
<p>这里主要在讨论如何说明两个变量的类型是相同的？对于Nominal类型系统，比较非常简单，只要两个类型的名字不一样，他们就是不一样的！无论他们的行为如何。但是对于Structural 类型系统，也叫 property based，只要两个类型的行为一样，他们就是一样的。对于一些存在集成的系统，比较就更加复杂了，需要更多的规则。</p>
<p>结构化类型最好的代表其实Python，在Python的世界里更喜欢被叫做 duck typing。我举个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a = <span class="number">1</span>   </span><br><span class="line">        </span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dummy</span>(<span class="params">o</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(o.a)</span><br><span class="line">    </span><br><span class="line">dummy(a)</span><br><span class="line">dummy(b)</span><br></pre></td></tr></table></figure>

<p>上面的代码运行完全没有问题，但是dummy函数的参数o却支持不同的类型（A和B），这就是所谓的 duck typing。</p>
<p><strong>类型检查</strong></p>
<p>这个很好理解，类型检查就是确保类型安全的过程。如果类型检查发生在编译阶段，那么就是静态类型；反之则是动态类型。</p>
<p>当然，也可以有另一个层面的理解，就是如果类型可以在运行时发生改变，那么就属于动态类型。Python毫无争议属于动态类型，但是Java在引入反射后，反而变得更加动态了。。。另一方面 Ocaml 的类型是完全静态的。</p>
<h2 id="类型系统痛点"><a href="#类型系统痛点" class="headerlink" title="类型系统痛点"></a>类型系统痛点</h2><p>带来了那些痛点？</p>
<ul>
<li>（通常）需要更多的代码</li>
<li>奇葩的编译错误</li>
</ul>
<p><em>举例1：需要更多的代码</em></p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">truncate_reminder</span>(<span class="params">x</span>):</span></span><br><span class="line">    int_part = <span class="built_in">int</span>(x)</span><br><span class="line">    <span class="keyword">return</span> (int_part, x - int_part)</span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 应该感谢Java终于有了泛型。。。不然这段代码的长度会扩大两倍。。。。</span></span><br><span class="line"><span class="comment"> * 泛型算是类型系统一个改善，Java之前的类型系统表达能力真的非常有限 。。。 */</span></span><br><span class="line"><span class="function">Pair&lt;Int, Float&gt; <span class="title">truncateReminder</span><span class="params">(Float x)</span> </span>&#123;</span><br><span class="line">    Int intPart = Int(x);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Pair&lt;Int, Float&gt;(intPart, x - intPart));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ocaml</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> truncate_reminder x = </span><br><span class="line">  <span class="keyword">let</span> int_part = truncate x <span class="keyword">in</span></span><br><span class="line">    (int_part, x -. <span class="built_in">float</span> int_part)</span><br><span class="line">    <span class="comment">(* float 需要显式的写出来，不然编译器也会告诉你这个 *)</span></span><br></pre></td></tr></table></figure>

<p>上面可以发现，Python代码显然是最简洁的，Ocaml其次，Java则多了很多类型标识符+泛型。Ocaml的类型系统可以进行推断，如果推断失败了，它会告诉你它需要哪些提示来完成推断，这样就即有了动态语言的简洁，又可以有用静态类型系统的好处。</p>
<p><em>举例2： 奇葩的错误</em></p>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>([<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">len</span>(<span class="number">1</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">TypeError                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="string">&lt;ipython-input-2-1cf91bb60cc0&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="string">----&gt; 1 len(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeError: object of type &#x27;int&#x27; has no len()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Ok，Python的类型错误提示还是很友好的。</p>
<p><strong>Ocaml</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>.length([<span class="number">1</span>])</span><br><span class="line"><span class="comment">(* 1 *)</span></span><br><span class="line"><span class="type">List</span>.length(<span class="number">1</span>)</span><br><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">Line 1, characters 11-14:</span></span><br><span class="line"><span class="comment">Error: This expression has type int but an expression was expected of type</span></span><br><span class="line"><span class="comment">         &#x27;a list</span></span><br><span class="line"><span class="comment">*)</span></span><br></pre></td></tr></table></figure>

<p>hmm，看起来更复杂一点了，比如<code>&#39;a list</code>是啥？需要更多关于带参类型的理解，才能读懂这段错误提示。但是起码，你看到表达式的类型是int，然而这个函数需要 类型 <code>a list</code>。（不懂无所谓现在）但是显然，类型系统需要更多的学习。</p>
<p>让我们来看看更加先进的Haskell:</p>
<p><strong>Haskell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :t length</span><br><span class="line">length :: Foldable t &#x3D;&gt; t a -&gt; Int</span><br><span class="line"></span><br><span class="line">-- hmm Foldable 是啥？ lenght这个函数的类型是 Foldable t &#x3D;&gt; t a -&gt; Int。 ok</span><br><span class="line">-- 在看</span><br><span class="line">Prelude&gt; length [1]</span><br><span class="line">1</span><br><span class="line">-- ok 结果正确，但是。。。</span><br><span class="line">Prelude&gt; length 1</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:4:8: error:</span><br><span class="line">    • No instance for (Num [a0]) arising from the literal ‘1’</span><br><span class="line">    • In the first argument of ‘length’, namely ‘1’</span><br><span class="line">      In the expression: length 1</span><br><span class="line">      In an equation for ‘it’: it &#x3D; length 1</span><br></pre></td></tr></table></figure>

<p>看到最后的错误提示，你是什么感觉呢？你只是想求一个int 的长度而已。。。</p>
<h2 id="类型系统好处"><a href="#类型系统好处" class="headerlink" title="类型系统好处"></a>类型系统好处</h2><ul>
<li>提高程序的性能</li>
<li>检测错误</li>
<li>指导代码重构</li>
<li>强迫不变量(Invariants)</li>
<li>让tooling变得更加简单</li>
</ul>
<p>工程经验表明，类型系统带来的好处，远远超过了痛点。特别是对于大型、需要多人合作的项目。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>选择类型安全的语言，除非你知道你面对的是什么</li>
<li>动态类型和静态类型各有利弊</li>
<li>不同的类型系统带来的表达能力和优势完全不一样</li>
<li>类型系统也不是越复杂越高级越好</li>
</ul>
<p>动态语言非常灵活，代码更加简洁，非常适合快速原型或者一些对正确性要求不高的项目。动态语言也更适合开发人员较少的项目。而静态类型语言则更加注重代码的正确性和性能，良好的类型系统对大型项目管理和重构都有很重要的意义，但是类型系统也意味着更多的学习。</p>
<p>我们从举例1可以看到，Ocaml的类型系统显然比Java的类型系统表达能力更强，更加先进。但是相应的也带来了一些学习曲线，比如 <code>&#39;a list</code>。当然，在实际工程中，我们也要取舍选择合适复杂度的类型系统，Haskell的类型系统显然过于先进了，学习成本可能更高。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wanwenli.com/programming/2013/12/27/Type-Systems.html">https://wanwenli.com/programming/2013/12/27/Type-Systems.html</a></li>
<li><a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_by_type_system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Type_system#Explicit_or_implicit_declaration_and_inference">https://en.wikipedia.org/wiki/Type_system#Explicit_or_implicit_declaration_and_inference</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ocaml</tag>
        <tag>Python</tag>
        <tag>Java</tag>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（3）GIL</title>
    <url>/2021/02/18/python_gil/</url>
    <content><![CDATA[<h1 id="重新认识Python（3）：GIL，Global-Interpreter-Lock"><a href="#重新认识Python（3）：GIL，Global-Interpreter-Lock" class="headerlink" title="重新认识Python（3）：GIL，Global Interpreter Lock"></a>重新认识Python（3）：GIL，Global Interpreter Lock</h1><p>之前的两个文章主要简述了Python的内存管理模型和对应的GC模型。今天我们来看看Python的另一个“著名”特征：GIL，全局解释器锁。GIL长久以来被各种内行、外行诟病，可是很多人并不清楚GIL究竟是什么？为什么当初要设计GIL？GIL的优势在哪里？</p>
<h2 id="Python-是如何工作的？"><a href="#Python-是如何工作的？" class="headerlink" title="Python 是如何工作的？"></a>Python 是如何工作的？</h2><p>要理解 GIL 需要知道一些Python解释器的运行原理。Python的解释器其实一个循环，循环里是一系列的cases，逐行读取编译后的Opcode进行计算，每一个线程都有独立的这么一个循环。这里插一嘴，其实Python不是解释型语言，起码不是纯粹的解释型，Python源代码会被编译成Python自己的byte code，就是上面循环中的那些opcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    assert(stack_pointer &gt;= f-&gt;f_valuestack); <span class="comment">/* else underflow */</span></span><br><span class="line">    assert(STACK_LEVEL() &lt;= co-&gt;co_stacksize);  <span class="comment">/* else overflow */</span></span><br><span class="line">    assert(!PyErr_Occurred());</span><br><span class="line">    <span class="comment">// 这部分省略的代码就是后面GIL的关键。。我们先来看看解释器的循环</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">/* Extract opcode and argument */</span></span><br><span class="line"></span><br><span class="line">        NEXTOPARG();</span><br><span class="line">    dispatch_opcode:</span><br><span class="line">      <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* BEWARE!</span></span><br><span class="line"><span class="comment">           It is essential that any operation that fails sets either</span></span><br><span class="line"><span class="comment">           x to NULL, err to nonzero, or why to anything but WHY_NOT,</span></span><br><span class="line"><span class="comment">           and that no operation that succeeds does this! */</span></span><br><span class="line"></span><br><span class="line">        TARGET(NOP)</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line"></span><br><span class="line">        TARGET(LOAD_FAST) &#123;</span><br><span class="line">            PyObject *value = GETLOCAL(oparg);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format_exc_check_arg(PyExc_UnboundLocalError,</span><br><span class="line">                                     UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                                     PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PREDICTED(LOAD_CONST);</span><br><span class="line">        TARGET(LOAD_CONST) &#123;</span><br><span class="line">            PyObject *value = GETITEM(consts, oparg);</span><br><span class="line">            Py_INCREF(value);</span><br><span class="line">            PUSH(value);</span><br><span class="line">            FAST_DISPATCH();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>主要参考的<a href="https://github.com/python/cpython/blob/ef5f4ba96e05f61ad3baca502012085f31e99342/Python/ceval.c#L930-L1064">源代码</a>在这里。</p>
<p>当然，为了支持计算Python的runtime还会准备对应的Frame、全局变量等等。</p>
<h2 id="GIL-是什么？"><a href="#GIL-是什么？" class="headerlink" title="GIL 是什么？"></a>GIL 是什么？</h2><p>上面我们提到，每一个线程都有自己独立的执行循环，但是这些执行循环并不是相互独立的，他们必然会共享一些内存，这里起就是经典的并发问题，比如race condition等等。并发模型的实现由很多方法，我们听到最多、看起来也最简单的方法就是基于锁的方法。Python其实就选择这个方法，GIL也就诞生了。</p>
<p>GIL就是一个锁，每一个线程的执行循环，只有拿到GIL，才可以执行，否则就要等待，而一个Python进程只有一个GIL锁，所以它才叫全局锁。GIL可以保证，在同一时间，只有一个线程可以拿到这个锁。</p>
<p>这里我参考了一个小哥的代码，他简单的实现了Python版本的GIL，方便我们理解GIL。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> SimpleNamespace</span><br><span class="line"></span><br><span class="line">DEFAULT_INTERVAL = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">gil_mutex = threading.RLock()</span><br><span class="line">gil_condition = threading.Condition(lock=gil_mutex)</span><br><span class="line">switch_condition = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># dictionary-like object that supports dot (attribute) syntax</span></span><br><span class="line">gil = SimpleNamespace(</span><br><span class="line">    drop_request=<span class="literal">False</span>,</span><br><span class="line">    locked=<span class="literal">True</span>,</span><br><span class="line">    switch_number=<span class="number">0</span>,</span><br><span class="line">    last_holder=<span class="literal">None</span>,</span><br><span class="line">    eval_breaker=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_gil</span>(<span class="params">thread_id</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gil.locked:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;GIL is not locked&quot;</span>)</span><br><span class="line"></span><br><span class="line">    gil_mutex.acquire()</span><br><span class="line"></span><br><span class="line">    gil.last_holder = thread_id</span><br><span class="line">    gil.locked = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Signals that the GIL is now available for acquiring to the first awaiting thread</span></span><br><span class="line">    gil_condition.notify()</span><br><span class="line"></span><br><span class="line">    gil_mutex.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># force switching</span></span><br><span class="line">    <span class="comment"># Lock current thread so it will not immediately reacquire the GIL</span></span><br><span class="line">    <span class="comment"># this ensures that another GIL-awaiting thread have a chance to get scheduled</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">        switch_condition.acquire()</span><br><span class="line">        <span class="keyword">if</span> gil.last_holder == thread_id:</span><br><span class="line">            gil.drop_request = <span class="literal">False</span></span><br><span class="line">            switch_condition.wait()</span><br><span class="line"></span><br><span class="line">        switch_condition.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take_gil</span>(<span class="params">thread_id</span>):</span></span><br><span class="line">    gil_mutex.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gil.locked:</span><br><span class="line">        saved_switchnum = gil.switch_number</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Release the lock and wait for a signal from a GIL holding thread,</span></span><br><span class="line">        <span class="comment"># set drop_request=True if the wait is timed out</span></span><br><span class="line"></span><br><span class="line">        timed_out = <span class="keyword">not</span> gil_condition.wait(timeout=DEFAULT_INTERVAL)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timed_out <span class="keyword">and</span> gil.locked <span class="keyword">and</span> gil.switch_number == saved_switchnum:</span><br><span class="line">            gil.drop_request = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># lock for force switching</span></span><br><span class="line">    switch_condition.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now we hold the GIL</span></span><br><span class="line">    gil.locked = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.last_holder != thread_id:</span><br><span class="line">        gil.last_holder = thread_id</span><br><span class="line">        gil.switch_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># force switching, send signal to drop_gil</span></span><br><span class="line">    switch_condition.notify()</span><br><span class="line">    switch_condition.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">        gil.drop_request = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    gil_mutex.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execution_loop</span>(<span class="params">target_function, thread_id</span>):</span></span><br><span class="line">    <span class="comment"># Compile Python function down to bytecode and execute it in the while loop</span></span><br><span class="line"></span><br><span class="line">    bytecode = <span class="built_in">compile</span>(target_function)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># drop_request indicates that one or more threads are awaiting for the GIL</span></span><br><span class="line">        <span class="keyword">if</span> gil.drop_request:</span><br><span class="line">            <span class="comment"># release the gil from the current thread</span></span><br><span class="line">            drop_gil(thread_id)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># immediately request the GIL for the current thread</span></span><br><span class="line">            <span class="comment"># at this point the thread will be waiting for GIL and suspended until the function return</span></span><br><span class="line">            take_gil(thread_id)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bytecode execution logic, executes one instruction at a time</span></span><br><span class="line">        instruction = bytecode.next_instruction()</span><br><span class="line">        <span class="keyword">if</span> instruction <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            execute_opcode(instruction)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>看代码我们可以知道：</p>
<ul>
<li>Python创建一个新的thread的时候，会首先call <code>take_gil</code> 尝试得到 GIL，然后才进入执行循环</li>
<li>通过在循环的开始部分检查gil状态，可以确保只有一个线程在执行</li>
</ul>
<p>目前这个版本的GIL其实也实现一些scheduler的功能，比如：</p>
<p><code>gil.drop_request</code> 为True就表明有其他的线程在等待执行，当前进程就会首先尝试放弃gil，给其他线程机会，然后他会立刻尝试夺回gil，以便自己可以继续运行。聪明的你可能想问，马上尝试夺回，那别的进程怎么办啊？</p>
<p>仔细看 <code>drop_gil</code> 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> gil.drop_request:</span><br><span class="line">    switch_condition.acquire()</span><br><span class="line">    <span class="keyword">if</span> gil.last_holder == thread_id:</span><br><span class="line">        gil.drop_request = <span class="literal">False</span></span><br><span class="line">        switch_condition.wait()</span><br><span class="line"></span><br><span class="line">    switch_condition.release()</span><br></pre></td></tr></table></figure>

<p>这段代码确保如果，OS分配的下一个线程还是自己，该线程就会被迫等待，确保其他进程有机会被系统的线程调度器分配。</p>
<p>CPython的源码在<a href="https://github.com/python/cpython/blob/master/Python/ceval_gil.h">这里</a></p>
<h2 id="关于GIL的思考"><a href="#关于GIL的思考" class="headerlink" title="关于GIL的思考"></a>关于GIL的思考</h2><p>GIL从1992年诞生到现在，其实经历一些变化。在GIL被设计的年代，多核CPU基本不存在，当时的线程也主要是用来做IO类型的工作，所以GIL的设计处理多线程IO效率非常高。</p>
<p>GIL的存在也让Python的单核性能大大增加，其实GIL是Python成功的一个重要原因。后来GIL加入了 <code>switch_condition</code>, <code>switch_number</code>, <code>timeout</code> 等参数，很大程度改善了多核处理下GIL线程schedule的问题。Python3以后的GIL仍然无法实现真正的CPU密集并行的多线程。不过这里说的线程都是OS线程，这不妨碍实现软件线程。</p>
<p>GIL难以被完全移除有很多原因，比如</p>
<ul>
<li>移除GIL，就需要修改Python的GC机制，特别是reference counting</li>
<li>GIL移除，会降低单核性能。因为移除全局锁，必然要引入粒度更小的锁</li>
<li>可以考虑其他的同步机制，比如Software transactional memory，那么就要修改整个C API，基本上所有的C-API库都废了。。。。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=7RlqbHCCVyc">https://www.youtube.com/watch?v=7RlqbHCCVyc</a></li>
<li><a href="https://www.youtube.com/watch?v=4zeHStBowEk">https://www.youtube.com/watch?v=4zeHStBowEk</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Python/ceval_gil.h">https://github.com/python/cpython/blob/master/Python/ceval_gil.h</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（2）内存管理</title>
    <url>/2021/02/18/python_memory_mgt/</url>
    <content><![CDATA[<h1 id="重新认识-Python（2）：内存管理"><a href="#重新认识-Python（2）：内存管理" class="headerlink" title="重新认识 Python（2）：内存管理"></a>重新认识 Python（2）：内存管理</h1><p>理解内存管理需要知道通常内存使用的基本规则。一般来说，一个进程的内存会被划分成两个部分，堆（heap）和栈（stack）。栈的结构相对简单，本质上就是一个先进后出队列，所有被分配在栈上的值必须是确定大小的、静态的。栈的功能主要是临时存储函数运行时的参数、临时变量和结果。显然，在程序运行的时候，我们需要产生许多大小不固定且动态的值，比如对象、列表、字典等等，这些数据结构不能直接分配到栈上，因此我们需要堆来存放这些值。相应的，堆的内存空间往往比栈大的多。</p>
<p>而我们通常将的内存管理，本质上是堆管理，不是栈管理。</p>
<h2 id="对象，Object"><a href="#对象，Object" class="headerlink" title="对象，Object"></a>对象，Object</h2><p>Python的内存管理主要是针对“一切皆对象”这个设计理念设计的（这里我们仅针对CPython实现展开说明。）。什么是对象，Object？在Python的世界里对象就是任何分配在堆中的值。</p>
<p>在CPython实现中，对象是struct, <code>PyObject</code>，包含四个部分：</p>
<ul>
<li>指向其他对象的指针(用来找到其他的对象)</li>
<li>对象的引用计数器</li>
<li>类型指针</li>
<li>对象的大小（对于大小可变的对象）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>

<p>类型对象也是一个对象，类型对象的类型指针指向他自己。对象一旦分配，他的的类型、size、地址就不能再改变。对于一些size会改变的对象，比如list或者dict，他们实现大小可变的方法是通过指针指向其他对象。</p>
<h2 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h2><p>CPython的内存管理是层状的，主要分成3层：</p>
<ul>
<li>object-specific memory</li>
<li>object memory</li>
<li>raw memory</li>
</ul>
<p>raw memory以下的内存就脱离了Python的控制，移交操作系统控制，如下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Object-specific allocators</span><br><span class="line">    _____   ______   ______       ________</span><br><span class="line">   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |</span><br><span class="line">+3 | &lt;----- Object-specific memory -----&gt; | &lt;-- Non-object memory --&gt; |</span><br><span class="line">    _______________________________       |                           |</span><br><span class="line">   [   Python&#39;s object allocator   ]      |                           |</span><br><span class="line">+2 | ####### Object memory ####### | &lt;------ Internal buffers ------&gt; |</span><br><span class="line">    ______________________________________________________________    |</span><br><span class="line">   [          Python&#39;s raw memory allocator (PyMem_ API)          ]   |</span><br><span class="line">+1 | &lt;----- Python memory (under PyMem manager&#39;s control) ------&gt; |   |</span><br><span class="line">    __________________________________________________________________</span><br><span class="line">   [    Underlying general-purpose allocator (ex: C library malloc)   ]</span><br><span class="line"> 0 | &lt;------ Virtual memory allocated for the python process -------&gt; |</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    _______________________________________________________________________</span><br><span class="line">   [                OS-specific Virtual Memory Manager (VMM)               ]</span><br><span class="line">-1 | &lt;--- Kernel dynamic storage allocation &amp; management (page-based) ---&gt; |</span><br><span class="line">    __________________________________   __________________________________</span><br><span class="line">   [                                  ] [                                  ]</span><br><span class="line">-2 | &lt;-- Physical memory: ROM&#x2F;RAM --&gt; | | &lt;-- Secondary storage (swap) --&gt; |</span><br></pre></td></tr></table></figure>

<p>因为Python的runtime会存在成千上万个Object，但是这些对象通常非常的小，比如int object，runtime必须减少小对象的内存分配代价。基本原理就是通过提前申请，且不轻易交回内存，反复利用已经申请到的内存。对于比较大的对象，超过512kb的对象，Python会直接调用C的内存分配器，直接在堆上申请内存。</p>
<p>下面我们主要介小于512kb的对象的内存管理。</p>
<h2 id="小对象的内存管理"><a href="#小对象的内存管理" class="headerlink" title="小对象的内存管理"></a>小对象的内存管理</h2><p>对于小对象内存，Python主要提供了三类对象进行管理：<code>arena</code>, <code>pool</code>, <code>block</code>。</p>
<ul>
<li>block, 最小内存分配单位，每一个block的大小以8byte为单位，划分为64个组。</li>
<li>pool, 是相同大小block的集合</li>
<li>arena, 每一个大小为256kb，包含64个pool</li>
</ul>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>Block是Python对象内存分配的最小单位，从8byte(或者16byte)到512byte不等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Request in bytes     Size of allocated block      Size class idx</span><br><span class="line">* ----------------------------------------------------------------</span><br><span class="line">*        1-8                     8                       0</span><br><span class="line">*        9-16                   16                       1</span><br><span class="line">*       17-24                   24                       2</span><br><span class="line">*       25-32                   32                       3</span><br><span class="line">*       33-40                   40                       4</span><br><span class="line">*       41-48                   48                       5</span><br><span class="line">*       49-56                   56                       6</span><br><span class="line">*       57-64                   64                       7</span><br><span class="line">*       65-72                   72                       8</span><br><span class="line">*        ...                   ...                     ...</span><br><span class="line">*      497-504                 504                      62</span><br><span class="line">*      505-512                 512                      63</span><br></pre></td></tr></table></figure>

<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p><code>pool</code> 是相同分组（大小） <code>block</code> 的集合。一般，pool的大小为4kb（内存分页的大小），这主要是为了方便处理内存的fragmentation。如果一个对象被回收了，内存管理器可以再次利用这部分内存存储其他合适大小的对象。pool的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool&#x27;s free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       &quot;&quot;        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，每一个pool通过双链表连接在一起，<code>szidx</code> 记录了这个pool下面的block的size，<code>ref.count</code> 记录了已经被使用的blocks，<code>arenaindex</code> 则记录了这个pool所属的 <code>arena</code> 地址。<code>freeblock</code> 是当前可用的第一个block的地址。值得注意的是，如果一个block是空的，那么它会存储下一个空block的地址，这样方便寻址。</p>
<p>每一个pool包含三个状态：</p>
<ul>
<li>used，部分被使用</li>
<li>full，全部被使用</li>
<li>empty，空</li>
</ul>
<p>为了提高寻址效率，Python还维护一个array <code>usedpools</code>, 存储不同分组的pool的头地址。如下：</p>
<p><img src="https://i.imgur.com/Hg7D3Rl.png" alt=""></p>
<p>另外，block和pool不会直接分配内存，他们只是维护内存的数据结构，内存是由 <code>arena</code> 进行分配的。</p>
<h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p><code>Arena</code> 代表了一片大小为256kb的在堆上的内存空间，每一个 arena 包含 64 个pool。arena的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address;</span><br><span class="line">    block* pool_address;</span><br><span class="line">    uint nfreepools;</span><br><span class="line">    uint ntotalpools;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，arena也是被双链表连接在一起，<code>ntotalpools</code>和<code>nfreepool</code>记录了目前可用的pool的信息。</p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h2><p>Python很少会把已经申请的小内存交还给操作系统，而是反复利用已经拥有的内存，以提高内存管理效率。通常一个 <code>arena</code> 只有在其全部pool均为空的情况下，才会被系统回收。这种情况可能发生，比如当你申请了大量小且短命的对象时候，垃圾回收后可能会出现这种完全空的 <code>arena</code>。</p>
<p>另一个角度说，Python进程可能会长期占有一些它不直接需要的内存。</p>
<p>内存使用状况可以通过：<code>sys._debugmallocstats()</code> 查询。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Small block threshold &#x3D; 512, in 32 size classes.</span><br><span class="line"></span><br><span class="line">class   size   num pools   blocks in use  avail blocks</span><br><span class="line">-----   ----   ---------   -------------  ------------</span><br><span class="line">    0     16           6            1484            34</span><br><span class="line">    1     32          58            7247            61</span><br><span class="line">    2     48         175           14654            46</span><br><span class="line">    3     64        1171           73721            52</span><br><span class="line">    4     80        1542           75259          1841</span><br><span class="line">    5     96         478           19851           225</span><br><span class="line">    6    112         184            6554            70</span><br><span class="line">    7    128         154            4766             8</span><br><span class="line">    8    144         950           26272           328</span><br><span class="line">    9    160          75            1812            63</span><br><span class="line">   10    176         405            9183           132</span><br><span class="line">   11    192          45             916            29</span><br><span class="line">   12    208          35             651            14</span><br><span class="line">   13    224          34             603             9</span><br><span class="line">   14    240         118            1876            12</span><br><span class="line">   15    256          29             402            33</span><br><span class="line">   16    272          26             357             7</span><br><span class="line">   17    288          20             277             3</span><br><span class="line">   18    304         157            2034             7</span><br><span class="line">   19    320          18             211             5</span><br><span class="line">   20    336          22             254            10</span><br><span class="line">   21    352          17             181             6</span><br><span class="line">   22    368          15             157             8</span><br><span class="line">   23    384          15             147             3</span><br><span class="line">   24    400          15             143             7</span><br><span class="line">   25    416          21             185             4</span><br><span class="line">   26    432          38             340             2</span><br><span class="line">   27    448          50             446             4</span><br><span class="line">   28    464          45             354             6</span><br><span class="line">   29    480          35             275             5</span><br><span class="line">   30    496          36             279             9</span><br><span class="line">   31    512          47             324             5</span><br><span class="line"></span><br><span class="line"># arenas allocated total           &#x3D;                  167</span><br><span class="line"># arenas reclaimed                 &#x3D;                   69</span><br><span class="line"># arenas highwater mark            &#x3D;                   98</span><br><span class="line"># arenas allocated current         &#x3D;                   98</span><br><span class="line">98 arenas * 262144 bytes&#x2F;arena     &#x3D;           25,690,112</span><br><span class="line"></span><br><span class="line"># bytes in allocated blocks        &#x3D;           23,843,888</span><br><span class="line"># bytes in available blocks        &#x3D;              323,536</span><br><span class="line">236 unused pools * 4096 bytes      &#x3D;              966,656</span><br><span class="line"># bytes lost to pool headers       &#x3D;              289,728</span><br><span class="line"># bytes lost to quantization       &#x3D;              266,304</span><br><span class="line"># bytes lost to arena alignment    &#x3D;                    0</span><br><span class="line">Total                              &#x3D;           25,690,112</span><br><span class="line"></span><br><span class="line">       3 free PyCFunctionObjects * 48 bytes each &#x3D;                  144</span><br><span class="line">           27 free PyDictObjects * 48 bytes each &#x3D;                1,296</span><br><span class="line">           7 free PyFloatObjects * 24 bytes each &#x3D;                  168</span><br><span class="line">          5 free PyFrameObjects * 368 bytes each &#x3D;                1,840</span><br><span class="line">           72 free PyListObjects * 40 bytes each &#x3D;                2,880</span><br><span class="line">         31 free PyMethodObjects * 40 bytes each &#x3D;                1,240</span><br><span class="line"> 102 free 1-sized PyTupleObjects * 32 bytes each &#x3D;                3,264</span><br><span class="line">1998 free 2-sized PyTupleObjects * 40 bytes each &#x3D;               79,920</span><br><span class="line"> 128 free 3-sized PyTupleObjects * 48 bytes each &#x3D;                6,144</span><br><span class="line">   4 free 4-sized PyTupleObjects * 56 bytes each &#x3D;                  224</span><br><span class="line">  25 free 5-sized PyTupleObjects * 64 bytes each &#x3D;                1,600</span><br><span class="line">  25 free 6-sized PyTupleObjects * 72 bytes each &#x3D;                1,800</span><br><span class="line">   3 free 7-sized PyTupleObjects * 80 bytes each &#x3D;                  240</span><br><span class="line">   1 free 8-sized PyTupleObjects * 88 bytes each &#x3D;                   88</span><br><span class="line">   0 free 9-sized PyTupleObjects * 96 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 10-sized PyTupleObjects * 104 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 11-sized PyTupleObjects * 112 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 12-sized PyTupleObjects * 120 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 13-sized PyTupleObjects * 128 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 14-sized PyTupleObjects * 136 bytes each &#x3D;                    0</span><br><span class="line"> 0 free 15-sized PyTupleObjects * 144 bytes each &#x3D;                    0</span><br><span class="line"> 1 free 16-sized PyTupleObjects * 152 bytes each &#x3D;                  152</span><br><span class="line"> 0 free 17-sized PyTupleObjects * 160 bytes each &#x3D;                    0</span><br><span class="line"> 1 free 18-sized PyTupleObjects * 168 bytes each &#x3D;                  168</span><br><span class="line"> 0 free 19-sized PyTupleObjects * 176 bytes each &#x3D;                    0</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/python/cpython/blob/cc54001c2eb3b14320c1667b22602d69c90d5865/Objects/object.c">https://github.com/python/cpython/blob/cc54001c2eb3b14320c1667b22602d69c90d5865/Objects/object.c</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Include/object.h">https://github.com/python/cpython/blob/master/Include/object.h</a></li>
<li><a href="https://github.com/python/cpython/blob/ad051cbce1360ad3055a048506c09bc2a5442474/Objects/obmalloc.c#L534">https://github.com/python/cpython/blob/ad051cbce1360ad3055a048506c09bc2a5442474/Objects/obmalloc.c#L534</a></li>
<li><a href="https://rushter.com/blog/python-memory-managment/">https://rushter.com/blog/python-memory-managment/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识 Python（1）GC，垃圾回收</title>
    <url>/2021/02/16/python_1_gc/</url>
    <content><![CDATA[<h1 id="重新认识-Python（1）：GC，垃圾回收"><a href="#重新认识-Python（1）：GC，垃圾回收" class="headerlink" title="重新认识 Python（1）：GC，垃圾回收"></a>重新认识 Python（1）：GC，垃圾回收</h1><p>Python是目前受众最为广泛的计算机语言之一，涉足的领域包罗万象：Web，机器学习，数据处理，爬虫等等。使用Python的人群也非常多样， 从专业的程序员到数据科学家。这种现状也导致了一个现象：大家对Python存在很多道听途说来的误解。比如，Python是解释型语言（其实python 还真不是，Python是编译型的，只不过他通过解释器执行编译后的代码，其实跟Java一样的，只不过java用虚拟机执行、解释代码），Python非常慢（讲快慢不讲场景都是耍流氓），GIL是垃圾设计（很多人其实不清楚GIL到底是什么？其设计初衷是什么？）， Python的GC很垃圾等等。这些误解通常是因为 Python过于火热，以至于内行、外行都可以随意评论一番，一些误解也就慢慢蔓延开来。我写这个系列的目的就是帮助大家重新认识Python，把 Python当成一个计算机语言，而不是一个工具来认识它。这样不仅会增加对语言本身的理解，也可以提高编写Python代码的质量。</p>
<p>今天我们先来聊一聊Python的GC。(CPython)</p>
<h2 id="Python的内存管理"><a href="#Python的内存管理" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>说GC之前，我们先来看看Python的内存管理。与许多其他语言不同，由于Python中的所有值都是一个对象，object，所以Python程序运行的时候会产生数量众多但是体积很小的对象。因此，Python通常不会把已经申请的内存交还给操作系统，他会为每一个小于512byte的对象分配一个专门的allocator并且不会释放这些内存，方便以后继续使用。Python的很多内存直到进程结束才会释放给系统。</p>
<p>即使我们运行一个简单的包含第三方库的程序，进程中可能存在上百万个对象，但是他们的体积通常都非常小。正是因为这种对象管理模式，才能支持了Python的很多运行时的动态特性，也正是因为这些特征，Python才变得的如此灵活（当然，灵活的代价是牺牲一些性能）。</p>
<p>知道了Python的内存管理特性，我们就可以进一步理解Python的GC设计了。你会发现，很多设计就是为了支持这种内存管理模式而出现的。</p>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>Python的设计其实非常的和谐，一切皆对象。就连一个int也不例外，比如你可以打印整数1的对象id：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 4419605632</span></span><br></pre></td></tr></table></figure>

<p>上面我们提到一个简单的Python进程中可能存在成千上万的大大小小的对象，为他们分配内存通常很简单，但是回收这些内存就需要更多的心思了，因为一旦回收了还在使用的对象的内存就会导致程序崩溃。</p>
<p>Python的 GC 其实包含两个部分：Reference Counting 和 Generational cyclic GC。引用计数高效，但是却存在一个致命的问题：无法检测循环引用。所以必须使用额外的垃圾回收机制，Cpython选择了generational GC。</p>
<p>值得注意的是，引用计数算法是不可以认为干预的，完全由Python的运行时控制，而generational GC可以通过<code>gc module</code>认为控制。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数其实是解决GC超多对象垃圾回收简单且高效的方法！引用计数的原理很简单，python的运行时会追踪每一个object的reference counter，当reference counter 归零的时候，这个对象的内存就会被回收。</p>
<p>Python中所有的变量其实都是一个引用或者说指针，指向对应的对象。比如赋值语句会增加对象的引用，而一个对象可以拥有来自多个变量的引用。</p>
<p>Python中有三种方式可以增加引用：</p>
<ul>
<li>赋值</li>
<li>传参</li>
<li>把对象放入容器，比如list</li>
</ul>
<p>当一个对象的引用归零，如果它包含对其他对象的引用，其他对象的引用也会减少，如果其他对象的引用也因此归零，那么这个对象也会被回收。值得注意的是，被全局变量引用的对象，不会被回收。可以通过 <code>global()</code> 函数查看全局变量。</p>
<p>对于局部变量，即定义在函数内部的变量，当Python的解释器退出函数时，会移除这些变量对对象的引用，但不会删除对象。所以，<strong>Python只有在退出函数或者对一个变量重新赋值的时候，才可能会进行垃圾回收（引用计数GC）！</strong>，换句话说，如果你有一个超长的函数，内部超多产生了超多对象，Python是无法进行GC的，所以，应该尽量写精简的函数。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">foo = []</span><br><span class="line"><span class="comment"># 2 references, 1 from the foo var and 1 from getrefcount</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(foo))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="comment"># 4 references</span></span><br><span class="line">    <span class="comment"># from the foo var, function argument, getrefcount and Python&#x27;s function stack</span></span><br><span class="line">    <span class="built_in">print</span>(sys.getrefcount(a))</span><br><span class="line"></span><br><span class="line">bar(foo)</span><br><span class="line"><span class="comment"># 2 references, the function scope is destroyed</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(foo))</span><br></pre></td></tr></table></figure>

<p>随便说一下，Python （cpython）无法轻易移除 GIL 的一个主要原因也是因为引用计数GC，因为多线程会搞乱引用计数。</p>
<h3 id="Generational-GC，-GGC"><a href="#Generational-GC，-GGC" class="headerlink" title="Generational GC， GGC"></a>Generational GC， GGC</h3><p>那么Python为什么还有第二套GC算法呢？这主要是因为引用计数无法处理循环引用或者自引用的情况。这两种情况都会让对象的引用数量至少维持在1，进而无法被GC。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># We use ctypes moule  to access our unreachable objects by memory address.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyObject</span>(<span class="params">ctypes.Structure</span>):</span></span><br><span class="line">    _fields_ = [(<span class="string">&quot;refcnt&quot;</span>, ctypes.c_long)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gc.disable()  <span class="comment"># Disable generational gc</span></span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">lst.append(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store address of the list</span></span><br><span class="line">lst_address = <span class="built_in">id</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Destroy the lst reference</span></span><br><span class="line"><span class="keyword">del</span> lst</span><br><span class="line"></span><br><span class="line">object_1 = &#123;&#125;</span><br><span class="line">object_2 = &#123;&#125;</span><br><span class="line">object_1[<span class="string">&#x27;obj2&#x27;</span>] = object_2</span><br><span class="line">object_2[<span class="string">&#x27;obj1&#x27;</span>] = object_1</span><br><span class="line"></span><br><span class="line">obj_address = <span class="built_in">id</span>(object_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Destroy references</span></span><br><span class="line"><span class="keyword">del</span> object_1, object_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment if you want to manually run garbage collection process </span></span><br><span class="line"><span class="comment"># gc.collect()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check the reference count</span></span><br><span class="line"><span class="built_in">print</span>(PyObject.from_address(obj_address).refcnt)</span><br><span class="line"><span class="built_in">print</span>(PyObject.from_address(lst_address).refcnt)</span><br></pre></td></tr></table></figure>

<p>上面的例子中， <code>del</code> 会移除变量对对象的引用，执行del以后，这个对象已经无法被系统的其他部分引用，但是，由于存在自引用，该对象无法被回收。为了解决这个问题，Python在1.5以后引入了GGC，专门处理这种情况。值得注意的是，循环引用只会出现在容器变量中，比如list，dict，自定义对象等等，因此GGC不会追踪不可变对象（除了Tuple）。</p>
<p>GGC不是实时进行的，而是周期性的触发。GGC会将所有的容器类型对象分成3代。新建立的对象首先进入第一代，如果它没有被第一次GC回收，这个对象会进入第二代，一次类推。而GGC会优先回收第一代的内存，假设新建的对象会更快的结束自己的生命。通过这种机制，提高GC性能，缩短系统暂停的时间。</p>
<p>那么GGC的触发机制是什么呢？我们提到GC会把对象分为三代，每一代都有自己的计数器和一个阈值。计数器存储自上一次GC以后，新分配的对象数量，减去回收的数量。每次系统分配新的内存时，会检查计数器是否超过阈值，如果是会出发GC。</p>
<p>如果检查时，超过2代达到阈值，GGC会选择更加古老的一代进行回收。因为老一代的对象是从新的一代过度进来的。但是，第三代的内存回收会做特别处理[3]，为了减少性能损失。</p>
<p>默认的设置是700，10，10。可以通过 <code>gc.get_threshold</code>查看每一代的阈值。</p>
<h2 id="如何利用GC？"><a href="#如何利用GC？" class="headerlink" title="如何利用GC？"></a>如何利用GC？</h2><p>了解GC的原理是为了更好的利用GC。比如对于GGC，我们可以根据情况停止gc，以提高性能。</p>
<p>我们可以通过利用 <code>weakref</code> 来引用一些临时且不重要的对象，比如cache，这样GC可以任意回收他们。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/3.6/c-api/intro.html#objects-types-and-reference-counts">https://docs.python.org/3.6/c-api/intro.html#objects-types-and-reference-counts</a></li>
<li><a href="https://rushter.com/blog/python-garbage-collector/">https://rushter.com/blog/python-garbage-collector/</a></li>
<li><a href="https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94">https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>SICP</title>
    <url>/2020/12/25/sicp_overview/</url>
    <content><![CDATA[<p><strong>SICP quick overview</strong></p>
<h1 id="Building-Abstraction-with-Procedures"><a href="#Building-Abstraction-with-Procedures" class="headerlink" title="Building Abstraction with Procedures"></a>Building Abstraction with Procedures</h1><h2 id="The-Elements-of-Programming"><a href="#The-Elements-of-Programming" class="headerlink" title="The Elements of Programming"></a>The Elements of Programming</h2><p>Three machanisms of powerful language:</p>
<ul>
<li>primitive expression, the simplest entities the language is concerned with</li>
<li>means of combination, compound elements are built from simpler ones</li>
<li>means of abstraction, compound elements can be named and manipulated as units</li>
</ul>
<p>Two elements in programming (maybe just one): data and procedures.</p>
<p><code>define</code> is the simplest means of abstraction. </p>
<p><code>environment</code> the memory to keep track name-value bindings.</p>
<h3 id="Evaluating-Combinations"><a href="#Evaluating-Combinations" class="headerlink" title="Evaluating Combinations"></a>Evaluating Combinations</h3><p>General rule of evaluation of combinations:</p>
<ol>
<li>Evaluate the sub-expression of the combinations</li>
<li>Apply the procedure: value of leftmost sub-expression to the arguments that are the value s of the other sub-expressions</li>
</ol>
<p><code>(define x 3)</code> is not a combination, which is not handled by above.<br>These kind of exceptions are <em>special forms</em>. Special forms have their<br>own evaluation rules.</p>
<h3 id="Compound-Procedures"><a href="#Compound-Procedures" class="headerlink" title="Compound Procedures"></a>Compound Procedures</h3><p><code>(define (square x) (* x x))</code><br>in the form of<br><code>(define (&lt;name&gt; &lt;parameters&gt;) (body))</code></p>
<p>we can now compound to more complex procedures:<br><code>(define (sum-of-square x y) (+ (square x) (square y)))</code>. </p>
<p>From now on, compound procedures are as same as primitive procedures.</p>
<h3 id="Substitution-Model-for-Procedure-Application"><a href="#Substitution-Model-for-Procedure-Application" class="headerlink" title="Substitution Model for Procedure Application"></a>Substitution Model for Procedure Application</h3><p>The application process is:</p>
<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</p>
</blockquote>
<p>This is the meaning of procedure application. <strong>But this is not necessarily how the program is executed.</strong></p>
<p>(Applicative-order evaluation) The interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.<br>(Normal-order evaluation) An alternative evaluation model would not evaluate the operands until their values were needed.</p>
<h3 id="Conditional-Expressions"><a href="#Conditional-Expressions" class="headerlink" title="Conditional Expressions"></a>Conditional Expressions</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line"> (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> x <span class="number">0</span>) x)</span><br><span class="line">       ((<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">       ((<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>) (<span class="name"><span class="builtin-name">-</span></span> x)))</span><br></pre></td></tr></table></figure>

<p>More examples:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">a-plus-abs-b</span> a b) ((<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> b <span class="number">0</span>) + -) a b))</span><br></pre></td></tr></table></figure>


<h2 id="Procedures-and-the-Processes-generated"><a href="#Procedures-and-the-Processes-generated" class="headerlink" title="Procedures and the Processes generated"></a>Procedures and the Processes generated</h2><blockquote>
<p>The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer</p>
</blockquote>
<blockquote>
<p>A procedure is a pattern for the local evolution of a computational process.</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n) </span><br><span class="line"> (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure>

<p>vs </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n) (<span class="name">fact-iter</span> <span class="number">1</span> <span class="number">1</span> n))</span><br><span class="line">(<span class="name">define</span> (<span class="name">fact-iter</span> product counter max-count) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> counter max-count)</span><br><span class="line">product</span><br><span class="line">(<span class="name">fact-iter</span> (<span class="name"><span class="builtin-name">*</span></span> counter product)</span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> counter <span class="number">1</span>) max-count)))</span><br></pre></td></tr></table></figure>

<p>Here are some common pattern of computations.</p>
<h3 id="Linear-Recursion-and-Iteration"><a href="#Linear-Recursion-and-Iteration" class="headerlink" title="Linear Recursion and Iteration"></a>Linear Recursion and Iteration</h3><p>The two procedures aim the same goal but the processes they generate<br>have different evaluation shapes. One is a linear recursive process,<br>and one is a linear iterative process.</p>
<blockquote>
<p>The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point.</p>
</blockquote>
<p>Note that, recursive procedure does not mean it will generate a recursive evaluation process (tail recursion for example). </p>
<h3 id="Tree-Recursion"><a href="#Tree-Recursion" class="headerlink" title="Tree Recursion"></a>Tree Recursion</h3><p>Use transform can change a tree recursion to an iterative one.</p>
<h3 id="Order-of-Growth"><a href="#Order-of-Growth" class="headerlink" title="Order of Growth"></a>Order of Growth</h3><p>Orders of growth provide only a crude description of the behavior of a process.</p>
<h3 id="Exponentiation"><a href="#Exponentiation" class="headerlink" title="Exponentiation"></a>Exponentiation</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">expt</span> b n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name">expt</span> b (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">expt1</span> b n)</span><br><span class="line">  (<span class="name">expt-iter</span> b n <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">expt-iter</span> b counter product)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> counter <span class="number">0</span>)</span><br><span class="line">      product</span><br><span class="line">      (<span class="name">expt-iter</span> b</span><br><span class="line">                 (<span class="name"><span class="builtin-name">-</span></span> counter <span class="number">1</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">*</span></span> b product))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">fast-expt</span> b n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">even?</span></span> n) (<span class="name">square</span> (<span class="name">fast-expt</span> b (/ n <span class="number">2</span>))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name">fast-expt</span> b (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name"><span class="builtin-name">even?</span></span> n)</span><br><span class="line">(<span class="name"><span class="builtin-name">=</span></span> (<span class="name">remainder</span> n <span class="number">2</span>) <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">square</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> n n))</span><br></pre></td></tr></table></figure>
<h2 id="Formulating-Abstractions-with-Higher-order-Functions"><a href="#Formulating-Abstractions-with-Higher-order-Functions" class="headerlink" title="Formulating Abstractions with Higher-order Functions"></a>Formulating Abstractions with Higher-order Functions</h2><p>Procedures are abstractions that describe compound operations.</p>
<h3 id="Procedures-as-Arguments"><a href="#Procedures-as-Arguments" class="headerlink" title="Procedures as Arguments"></a>Procedures as Arguments</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; Procedures as Arguments</span></span><br><span class="line"><span class="comment">;; (define (inc n) (+ n 1))</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum</span> term a next b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">term</span> a)</span><br><span class="line">         (<span class="name">sum</span> term (<span class="name"><span class="builtin-name">next</span></span> a) next b))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-iter</span> term a next b)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> a result)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        result</span><br><span class="line">        (<span class="name">iter</span> (<span class="name"><span class="builtin-name">next</span></span> a) (<span class="name"><span class="builtin-name">+</span></span> result (<span class="name">term</span> a)))))</span><br><span class="line">  (<span class="name">iter</span> a <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p><code>lambda</code> function is useful. <code>let</code> is useful to create local variables.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((⟨var1⟩ ⟨exp1⟩) (⟨var2⟩ ⟨exp2⟩)</span><br><span class="line">...</span><br><span class="line">(⟨varn⟩ ⟨expn⟩)) ⟨body⟩)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Procedures-as-General-Methods"><a href="#Procedures-as-General-Methods" class="headerlink" title="Procedures as General Methods"></a>Procedures as General Methods</h3><h3 id="Procedures-as-Return-Values"><a href="#Procedures-as-Return-Values" class="headerlink" title="Procedures as Return Values"></a>Procedures as Return Values</h3><p>Elements with the fewest restrictions are said to have first-class status. Some of the “rights and privileges” of first-class elements are:</p>
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to procedures.</li>
<li>They may be returned as the results of procedures.</li>
<li>They may be included in data structures.</li>
</ul>
<h1 id="Building-Abstractions-with-Data"><a href="#Building-Abstractions-with-Data" class="headerlink" title="Building Abstractions with Data"></a>Building Abstractions with Data</h1><p>After compound procedures, we build abstractions by compounding data.</p>
<blockquote>
<p>Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
</blockquote>
<p>The notion of <code>closure</code> is one of the key ideas dealing with compound<br>data. Another idea is <code>conventional interfaces</code> to combine program module in mix-and-match ways. </p>
<p>Data may be represented differently by different parts of program, this leads to <code>generic operations</code>. </p>
<h2 id="Introduction-of-Data-Abstraction"><a href="#Introduction-of-Data-Abstraction" class="headerlink" title="Introduction of Data Abstraction"></a>Introduction of Data Abstraction</h2><p><code>selector</code> and <code>constructor</code> as interface of abstract data.<br>Sometime, we also need <code>predicates</code>.</p>
<p>Example of rational number data abstraction: </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-rat</span> n d) (<span class="name"><span class="builtin-name">cons</span></span> n d))</span><br><span class="line">(<span class="name">define</span> (<span class="name">numer</span> x) (<span class="name">car</span> x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">denom</span> x) (<span class="name">cdr</span> x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">print-tar</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">  (<span class="name">display</span> (<span class="name">numer</span> x))</span><br><span class="line">  (<span class="name">display</span> <span class="string">&quot;/&quot;</span>)</span><br><span class="line">  (<span class="name">display</span> (<span class="name">denom</span> x)))</span><br></pre></td></tr></table></figure>
<p>The horizontal lines represent <code>abstraction barrier</code>.</p>
<p><img src="https://i.imgur.com/jBwpFte.png" alt=""></p>
<h3 id="What-is-Meant-by-Data"><a href="#What-is-Meant-by-Data" class="headerlink" title="What is Meant by Data??"></a>What is Meant by Data??</h3><p>In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.</p>
<h2 id="Hierarchical-Data-and-the-Closure-Property"><a href="#Hierarchical-Data-and-the-Closure-Property" class="headerlink" title="Hierarchical Data and the Closure Property"></a>Hierarchical Data and the Closure Property</h2><p>THe ability to create pairs whose elements are pairs is the essence of list structure’s importance as a representational tool. This is called <code>closure property</code>: an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.</p>
<blockquote>
<p> very simplest programs rely on the fact that the elements of a combination can themselves be combinations.</p>
</blockquote>
<p>With pairs we could build a lot of stuff.</p>
<h3 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; Sequences</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">list-ref</span> items n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name">car</span> items)</span><br><span class="line">      (<span class="name">list-ref</span> (<span class="name">cdr</span> items) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name"><span class="builtin-name">map</span></span> proc items)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">null?</span> items)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">proc</span> (<span class="name">car</span> items))</span><br><span class="line">            (<span class="name"><span class="builtin-name">map</span></span> proc (<span class="name">cdr</span> items)))))</span><br></pre></td></tr></table></figure>

<h3 id="Hierarchical-Structures"><a href="#Hierarchical-Structures" class="headerlink" title="Hierarchical Structures"></a>Hierarchical Structures</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">count-leaves</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">null?</span> x) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name">pair?</span> x)) <span class="number">1</span>)</span><br><span class="line">        (<span class="name">else</span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">count-leaves</span> (<span class="name">car</span> x))</span><br><span class="line">                 (<span class="name">count-leaves</span> (<span class="name">cdr</span> x))))))</span><br></pre></td></tr></table></figure>

<h3 id="Sequences-as-Conventional-Interfaces"><a href="#Sequences-as-Conventional-Interfaces" class="headerlink" title="Sequences as Conventional Interfaces"></a>Sequences as Conventional Interfaces</h3><p><code>Conventional Interfaces</code> is anther powerful design tool other than data abstraction. </p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> low high)</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> low (<span class="name">enumerate-interval</span> (<span class="name"><span class="builtin-name">+</span></span> low <span class="number">1</span>) high))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">enumerate-tree</span> tree)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">null?</span> tree) <span class="literal">nil</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name">pair?</span> tree)) (<span class="name"><span class="builtin-name">list</span></span> tree))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">append</span> (<span class="name">enumerate-tree</span> (<span class="name">car</span> tree))</span><br><span class="line">                      (<span class="name">enumerate-tree</span> (<span class="name">cdr</span> tree))))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">null?</span> sequence)</span><br><span class="line">      initial</span><br><span class="line">      (<span class="name">op</span> (<span class="name">car</span> sequence)</span><br><span class="line">          (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</span><br></pre></td></tr></table></figure>

<h3 id="Example-the-Picture-Language"><a href="#Example-the-Picture-Language" class="headerlink" title="Example: the Picture Language"></a>Example: the Picture Language</h3><p>Good designs:</p>
<ul>
<li>Use data abstractions</li>
<li>The means of combination satisfy the closure property</li>
<li>With above, all the tools for abstracting procedures are available now</li>
<li>complex system should be structured as a sequence of levels.</li>
</ul>
<p>The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail. This is called <code>Stratified design</code>.</p>
<h2 id="Symbolic-Data"><a href="#Symbolic-Data" class="headerlink" title="Symbolic Data"></a>Symbolic Data</h2><p>Another type of data, Symbols, which is not numbers.<br>In order to manipulate symbols we need a new element in our language: the ability to <code>quote</code> a data object.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">list</span></span> &#x27;a &#x27;b &#x27;c)</span><br><span class="line">(<span class="name">cdr</span> &#x27;((<span class="name">x1</span> x2) (<span class="name">y1</span> y2)))</span><br><span class="line">(<span class="name">cadr</span> &#x27;((<span class="name">x1</span> x2) (<span class="name">y1</span> y2)))</span><br><span class="line">(<span class="name">pair?</span> (<span class="name">car</span> &#x27;(<span class="name">a</span> short list)))</span><br></pre></td></tr></table></figure>

<h3 id="Example-Symbolic-Differentiation"><a href="#Example-Symbolic-Differentiation" class="headerlink" title="Example: Symbolic Differentiation"></a>Example: Symbolic Differentiation</h3><p>First, work out the data abstractions needed: <code>constructor</code>, <code>selector</code>, and <code>predicator</code>. </p>
<p>Then define the procedure to do derive on above data abstraction.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">deriv</span> exp var) (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">number?</span></span> exp) <span class="number">0</span>)</span><br><span class="line">((<span class="name">variable?</span> exp) (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">same-variable?</span> exp var) <span class="number">1</span> <span class="number">0</span>)) ((<span class="name">sum?</span> exp) (<span class="name">make-sum</span> (<span class="name">deriv</span> (<span class="name">addend</span> exp) var)</span><br><span class="line">                              (<span class="name">deriv</span> (<span class="name">augend</span> exp) var)))</span><br><span class="line">((<span class="name">product?</span> exp) (<span class="name">make-sum</span></span><br><span class="line">(<span class="name">make-product</span> (<span class="name">multiplier</span> exp)</span><br><span class="line">(<span class="name">deriv</span> (<span class="name">multiplicand</span> exp) var))</span><br><span class="line">(<span class="name">make-product</span> (<span class="name">deriv</span> (<span class="name">multiplier</span> exp) var) (<span class="name">multiplicand</span> exp))))</span><br><span class="line">(<span class="name">else</span></span><br><span class="line">(<span class="name">error</span> <span class="string">&quot;unknown expression type: DERIV&quot;</span> exp))))</span><br></pre></td></tr></table></figure>

<h2 id="Multiple-Representations-for-Abstract-Data"><a href="#Multiple-Representations-for-Abstract-Data" class="headerlink" title="Multiple Representations for Abstract Data"></a>Multiple Representations for Abstract Data</h2><p>There might be more than one useful representation for a data object, and we might like to design systems that can deal with multiple representations. </p>
<p>So in addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program. </p>
<p>In addition, we need to make the system more additive.</p>
<p>To achieve above, we need a new tool <code>generic procedure</code>. Type tags and data-directed style enable this.</p>
<h3 id="Example-Complex-number"><a href="#Example-Complex-number" class="headerlink" title="Example: Complex-number"></a>Example: Complex-number</h3><p><img src="https://i.imgur.com/08f8LQm.png" alt=""></p>
<p>But we soon realized that, using type tag make the system not additive!<br>And this kind of system is hard to maintain.</p>
<p>NOT A GOOD DESIGN!</p>
<p>Here is Table of operations for the complex-number system:</p>
<p><img src="https://i.imgur.com/1UiVC6S.png" alt=""></p>
<p>Data-directed programming is the technique of designing programs to work with such a table directly. If we do this, then to add a new representation package to the system we need not change any existing procedures; we need only add new entries to the table.</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">apply-generic</span> op . args)</span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">type-tags</span> (<span class="name"><span class="builtin-name">map</span></span> type-tag args)))</span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">proc</span> (<span class="name"><span class="builtin-name">get</span></span> op type-tags))) (<span class="name"><span class="builtin-name">if</span></span> proc</span><br><span class="line">          (<span class="name"><span class="builtin-name">apply</span></span> proc (<span class="name"><span class="builtin-name">map</span></span> contents args))</span><br><span class="line">          (<span class="name">error</span> <span class="string">&quot;No method for these types: APPLY-GENERIC&quot;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">list</span></span> op type-tags))))))</span><br><span class="line"><span class="comment">;; selectors with generics</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">real-part</span> z) (<span class="name">apply-generic</span> &#x27;real-part z))</span><br><span class="line">(<span class="name">define</span> (<span class="name">imag-part</span> z) (<span class="name">apply-generic</span> &#x27;imag-part z)) </span><br><span class="line">(<span class="name">define</span> (<span class="name">magnitude</span> z) (<span class="name">apply-generic</span> &#x27;magnitude z)) </span><br><span class="line">(<span class="name">define</span> (<span class="name">angle</span> z)     (<span class="name">apply-generic</span> &#x27;angle z))</span><br></pre></td></tr></table></figure>

<p>In effect, this decomposes the operation-and-type table into rows, with each generic operation procedure representing a row of the table.</p>
<p>An alternative implementation strategy is to decompose the table into columns. This style is called <code>message passing</code>.</p>
<h2 id="Systems-with-Generic-Operations"><a href="#Systems-with-Generic-Operations" class="headerlink" title="Systems with Generic Operations"></a>Systems with Generic Operations</h2><h3 id="Generic-Arithmetic-Operations"><a href="#Generic-Arithmetic-Operations" class="headerlink" title="Generic Arithmetic Operations"></a>Generic Arithmetic Operations</h3><p><img src="https://i.imgur.com/Yf6vQCg.png" alt=""></p>
<p>The generic arithmetic procedures are defined as</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">add</span> x y) (<span class="name">apply-generic</span> &#x27;add x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">sub</span> x y) (<span class="name">apply-generic</span> &#x27;sub x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">mul</span> x y) (<span class="name">apply-generic</span> &#x27;mul x y))</span><br><span class="line">(<span class="name">define</span> (<span class="name">div</span> x y) (<span class="name">apply-generic</span> &#x27;div x y))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">install-scheme-number-package</span>)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">tag</span> x) (<span class="name">attach-tag</span> &#x27;scheme-number x)) </span><br><span class="line">  (<span class="name">put</span> &#x27;add &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">+</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;sub &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">-</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;mul &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (<span class="name"><span class="builtin-name">*</span></span> x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;div &#x27;(<span class="name">scheme-number</span> scheme-number)</span><br><span class="line">       (<span class="name">lambda</span> (<span class="name">x</span> y) (<span class="name">tag</span> (/ x y))))</span><br><span class="line">  (<span class="name">put</span> &#x27;make &#x27;scheme-number (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">tag</span> x))) &#x27;done)</span><br></pre></td></tr></table></figure>

<p>In the end, we need a two level tag system for complex number.</p>
<h3 id="Combining-Data-of-Different-Types"><a href="#Combining-Data-of-Different-Types" class="headerlink" title="Combining Data of Different Types"></a>Combining Data of Different Types</h3><p>We would like to introduce the cross-type operations in some carefully controlled way, so that we can support them without seriously violating our module boundaries.</p>
<p>One strategy could be making a type transfer of types if possible.</p>
<p>Or we could build a hierachies of type.</p>
<h3 id="Example-Symbolic-Algebra"><a href="#Example-Symbolic-Algebra" class="headerlink" title="Example: Symbolic Algebra"></a>Example: Symbolic Algebra</h3><p>TODO.</p>
<h1 id="Modularity-Objects-and-State"><a href="#Modularity-Objects-and-State" class="headerlink" title="Modularity, Objects, and State"></a>Modularity, Objects, and State</h1><p>Procedure and Data abstractions are powerful tools to deal with complex systems, but not enough. We need organizational principles that can guide us in formulating the overall design of a program.</p>
<p>Two prominent organizational strategies: objects and streams.</p>
<p>With objects, we must be concerned with how a computational object can change and yet maintain its identity. The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation.This essentially a environmental model instead of substitution model.</p>
<p><strong>object</strong>, viewing a large system as a collection of distinct objects whose behaviors may change over time. </p>
<p><strong>stream</strong>, viewing streams of information flow in the system. </p>
<p>While using object to model state come with a price because it couples time and data at the same time. And <code>Stream</code> is a solution.</p>
<h2 id="Assignment-and-Local-State"><a href="#Assignment-and-Local-State" class="headerlink" title="Assignment and Local State"></a>Assignment and Local State</h2><p>Two new operators are needed in order to mantain local state and assignment.<br><code>(set! &lt;name&gt; &lt;new-value&gt;)</code> and <code>(begin &lt;exp1&gt; &lt;exp1&gt; ...)</code>. The value of <code>begin</code> is the value of last expression. The we can use <code>let</code> to create some local variable in the procedure:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> new-withdraw </span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">balance</span> <span class="number">100</span>))</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">        (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount)) balance)</span><br><span class="line">        <span class="string">&quot;Insufficient funds&quot;</span>))))</span><br></pre></td></tr></table></figure>

<p>Then we can have a procedure to create objects:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">      (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount))</span><br><span class="line">             balance)</span><br><span class="line">      <span class="string">&quot;Insufficient funds&quot;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>With these techniques, we can create complex objects with more methods and local variable:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance) </span><br><span class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount) </span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> balance amount)</span><br><span class="line">      (<span class="name">begin</span> (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount)) balance)</span><br><span class="line">      <span class="string">&quot;Insufficient funds&quot;</span>))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">+</span></span> balance amount))</span><br><span class="line">    balance)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">eq?</span> m &#x27;withdraw) withdraw)</span><br><span class="line">          ((<span class="name">eq?</span> m &#x27;deposit) deposit)</span><br><span class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">&quot;Unknown request: MAKE-ACCOUNT&quot;</span></span><br><span class="line">                       m))))</span><br><span class="line">  dispatch)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as functional programming. In contrast to functional programming, programming that makes ex- tensive use of assignment is known as imperative programming. </p>
</blockquote>
<p>As soon as we introduce assignment, a variable can no longer be simply a name. Now a variable somehow refers to a place where a value can be stored, and the value stored at this place can change. And the place is the environment.</p>
<p>A language that supports the concept that “equals can be substituted for equals” in an expression without changing the value of the expression is said to be referentially transparent. </p>
<h2 id="Environment-Model-of-Evaluation"><a href="#Environment-Model-of-Evaluation" class="headerlink" title="Environment Model of Evaluation"></a>Environment Model of Evaluation</h2><p>An environment is a sequence of frames. Each frame is a table (possibly empty) of bindings, which associate variable names with their corresponding values.</p>
<p>In the environment model of evaluation, a procedure is always a pair consisting of some code and a pointer to an environment.</p>
<p>The environment model of procedure application can be summa- rized by two rules:</p>
<ul>
<li>apply rule,  is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the proce- dure in the context of the new environment constructed</li>
<li>creation rule, created by evaluating a λ-expression relative to a given environment.</li>
</ul>
<h2 id="Modeling-with-Mutable-Data"><a href="#Modeling-with-Mutable-Data" class="headerlink" title="Modeling with Mutable Data"></a>Modeling with Mutable Data</h2><p>To model data that can change, we need not only <code>constructor</code> and <code>selector</code>, but also <code>moutator</code>. Data objects for which mutators are defined are known as mutable data objects.</p>
<p>We introduce two primitives, which are similar to <code>cons</code>, <code>car</code>, and <code>cdr</code>: <code>set-car!</code> and <code>set-cdr!</code>.</p>
<p>Just like pairs can be represented purely by procedures, mutation is just assignment.</p>
<h3 id="Example-Digital-Circuits"><a href="#Example-Digital-Circuits" class="headerlink" title="Example: Digital Circuits"></a>Example: Digital Circuits</h3><p>TODO:</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p>Before we introduced assignment, all our programs were timeless, in the sense that any expression that has a value always has the same value.</p>
<p>So it is often natural to model systems as collections of computational processes that execute concurrently.<br>Just as we can make our programs modular by organizing models in terms of objects with separate local state, it is often appropriate to divide computational models into parts that evolve separately and concurrently.</p>
<p>One possible restriction on concurrency would stipulate that no two operations that change any shared state variables can occur at the same time.<br>A less stringent restriction on concurrency would ensure that a concurrent system produces the same result as if the processes had run sequentially in some order.</p>
<h3 id="Mechanisms-for-Controlling-Concurrency"><a href="#Mechanisms-for-Controlling-Concurrency" class="headerlink" title="Mechanisms for Controlling Concurrency"></a>Mechanisms for Controlling Concurrency</h3><p>We’ve seen that the difficulty in dealing with concurrent processes is rooted in the need to consider the interleaving of the order of events in the different processes. </p>
<p>A more practical approach to the design of concurrent systems is to devise general mechanisms that allow us to constrain the interleaving of concurrent processes.</p>
<p>For example <code>serilizing</code>: Serialization implements the following idea: Processes will execute con- currently, but there will be certain collections of procedures that cannot be executed concurrently. We implement serializers in terms of a more primitive synchronization mechanism called a mutex.</p>
<blockquote>
<p>The complexities we encounter in dealing with time and state in our computational models may in fact mirror a fundamental complexity of the physical universe.</p>
</blockquote>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="Streams-Are-Delayed-Lists"><a href="#Streams-Are-Delayed-Lists" class="headerlink" title="Streams Are Delayed Lists"></a>Streams Are Delayed Lists</h3><p>Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists.<br>The key modularity issue was that we wished to hide the internal state.</p>
<h1 id="Metalinguistic-Abstraction"><a href="#Metalinguistic-Abstraction" class="headerlink" title="Metalinguistic Abstraction"></a>Metalinguistic Abstraction</h1><p>Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that suitable to the problem at hand.</p>
<h2 id="The-Metacircular-Evaluator"><a href="#The-Metacircular-Evaluator" class="headerlink" title="The Metacircular Evaluator"></a>The Metacircular Evaluator</h2><p>An evaluator that is written in the same language that it evaluates is said to be metacircular.</p>
<p>Here we talk about a Scheme formulation of the environment model of evaulation. Recall that the model has two parts:</p>
<ol>
<li>Evulation</li>
<li>Application</li>
</ol>
<p>This is basically <code>eval</code> and <code>apply</code>. </p>
<p>We will use <strong>data abstraction</strong> to make the evaluator independent of the representation of the language.</p>
<h3 id="The-core-of-evaluator"><a href="#The-core-of-evaluator" class="headerlink" title="The core of evaluator"></a>The core of evaluator</h3><p><strong><code>eval</code></strong>: takes an expression and an environment.</p>
<p>Rules:</p>
<ul>
<li>Primitives expression<ul>
<li>self-evaluting expression -&gt; self</li>
<li>lookup value in the environment</li>
</ul>
</li>
<li>Special forms<ul>
<li>quoted expression -&gt; expression that was qouted </li>
<li>assignment</li>
<li>if</li>
<li>lambda</li>
<li>begin</li>
<li>case</li>
</ul>
</li>
<li>Combinations<ul>
<li>procedure application </li>
</ul>
</li>
</ul>
<p><strong><code>apply</code></strong>: takes a procedure and a list of argments.</p>
<ul>
<li>primitive procedures</li>
<li>compound procedures</li>
</ul>
<h3 id="Variations-on-a-Scheme-—-Lazy-Evaluation"><a href="#Variations-on-a-Scheme-—-Lazy-Evaluation" class="headerlink" title="Variations on a Scheme — Lazy Evaluation"></a>Variations on a Scheme — Lazy Evaluation</h3><h4 id="Normal-Order-and-Applicative-Order"><a href="#Normal-Order-and-Applicative-Order" class="headerlink" title="Normal Order and Applicative Order"></a>Normal Order and Applicative Order</h4><h1 id="Computing-with-Register-Machines"><a href="#Computing-with-Register-Machines" class="headerlink" title="Computing with Register Machines"></a>Computing with Register Machines</h1><blockquote>
<p>A more primitive level than Lisp itself.</p>
</blockquote>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>SICP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020总结</title>
    <url>/2020/12/24/summary_2020/</url>
    <content><![CDATA[<h1 id="2020-年总结"><a href="#2020-年总结" class="headerlink" title="2020 年总结"></a>2020 年总结</h1><h2 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h2><p>今年对世界很独特。2020年1月，新冠（COVID-19）在武汉首先爆发，3月疫情拓展至美国、英国、欧洲等世界各地。在我写下这篇博客的时候，中国的疫情已经得到了完全控制，而欧洲、美国正处在新兴变种病毒的第三波高峰期。</p>
<p><img src="https://i.imgur.com/v3YNSlk.png" alt="日新增病例"></p>
<p>在新冠疫情的影响下，美股出现了前所未有的崩盘运动。2020年2月到3月之间，标普500期货连熔断三次，跌幅高达40%。</p>
<p><img src="https://i.imgur.com/HRqM9sy.png" alt="标普500"></p>
<p>连带影响，原油期货价格更是出现了前所未有的负值。</p>
<p><img src="https://i.imgur.com/znXcKtx.png" alt="原油期货"></p>
<p>不过，这种独特的情况也成就了某些公司，比如Zoom。Zoom的股票一年翻了8倍！</p>
<p><img src="https://i.imgur.com/GDHzSob.png" alt="Zoom股票"></p>
<p>年末另一个引起我注意的是比特币。比特币在18年泡沫破裂后，在2020年12月再创新高，达到了24000美金。。。</p>
<p><img src="https://i.imgur.com/M2Fh105.png" alt="比特币"></p>
<p><strong>这些事情基本都在告诉我：黑天鹅事件必然会发生，而且概率远远超过统计数据。</strong><br>这不仅仅针对金融市场，世界的各个领域正在更加紧密的连接，不同领域的黑天鹅很可能对其他领域产生连锁效应。</p>
<p>应对黑天鹅存在的世界，控制风险异常重要，预测异常困难。多样性仍然是在尽可能少的依赖预测前提下最好的风控方式。但是多样性有成本，无限多样得不偿失。</p>
<p>多样性的本质是相关性，也许也有因果关系。</p>
<p>多样性同样体现在多个方面：个人的资产管理、技能管理、人际关系管理等等。</p>
<h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>今年还处于我的计算机科学探索期，我对很多计算机科学很多方面进行了非常简略的学习和了解，从硬件层面的ISA到操作系统，简单的探索了编译器，以及各种范式的计算机语言，比如函数式和过程式；探索了不同的编程范式，比如基于Actor的并发编程、分布式编程等等；探索了数据库的设计，实现部分目前还没有涉及。</p>
<p>发现了一个有趣的东西：Live music coding。目前主要用的库是FoxDot和TidalCycles，一个是Python写的，一个是Haskell写的。</p>
<p>研究生课程：</p>
<ul>
<li>Embedded System</li>
<li>Database Design</li>
<li>Concurrent Programming</li>
</ul>
<p>自学课程：</p>
<ul>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2018sp/">Data Structures and Functional Programming</a></li>
<li>[On going] <a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">Operating System</a></li>
<li>[On going] <a href="https://pdos.csail.mit.edu/6.824/schedule.html">Distributed System</a></li>
</ul>
<p>语言表 (按照熟悉程度排序）：</p>
<ul>
<li>Python</li>
<li>Erlang/Elixir</li>
<li>Ocaml</li>
<li>Haskell</li>
<li>Javascript</li>
<li>C</li>
<li>Go</li>
<li>Ruby</li>
</ul>
<p>书籍：</p>
<ul>
<li><a href="https://hackmd.io/Ii5bK9VfSdiUkqKcRjOecg">The C Programming Language</a></li>
<li><a href="https://drive.google.com/drive/folders/1JWyvQk9QWAnce2da2boiiSDh3oK5yFU6">Systematic Trading</a></li>
<li><a href="https://wangzhe3224.github.io/2020/10/03/efficiently_inefficient/">Efficiently Inefficient: How Smart Money Invests and Market Prices Are Determined</a></li>
<li><a href="https://wangzhe3224.github.io/2020/09/20/cs_app/">Computer System: A Programmer’s Perspectives</a></li>
<li><a href="https://wangzhe3224.github.io/2020/05/16/a_new_kind_of_science/">A New Kind of Science</a></li>
<li><a href="https://www.amazon.co.uk/Erlang-OTP-Action-Martin-Logan/dp/1933988789/ref=sr_1_1?adgrpid=52230164094&dchild=1&gclid=Cj0KCQiA5vb-BRCRARIsAJBKc6K6xWXN5HxiyPiartNJjscP2mEpuBZGAr6JrvLZPgUH3ostwAjG3V4aAg5aEALw_wcB&hvadid=259088862228&hvdev=c&hvlocphy=9044953&hvnetw=g&hvqmt=e&hvrand=12324936168106335447&hvtargid=kwd-300183560570&hydadcr=17611_1775466&keywords=erlang+and+otp+in+action&qid=1608382554&sr=8-1&tag=googhydr-21">Erlang and OTP in Action</a></li>
<li><a href="">A Pragmatic Programmer</a></li>
</ul>
<p><strong>多样性思考</strong></p>
<p>在知识领域，多样性的成本主要是时间且成本巨大。但是，由于我是转行学习计算机科学，还处于一个然所学科的阶段。目前多样性体现如下几个大领域：</p>
<ul>
<li>理论层<ul>
<li>离散数学</li>
<li>计算机语言和类型理论</li>
<li>算法理论</li>
<li>数据库理论</li>
<li>并发理论</li>
</ul>
</li>
<li>硬件层<ul>
<li>编译器</li>
<li>虚拟机实现</li>
<li>数据库实现</li>
<li>操作系统</li>
</ul>
</li>
<li>软件层<ul>
<li>各种语言的使用</li>
<li>分布式系统设计</li>
<li>并发系统设计</li>
</ul>
</li>
<li>Domain知识<ul>
<li>量化交易</li>
<li>量化科技</li>
</ul>
</li>
</ul>
<p>探索期过后，需要寻找一个部分深入学习、研究和应用。对于Domain知识也需要进一步加强，今年没有太多关注，主要是完成工作任务，养家糊口。。。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>因为疫情的原因，整整一年都在家里远程工作。因为减少了上下班交通的时间，自己多了很多时间可以支配。也许，等疫情过去，这种远程工作的模式会成为常态。</p>
<p>当然除了工作，教会的活动也都变成了线上。不过线上模式反而增加了很多拓展福音的机会。我们组织了两期线上的圣经课程，讨论福音书。因为是线上，我们可以跟更多不同地方的人交流。</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>6.004 The Digital Abstraction</title>
    <url>/2020/12/19/6004-2/</url>
    <content><![CDATA[<h1 id="The-Digital-Abstraction"><a href="#The-Digital-Abstraction" class="headerlink" title="The Digital Abstraction"></a>The Digital Abstraction</h1><p>Q: the physical representation of bits?</p>
<p>Then ask what is a good bit?</p>
<ul>
<li>small</li>
<li>cheap</li>
<li>stable</li>
<li>easy and fast to manipulate, access/transform/combine/store/transmit</li>
</ul>
<p>Industry selected to use voltage to represent information.<br>But the system need to tolerate errors.</p>
<p>Encode 1 bit with 0 or 1. </p>
<p>Digitalize voltage with buffer.</p>
<h2 id="Combinational-logic"><a href="#Combinational-logic" class="headerlink" title="Combinational logic"></a>Combinational logic</h2><p>Stateless machine</p>
<h2 id="Sequential-logic"><a href="#Sequential-logic" class="headerlink" title="Sequential logic"></a>Sequential logic</h2><p>Circuits that include both combinational logic and memory components are called sequential logic.</p>
<h2 id="Finite-state-machine"><a href="#Finite-state-machine" class="headerlink" title="Finite state machine"></a>Finite state machine</h2><h1 id="Instruction-Set-Architectures"><a href="#Instruction-Set-Architectures" class="headerlink" title="Instruction Set Architectures"></a>Instruction Set Architectures</h1><p>An instruction is the fundamental unit of work, it includes: opcode to be performed and operands, destination for the result.</p>
<p>ISA, is a contract between software and hardware. ISA is the first abstraction layer that describes what CPU can do but hides how CPU do it.</p>
<h2 id="Beta-a-RISC-reduced-instruction-set-computer"><a href="#Beta-a-RISC-reduced-instruction-set-computer" class="headerlink" title="Beta: a RISC, reduced instruction set computer."></a>Beta: a RISC, reduced instruction set computer.</h2><h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2><p>A human readable ISA+ </p>
<h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>High level languages. Two basic execution logic: interpretation and complilation. </p>
<p>Front end + Back end.</p>
<p><img src="https://i.imgur.com/yC1UdhA.png" alt=""></p>
<h2 id="Procedures-abstraction-by-high-level-languages"><a href="#Procedures-abstraction-by-high-level-languages" class="headerlink" title="Procedures, abstraction by high level languages"></a>Procedures, abstraction by high level languages</h2><h1 id="Memory-tech"><a href="#Memory-tech" class="headerlink" title="Memory tech"></a>Memory tech</h1><blockquote>
<p>Everything is cache of something else..</p>
</blockquote>
<p><img src="https://i.imgur.com/NMkOpar.png" alt=""></p>
]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>6.004</tag>
        <tag>Information</tag>
      </tags>
  </entry>
  <entry>
    <title>6.004 Basic of information</title>
    <url>/2020/12/19/6004_1/</url>
    <content><![CDATA[<h1 id="6-004-Basic-of-information"><a href="#6-004-Basic-of-information" class="headerlink" title="6.004 Basic of information"></a>6.004 Basic of information</h1><p>Q: what is good representation of information?</p>
<p>What is <strong>information</strong>? Information is data that resolves uncertainty about a particular fact.</p>
<p>$X$ is discrete random variable, which has $N$ possible values ($x_i$) and associated probability $p_i$, Information received when learning that choice was $x_i$:</p>
<p>$$I(x_i)=log_2(\frac{1}{p_i})$$</p>
<p>the unit is bits, the number of bits required to encode the choice.</p>
<p>The <strong>entropy</strong>, $H(X)$, of a discrete random variable $X$ is average amount of information received when learning the value of X:</p>
<p>$$H(X)=E(I(X))=\sum_ilog_2(\frac{1}{p_i})$$</p>
<p><strong>encoding</strong> is a unambiguous mapping between bits string to set of possible data.</p>
<p>Encoding as binary tree is a good way to think. </p>
<p>Huffman’s algorithm, given a set of symbols and their probability, constructs an optima variable-length encoding <strong>1 symbol per time</strong>.<br>Build encoding tree bottom up with lower probability.</p>
<p>If we do same algorithm but using multiple symbols, we can do better.</p>
<p><strong>Hamming distance</strong>: same length bits, how many different bits in the same position.</p>
<p><strong>single-bit error</strong> detection and correction by add hamming distance of valid word encoding. </p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2017/c1/c1s1/">6.004</a></p>
<h6 id="tags-6-004-Information"><a href="#tags-6-004-Information" class="headerlink" title="tags: 6.004, Information"></a>tags: <code>6.004</code>, <code>Information</code></h6>]]></content>
      <categories>
        <category>Computing</category>
      </categories>
      <tags>
        <tag>6.004</tag>
        <tag>Information</tag>
      </tags>
  </entry>
  <entry>
    <title>被时间“埋没”的分布式王者：Erlang</title>
    <url>/2020/12/11/erlang/</url>
    <content><![CDATA[<h1 id="被时间“埋没”的高并发王者：Erlang"><a href="#被时间“埋没”的高并发王者：Erlang" class="headerlink" title="被时间“埋没”的高并发王者：Erlang"></a>被时间“埋没”的高并发王者：Erlang</h1><p>分布式、fault-tolerant、高并发等等这些名词变得越来越火爆，一个新的框架、数据库、语言如果不跟这几个名词沾边，都不好意思摆在台面上。可是，早在20-30年前的通信领域已经出现了这样的需求，比如 容错、超高并发、在线代码更新、99.9%在线率等等。而互联网领域直到最近10今年才特别关注这种系统。</p>
<p>大概在90年代初，Erlang诞生了，它的设计者正式为了满足通讯领域系统高并发、高容错、分布式的需求设计Erlang和它的虚拟机，BEAM。（当然BEAM不是第一代虚拟机，而是经过几轮迭代后被大规模投入使用的版本）。</p>
<p>虽然，很多年轻的程序员可能没有通过Erlang，提起分布式、高并发，他们更多想到的可能是 Golang，Scala/Akka等等。可是Erlang系统就在我们身边：Cisco超过90%的交换机仍然在使用Erlang；早在2012年，WhatApp的生产系统就实现了在单个Beam虚拟机节点上同时处理超过2百万个TCP/IP连接；RabbitMQ 服务器端代码是Erlang实现的；电信公司T-Mobile的短信业务也是Erlang实现的；Ericsson用Erlang生态构建新的5G基础设施软件；等等。</p>
<p>可以说，在分布式、高并发、高容错这个领域，Erlang得到了广泛的应用，多年的使用也证明了Erlang生态在这个领域的可靠性。</p>
<p>我有幸和Erlang最初的几个设计者之一Robert Virding 学习过一段时间，了解了一些Erlang背后的故事。</p>
<h1 id="Erlang的设计哲学"><a href="#Erlang的设计哲学" class="headerlink" title="Erlang的设计哲学"></a>Erlang的设计哲学</h1><p>Erlang不是完美的语言，Erlang的设计具有鲜明的目的性：高并发、高容错、分布式。Erlang的虚拟机BEAM也是为了实现相同的目的，可以说，它只围绕这几个设计目的进行优化，比如它对Binary类型计算进行了优化，而浮点计算则非常缓慢。</p>
<p>Erlang本身属于函数式语言，没有变量，循环，一切都是Immutable等等。而 Erlang 的 Pattern Matching 能力非常优秀且高效。代码精简且清晰，同时为信息传递奠定了基础。最近十几年，工业界也开始慢慢接受、甚至推崇函数式编程，但是Erlang已经在30年前把函数式代码部署在了生产环境。</p>
<p>Erlang的并发模型属于Actor Model，它实现高并发的基石在于非常廉价的Process。这个Process不是操作系统中的进程，而是Beam虚拟机内部的一个抽象。Process非常廉价，每个进程只有2-4kb的foot print，一个Beam节点可以毫无压力的同事运行超过2百万个process。这些Process都是相互独立的，他们不共享任何内存，有独立的堆栈，除非建立连接，一个Process的崩溃完全不会影响到系统的其他进程。</p>
<p>更加有意思的是，这200万个虚拟机进程，仅仅需要运行在一个操作系统线程内。换句话说，BEAM把并发模型从操作系统中抽象出来了。这样做的优势显而易见：如果我们有多核处理器，相同的代码可以毫不费力的通过增加节点分布在不同的内核里，增加处理能力。</p>
<p>进程之间是通过传递信息实现互动，注意这些信息都是不可变的（immutable），同时信息的传递可以跨越节点，即可以实现不同内核中节点的通信、不同物理机器节点的通讯。事实上，代码中几乎不需要区分进程是local还是remote。这种跨节点通讯正式分布式系统的基础。</p>
<p>在BEAM进程、进行通讯以及函数式语法的基础上，为了进一步增加容错能力，实现99.9%系统在线率，Erlang也发展出了非常独特的 异常处理 和 代码更新 模式。BEAM虚拟机可以实现系统在线的情况下修复bug，并仅仅重新部署一部分出问题的系统。</p>
<p>大部分编程模式的异常处理都是基于 try-catch，也就是 Defensive Programming，即尽可能的捕捉异常，阻止程序崩溃。以为绝大部分系统不能接受线程异常，一个线程异常有肯能会导致整个系统崩溃。Erlang系统很不一样，因为所有进程都是独立的，一个进程的崩溃完全不会影响系统，甚至，系统中的大部分进程都不会意识到。所以，Erlang的 异常处理 更加专注于如何让仍然工作的进程修复崩溃的进程，也就是自我恢复，Self-healing。当然，Erlang生态并没有这个名词， 在Erlang 的世界里叫做 supervisor-tree。通常编写业务逻辑的时候，仅仅关注正确的情况，而不去主动捕捉异常，以为异常总是多种多样的，而且一定会发生。通常如果出现异常，进程就会终结，而他的supervisor进程会介入进行合理的操作，比如重启它等等。换句话说，把业务逻辑和异常处理逻辑分离。也正式因为这样的 异常处理和自我修复设计，实现了Erlang系统的高容错性能。</p>
<h1 id="Erlang生态"><a href="#Erlang生态" class="headerlink" title="Erlang生态"></a>Erlang生态</h1><p>总结一下 Erlang 实现高并发、高容错、分布式的基石：</p>
<ul>
<li>函数式语言，Immutability</li>
<li>超轻量线程，Process</li>
<li>自愈模式的异常处理，Supervision tree</li>
</ul>
<p>无论是Erlang语言本身，还是他的虚拟机BEAM都是围绕上面那三个特征进行设计的。</p>
<p>其实，很多新的语言和框架都或多或少的在学习上面的特性，比如 go routine 和 channel其实就是轻量级线程和通讯，但却没有Erlang进程那么轻，而且共享内存。Erlang的独特之处在于它的设计目的很单一：高并发。而上面的三个特征是实现可靠的高并发系统必不可少的，Erlang把他们做到了极致，不妥协。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><blockquote>
<p>正确的工具做正确的事情</p>
</blockquote>
<p>Erlang 就是高并发场景的正确工具，他非常不完美，但是他满足了高并发场景所需要的工程特征，而且经历近30年的生产环境考验。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>Distributed System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim增加定制帮助文件</title>
    <url>/2020/11/18/vim_tags/</url>
    <content><![CDATA[<h1 id="Vim增加自定义帮助文件"><a href="#Vim增加自定义帮助文件" class="headerlink" title="Vim增加自定义帮助文件"></a>Vim增加自定义帮助文件</h1><p>首先，准备一份帮助文件，文件名必须是 <code>*.txt</code>，然后该文件必须存放在vim的<code>runtimepath</code>。可以通过 <code>:echo &amp;runtimepath</code> 查看，通常就是在<br><code>~/.vim/doc</code> 或者 如果是 neovim 在 <code>~/.config/nvim/</code>。</p>
<p>帮助文件的首行第一个字符必须是 <code>*</code>，文件的其余部分不限。但是文件中所有<br>包含在<code>**</code>内部的单词，都会被检索。所以应该注意不要与其他部分冲突。</p>
<p>一个帮助文件例子：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">*tidal.txt* Tidal documentation</span><br><span class="line"></span><br><span class="line">this <span class="keyword">file</span> <span class="keyword">is</span> <span class="keyword">a</span> consolidation of the official tidalCycles documentation : http<span class="variable">s:</span>//tidalcycles.org/<span class="built_in">index</span>.php/Userbase</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Time = Rational</span><br><span class="line"></span><br><span class="line">## CORE</span><br><span class="line"></span><br><span class="line">*(&lt;~)*:: Pattern Time -&gt; Pattern <span class="keyword">a</span> -&gt; Pattern <span class="keyword">a</span></span><br><span class="line">&lt;~ <span class="keyword">is</span> <span class="keyword">an</span> operator that shifts <span class="keyword">a</span> pattern backward in time, by the given amount.</span><br><span class="line">For example, <span class="keyword">to</span> shift <span class="keyword">a</span> pattern by <span class="keyword">a</span> quarter of <span class="keyword">a</span> cycle, every fourth cycle:</span><br><span class="line">d1 $ every <span class="number">4</span> (<span class="number">0.25</span> &lt;~) $ sound (<span class="string">&quot;arpy arpy:1 arpy:2 arpy:3&quot;</span>)</span><br><span class="line">Or <span class="keyword">to</span> alternate between different shift<span class="variable">s:</span></span><br><span class="line">d1 $ <span class="string">&quot;&lt;0 0.5 0.125&gt;&quot;</span> &lt;~ sound (<span class="string">&quot;arpy arpy:1 arpy:2 arpy:3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里面的 <code>tidal.txt</code> 和 <code>(&lt;~)</code> 将来都会被检索。</p>
<p>完成上述后，运行 <code>:helptags ~/.vim/doc</code>，这样就会为新的帮助文件生成Tag检索。</p>
<p>检索完成后，就可以运行 <code>:h tidal.txt</code> 来显示对应的帮助文件定位了，同时也支持<br>自动补全，在 intert 模式下， <code>C-N</code> 就可以进行补全。</p>
<p>也可以增加如下段落在 <code>.vimrc</code>里面支持 K 键 阅读文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> K :<span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>show_documentation()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">show_documentation</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">index</span>([<span class="string">&#x27;vim&#x27;</span>,<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;tidal&#x27;</span>], &amp;<span class="keyword">filetype</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">execute</span> <span class="string">&#x27;h &#x27;</span>.<span class="built_in">expand</span>(<span class="string">&#x27;&lt;cword&gt;&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">call</span> CocAction(<span class="string">&#x27;doHover&#x27;</span>)</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span> </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>CS3110总结</title>
    <url>/2020/11/09/cs3110/</url>
    <content><![CDATA[<h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>总体感觉CS3110这门课程像是一个关于Coding的“大杂烩”，这里完全没有贬义，相反这门课对我这种转行背景的程序员非常有帮助。<br>正如这么课程介绍中说：</p>
<blockquote>
<p>This course is about making you a better programmer. </p>
</blockquote>
<p>为了实现这一目的，这门课程的内容涉及了较多方面的内容，而且每一个部分都有为这个目的贡献了力量：</p>
<ul>
<li>Functional Programming with Ocaml：为了说明如何系统化学习任何一门新的计算机预言</li>
<li>Modular Programming: 为了说明如何构建大型程序</li>
<li>Data Structures: 深度讲解了基本的数据结构,Mutable and Immutable, 比如流、红黑树、哈希表等等</li>
<li>Interpreter: 讲解了计算机预言解释器，即更加了解程序员的工具：计算机语言</li>
<li>Formal Methods: 讲解进行软件Formal verification</li>
</ul>
<p>课程虽然选择Ocaml，但是讲解的内容多数可以应用于任何语言，通过学习背后动机，可以帮助学习和理解其他计算机语言。</p>
<p>同时，这门课的很多主题为深入学习其他领域奠定了基础，比如：</p>
<ul>
<li>CS4110/6110 Programming Languages and Logics，如何设计一门语言</li>
<li>CS4120 Compilers，如何实现一门语言</li>
<li>CS4160 Formal Verification，如何证明程序的正确性 :+1: </li>
</ul>
<h2 id="几个大的主题"><a href="#几个大的主题" class="headerlink" title="几个大的主题"></a>几个大的主题</h2><h3 id="语言可以系统化学习"><a href="#语言可以系统化学习" class="headerlink" title="语言可以系统化学习"></a>语言可以系统化学习</h3><p>计算机语言可以有系统化的学习方法，任何一门计算机语言特性都可有通过如下三个规则进行分析：</p>
<ul>
<li>语法，Syntax</li>
<li>静态语义，static semantic, 即 typing rule</li>
<li>动态语义，dynamic semantic，即 Evaluation rule</li>
</ul>
<p>分治，Divide-and-conquer，无处不在。</p>
<p>计算机语言可以从数学的角度精确定义。</p>
<h3 id="计算机语言不是魔法"><a href="#计算机语言不是魔法" class="headerlink" title="计算机语言不是魔法"></a>计算机语言不是魔法</h3><ul>
<li>编写一个语言的解释器非常简单！</li>
<li>DSL，可能是一个好的选择</li>
</ul>
<h3 id="优雅的抽象确实是魔法"><a href="#优雅的抽象确实是魔法" class="headerlink" title="优雅的抽象确实是魔法"></a>优雅的抽象确实是魔法</h3><ul>
<li>语言特征：product types, union types</li>
<li>Higher order functions: map, fold..</li>
<li>Data structures: lists, tree, dictionary, monad</li>
<li>Module system: abstraction, functors</li>
<li>Use abstraction and decomposition</li>
<li>Think in multiple levels of abstractions</li>
</ul>
<h3 id="编写软件需要系统化的方法"><a href="#编写软件需要系统化的方法" class="headerlink" title="编写软件需要系统化的方法"></a>编写软件需要系统化的方法</h3><ul>
<li>设计：动手编程以前，先想。</li>
<li>同理心：编写可以被人轻易看懂的代码</li>
<li>保证：测试和证明</li>
<li>团队合作</li>
</ul>
<h3 id="这门课教给我的"><a href="#这门课教给我的" class="headerlink" title="这门课教给我的"></a>这门课教给我的</h3><ul>
<li>复杂的系统可以被分解成小的、容易理解的部分</li>
<li>学习小的部分更加容易</li>
<li>学习小的部分如何配合形成复杂系统</li>
</ul>
<h2 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h2><p>模块化编程的核心在于，通过构建抽象以实现局部化。具体实现的工具包括：</p>
<ul>
<li>命名空间，Namespace，把相关的数据结构和函数放在一起</li>
<li>抽象，Abstraction，隐藏具体的数据结构和函数实现，仅保留<strong>接口和文档</strong></li>
<li>代码复用，Code reuse</li>
</ul>
<p>这些概念通常在OO中已经比较常见和熟悉，但是这门课程同时强调了文档和测试的重要性。</p>
<p>好的文档应该区别对待接口和实现，接口文档是写给Client看的，而实现文档是写给内部程序员。</p>
<p>好的接口文档应该包含：</p>
<ul>
<li>Return clause</li>
<li>Requires clause</li>
<li>Raises clause</li>
<li>Example clause</li>
</ul>
<p>好的实现文档应该包含：</p>
<ul>
<li>AF, Abstract Function，实现数据结构到抽象结构的映射关系</li>
<li>RI, Representation Invariant， 那些实现数据结构是合法的抽象结构</li>
</ul>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lexing -&gt; (Tokens) -&gt; Parsing -&gt; (AST) -&gt; Semantic Check ...</span><br><span class="line">         -&gt; (Intermediate Representation) -&gt; (Target code)</span><br></pre></td></tr></table></figure>

<h2 id="Lab-解答"><a href="#Lab-解答" class="headerlink" title="Lab 解答"></a>Lab 解答</h2><p><a href="https://github.com/wangzhe3224/cs3110">CS3110 Labs</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook">https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2018sp/">https://www.cs.cornell.edu/courses/cs3110/2018sp/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Ocaml</tag>
        <tag>CS3110</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6828 lab 1</title>
    <url>/2020/10/10/mit6828_lab1/</url>
    <content><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>First thing, what does it mean by saying <code>cs:ip</code>?<br>This is a old but still being used memory addressing method. <code>Segment: Offfset</code>. The absolute memory addres = (Segment * 16) + Offset. For example, <code>F000:FFFD</code> means address <code>FFFFD</code>. This strange way of expressing address is due to the fact that in the old days, CPU’s regeisters are only 16bit, which can only address a memeory address of 2^16 (which is 64KiB memory). This is even too small at that age. So CPU manufacturers combines two regiesters to express larger address, which is this <code>segment: offset</code> thing.<br><code>cs</code> means “code segment” and <code>ip</code> means “instruction pointer”. The combination represents the location where CPU is currently fetching instructions to execute.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)                 [Intel 8088]</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |                                      [Conventional Memory]</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<h3 id="Exercise-2-debug-boot"><a href="#Exercise-2-debug-boot" class="headerlink" title="Exercise 2: debug boot"></a>Exercise 2: debug boot</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [CS:IP]    address: command  args</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b   # goto 0xfe05b</span><br><span class="line">[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6c48</span><br><span class="line">[f000:e062]    0xfe062: jne    0xfd2e1</span><br><span class="line">[f000:e066]    0xfe066: xor    %dx,%dx</span><br><span class="line">[f000:e068]    0xfe068: mov    %dx,%ss</span><br><span class="line">[f000:e06a]    0xfe06a: mov    $0x7000,%esp</span><br><span class="line">[f000:e070]    0xfe070: mov    $0xf3691,%edx</span><br><span class="line">[f000:e076]    0xfe076: jmp    0xfd165</span><br><span class="line">[f000:d165]    0xfd165: mov    %eax,%ecx</span><br><span class="line">[f000:d168]    0xfd168: cli</span><br><span class="line">[f000:d169]    0xfd169: cld</span><br><span class="line">[f000:d16a]    0xfd16a: mov    $0x8f,%eax</span><br><span class="line">[f000:d170]    0xfd170: out    %al,$0x70</span><br><span class="line">[f000:d172]    0xfd172: in     $0x71,%al</span><br><span class="line">[f000:d174]    0xfd174: in     $0x92,%al</span><br><span class="line">[f000:d176]    0xfd176: or     $0x2,%al</span><br><span class="line">[f000:d178]    0xfd178: out    %al,$0x92</span><br><span class="line">[f000:d17a]    0xfd17a: lidtw  %cs:0x6c38</span><br><span class="line">[f000:d180]    0xfd180: lgdtw  %cs:0x6bf4</span><br><span class="line">[f000:d186]    0xfd186: mov    %cr0,%eax</span><br><span class="line">[f000:d189]    0xfd189: or     $0x1,%eax</span><br><span class="line">[f000:d18d]    0xfd18d: mov    %eax,%cr0</span><br><span class="line">[f000:d190]    0xfd190: ljmpl  $0x8,$0xfd198</span><br><span class="line">&#x3D;&gt; 0xfd198:     mov    $0x10,%eax</span><br><span class="line">&#x3D;&gt; 0xfd19d:     mov    %eax,%ds</span><br><span class="line">&#x3D;&gt; 0xfd19f:     mov    %eax,%es</span><br><span class="line">&#x3D;&gt; 0xfd1a1:     mov    %eax,%ss</span><br></pre></td></tr></table></figure>

<h2 id="Part-2-Boot-Loader"><a href="#Part-2-Boot-Loader" class="headerlink" title="Part 2 Boot Loader"></a>Part 2 Boot Loader</h2><p>BIOS handle control to boot loader by loading boot loader into memory and jump instruction pointer to <code>0x7C00</code>, where boot<br> loader code started.</p>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><ul>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
</ul>
<p><code>[   0:7c1e] =&gt; 0x7c1e:  lgdtw  0x7c64</code>. Here starting using GDT, Global Descriptor Table.<br>Then mark control regesiter, <code>cr0</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   0:7c23] &#x3D;&gt; 0x7c23:  mov    %cr0,%eax</span><br><span class="line">[   0:7c26] &#x3D;&gt; 0x7c26:  or     $0x1,%eax</span><br><span class="line">[   0:7c2a] &#x3D;&gt; 0x7c2a:  mov    %eax,%cr0</span><br><span class="line">[   0:7c2d] &#x3D;&gt; 0x7c2d:  ljmp   $0x8,$0x7c32   # &lt;-- Jump to next instruction, which in 32-bit code segment.</span><br><span class="line">&#x3D;&gt; 0x7c32:      mov    $0x10,%ax   # notice that the address format changed.</span><br></pre></td></tr></table></figure>

<p>In <code>boot.S</code> source code, one can see <code>.code16</code> as a sign of 16-bit mode, and <code>.code32</code> as 32-bit mode.</p>
<ul>
<li><p>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&gt; 0x7c40:      mov    $0x7c00,%esp # setup stack pointer to call boot&#x2F;main.c</span><br><span class="line">&#x3D;&gt; 0x7c45:      call   0x7d15</span><br><span class="line">&#x3D;&gt; 0x7d15:      push   %ebp # here we move to &#96;main.c&#96;. boot.S hands over control to main.c </span><br><span class="line">&#x3D;&gt; 0x7d6b:      call   *0x10018       # this is the last instruction from boot loader</span><br><span class="line">&#x3D;&gt; 0x10000c:    movw   $0x1234,0x472  # this is the first instruction from the kernel.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Where is the first instruction of the kernel? <code>0x10000c</code></p>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?  The boot loader find sector number from </p>
</li>
</ul>
<p>Notes:<br><code>x/i $pc</code>: show current instruction (content that program counter, <code>pc</code>, pointed to)<br><code>si</code>: execute current instruction<br><code>c</code>: execute until next break point<br><code>b *address</code>: set a break point at address</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><ul>
<li>Understand <code>pointer.c</code>. Read K&amp;R Ch5.1 - 5.5.</li>
</ul>
<p>Note:</p>
<ul>
<li>Unary operators like * and ++ associate right to left. <code>++*p</code> and <code>(*p)++</code> and <code>*p++</code>.</li>
<li>(int *) ((char *) c) makes the trick, char is 1 byte long whereas int is 4 bytes.</li>
</ul>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>The first instruction that would break will be <code>ljmp $PORT_MODE_CSEG, $protcseg</code>, <code>$protcseg</code> is part of<br>.text segment, and the segement is assumed to be loaded at <code>0x7c00</code>. </p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>Breakpoint 0x7c00</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[   0:7c00] &#x3D;&gt; 0x7c00:  cli</span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x100010:       0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">&#x3D;&gt; 0x10000c:    movw   $0x1234,0x472</span><br><span class="line">Breakpoint 2, 0x0010000c in ?? ()</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x0000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure>

<h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>this bit code activate page:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Turn on paging.</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>

<p>Set the breakpoint at 0x00100025 (this is the pysical address of movl %eax, %cr0). We can see:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb) x&#x2F;8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p>After execute this line, we can see that both 100000 and f0100000 hold same content.<br> Memory is mapped.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;8x 0x00100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br><span class="line">(gdb) x&#x2F;8x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x34000004      0x2000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure>

<p>The next instruction need the virtual memeory setup, otherwise it cannot find the right memory address.<br> 0xf010002f.</p>
<p><code>f0100028:   b8 2f 00 10 f0          mov    $0xf010002f,%eax</code></p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>The code is similar to unsigned int, just change base to 8:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; getuint(&amp;ap, lflag);</span><br><span class="line">base &#x3D; 8;</span><br><span class="line">goto number;</span><br></pre></td></tr></table></figure>

<p><strong>Explain the interface between printf.c and console.c. Specifically, what function does console.c export?</strong><br><strong>How is this function used by printf.c?</strong></p>
<p><code>putch()</code> function in printf.c calls <code>cputchar()</code> in console.c to show chars in concole.</p>
<p>the following code will give a new page when screen is full.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (crt_pos &gt;&#x3D; CRT_SIZE) &#123;</span><br><span class="line">    int i;</span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">            for (i &#x3D; CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">                    crt_buf[i] &#x3D; 0x0700 | &#39; &#39;;</span><br><span class="line">                        crt_pos -&#x3D; CRT_COLS;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercies-9-The-Stack"><a href="#Exercies-9-The-Stack" class="headerlink" title="Exercies 9: The Stack"></a>Exercies 9: The Stack</h3><blockquote>
<p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p>
</blockquote>
<p>The kernel initialized stack pointer in line 76 of <code>kern/entry.S</code> with <code>movl $(bootstacktop), %esp</code>.<br>By looking at <code>obj/kern/kernel.asm</code> line 57, we know that stack pointer is pointing to <code>0xf0110000</code><br> which is right after the 1MB kernel space.</p>
<p><code>f0100034:   bc 00 00 11 f0          mov    $0xf0110000,%esp</code></p>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ebp = (<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ebp != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> eip = ebp[<span class="number">1</span>];</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (debuginfo_eip(eip, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        ebp = (<span class="keyword">uint32_t</span> *)(*ebp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://qiita.com/kagurazakakotori/items/b092fc0dbe3c3ec09e8e">Solution</a></li>
<li><a href="https://www.youtube.com/watch?v=Q2sFmqvpBe0">Call stack video</a></li>
<li><a href="https://www.youtube.com/watch?v=XbZQ-EonR_I">Details in stack and register</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Efficiently Inefficient Market</title>
    <url>/2020/10/03/efficiently_inefficient/</url>
    <content><![CDATA[<h1 id="Efficiently-Inefficient-Market"><a href="#Efficiently-Inefficient-Market" class="headerlink" title="Efficiently Inefficient Market"></a>Efficiently Inefficient Market</h1><p><a href="https://hackmd.io/DEJL1LPVSd6-XRKV85iEeg"><img src="https://hackmd.io/DEJL1LPVSd6-XRKV85iEeg/badge" alt="hackmd-github-sync-badge"></a></p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>作者认为，市场足够的有效，但是不是完全有效，也正式基金经理的主动挖掘无效性，才进一步促进了市场的有效。只不过，主动投资是有花销的，比如人力、技能、电脑、场地等等，这些都会为主动管理资金设立门槛，导致超过容量有限。</p>
<p>作者在AQR从事量化投资相关研究，具有很好的学术和工业背景，所以他的见解更加贴合真是市场，但是又包含严谨的说明，没有任何玄学。比如，他就明确的说出：想要盈利就必须要预测，而且要做好的预测。</p>
<p>这一点我很认同，母我看到太多所谓的“交易”达人胡扯：不预测，只是跟随市场。&lt;—- <strong>扯淡</strong>。</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul>
<li>价值</li>
<li>趋势</li>
<li>流动性</li>
<li>Carry</li>
<li>质量</li>
</ul>
<h1 id="1、主动投资活动"><a href="#1、主动投资活动" class="headerlink" title="1、主动投资活动"></a>1、主动投资活动</h1><h2 id="评价策略表现"><a href="#评价策略表现" class="headerlink" title="评价策略表现"></a>评价策略表现</h2><p>Alpha, t-statics, sharpe ratio, information ratio, alpha-to-margin ratio, sortino ratio</p>
<h2 id="寻找、回测策略"><a href="#寻找、回测策略" class="headerlink" title="寻找、回测策略"></a>寻找、回测策略</h2><p>每一个策略背后都应该有合理的盈利逻辑，因为你的每一笔交易都会存在对手方，如果你的策略真的有效，那么对手会亏损，问题在于他有什么理由一直亏损？</p>
<p>所以超额利润，alpha，一般来源有两个：流动性的补偿和信息的补偿。</p>
<p><img src="https://i.imgur.com/FRHkc6g.png" alt="Alpha的来源"></p>
<p><strong>信息</strong></p>
<p>市场价格如果可以反映该产品的一切信息，那么这个过程不是自动完成的，也不是瞬间完成的，需要有人去交易这些信息，把这些信息反映到市场价格中去。反过来说，如果市场自动、瞬间反映了所有信息，那么不会有人去收集并交易任何信息，因为没有意义。可以，如果是这样的话，市场优又如何可以反映新出现的信息？所以，对冲基金等主动管理者就通过收集和交易信息成全了市场的有效性。</p>
<p>对冲基金往往也充当了信息的生产者，比如他们会对公司进行深入系统的研究，然后做出对应的交易，从而将这些信息反映到价格中。对冲基金也会高价购买信息，然后通过交易行为，将这些信息反映到价格中，并且从中盈利。同时，对冲基金也会交易一些非理性行为，比如</p>
<blockquote>
<p>there is a general tendency of initial underreaction and delayed overreaction that creates trends and momentum.</p>
</blockquote>
<p>所以，当一个新的策略形成的时候，问问自己受益从何而来？</p>
<ul>
<li>这些信息被大部分人忽略了吗？</li>
<li>通过整个多种不同的信息，得到了新的信息吗？</li>
<li>我比其他人更快的获得了这个信息吗？</li>
<li>这些信息还没有完全反映到市场价格吗？</li>
</ul>
<p><strong>风险</strong></p>
<p>获得超额回报的另一个途径就是承担风险。市场风险不计入。通常对冲基金会通过承担流动性风险获得市场收益意外的超额回报。</p>
<p>流动性风险会直接影响资产的价格。</p>
<p><em>市场流动性风险</em>，是指需要花费巨额的费用才能退出某个资产。最常见的情况就是在崩盘的情况下，bid-ask差价非常大，甚至出现没有bid的情况，无人接盘。因此，流动性差的资产通常具有较高的回报率或者比较便宜，这就是市场流动性风险补偿。</p>
<p><em>资本流动性风险</em>，是指被margin call的风险。换句话说，持有高Margin的资产应该得到相应的回报，因为承担了资本流动性风险。</p>
<p><em>需求压力</em>，Demand pressure，并购套利就是一个典型的需求压力策略。当一些机构进行风险对冲的时候，也会出现需求压力。在比如需要roll future contract的时候，债券降级的时候，都会产生一些需求压力，通常都是卖出压力。</p>
<p><strong>回测</strong></p>
<p>回测的基本组成部分：</p>
<ul>
<li>交易池，定义可以交易的资产</li>
<li>信号，信息输入</li>
<li>交易规则，包括调仓规则，交易规则等等</li>
<li>时间延迟，Point-in-time 信息</li>
<li>交易费用</li>
</ul>
<h2 id="回归分析的等效性"><a href="#回归分析的等效性" class="headerlink" title="回归分析的等效性"></a>回归分析的等效性</h2><p>投资组合资产的选择和比较几乎等效于线性回归系数的分析：</p>
<blockquote>
<p>任何预测性质的回归分析都可以等效成资产组合选择，任何资产组合选择都可以等效成为预测回归分析。</p>
</blockquote>
<ul>
<li>时间序列回归分析，与择时策略相关</li>
<li>Corss-sectional回归分析与则产选择策略相关</li>
<li>单因子回归分析与根据一个信号排序资产相关；而多因子回归则与多因子排序相关</li>
</ul>
<h3 id="时间序列回归"><a href="#时间序列回归" class="headerlink" title="时间序列回归"></a>时间序列回归</h3><p>$$R_{t+1}^e = a + bF_t + e_{t+1}$$</p>
<p><strong>而 $b$ 的最小二乘估计值就可以被看成一个long-short择时策略的累计回报率</strong>：</p>
<p>$$\hat{b}=\frac{\sum_t(F_t - \bar{F})R_{t+1}}{\sum_t(F_t-\bar{F})^2} = \sum_{t=1}^{T}x_tR_{t+1}$$</p>
<p>其中，$x_t = k(F_t - \bar{F})$，而$k = 1/\sum(F_t-\bar{F})^2$ 不影响策略的夏普值。</p>
<p>$x_t$就是实际的交易仓位，当信号$F_t$超过其均值时，x为正，即买入。反之，则卖出。</p>
<h3 id="Corss-sectional回归与选股"><a href="#Corss-sectional回归与选股" class="headerlink" title="Corss-sectional回归与选股"></a><em>Corss-sectional回归与选股</em></h3><p>$$R_{t+1}^i= a + bF_t^i + e_{t+1}^i$$</p>
<p>其中，i代表一个资产，F同样代表信号。针对投资组合中的所有资产进行上述回归分析，得到回归系数矩阵：</p>
<p>$$\hat{b}<em>t=\frac{\sum_i(F_t^i - \bar{F_t})R^i</em>{t+1}}{\sum_i(F_t^i - \bar{F_t})^2} = \sum_{i}x_t^iR_{t+1}^i$$</p>
<p><strong>这个回归系数 $\hat{b}$ 就代表了一个long-short策略在t和t-1获得的收益</strong>。而资产的权重就是：</p>
<p>$$x_t^i=k_t(F_t^i-\bar{F_t})$$</p>
<p>这个回归系数$\hat{b_t}$的平均值，其实就是Fama–MacBeth模型中的系数$\hat{b}$。</p>
<p>$$\hat{b} = 1/T\sum_{t=1}^T\hat{b}_t$$</p>
<p>进而，我们可以求出策略的波动率：</p>
<p>$$\hat{\sigma} = \sqrt{\frac{1}{T-1}\sum_{t=1}^T(\hat{b_t}-\hat{b})^2}$$</p>
<p>这里如果看一下t-static会发现，其实t-statistics就是高夏普比例的表现。</p>
<p>$$tstatistics = \sqrt{T}\frac{\hat{b}}{\hat{\sigma}}$$</p>
<h3 id="多因子回归"><a href="#多因子回归" class="headerlink" title="多因子回归"></a>多因子回归</h3><p>$$R_{t+1}^i= a + b^FF_t^i + b^GG_t^i + e_{t+1}^i$$</p>
<p>在这种情况下，$b^F$ 代表了同时交易信号F和信号G的时候，信号F的收益。</p>
<blockquote>
<p>值得注意的是，时间序列线性回归更加可以，因为用到了信号均值进行计算。而信号均值从回测的角度，属于未来信息。</p>
</blockquote>
<h2 id="构建投资组合以及风险管理"><a href="#构建投资组合以及风险管理" class="headerlink" title="构建投资组合以及风险管理"></a>构建投资组合以及风险管理</h2><p>当我们识别出若干可用的信号以后，就需要组合这些信号形成投资组合进行交易。具体方法多种多样，但是总体原则是：</p>
<ul>
<li>多样性</li>
<li>头寸限制</li>
<li>对信心更强的信号，下注更多</li>
<li>根据风险指标调整投资组合</li>
<li>关注相关性</li>
</ul>
<h2 id="交易的花费"><a href="#交易的花费" class="headerlink" title="交易的花费"></a>交易的花费</h2><ul>
<li>交易花费</li>
<li>funding cost<ul>
<li>总杠杆</li>
<li>净杠杆</li>
</ul>
</li>
<li>Margin</li>
</ul>
<h1 id="2-股票类策略"><a href="#2-股票类策略" class="headerlink" title="2. 股票类策略"></a>2. 股票类策略</h1><p>主要分为三类：discretionary equity, dedicated short bias, and quantitative equities.</p>
<blockquote>
<p>Intrinsic value: It is the discounted value of the cash that can be taken out of a business during its remaining life.</p>
</blockquote>
<p>交易股票的基础在于股票估值，即固有价值。估值的核心在于未来现金流的现今折扣价值：</p>
<p>$$V_t = E_t(\frac{D_{t+1}+V_{t+1}}{1+k_t})$$</p>
<p>其中，k 即使股票的回报率，D 是股票的分红。</p>
<p>不过，分红并不容易预测，特别对于有些成长型的公司，股票并没有分红，所以需要Earning和Book value进行替代计算。</p>
<p>当然，除了上述绝对估值，也可以对股票进行相对估值。</p>
<h2 id="Discretionary-equity"><a href="#Discretionary-equity" class="headerlink" title="Discretionary equity"></a>Discretionary equity</h2><ul>
<li>Value</li>
<li>Growth</li>
<li>Quality</li>
</ul>
<h2 id="Dedicated-short-bias"><a href="#Dedicated-short-bias" class="headerlink" title="Dedicated short bias"></a>Dedicated short bias</h2><h2 id="Quant-equity"><a href="#Quant-equity" class="headerlink" title="Quant equity"></a>Quant equity</h2><ul>
<li>Fundamental quant<ul>
<li>value</li>
<li>quality</li>
<li>bet against beta</li>
</ul>
</li>
<li>Statistic Arb</li>
<li>HFT</li>
</ul>
<h1 id="3、资产配置和宏观策略"><a href="#3、资产配置和宏观策略" class="headerlink" title="3、资产配置和宏观策略"></a>3、资产配置和宏观策略</h1><p>宏观策略的逻辑是自顶向下的，而股票策略则通常是自底向上的。宏观策略的主要受益来源是各种Risk Premiums，比如股票风险回报、时间结构回报（国债）、信誉风险回报（公司债）、流动性风险回报（房地产等）、其他（比如价值引子、趋势、carry等等）。</p>
<p><strong>市场择时</strong></p>
<p>市场择时策略可以通过回归和回测进行分析。</p>
<p><strong>回报率的来源</strong></p>
<h2 id="全球资产配置"><a href="#全球资产配置" class="headerlink" title="全球资产配置"></a>全球资产配置</h2><blockquote>
<p>The whole world is simply nothing more than a flow chart for capital.</p>
</blockquote>
<ul>
<li>Carry</li>
<li>Central banks</li>
</ul>
<h2 id="CTA"><a href="#CTA" class="headerlink" title="CTA"></a>CTA</h2><p>趋势策略，不同时间周期、不同产品的多样性效应。</p>
<h1 id="4、套利策略"><a href="#4、套利策略" class="headerlink" title="4、套利策略"></a>4、套利策略</h1>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>Hedge Fund</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer System</title>
    <url>/2020/09/20/cs_app/</url>
    <content><![CDATA[<h1 id="Computer-System-A-Programmer’s-Perspectives"><a href="#Computer-System-A-Programmer’s-Perspectives" class="headerlink" title="Computer System: A Programmer’s Perspectives"></a>Computer System: A Programmer’s Perspectives</h1><p><a href="https://hackmd.io/fzzDuqP9TO2f8MOsqmOxUQ"><img src="https://hackmd.io/fzzDuqP9TO2f8MOsqmOxUQ/badge" alt="hackmd-github-sync-badge"></a></p>
<p>一个读书笔记。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书首先自底向上介绍现代计算机的基本工作原理，论述了计算软件和硬件如何协调工作。在此基础上，介绍了一个程序是如何从源代码，被编译，然后被执行的。然后，详细展开说明一个应用程序在硬件和操作系统层面是如何被执行的。 最后，介绍了多个程序之间是如何互动，比如IO、网络、以及并发。</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>这本书的角度很独特，作者从一个开发应用程序的程序员角度切入，而不是从操作系统开发人员的角度切入。刚开始读这本书的时候，原本的目的是学习操作系统，但是却意外发现这本书的角度其实非常适合非操作系统开发程序员阅读。因为他深入浅出的解释了很多幕后的事情，读后感觉对整个计算机工作原理有了更加深入的理解，同时也有助于写出更加高效的程序。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>Information is Bits + Context</p>
</blockquote>
<p>源代码的编译过程：</p>
<p><img src="https://i.imgur.com/RBffpof.png" alt="源代码编译"></p>
<p>编译过程主要包含：预处理，编译，汇编，连接等四个过程。预处理主要是扩充源代码的语法糖，比如宏，导入等等；编译器输出汇编版本的程序；汇编器会形成二进制的目标文件；最终，连接器会把各个目标文件组合在一起形成最终的可执行二进制文件。整个过程就是一个把高级语言翻译成二进制指令的过程。</p>
<p>计算机只能执行二进制指令，这些指令通常涉及：读入、存储、计算和跳转。当我们执行一个程序的时候，就是执行编译产生的二进制文件的时候，所有指令和数据会被读入内存，然后CPU通过读取指令和数据完成计算。</p>
<p><img src="https://i.imgur.com/ggjMHJJ.png" alt=""></p>
<p>操作系统的主要功能就是提供一个硬件和一般引用程序之间的抽象，为每一个应用程序提供一个进程，也就是一个相对独立的CPU和内存环境。</p>
<p><img src="https://i.imgur.com/79exfiM.png" alt=""></p>
<p>计算机的各个部分通过总线连接：</p>
<p><img src="https://i.imgur.com/b9gUgiO.png" alt=""></p>
<h2 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h2><h3 id="信息的表达与操作"><a href="#信息的表达与操作" class="headerlink" title="信息的表达与操作"></a>信息的表达与操作</h3><p>word size: 寻址极限，指针的范围。因为1 byte = 8 bit. 所以在64位寻址系统中，一个指针类型由8 byte表达，即64bits。</p>
<p>fix point fraction and floating point fraction。 这里有个不错的参考：<br><a href="https://ryanstutorials.net/binary-tutorial/binary-floating-point.php">https://ryanstutorials.net/binary-tutorial/binary-floating-point.php</a></p>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>bit wise 运算。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>转化小数到二进制的小数的一种方法：不断给小数部分乘2，取结果整数部分（1或者0）作为该位置的bit，持续进行。</p>
<p>一些“奇怪”的问题，浮点数的代数性质并不能跟真正的小数一致，比如</p>
<ul>
<li>(3.14+1e10) - 1e10 = 0</li>
<li>(1e20<em>1e10)*1e-20 = 无穷，1e20</em>(1e20*1e-20) = 1e20</li>
</ul>
<p>为了避免这些，尽量考虑计算过程中的数值的极值范围，合理处理上面的极端情况。减少两个数量级相差很多的量进行计算， 通常先进行规范化处理后进行计算。</p>
<h3 id="代码的机器层面表达"><a href="#代码的机器层面表达" class="headerlink" title="代码的机器层面表达"></a>代码的机器层面表达</h3><p>源代码经过编译，会形成汇编文件，这个文件其实就是通过简单的指令按顺序排列。只不过在这个阶段，指令使用人类可以理解的单词表达，比如<code>pushl</code>等等。汇编文件经过汇编，就形成了二进制文件，也就是把汇编指令一一对应的翻译成二进制（一般采用16进制表达），如下图所示：</p>
<p><img src="https://i.imgur.com/LkwkUrY.png" alt=""></p>
<h3 id="提高速度的一些小技巧"><a href="#提高速度的一些小技巧" class="headerlink" title="提高速度的一些小技巧"></a>提高速度的一些小技巧</h3><ol>
<li>减少循环</li>
<li>循环中减少函数调用</li>
<li>使用局部变量</li>
</ol>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>这里的异常处理指的是硬件或者操作系统层面的异常，不是高级语言中的异常处理。</p>
<p>在硬件层面，异常主要分成四种：</p>
<ul>
<li>Interrupt，异步，通常由IO造成</li>
<li>Trap,同步，一般是操作系统内核制造</li>
<li>Fault，同步，可恢复的错误产生</li>
<li>Abort，同步，不可恢复的错误产生</li>
</ul>
<p>其中，只有Interrupt是异步的，因为它是由CPU外部的设备产生的，而其他异常都是CPU执行指令的结果。</p>
<h3 id="进程，Processes"><a href="#进程，Processes" class="headerlink" title="进程，Processes"></a>进程，Processes</h3><p>异常处理是系统实现进程抽象的基本方法，每一个运行在操作系统上的程序都有自己的进程，进程中包含了程序的代码、数据、盏、寄存器状态等等。进程提供了两个基本的抽象：</p>
<ul>
<li>独立的逻辑控制流程</li>
<li>独立的私有内存空间</li>
</ul>
<p>有了这个两个抽象，每一个程序就好像独占整个电脑一样。每一个进程都至少有一个进程ID，PID，如果是子进程，还会有对应的子进程pid。从程序员的角度看，一个进程有三种状态：running, stopped, terminated。</p>
<p><code>fork</code>可以用来创建进程或者子进程。<code>execve</code> 可以用来执行一段程序。程序与进程是不同的，程序通常只是一段代码加数据，而进程则是一系列的计算资源、内存、IO等等。通常一个程序需要在进程中运行。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存，Virtual Memory，是另一个非常重要的抽象。VM主要有三个功能：</p>
<ul>
<li>物理内存成为虚拟内存地址的高速缓存</li>
<li>实现了每一个进程独立的虚拟内存空间</li>
<li>确保不同进程的内存空间不发生冲突</li>
</ul>
<p>Memory management unit, MMU, is the hardware that translate virtual addresses to physical addresses. </p>
<p>虚拟内存的基本思想就是区分数据本身和数据属性，比如地址并不是数据本身，而是数据的一个属性，因此，同一个数据可以具有不同的地址属性。因此，每一个字节（Byte）的内存空间都有一个物理地址和一个虚拟地址。</p>
<blockquote>
<p>任何计算机问题都可以通过增加重新定向解决，Mapping。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p><img src="https://i.imgur.com/PPKEmBj.png" alt=""></p>
<h2 id="程序的互动"><a href="#程序的互动" class="headerlink" title="程序的互动"></a>程序的互动</h2><h3 id="系统IO"><a href="#系统IO" class="headerlink" title="系统IO"></a>系统IO</h3><p>Input/Output，IO，指的是内存和其他外设之间的数据传输过程。Input，从外部设备拷贝数据进入内存；Output，从内存传输数据进入外部设备。外部设备可以是硬盘、终端、网络等等。</p>
<p>系统内核，Kernel，提供了基本的IO操作。在Unix类系统中，所有的I/O设备，例如网络、硬盘、终端等，都用文件表达，所有的输入、输出都已读写对应的文件完成。文件，就是一些列的字节。</p>
<p>注意到，这里出现了另一个重新定向，Mapping：I/O设备到文件。通过文件映射，统一了各类外设的操作方法。跟虚拟内存异曲同工。</p>
<p><img src="https://i.imgur.com/vPBnwkw.png" alt=""></p>
<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>Socket Interface.</p>
<p><img src="https://i.imgur.com/QcA0tVp.png" alt=""></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>这里是应用层面的并发。操作系统提供了三种并发方法：</p>
<ul>
<li>Process,进程</li>
<li>I/O multiplexing</li>
<li>Thread，线程</li>
</ul>
<p>线程实现可以看成是Process和Multiplexing的结合，多个线程在同一个进程中，因此共享内存，但是程序执行的schedule是由系统内核完成的。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning 4 Dynamic Programming</title>
    <url>/2020/08/01/rl4/</url>
    <content><![CDATA[<p>In previous chapter, value functions are defined. Dynamic Programming method is used here to use value functions to organize and structure the search for agent best policy.</p>
<p><img src="https://i.imgur.com/26qVDFu.png" alt=""></p>
<p><img src="https://i.imgur.com/YFH5OcT.png" alt=""></p>
<p>In other words, DP algorithms are obtained by turning Bellman equations such as these into assignments, that is, into update rules for improving approximations of the desired value functions.</p>
<h2 id="Policy-Evaluation"><a href="#Policy-Evaluation" class="headerlink" title="Policy Evaluation"></a>Policy Evaluation</h2><p>First thing, how can we compute value function $v_{\pi}$ given a policy? This is also known as <em>prediction problem</em> or <em>policy evaluation</em>. </p>
<p><img src="https://i.imgur.com/GBtvnIv.png" alt=""></p>
<p>As above, there is a iterative method that we can solve this recursive problem.</p>
<p><img src="https://i.imgur.com/qwEAxdf.png" alt=""></p>
<p>TODO: code to simulate Grid world value functions</p>
<h2 id="Policy-Improvement"><a href="#Policy-Improvement" class="headerlink" title="Policy Improvement"></a>Policy Improvement</h2><p>The theory is simple. If $q_{\pi}(s,\pi’(s)) \gt v_{\pi}(s)$, then $\pi’$ must be as good as, or better than, $\pi$ . Hence $v_{\pi’}(s) \gt v_{\pi}(s)$</p>
<p><img src="https://i.imgur.com/Yrw6w2t.png" alt=""></p>
<p>Or in another equation:</p>
<p><img src="https://i.imgur.com/NMnxuE7.png" alt=""></p>
<p>TODO：code</p>
<h2 id="Policy-Iteration"><a href="#Policy-Iteration" class="headerlink" title="Policy Iteration"></a>Policy Iteration</h2><p>Once we know how to compute value function and how to improve a policy using value function, we can iterate the process to get a optimal policy.</p>
<p><img src="https://i.imgur.com/39yUEIw.png" alt=""></p>
<h2 id="Value-Iteration"><a href="#Value-Iteration" class="headerlink" title="Value Iteration"></a>Value Iteration</h2><p><img src="https://i.imgur.com/kfwyLJf.png" alt=""></p>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning 3 Markov Decision Process</title>
    <url>/2020/07/31/rl2/</url>
    <content><![CDATA[<h1 id="Markov-Decision-Process-MDP"><a href="#Markov-Decision-Process-MDP" class="headerlink" title="Markov Decision Process, MDP"></a>Markov Decision Process, MDP</h1><p><a href="https://hackmd.io/BGkR2gTjTLy6oHBfkQ2EAQ"><img src="https://hackmd.io/BGkR2gTjTLy6oHBfkQ2EAQ/badge" alt="hackmd-github-sync-badge"></a></p>
<h2 id="High-level-overview-of-RL"><a href="#High-level-overview-of-RL" class="headerlink" title="High level overview of RL"></a>High level overview of RL</h2><p>At the heart of RL theory, it is Markov Decision Process.</p>
<p>The general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment.</p>
<p>High level description of RL problem: three signals.</p>
<p>The <strong>representation</strong> of the signals (actions and states) is art! Reword, on the other hand, is always real numbers. (why?? this does not sound good!!! Not consistent with actions and states which have complex representation!!)</p>
<p>Two types of RL tasks: episodic task and continuing task.</p>
<p>The reward for both cases: </p>
<p>$$G_t = \sum_{k=0}^{T-t-1}\gamma^k R_{t+k+1}$$</p>
<p>where, $T$ can be infinite and $\gamma$ can be 1.</p>
<h2 id="The-Markov-Property"><a href="#The-Markov-Property" class="headerlink" title="The Markov Property"></a>The Markov Property</h2><p>Here we don’t discuss the design of state signal, because I focus on form the RL problem framework. However, the design of the states representation is very important in terms of make a good RL model.</p>
<p>State representation can be very complicated and not expected to inform the agent everything about the environment. </p>
<p>A state signal that succeeds in retaining all relevant information is said to be Markov, or to have the <strong>Markov property</strong>.</p>
<p>The dynamic of environment is a joint distribution of states and rewards:</p>
<p>$$Pr{R_{t+1}=r, S_{t+1}=s’|S_0,A_0,R_1,…,S_t, A_t}$$</p>
<p>If state signal has the Markov property, we have</p>
<p>$$p(s’,r|s,a) = Pr{R_{t+1}=r, S_{t+1}=s’|S_t, A_t}$$</p>
<p>In order for these to be effective and informative, the state representation must be informative.</p>
<h2 id="Markov-Decision-Process"><a href="#Markov-Decision-Process" class="headerlink" title="Markov Decision Process"></a>Markov Decision Process</h2><p>Expected rewords for state-action pairs:</p>
<p><img src="https://i.imgur.com/64vtOf2.png" alt=""></p>
<p>The state-transition probability:</p>
<p><img src="https://i.imgur.com/eqZhGEy.png" alt=""></p>
<p>The expected rewards for state-action-next-state triples:</p>
<p><img src="https://i.imgur.com/7xgrcZX.png" alt=""></p>
<h2 id="Value-functions"><a href="#Value-functions" class="headerlink" title="Value functions"></a>Value functions</h2><p>Value functions estimation how good is a state in terms of the goal. Accordingly, value functions are defined with respect to particular policies.</p>
<p>For MDPs, we can define $v_{\pi}(s)$ formally as</p>
<p>$$v_{\pi}(s)=\mathbb{E}_{\pi}[G_t|S_t=s]$$</p>
<p>where, $G_t = \sum_{k=0}^{\infty}\gamma^kR_{t+k+1}$.</p>
<p>Similarly, we can define the value of taking action a in state s under a policy:</p>
<p>$$q_{\pi}(s, a) = \mathbb{E}_{\pi}[G_t | S_t=s, A_t=a]$$</p>
<p>A fundamental property of value function is that they satisfy particular recursive relationships.</p>
<p>$$v_{\pi} = \sum_{a}\pi(a|s)\sum_{s’,r}p(s’,r|s,a)[r+\gamma v_{\pi}(s’)]$$</p>
<p>This is <strong>Bellman equation</strong>.</p>
<h2 id="Optimal-Value-Functions"><a href="#Optimal-Value-Functions" class="headerlink" title="Optimal Value Functions"></a>Optimal Value Functions</h2><p>Solving a reinforcement learning task means, roughly, finding a policy that achieves a lot of reward over the long run. </p>
<p>$$q_{<em>}=\mathbb{E}[R_{t+1}+\gamma v_{</em>}(S_{t+1})|S_t=s,A_t=a]$$</p>
<p>We have</p>
<p>$$v_{<em>}=max\sum_{s’,r}p(s’,r|s,a)[r+\gamma v_{</em>}(s’)], for all A(s)$$</p>
<p>$$q_{<em>}(s,a) = \sum_{s’,r}p(s’,r|s,a)[r + \gamma max q_{</em>}(s’,a’)]$$</p>
<p>These are Bellman optimality equation.</p>
<h2 id="Bellman-Equations"><a href="#Bellman-Equations" class="headerlink" title="Bellman Equations"></a>Bellman Equations</h2><p><img src="https://i.imgur.com/Ln7PnVy.png" alt=""></p>
<p>The are relationships between value function and q-function:</p>
<p><img src="https://i.imgur.com/YEGGt2x.png" alt=""></p>
<p>Our goal in RL is to solve Bellman Optimality Equation. There are two ways of solving this non-linear problem:</p>
<ul>
<li>Dynamic Programming, this when you have a model of the MDP.<ul>
<li>Value iteration</li>
<li>Policy iteration</li>
</ul>
</li>
<li>Sampling <ul>
<li>Monte Carlo</li>
<li>Q-learning</li>
<li>Sarsa</li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>Reinforcement learning is about learning from interaction how to behave in order to achieve a goal.</li>
<li>the actions are the choices made by the agent; the states are the basis for making the choices; and the rewards are the basis for evaluating the choices.</li>
<li>A policy is a stochastic rule by which the agent selects actions as a function of states. The agent’s objective is to maximize the amount of reward it receives over time.</li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>MDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforment Learning Introduction 1 - 2</title>
    <url>/2020/07/25/rl1/</url>
    <content><![CDATA[<p><a href="https://hackmd.io/EF3LjEjfQtCa-yEZlFNCmQ"><img src="https://hackmd.io/EF3LjEjfQtCa-yEZlFNCmQ/badge" alt="hackmd-github-sync-badge"></a></p>
<p>Reinforcement learning, RL is a framework that let an agent to make suitable  decisions to achieve best goal. Underneath math problem to solve is a  Markov Decision Process, MDP.  RL is different from both supervised and unsupervised learning. </p>
<h1 id="Elements-of-RL"><a href="#Elements-of-RL" class="headerlink" title="Elements of RL"></a>Elements of RL</h1><p>Apart from Agent and Environment, following elements also play central<br>roles: Policy, Reward Signal, Value Function, and Model of environment. </p>
<p>Policy, is a map from current states to actions to take. It might be<br>deterministic or stochastic.</p>
<p>Reword signal, defines the goal of RL. At each step, environment will<br>give agent a single number, a reward.</p>
<p>Value function, specifies what is good in the long run. The estimation<br>of value is in the central part of RL.</p>
<p>Model, is what the agent think the environment will behave. Basically by<br>building a model of env, the agent can do planning better. But model env<br>sometime is very hard.</p>
<p>Not all RL model need full set of above. But a good value function does<br>help to make a better decision.In the end, evolutionary and value function methods both search the space of policies, but learning a value function takes advantage of information available during the course of play.</p>
<h1 id="A-bit-history"><a href="#A-bit-history" class="headerlink" title="A bit history"></a>A bit history</h1><p>There are two threads of RL histories. One thread concerns learning by trial and error that started in the psychology of animal learning. The other thread concerns the problem of optimal control and its solution using value functions and dynamic programming. </p>
<p>Although the two threads have been largely independent, the exceptions revolve around a third, less distinct thread concerning temporal-difference methods</p>
<h1 id="Simplest-problem-Multi-arm-Bandits"><a href="#Simplest-problem-Multi-arm-Bandits" class="headerlink" title="Simplest problem: Multi-arm Bandits"></a>Simplest problem: Multi-arm Bandits</h1><p>The most important feature distinguishing reinforcement learning from other types of learning is that it uses training information that evaluates the actions taken rather than instructs by giving correct actions.</p>
<p>Consider the following learning problem. You are faced repeatedly with a choice among n different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period, for example, over 1000 action selections, or time steps.</p>
<h2 id="Action-Value-method"><a href="#Action-Value-method" class="headerlink" title="Action Value method"></a>Action Value method</h2><p>Assume $q(a)$ is the true value of action a, and the estimation on t step is $Q_t(a)$. Then the simplest idea is average: </p>
<p>$$Q_t(a) = \frac {R_1+ R_2 + … + R_{N_t(a)}}{N_t(a)}$$</p>
<p>Once we have $Q_t(a)$, we can then select the action with highest estimated action value. The <em>greedy</em> action selection method can be written as</p>
<p>$$A_t = argmax Q_t(a)$$</p>
<p>Greedy means that action selection always <strong>exploits</strong> currently knowledge to max immediate reward. A simple alternative is to behave greedily most of the time, but, <strong>explore</strong> new actions sometimes.</p>
<h2 id="Incremental-Implementation"><a href="#Incremental-Implementation" class="headerlink" title="Incremental Implementation"></a>Incremental Implementation</h2><p>$$Q_{k+1} = Q_k + \frac {1}{k}[R_k - Q_k]$$</p>
<p>So esentially, update previous estimation with adjustment of new update.</p>
<p>$$NewEstimate \leftarrow OldEstimate + StepSize * [Target - OldEstimate]$$</p>
<h2 id="Nonstationary-Problem"><a href="#Nonstationary-Problem" class="headerlink" title="Nonstationary Problem"></a>Nonstationary Problem</h2><p>For non-stationary problem, it makes more sense to has more weights on recent result.</p>
<p>$$Q_{k+1} = Q_k + \alpha [R_k - Q_k]$$</p>
<p>$$Q_{k+1} = (1-\alpha)^kQ_1 + \sum_{i=1}^k\alpha(1-\alpha)^{k-i}R_i$$</p>
<h2 id="Upper-Confidence-Bound-Action-Selection"><a href="#Upper-Confidence-Bound-Action-Selection" class="headerlink" title="Upper-Confidence-Bound Action Selection"></a>Upper-Confidence-Bound Action Selection</h2><p>$$A_t = argmax_a\Big[Q_t(a) + c\sqrt{\frac{ln t}{N_t(a)}}\Big]$$</p>
<p>The idea here is to add exploration more wisely. So if an action is not selected for a long time, it is more likely to be selected, and if an action has been selected a lot of time, it is more likely to be selected (stick with optimal action, i.e. exploiate. )</p>
<h2 id="Gradient-Bandits"><a href="#Gradient-Bandits" class="headerlink" title="Gradient Bandits"></a>Gradient Bandits</h2><p>we can also learn a preference of each action, $H_t(a)$. The more preference, the more change to take that action. But preference is a relative value.</p>
<p>$$\pi_{t}(a) = P{A_t=a} = \frac {e^{H_t(a)}}{\sum_{b=1}^{n}e^{H_t(b)}}$$</p>
<p>So action is a softmax of preferences. We want to learn the preference of each actions.</p>
<p>Initially, all preference is 0.</p>
<p>So the learning/updating process is:</p>
<p>$$H_{t+1}(A_t) = H_t(A_t) + \alpha(R_t - \bar{R_t})(1 - \pi_{t}(A_t))$$</p>
<p>$$H_{t+1}(a) = H_t(a) - \alpha(R_t - \bar{R_t}\pi_t(a), \forall{a} \ne A_t$$</p>
<p>Above is a stochastic approximation to gradient ascent:</p>
<p>$$H_{t+1}(a) = H_t(a) + \alpha \frac {\partial {E[R_t]}} {\partial {H_t(a)}}$$</p>
<p>where, $E[R_t] = \sum_{b}\pi_t(b)q(b)$</p>
<h1 id="Different-Agents-of-Mult-arm-Bandits"><a href="#Different-Agents-of-Mult-arm-Bandits" class="headerlink" title="Different Agents of Mult-arm Bandits"></a>Different Agents of Mult-arm Bandits</h1><h2 id="Random-Agent"><a href="#Random-Agent" class="headerlink" title="Random Agent"></a>Random Agent</h2><p>The agent pick action randomly from action space, <code>number_of_arms</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Random</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;A random agent.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  This agent returns an action between 0 and &#x27;number_of_arms&#x27;, </span></span><br><span class="line"><span class="string">  uniformly at random. The &#x27;previous_action&#x27; argument of &#x27;step&#x27;</span></span><br><span class="line"><span class="string">  is ignored.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;random&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="Greedy-Agent"><a href="#Greedy-Agent" class="headerlink" title="Greedy Agent"></a>Greedy Agent</h2><p>The agent pick action that has most big expected value.</p>
<p>So pick action as following:</p>
<p>$$A_t = argmax Q_t(a)$$</p>
<p>Every step, update Q value of previous actions and counter of actions:</p>
<p>$$N(A_{t-1}) = N(A_{t-1}) + 1$$<br>$$Q(A_{t-1}) = Q(A_{t-1}) + \alpha(R_t - Q(A_{t-1}))$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greedy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;greedy&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="keyword">return</span> np.argmax(self.Q)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="epsilon-Greedy-Agent"><a href="#epsilon-Greedy-Agent" class="headerlink" title="$\epsilon$-Greedy Agent"></a>$\epsilon$-Greedy Agent</h2><p>The issue of pure greedy agent is that it may stuck in some false action and never explore. So we add a small change to select action which does not have best q value, but just to explore to gather more information.</p>
<p>The update process is as same as Greedy agent. But the way we choose actions changed:</p>
<p>$$A_t = argmax Q, rand &gt; \epsilon$$<br>$$A_t = random action, rand &lt;= \epsilon$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EpsilonGreedy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms, epsilon=<span class="number">0.1</span></span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self._epsilon = epsilon</span><br><span class="line">    self.name = <span class="string">&#x27;epsilon-greedy epsilon:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(epsilon)</span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line"></span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      ra = <span class="built_in">bool</span>( np.random.random() &lt; self._epsilon )</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">not</span> ra) * np.argmax(self.Q) + (ra) * np.random.randint(self._number_of_arms)</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="comment">## UCB Agent</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCB</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms</span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self.name = <span class="string">&#x27;ucb&#x27;</span></span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.t += <span class="number">1</span></span><br><span class="line">      <span class="comment"># update values</span></span><br><span class="line">      self.N[previous_action] += <span class="number">1</span></span><br><span class="line">      lr = <span class="number">1.</span>/self.N[previous_action]</span><br><span class="line">      error = reward - self.Q[previous_action]</span><br><span class="line">      self.Q[previous_action] += lr*error</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># here is the extra bit</span></span><br><span class="line">      U = np.sqrt(np.log(self.t)/<span class="number">1.</span>/(self.N+<span class="number">1.</span>))</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="keyword">return</span> np.argmax(self.Q+U)</span><br><span class="line">      </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.Q = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.N = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.t = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Reinforce-Agent"><a href="#Reinforce-Agent" class="headerlink" title="Reinforce Agent"></a>Reinforce Agent</h2><p>Base line will not affect mean, but will change the variance of the estimation. </p>
<p>After we have the policy, we can sample an action from the policy.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reinforce</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number_of_arms, step_size=<span class="number">0.1</span>, baseline=<span class="literal">False</span></span>):</span></span><br><span class="line">    self._number_of_arms = number_of_arms</span><br><span class="line">    self._lr = step_size</span><br><span class="line">    self.name = <span class="string">&#x27;reinforce, baseline: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(baseline)</span><br><span class="line">    self._baseline = baseline</span><br><span class="line">    self.reset()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, previous_action, reward</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(previous_action) == <span class="built_in">type</span>(<span class="literal">None</span>):</span><br><span class="line">      <span class="keyword">return</span> np.random.randint(self._number_of_arms)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.t += <span class="number">1</span></span><br><span class="line">      self.all_reward += reward</span><br><span class="line">      <span class="keyword">if</span> self._baseline:</span><br><span class="line">        base = self.all_reward / (self.t * <span class="number">1.</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        base = <span class="number">0</span></span><br><span class="line">      <span class="comment"># update preferences</span></span><br><span class="line">      <span class="comment"># this is H_a, reduce others preference</span></span><br><span class="line">      self.prob -= self._lr * (reward-base) * self.policy</span><br><span class="line">      <span class="comment"># this is H_A, increase current action preference</span></span><br><span class="line">      self.prob[previous_action] += self._lr * (reward-base)</span><br><span class="line">      x = self.prob</span><br><span class="line">      y = np.exp(x - np.<span class="built_in">max</span>(x))</span><br><span class="line">      self.policy = y / np.<span class="built_in">sum</span>(y)</span><br><span class="line">      <span class="comment"># get new actions</span></span><br><span class="line">      <span class="comment"># here we sample an action from the updated policy</span></span><br><span class="line">      <span class="keyword">import</span> bisect</span><br><span class="line">      acc = np.cumsum(self.policy)</span><br><span class="line">      <span class="keyword">return</span> bisect.bisect(acc, np.random.random())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.policy = np.ones((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)/self._number_of_arms</span><br><span class="line">    self.prob = np.zeros((self._number_of_arms,),dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">    self.t = <span class="number">0</span></span><br><span class="line">    self.all_reward = <span class="number">0</span> </span><br></pre></td></tr></table></figure>

<h1 id="Full-RL-Problem"><a href="#Full-RL-Problem" class="headerlink" title="Full RL Problem"></a>Full RL Problem</h1><p>Above problem is not a full RL problem, because there is no association between action and different situations. Full RL problem needs to learn a policy that maps situations to actions.</p>
<h1 id="Bandit-Env-Code-Attached"><a href="#Bandit-Env-Code-Attached" class="headerlink" title="Bandit Env Code Attached"></a>Bandit Env Code Attached</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BernoulliBandit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;A stationary multi-armed Bernoulli bandit.&quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, success_probabilities, success_reward=<span class="number">1.</span>, fail_reward=<span class="number">0.</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Constructor of a stationary Bernoulli bandit.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      success_probabilities: A list or numpy array containing the probabilities,</span></span><br><span class="line"><span class="string">          for each of the arms, of providing a success reward.</span></span><br><span class="line"><span class="string">      success_reward: The reward on success (default: 1.)</span></span><br><span class="line"><span class="string">      fail_reward: The reward on failure (default: 0.)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self._probs = success_probabilities</span><br><span class="line">    self._number_of_arms = <span class="built_in">len</span>(self._probs)</span><br><span class="line">    self._s = success_reward</span><br><span class="line">    self._f = fail_reward</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, action</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The step function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      action: An integer or tf.int32 that specifies which arm to pull.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      A sampled reward according to the success probability of the selected arm.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">      ValueError: when the provided action is out of bounds.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> action &lt; <span class="number">0</span> <span class="keyword">or</span> action &gt;= self._number_of_arms:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Action &#123;&#125; is out of bounds for a &#x27;</span></span><br><span class="line">                       <span class="string">&#x27;&#123;&#125;-armed bandit&#x27;</span>.<span class="built_in">format</span>(action, self._number_of_arms))</span><br><span class="line"></span><br><span class="line">    success = <span class="built_in">bool</span>(np.random.random() &lt; self._probs[action])</span><br><span class="line">    reward = success * self._s + (<span class="keyword">not</span> success) * self._f</span><br><span class="line">    <span class="keyword">return</span> reward</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Reinforcement Learning</tag>
        <tag>n-arm bandit</tag>
      </tags>
  </entry>
  <entry>
    <title>Python无成本加速技巧</title>
    <url>/2020/06/14/python_speedup/</url>
    <content><![CDATA[<p>Python是个很精巧的语言，但是常见的Cython解释器生成的代码相对来说还是比较慢的，这里主要是跟动态语言的一些特性有关系。但是，我会介绍一下非常常见的手段，可以通过简单的变化提升代码速度：无成本的加速技巧。</p>
<h1 id="palm-tree-Python到底慢在哪里？"><a href="#palm-tree-Python到底慢在哪里？" class="headerlink" title=":palm_tree: Python到底慢在哪里？"></a>:palm_tree: Python到底慢在哪里？</h1><p>其实，巨大部分的场景我们觉得Python慢是在循环的时候。那么<strong>在循环里，我们可以注意如下</strong>：</p>
<h2 id="1、避免使用-操作"><a href="#1、避免使用-操作" class="headerlink" title="1、避免使用 . 操作"></a>1、避免使用 <code>.</code> 操作</h2><p>比如如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        z = math.sqrt(x) + math.sqrt(y)  <span class="comment"># 这里的 . 操作很慢</span></span><br><span class="line">        demo.something()   <span class="comment"># 这里的 . 操作很慢</span></span><br></pre></td></tr></table></figure>

<p><code>.</code> 会访问类的内部字典找到合适的方法或者属性，这些操作放在循环中就会拖慢速度。所以，应该尽量把这个操作从循环中去除。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt   <span class="comment"># &lt;==== </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">10000</span></span><br><span class="line">demo = Demo()</span><br><span class="line">sth = demo.something()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        z = sqrt(x) + sqrt(y)  <span class="comment"># &lt;----</span></span><br><span class="line">        sth()   <span class="comment"># &lt;----</span></span><br></pre></td></tr></table></figure>

<h2 id="2、避免循环临时变量"><a href="#2、避免循环临时变量" class="headerlink" title="2、避免循环临时变量"></a>2、避免循环临时变量</h2><p>比如使用 <code>a, b = b, a</code> 来交换变量，而不是使用临时变量</p>
<h2 id="3、字符串使用join-而不是"><a href="#3、字符串使用join-而不是" class="headerlink" title="3、字符串使用join 而不是 +"></a>3、字符串使用<code>join</code> 而不是 +</h2><p>比如 <code>&#39;_&#39;.join([&quot;a&quot;, &quot;b&quot;])</code>而不是 <code>&quot;a&quot;+&quot;_&quot;+&quot;b&quot;</code>。</p>
<p>使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。</p>
<h2 id="4、使用隐式循环"><a href="#4、使用隐式循环" class="headerlink" title="4、使用隐式循环"></a>4、使用隐式循环</h2><p>比如 <code>sum(range(10)</code> 速度比for 循环更快。但是for循环比while循环更快！</p>
<h2 id="5、大杀器：numba-jit"><a href="#5、大杀器：numba-jit" class="headerlink" title="5、大杀器：numba.jit"></a>5、大杀器：<code>numba.jit</code></h2><p>比如同样的代码，下面的循环一个在1s内完成，而普通版本需要4s。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numba</span><br><span class="line"></span><br><span class="line"><span class="meta">@numba.jit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeSum</span>(<span class="params">size: <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="built_in">sum</span> = computeSum(size)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总之，最低成本加速的方法就是尽量减少循环中的无意义操作，或者进行jit编译（其实也是减少Head的重量）。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新科学</title>
    <url>/2020/05/16/a_new_kind_of_science/</url>
    <content><![CDATA[<blockquote>
<p>一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
</blockquote>
<h1 id="1、新科学的基础"><a href="#1、新科学的基础" class="headerlink" title="1、新科学的基础"></a>1、新科学的基础</h1><p>简单的规则，可以形成复杂的行为。</p>
<p>如果人也是规则计算的一部分，自由意志又是如何与之协调的？</p>
<p>数学、物理、生物学、社会学、哲学、计算机科学、艺术的关系。这个系统真的解决了这些领域的基本问题吗？？</p>
<h1 id="2、关键性的实验"><a href="#2、关键性的实验" class="headerlink" title="2、关键性的实验"></a>2、关键性的实验</h1><p>每一个新的科学产生都起始于某一个现象或者观察。这本书的起点是程序和计算。日常生活中程序通常是为了某些特殊的目的编写的，那么问题来了，如果我们随便选一些程序，而没有明确的目的，这些程序的运行结果会是什么呢？</p>
<p>上面这个问题，数学很难解决，而最简单的办法就是用计算机进行试验。</p>
<p>程序从抽象的角度可以理解成为：包含一些规则（Rules），这些会规定每一步做什么。设定规则的方式有很多。比如cellular automata，元细胞自动机。</p>
<p>重要的发现是：简单的规则，可以产生复杂的模式。这也是本书的所谓新科学的核心思想。</p>
<p>Rule30，是一个简单的规则，但是产生了随机数。</p>
<p>问题是当我们观察到非常复杂的行为时，产生这种行为的规则（如果是有规则产生的话）可能非常简单。</p>
<h1 id="3、简单程序的世界！"><a href="#3、简单程序的世界！" class="headerlink" title="3、简单程序的世界！"></a>3、简单程序的世界！</h1><p>问题：简单程序的一般行为是什么样的？</p>
<p>作者发现的规律：</p>
<ul>
<li>Cellular automata, 不仅可以产生重复的模式，还可以产生随机性</li>
<li>Substitute system，似乎只能产生重复的模式，而不能产生随机性</li>
<li>Sequence Substitute system，也可以产生随机性</li>
<li>Tag system</li>
<li>Cyclic Tag system</li>
<li>Symbolic system</li>
</ul>
<p>（是吗？）</p>
<p>作者发现，在很多迥异的系统中，简单的规则总是能够产生复杂的行为，甚至随机性。所以这种简单导致的复杂性普遍存在。下一个问题是：什么时候会出现复杂性？通过目前的实验，如果规则很简单，会出现重复的行为；规则稍微复杂，会出现嵌套类型的现象；当规则进一步复杂，就会出现更加复杂的行为，比如混合和随机性。</p>
<p>作者发现，出现复杂行为的阈值通常很低。但是，一旦超过阈值，提高规则的复杂度，并不能显著提高系统的复杂性。复杂的系统行为与规则的复杂度并没有显著的关联，也就是说，行为异常复杂的系统，其控制规则可能非常简单。</p>
<p>据此，作者推断应该存在一般性的原则控制这些系统的复杂度。</p>
<p>（如何定义复杂度？随机性？熵？）</p>
<p>这章最后作者提到了一些对传统数学和物理研究方法的看法：<br>他的研究方法在传统领域可能会被认为是不精确的，但是传统方法是从现象出发的，可能不能发现上文的复杂度。作者采用了实验的途径。</p>
<h1 id="4、基于数字的系统"><a href="#4、基于数字的系统" class="headerlink" title="4、基于数字的系统"></a>4、基于数字的系统</h1><p>基于数字的系统在传统科学和数学领域非常普遍。那么，基于数字的系统是不是能够产生复杂度？作者给出的答案是肯定的。</p>
<p>（这类系统与细胞自动机系统有什么区别和联系？）</p>
<p>数学系统的基础是数字系统，而计算系统（比如细胞自动机）的基础是通过一个序列的代码。这种代码的表达方式在自然界非常常见，比如DNA。</p>
<h2 id="基础代数"><a href="#基础代数" class="headerlink" title="基础代数"></a>基础代数</h2><p>基础代数的操作（operation，也可以看做规则的一种吧）非常简单，但是作者发现即使这种规则也可以产生复杂系统行为，就像上一章的细胞自动机。</p>
<p>比如，以1作为基，持续加1，就像1，2，3，….从数学的角度看这是一个再简单不过的操作，但是如果我们看这个操作以二进制的形式就会呈现一定的复杂度。</p>
<p><img src="https://i.imgur.com/7yhmZHN.png" alt="简单加法的二进制模式"></p>
<p>有人可能提出疑问，就是这种复杂度仅仅是看起来而已，并没有本质的复杂度。但是作者提出了新的例子：除法。</p>
<p>(其实无理数对于数字来说已经非常奇葩了。。。随机性还记得吗？)</p>
<p><img src="https://i.imgur.com/yNSwlnU.png" alt="这个看起来就好像股票价格"></p>
<p>这些系统与细胞自动机不同，细胞自动机的变化通常是局部的，而数字系统则没有这个限制。</p>
<h2 id="递归序列"><a href="#递归序列" class="headerlink" title="递归序列"></a>递归序列</h2><p>比如，$f[n] = f[n-1] + f[n-2]$。简单的规则可以发现：</p>
<p><img src="https://i.imgur.com/WCTTJpN.png" alt=""></p>
<p>但是，如果稍微增加复杂度，我们就会发现复杂系统行为：</p>
<p><img src="https://i.imgur.com/kBF0hMf.png" alt=""></p>
<h2 id="数学常数"><a href="#数学常数" class="headerlink" title="数学常数"></a>数学常数</h2><p>常数比如$\pi$, $e$，无理数等等。</p>
<p><img src="https://i.imgur.com/GxEXKZd.png" alt=""></p>
<p>作者表明，不论采用哪种形式表达，数学常数也表现了高的复杂度。</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>一个自然的推广就是函数。简单函数只要稍微叠加，就会出现复杂现象。</p>
<p><img src="https://i.imgur.com/X5ANIxW.png" alt=""></p>
<h2 id="连续细胞自动机"><a href="#连续细胞自动机" class="headerlink" title="连续细胞自动机"></a>连续细胞自动机</h2><p>目前为止作者讨论的系统全部都是离散系统。</p>
<p><img src="https://i.imgur.com/Wgjq8VT.png" alt=""></p>
<h2 id="连续系统和离散系统"><a href="#连续系统和离散系统" class="headerlink" title="连续系统和离散系统"></a>连续系统和离散系统</h2><p>区别在哪里呢？</p>
<h1 id="5、二维和更高维度"><a href="#5、二维和更高维度" class="headerlink" title="5、二维和更高维度"></a>5、二维和更高维度</h1><p>结论是，维度的增加并没有改变复杂度的基本特征。</p>
<h2 id="高纬度细胞自动机"><a href="#高纬度细胞自动机" class="headerlink" title="高纬度细胞自动机"></a>高纬度细胞自动机</h2><p><img src="https://i.imgur.com/wKcVljW.png" alt=""></p>
<p>这个像不像雪花？自然界的现象。</p>
<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><h2 id="Substitute系统和分型"><a href="#Substitute系统和分型" class="headerlink" title="Substitute系统和分型"></a>Substitute系统和分型</h2><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><p>这个其实已经看到了现在火爆的作者的物理学项目的影子了。</p>
<h1 id="6、从随机性说起"><a href="#6、从随机性说起" class="headerlink" title="6、从随机性说起"></a>6、从随机性说起</h1><p>作者综合分析了细胞自动机的四类行为，并且认为这些行为具有通用价值。</p>
<h1 id="7、程序和自然界的机理"><a href="#7、程序和自然界的机理" class="headerlink" title="7、程序和自然界的机理"></a>7、程序和自然界的机理</h1><p>作者让我们看到自然界的很多现象都与之前的介绍的内容非常相似。</p>
<p><em>随机性</em></p>
<ul>
<li>外界注入随机性，通过与系统外界的通讯</li>
<li>初始条件随机性</li>
<li>自身演化产生随机性，无外界通讯</li>
</ul>
<p>作者认为第三种是控制自然界随机性的主要形式。</p>
<p>（是否有可能是三者的共同作用呢？）</p>
<p>（预定论和随机性并不冲突。）</p>
<p>作者认为随机性是让离散系统看起来像连续系统的原因。（实际上我觉得这个世界本身就是离散的，现代物理学似乎也支持这个观点）</p>
<h1 id="8、对日常系统的分析"><a href="#8、对日常系统的分析" class="headerlink" title="8、对日常系统的分析"></a>8、对日常系统的分析</h1><h2 id="8-1-建模的问题"><a href="#8-1-建模的问题" class="headerlink" title="8.1 建模的问题"></a>8.1 建模的问题</h2><p>从简单规则演化的角度思考很多系统的现象，似乎可以解释一些基础的问题。</p>
<h1 id="9、物理学的基础"><a href="#9、物理学的基础" class="headerlink" title="9、物理学的基础"></a>9、物理学的基础</h1><p>我们的宇宙看起来异常复杂，那么，我们的宇宙可能是由简单规则经过迭代产生吗？这本书的一个重要发现就是：复杂现象的成因不一定是复杂的。</p>
<p>值得注意的是，作者指出即使上面这个假设成立，这个系统并不具有可逆性，我们无法通过反向工程我们的宇宙找到对应的法则。</p>
<p>好，如果我们假设宇宙的演化可以由简单规则表达，那么我们如何找到这些规则？这些规则有什么特征？</p>
<p>细胞自动机可能不是一个好的选择，因为它的演化被限制在了一些格子里。。（也许这只是编码结构的不同而已，最终他们代表了相同的意义？）</p>
<p>作者对传统物理提出了挑战，他认为目前的物理定律并没有解释基础问题，而仅仅是规则在大尺度下的一些特征。换句话说，目前的物理定律，对解释基础物理毫无作用！</p>
<h2 id="空间的本质"><a href="#空间的本质" class="headerlink" title="空间的本质"></a>空间的本质</h2><p>物理学普遍认为空间是连续的，但是对于细胞自动机而言，他们的空间显然是离散的。</p>
<p>那么问题是：如何对这样的宇宙建模？</p>
<p>作者选择了用网络的形式表达空间。每一个节点具有三个连接。</p>
<h2 id="时间和空间的联系"><a href="#时间和空间的联系" class="headerlink" title="时间和空间的联系"></a>时间和空间的联系</h2><p>作者相信时间也是离散的。同样采用网络进行建模：因果网络。</p>
<h1 id="10、认知与分析"><a href="#10、认知与分析" class="headerlink" title="10、认知与分析"></a>10、认知与分析</h1><p>解释人类感知和分析能力。</p>
<h1 id="11、计算的语言"><a href="#11、计算的语言" class="headerlink" title="11、计算的语言"></a>11、计算的语言</h1><p>泛化的原细胞自动机。</p>
<h1 id="12、计算等价原则"><a href="#12、计算等价原则" class="headerlink" title="12、计算等价原则"></a>12、计算等价原则</h1><p>假设: 一切过程，无论是自然过程还是人工过程，都可以被等价成计算（computation）</p>
<p>自从计算机诞生，计算的对象已经从抽象的数字发展到图像、声音等等。</p>
<p>从计算的角度看，即使具有截然不同的内部结构的系统仍然具有一定的等价性。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Computation</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph - DiGraph</title>
    <url>/2020/05/09/graph3_digraph/</url>
    <content><![CDATA[<h1 id="1-Concepts"><a href="#1-Concepts" class="headerlink" title="1. Concepts"></a>1. Concepts</h1><p><strong>Definition.</strong> A <code>directed graph</code> or <code>digraph</code> is a set of nodes and a<br>collection of <code>directed edges</code>. Each directed edge connects an ordered<br>pair of nodes.</p>
<p><strong>Definition.</strong> A <code>directed path</code> is a path in a digraph is a sequence of nodes in which there is a directed edge pointing from each node in the sequence to its successor in the sequence. A <code>directed cycle</code> is a directed path with at least one edge whose first and last nodes are the same. A <code>simple cycle</code> is a cycle with no repeated edges or nodes. The <code>length</code> of a path is its number of edges.</p>
<p>With above, we can define that a node a is reachable from node b if there is a directed path from a to b. </p>
<h1 id="2-Data-Structure"><a href="#2-Data-Structure" class="headerlink" title="2. Data Structure"></a>2. Data Structure</h1><p>Again, before we go to the algorithms of DiGraph, let’s define our data structure representation of digraph. Full code can be found here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/digraph.py</a>.</p>
<p>Here I list the important part. DiGraph is a bit different from Undirected graph in terms of its internal data containers. DiGraph has not only <code>_adj</code> for adjacent list, but also has <code>_succ</code> and <code>_pred</code> which is used to represent the direction of edges. What’s more, there is a <code>reverse</code> function to reverse the direction of the edges in the graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Hashable</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygraph.entities.graph <span class="keyword">import</span> GraphBase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiGraph</span>(<span class="params">GraphBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dict_dict_dict = <span class="built_in">dict</span></span><br><span class="line">    dict_dict = <span class="built_in">dict</span></span><br><span class="line">    node_factory = <span class="built_in">dict</span></span><br><span class="line">    edge_factory = <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(kwargs)</span><br><span class="line">        self._succ = self._adj</span><br><span class="line">        self._pred = self.dict_dict_dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node: Hashable, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Add node to graph,</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :param kwargs: node&#x27;s meta data</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node] = self.dict_dict()</span><br><span class="line">            self._pred[node] = self.dict_dict()</span><br><span class="line">            attr_dict = self._nodes[node] = self.node_factory()</span><br><span class="line">            attr_dict.update(kwargs)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># already existed</span></span><br><span class="line">            self._nodes[node].update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span>(<span class="params">self, node_a: Hashable, node_b: Hashable, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; add edge to graph</span></span><br><span class="line"><span class="string">        :param node_a:</span></span><br><span class="line"><span class="string">        :param node_b:</span></span><br><span class="line"><span class="string">        :param kwargs: meta data for edge, weights can go here!</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node_a <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_a] = self.dict_dict()</span><br><span class="line">            self._pred[node_a] = self.dict_dict()</span><br><span class="line">            self._nodes[node_a] = self.node_factory()</span><br><span class="line">        <span class="keyword">if</span> node_b <span class="keyword">not</span> <span class="keyword">in</span> self._succ:</span><br><span class="line">            self._succ[node_b] = self.dict_dict()</span><br><span class="line">            self._pred[node_b] = self.dict_dict()</span><br><span class="line">            self._nodes[node_b] = self.node_factory()</span><br><span class="line"></span><br><span class="line">        data = self._adj[node_a].get(node_b, self.edge_factory())</span><br><span class="line">        data.update(kwargs)</span><br><span class="line">        self._succ[node_a][node_b] = data</span><br><span class="line">        self._pred[node_b][node_a] = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj_nodes</span>(<span class="params">self, node: Hashable</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; find adj nodes view</span></span><br><span class="line"><span class="string">        :param node:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._succ[node]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self</span>) -&gt; GraphBase:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; reverse the graph &quot;&quot;&quot;</span></span><br><span class="line">    gp = self.__class__()</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> self.nodes:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> self._adj[a]:</span><br><span class="line">            gp.add_edge(b, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gp</span><br></pre></td></tr></table></figure>

<h1 id="3-Problems"><a href="#3-Problems" class="headerlink" title="3. Problems"></a>3. Problems</h1><p>Ok, let’s visit some of the problems around DiGraph:</p>
<ul>
<li>Single-source reachability</li>
<li>Topological sort</li>
<li>Strong connectivity</li>
</ul>
<p>These problem is similar to what we have in <a href="https://wangzhe3224.github.io/2020/05/02/graph2_search/">undirected graph</a>. </p>
<h2 id="3-1-Single-source-reachability"><a href="#3-1-Single-source-reachability" class="headerlink" title="3.1 Single-source reachability"></a>3.1 Single-source reachability</h2><blockquote>
<p>Given a digraph and a source node <em>a</em>, support query of the form: Is there a directed path from <em>a</em> to a given node <em>x</em>?</p>
</blockquote>
<p>This problem is solved using the same function as in undirected graph. Both single-source directed path(DFS) and shortest directed path (BFS).</p>
<p>Related code: <a href="https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos">https://github.com/wangzhe3224/pygraph/tree/master/pygraph/algos</a></p>
<h2 id="3-2-Topological-sort"><a href="#3-2-Topological-sort" class="headerlink" title="3.2 Topological sort"></a>3.2 Topological sort</h2><p>This is a scheduling problem. Defines:</p>
<blockquote>
<p>Given a digraph, put the nodes in order such that all its directed edges point from a node earlier in the order to a node later in the order. Or does not exist. </p>
</blockquote>
<p>In order to solve this, we first need to make sure, there is no cyclic in the graph. or make sure the graph a DAG, directed acyclic graph. <strong>So first we need a algorithm to detect cyclic in a graph.</strong></p>
<p>The solution is leverage DFS’s stack, one fact is that all the node in current stack is in the same path, of we find a node that appear twice in the stack, we know there is a cyclic, hence graph is not a DAG.</p>
<p>Once we know we have a DAG, the next job is to find the order. It turns out that it is another application of DFS.</p>
<h2 id="3-3-Strong-connection"><a href="#3-3-Strong-connection" class="headerlink" title="3.3 Strong connection"></a>3.3 Strong connection</h2><p>Strong connection between a and b is that they are mutually reachable. </p>
<p>The solution is similar to cyclic detection in undriected graph, but we need loop through reverse post order in previous section. </p>
<p>Check code here: <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/cyclic.py#L28</a></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Python</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph Algorithms - Search</title>
    <url>/2020/05/02/graph2_search/</url>
    <content><![CDATA[<p>When working with graph, search is an important topic. For example, search for connectivity, search for shortest path. There are two basic strategies to do search in graph: Depth-first(DFS) and Breadth-first(BFS). <strong>Note that in this blog, all the discussions are based on undirected graph</strong>. But the strategy can be used to all kind of graphs given they share similar data structures.</p>
<h1 id="What-kind-of-problems-we-are-solving"><a href="#What-kind-of-problems-we-are-solving" class="headerlink" title="What kind of problems we are solving?"></a>What kind of problems we are solving?</h1><p>The basic idea of search in general is to walk through the data structure and collection information we need. In terms of Graph, only two elements matters: nodes (vertices) and edges. Walking through a graph, really means iterating the nodes in a way.</p>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>The next questions to ask is that how can I solve a question by looping through the least nodes? Well to answer this question, we need to decide a data structure to represent graph. </p>
<p>Here we select a straight forward way: adjacent list. Completed code can be found <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/entities/graph.py">here</a></p>
<p>Essentially, we use dict of dict to represent nodes, and dict of dict of dict to represent adjacent list. I know.. it is not a list at all. But the idea is the same, the benefit of using a dict is that it is very easy to embed meta data to either nodes or edges. And it is an easy way to extend this data structure to other types of graph, say weighted graph. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span>(<span class="params">Graph</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    dict_dict_dict = <span class="built_in">dict</span></span><br><span class="line">    dict_dict = <span class="built_in">dict</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">        self.__adj = self.dict_dict_dict()  <span class="comment"># dict of dict of dict</span></span><br><span class="line">        self.__nodes = self.dict_dict()  <span class="comment"># dict of dict</span></span><br></pre></td></tr></table></figure>

<p>And.. in the end, dict (hash map) is just a list with hashable index instead of int as index. Or in another words, dict is just a generalized list… alright.. too far away. :smirk: </p>
<p>For example, we can represent graph: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 2 - 3</span><br><span class="line">    |</span><br><span class="line">    4</span><br></pre></td></tr></table></figure>

<p>with following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__adj &#x3D; &#123;1: &#123;2: &#123;&#125;&#125;, 2:&#123;3:&#123;&#125;, 4:&#123;&#125;&#125;, 3:&#123;2:&#123;&#125;&#125;, 4:&#123;2:&#123;&#125;&#125;&#125;</span><br><span class="line">__nodes &#x3D; &#123;1:&#123;&#125;, 2:&#123;&#125;, 3:&#123;&#125;, 4:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Search-strategy"><a href="#Search-strategy" class="headerlink" title="Search strategy"></a>Search strategy</h1><p>Ok, we got our little dict(s), the next question is how can we search or walk through this structure? Well when we meet the first node, there are two obvious ways: 1. go to one of its adjacent node and go even deeper via that node. 2. go to all of its adjacent nodes and do the same for other nodes. </p>
<p>The first way is called depth-first, the second is called breadth-first.</p>
<p>Apperently they have different properties.</p>
<h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><p>For detailed code, please go <a href="https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py">https://github.com/wangzhe3224/pygraph/blob/master/pygraph/algos/dfs.py</a></p>
<p>We can prove that DFS marks all the nodes connected to a given node in time proportional to the sum of their degrees.</p>
<p>Recall <code>degree of a node</code> is the number of nodes connected to it directly. </p>
<p>This strategy is efficient in may problems:</p>
<ul>
<li>Given a graph, are two given nodes are connected? This question, is equivalent to ask, given two nodes, is there a path from node a to b? if so, find me the path (in terms of sequence of nodes of course)!</li>
<li>How many connected components does the graph have?</li>
</ul>
<p>All right, let’s try to solve a find path problem using DFS.</p>
<p>Here is one question: given a graph, node a, calculate <em>one</em> path between a and the rest of the nodes, if no path, return None.</p>
<p>So let’s start with a recursive way, which is the nature of DFS. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_view</span>(<span class="params">nodes, edge_to: <span class="built_in">dict</span>, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; convert edge_to to path view &quot;&quot;&quot;</span></span><br><span class="line">    _paths = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> edge_to:  <span class="comment"># has a path</span></span><br><span class="line">            path = []</span><br><span class="line">            _<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">while</span> _<span class="built_in">next</span> != source:</span><br><span class="line">                path.append(_<span class="built_in">next</span>)</span><br><span class="line">                _<span class="built_in">next</span> = edge_to[_<span class="built_in">next</span>]</span><br><span class="line">            path.append(source)</span><br><span class="line">            _paths[node] = path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _paths[node] = <span class="literal">None</span>   <span class="comment"># no path</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _path</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_path</span>(<span class="params">graph, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; get paths from source to other nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string">    Note: not all the path, but one of the path if exist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param graph: Graph</span></span><br><span class="line"><span class="string">    :param source: the source node</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#123;target: [source, x, x, node2]&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    edge_to = &#123;&#125;  <span class="comment"># magic path..</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs_path</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">        <span class="keyword">for</span> _node <span class="keyword">in</span> graph[start]:  <span class="comment"># all its neighbour</span></span><br><span class="line">            <span class="keyword">if</span> _node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(_node)</span><br><span class="line">            edge_to[_node] = start</span><br><span class="line">            _dfs_path(graph, _node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    _dfs_path(graph, source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, edge_to, source)</span><br></pre></td></tr></table></figure>

<h2 id="Breadth-first-search"><a href="#Breadth-first-search" class="headerlink" title="Breadth-first search"></a>Breadth-first search</h2><p>Breadth-first search use a different strategy from depth-first search. It will search all the connected nodes and do the same process to sub-nodes. While depth search will go down a path to the end.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_path</span>(<span class="params">graph, source</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; a breadth first search for paths. These suppose to be the shortest paths.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    edge_to is a parent-link representation of the tree which has source as root.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reference</span></span><br><span class="line"><span class="string">    ---------</span></span><br><span class="line"><span class="string">    &lt;Algorithms 4th edition&gt; by Robert Sedgewick. P540</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param source: a source node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _queue = deque([])</span><br><span class="line">    _visited = <span class="built_in">set</span>()</span><br><span class="line">    _queue.append(source)</span><br><span class="line">    _edge_to = &#123;source: source&#125;</span><br><span class="line">    <span class="keyword">while</span> _queue:</span><br><span class="line">        cur_node = _queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> graph[cur_node]:</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> _visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            _visited.add(cur_node)</span><br><span class="line">            _edge_to[child] = cur_node</span><br><span class="line">            _queue.append(child)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path_view(graph.nodes, _edge_to, source</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Python</tag>
        <tag>Graph</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph basics - 1 Concepts</title>
    <url>/2020/04/25/graph1/</url>
    <content><![CDATA[<p>Graph is a mathematical object to model pairwise connections between objects. There are a lot of applications:</p>
<p><img src="https://i.imgur.com/aDYbUMC.png" alt="Typical graph applications"></p>
<span id="more"></span>

<h1 id="1-Definitions"><a href="#1-Definitions" class="headerlink" title="1. Definitions"></a>1. Definitions</h1><p>Definition: </p>
<ul>
<li>A <code>graph</code> is a set of vertices and a collection of edges that each connect a pair of vertices.</li>
<li>A <code>Bipartite graph</code> is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set.</li>
</ul>
<p>Definition: </p>
<ul>
<li>A <code>path</code> in a graph is a sequence of vertices connected by edges. </li>
<li>A <code>simple path</code> is one with no repeated vertices. </li>
<li>A <code>cycle</code> is a path with at least one edge whose first and last vertices are the same.</li>
<li>A <code>simple cycle</code> is a cycle with no repeated edges or vertices.</li>
<li><em>length</em> of a path or cycle is its number of edges.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A graph is <code>connected</code> if there is a path from every vertex to every other vertex in the graph.</li>
<li>A graph is <code>not connected</code> consists of a set of connected <code>components</code>, which are maximal connected subgraphs. </li>
<li>An <code>acyclic</code> graph is graph without cycles.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>A <code>tree</code> is an <code>acyclic connected</code> graph.</li>
<li>A disjoint set of trees is called a <code>forest</code>.</li>
</ul>
<p>Definitions:</p>
<ul>
<li>The <code>density</code> of a graph is the proportion of possible pairs of vertices that are connected by edges.</li>
</ul>
<p><img src="https://i.imgur.com/goP5flX.png" alt="Anatomy of a graph"></p>
<p><img src="https://i.imgur.com/RHAkNfF.png" alt="A tree"></p>
<p><img src="https://i.imgur.com/zRy67JE.png" alt="A forest"></p>
<h1 id="2-Graph-Interface"><a href="#2-Graph-Interface" class="headerlink" title="2. Graph Interface"></a>2. Graph Interface</h1><p>We now need to define fundamental graph operation interface and find a data structure to represent undirected graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Vertex &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Edge &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphOperation</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Graph operation interface &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span>(<span class="params">v: Vertex, m: Vertex</span>)-&gt;<span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj</span>(<span class="params">v: Vertex</span>) -&gt; []:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; find adjacent to v &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">degree</span>(<span class="params">v: Vertex</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; get degree of &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_self_loops</span>() -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; number of self loops &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>In the end, most of the operations can be done via <code>adj</code> method. We could add more operations for graph, but it will depends on the application’s use case. </p>
<h1 id="3-Data-Structures"><a href="#3-Data-Structures" class="headerlink" title="3. Data Structures"></a>3. Data Structures</h1><p>There are several ways to represent graph, such as adjacent matrix, array of edges, and adjacent list. Here we select adjacent list because it makes <code>adj</code> method very simple and it will also be able to represent parallel edges whereas adjacent matrix cannot do.</p>
<p><code>adjacent list</code> representation has following characteristics:</p>
<ul>
<li>space usage is proportional to V + E</li>
<li>constant time to add an edge</li>
<li>constant time per adjacent vertex processed</li>
</ul>
<p>However, the order of adjacent vertex is random for now. We could add order for it (but add some time complex).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraph</span>(<span class="params">GraphOperation</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;  &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>():</span></span><br><span class="line">        self.__adj_list = []  <span class="comment"># type: <span class="type">List</span>[Vertex]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/G0aulAp.png" alt="Adjacent list representation"></p>
<h1 id="4-Design-Pattern-of-graph-processing"><a href="#4-Design-Pattern-of-graph-processing" class="headerlink" title="4. Design Pattern of graph processing"></a>4. Design Pattern of graph processing</h1><p>The idea here is to delegate more complex operations from Graph interface, such as search connected vertex, find path or find shortest path.</p>
<p>Common algorithms:</p>
<ul>
<li>search connected vertex</li>
<li>find paths</li>
<li>find shortest path</li>
<li>is connected components?</li>
<li>is a acylic graph?</li>
<li>is graph bipartite?</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Systematic Trading</title>
    <url>/2020/04/21/systematic_trading/</url>
    <content><![CDATA[<h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><h3 id="Layer-1-Read"><a href="#Layer-1-Read" class="headerlink" title="Layer 1 Read"></a>Layer 1 Read</h3><p>作者退休前是AHL的基金经理，经历过2008年的股灾。</p>
<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
<h3 id="Layer-2-Read"><a href="#Layer-2-Read" class="headerlink" title="Layer 2 Read"></a>Layer 2 Read</h3><ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
<h3 id="Layer-3-read-精读感兴趣的地方，甚至动手操作。"><a href="#Layer-3-read-精读感兴趣的地方，甚至动手操作。" class="headerlink" title="Layer 3 read: 精读感兴趣的地方，甚至动手操作。"></a>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</h3><span id="more"></span>

<h2 id="Part-I-theory"><a href="#Part-I-theory" class="headerlink" title="Part I: theory"></a>Part I: theory</h2><h3 id="Cognitive-bias"><a href="#Cognitive-bias" class="headerlink" title="Cognitive bias"></a>Cognitive bias</h3><ol>
<li>hard to admit failure</li>
<li>happy to be confirmed</li>
<li>overconfident</li>
</ol>
<blockquote>
<p>what makes an addictive game:</p>
<ol>
<li>an illusion of control</li>
<li>frequent changes of <em>Almost</em> win big</li>
<li>rapid and continous to give a constant flow of stimulation</li>
</ol>
</blockquote>
<p>if we know most of player has these bias, we can leverage them by apply trading rules to remove our own bias.</p>
<h3 id="Good-system-design"><a href="#Good-system-design" class="headerlink" title="Good system design"></a>Good system design</h3><ul>
<li>objective</li>
<li>easiy to explain/understand</li>
<li>avoid over-fitting</li>
<li>avoid over-trading</li>
<li>avoid over-betting</li>
</ul>
<h3 id="What-makes-good-trading-rule"><a href="#What-makes-good-trading-rule" class="headerlink" title="What makes good trading rule"></a>What makes good trading rule</h3><ul>
<li>Risk prem</li>
<li>Skew trading</li>
<li>Leverage</li>
<li>Liquidity</li>
<li>Correlation</li>
</ul>
<blockquote>
<p>I also believe finding the best trading rules is less important than designing your trading system in the correct way.</p>
</blockquote>
<h2 id="Part-II-toolbox"><a href="#Part-II-toolbox" class="headerlink" title="Part II: toolbox"></a>Part II: toolbox</h2><h3 id="Fitting"><a href="#Fitting" class="headerlink" title="Fitting"></a>Fitting</h3><ol>
<li>Come up with a small number of trading rules to exploit each idea I have about how the market behaves.</li>
<li>For each rule select a few variations. At this stage I am not looking at performance, but at behaviour such as trading speed and correlation with other variations.</li>
<li>Allocate forecast weights to each variation, taking uncertainty about Sharpe ratios into account. Poor rules will have lower weight, but are rarely entirely excluded.</li>
</ol>
<p><strong>Select rules from different themes</strong></p>
<ul>
<li>trend following</li>
<li>carry </li>
</ul>
<p>Some points:</p>
<ul>
<li>So diversification amongst instruments is preferable to rule diversification, Adding new instruments is a tiresome task of uploading and checking data which is less fun than coming up with more trading rules, but in my experience is of far more benefit.</li>
</ul>
<h3 id="Portfolio-Allocation"><a href="#Portfolio-Allocation" class="headerlink" title="Portfolio Allocation"></a>Portfolio Allocation</h3><ul>
<li>Forecast weights</li>
<li>Instrument weights</li>
</ul>
<p>The goal here is given some constrains to produce allocation weights on underlyings (instruments or trading rules).</p>
<p>Portfolio allocation should be tool to control risk, leverage divercification. Optimizaion is good but only when result is still reasonable in terms of diversification. </p>
<p><strong>question:</strong> how can we quantify diversification?</p>
<h2 id="Part-III-framework"><a href="#Part-III-framework" class="headerlink" title="Part III: framework"></a>Part III: framework</h2><h3 id="Framework-overview"><a href="#Framework-overview" class="headerlink" title="Framework overview"></a>Framework overview</h3><p>Components:</p>
<ul>
<li>Instruments to trade</li>
<li>Forecasts</li>
<li>Combine forecast</li>
<li>Volatility targeting</li>
<li>Portfolio</li>
<li>Speed and Size for all</li>
</ul>
<h3 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h3><p><img src="https://i.imgur.com/v9TZ5ds.png" alt=""></p>
<h3 id="Forecasts"><a href="#Forecasts" class="headerlink" title="Forecasts"></a>Forecasts</h3><ul>
<li>Forecast should be a scale not binary</li>
<li>Should be vol adjusted</li>
<li>Should be consisten in scale</li>
<li>Forecast should be capped</li>
</ul>
<p><img src="https://i.imgur.com/aTjsVtr.png" alt=""></p>
<p>The process works as following:</p>
<p>$$<br>signal = cap({raw} / vol * scalar, up_limit, floor_limit)<br>$$</p>
<p>where,<br>$raw$ is raw signal,<br>$vol$ is volatility estimation of underly asset(s),<br>$scalar$ is an enstimation number to scale the signal to a range, say -20~+20<br>$cap(.)$ is a function that cap the signal to $up_limit, floor_limit$ </p>
<h3 id="Combined-Forecasts"><a href="#Combined-Forecasts" class="headerlink" title="Combined Forecasts"></a>Combined Forecasts</h3><p>The purpose is that given more than 1 signals for 1 instrument (can be extented to multiple instruments), we need a function to aggregate thme. $fweight$ or forecast weights estimation is at the core of this stage. And they should all be positive and<br>add up to 100%.</p>
<p><strong>Next question is how to choose an fweights given several signals?</strong></p>
<p>To answer this, portfolio construction method is useful, although the underlyings here is signals not assets. And correlation of signal return (NOTE: not performance) are needed in order to come up with weights. Several level (say, 2 levels) of grouping is useful, if you have several types of signals, and each of them has several variances. </p>
<p>$$raw_combined = f(corr, raw_signals)$$</p>
<p>There is another concept is needed: forcast diversification multiplier, FDM. The reason is that we want to maintian the scale level of combined signal as same as scale level as individiual signals. When the signals are not perfectly correlated, the raw weighted combination will always results in a lower scale level. So we need a multiplier to scale it back.</p>
<p>Agian, correlation is important here:</p>
<p>$$FDM = target_vol / portfolio_vol$$</p>
<p>NOTE: it is better to cap this formula as well to avoid large multiplier. </p>
<p>Again, after FDM, the signal level should be capped to 20, as we always do. (20 is just standard we selected, it needs to be consistent.)</p>
<p>So in the end:</p>
<p>$$<br>combined_signal = cap(raw_combined * FDM, -20, 20)$$</p>
<p><img src="https://i.imgur.com/xMt7Oll.png" alt=""></p>
<h3 id="Vol-targeting"><a href="#Vol-targeting" class="headerlink" title="Vol targeting"></a>Vol targeting</h3><p>The end result of this is just float, which is a overall volatility target you want to achieve. In another word, a parameter in the system, that will be used across the system. </p>
<p>There are two ways:</p>
<ul>
<li>vol in pct</li>
<li>vol in cash value</li>
</ul>
<h3 id="Position-sizing"><a href="#Position-sizing" class="headerlink" title="Position sizing"></a>Position sizing</h3><p>In this stage, the task is to work out how scaled position, like how may shares (no rounding yet),given vol target and combined signal for one instrument. Note that, here we assumed that all the capital will be allocated to one instrument.</p>
<p>To achieve this, the first quesitons: if I am holding 1 share/unit of this instrument, how much rish am I exposed to in terms of cash?</p>
<p>To answer that question, we define <strong>block value</strong> as: when holding 1 unit of instrument, the cash value movement when the price of the instrument moves 1%. In this way, a connection between cash value movement and price quote movement is built. Then we just need to figure out the prive volatility. </p>
<p>Bad news, estimation of volatility is not that easy.. </p>
<p>What’more, if you are holding multiple currency, it is better to convert cash value movement into base currency.</p>
<p>Now, without considering forecast, assume we put all the capital into one instrument, and want to achieve a cash volatility, we need a <strong>volatility scalar</strong>.</p>
<p>$$vol_scalar = tartet_cash_risk / block_value$$</p>
<p>Above vol scalar is associated to a average signal level 10, so the final position will be:</p>
<p>$$pos_sub = signal_level * vol_scalar<br>$$</p>
<h3 id="Portfolio"><a href="#Portfolio" class="headerlink" title="Portfolio"></a>Portfolio</h3><p>Finally, it is time to put all sub system above into a portfolio. Out of this, we will work out exactly how much units of each instruments we need to fill. In other words, generate a target position in terms of units (rounded).</p>
<p>The concept here is as same as in Combine Forecasts, except that the underlyings are now correlation between sub systems, instead of instruments.</p>
<blockquote>
<p>A good approximation is that the correlation between subsystem returns will be 0.70 of the correlation of instrument returns. So if two assets have a correlation of 0.5 between their instrument returns in appendix C, then their subsystems will have a correlation of 0.7 × 0.5 = 0.35.</p>
</blockquote>
<p>Note that, similar to FDM, an Instrument diversification multiplier, IDM, is needed here to avoid low resulting vol.</p>
<p>By this step, the positions are still fractional. Before we decide how much to trade, we need a buffer (position inertia) to avoid back forward small trade because of rounding. For the sake of reducing trading cost.</p>
<h3 id="Speed-and-size"><a href="#Speed-and-size" class="headerlink" title="Speed and size"></a>Speed and size</h3><p>Now, we have system to trade, the next question is that how to config the system? For example, what kind of predicor should I used? what kind of instrument should I trade? What target vol should I select?</p>
<h4 id="Caluclate-cost-of-trading"><a href="#Caluclate-cost-of-trading" class="headerlink" title="Caluclate cost of trading"></a>Caluclate cost of trading</h4><p>Types of cost:</p>
<ul>
<li>execution cost</li>
<li>mamangement fee for ETFs</li>
</ul>
<p>Agian, the costs of different instruments should be normalized to be compared. </p>
<p>$$ norm_cost = (2*C) / (16 * ICV)<br>$$</p>
<p>where,<br>$C$ is cost to trade 1 unit in currency C,<br>$ICV$ is daily instrument currency volatility.  </p>
<p>Note that 16 is for tha annulized vol. $norm_cost$ has the same unit as Sharpe ratio. So it is easy to compare the cost effect with the strategy sharpe ratio.</p>
<p>Some experience value of costs:</p>
<ul>
<li>Futures: 0.001</li>
<li>Spread betting: 0.01</li>
<li>ETF: 0.08</li>
</ul>
<h3 id="Turnover"><a href="#Turnover" class="headerlink" title="Turnover"></a>Turnover</h3><p>Now we need to measure how qucikly you trade. The number of round trips per year is the turnover. </p>
<p>A norm cost times turnover inshares, it is the final cost, in the same unit as sharpe ratio.</p>
<h3 id="Determine-portfolio-size"><a href="#Determine-portfolio-size" class="headerlink" title="Determine portfolio size"></a>Determine portfolio size</h3><p>2 × volatility scalar × instrument weight × instrument diversification multiplier</p>
<h2 id="Part-IV-Practice"><a href="#Part-IV-Practice" class="headerlink" title="Part IV Practice"></a>Part IV Practice</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Systematic Trading: A unique new method for designing trading and investing systems</li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>很潮的属11和弦</title>
    <url>/2020/04/13/chord_2/</url>
    <content><![CDATA[<p>在我们想要结束一段的时候，通常会用V -&gt; I的方式结束。以下我们用C调说明。</p>
<p>比如，<code>G7 -&gt; C</code>:</p>
<p><img src="https://i.imgur.com/9DPfaZS.png" alt=""></p>
<span id="more"></span>
<p>但是，这种进行显得非常古典。我们可以通过采用属11和弦让进行听起来更加流行。比如<code>F/G</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;:[GFAc]</span><br></pre></td></tr></table></figure>

<p>这样我们的和声进行可以变成：</p>
<p><img src="https://i.imgur.com/JqqVIIH.png" alt=""></p>
<p>这个<code>F/G</code> 也可以理解成G11但是去掉3和5音，也就是缩减版本的属11和弦。</p>
<p><img src="https://i.imgur.com/pp6Q65K.png" alt=""></p>
<p>吉他版本的 <code>F/G</code> and <code>Cadd2</code>:</p>
<p><img src="https://i.imgur.com/vWQGych.png" alt=""> <img src="https://i.imgur.com/r4rnaoa.png" alt=""></p>
<p>也可以记成<code>G9sus</code></p>
<p><img src="https://i.imgur.com/dqPj7q1.png" alt=""></p>
<p>吉他版本的 <code>G9sus4</code> 和 <code>Cmaj9</code> : </p>
<p><img src="https://i.imgur.com/hGKcbVN.png" alt=""> <img src="https://i.imgur.com/kxEC3F9.png" alt=""></p>
<p>所以，总结一下：</p>
<p><img src="https://i.imgur.com/NCmERJy.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=EdT1xi4qtT4">https://www.youtube.com/watch?v=EdT1xi4qtT4</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Chord</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo拓展功能</title>
    <url>/2020/04/13/chord_3/</url>
    <content><![CDATA[<p>目前，<code>abcjs</code> 还不支持非浏览器环境的使用，所以，目前似乎没办法变成 Hexo Tag。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://dustinpfister.github.io/2018/01/03/hexo-plugins/">https://dustinpfister.github.io/2018/01/03/hexo-plugins/</a></li>
<li><a href="https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html">https://blog.bitbadger.solutions/2017/writing-a-hexo-tag-plugin.html</a></li>
<li><a href="https://hexo.io/api/">https://hexo.io/api/</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Z-backtest</title>
    <url>/2020/04/07/z_backtesting/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Why? bother to create another backtest framework, if we already have plenty of them?</p>
<ul>
<li>I can not find even one backtest framework to backtest option (or deriveritive) based strategy properly. (Mix of option and delta one product is a Bigger NO!)</li>
<li>Debug/Reconcile backtest is painful, because of bad state management</li>
<li>Logic components are hard to re-use</li>
<li>And thanks to point 3, strategy code to strategy logic is not easy</li>
<li>Not easy to do strategy of strategies</li>
</ul>
<p>How? to solve above problems?</p>
<ol>
<li>Use unified interface for derivertive and delta-one Node (And Event a Strategy!)</li>
<li>Use explicit state management, things like Redux</li>
<li>Use Algo stacks to express logics</li>
<li>Thanks to point 3, this is solved</li>
<li>Use Tree structure to describe strategy (Check point 1)</li>
</ol>
<p>What? we will achieve in this framework?</p>
<ol>
<li>Derivertive/Delta-one/Strategy can be backtested together</li>
<li>Strategy data will be presented as a tree structure</li>
<li>Common logic can be tested and re-used easily</li>
<li>Compose common logics creats new strategy easily</li>
<li>Strategy logic will be explicitly expressed as Algo stucks</li>
<li>State evolution during backtesting is trasnprent </li>
</ol>
<p>What are not our goals (at least for now):</p>
<ol>
<li>Spead (If you are simple enough, you should be fast as well)</li>
<li>Live trading (state =&gt; order =&gt; trade =&gt; state)</li>
<li>Intraday strategy</li>
<li>A lot of built in batteries (common logics, or complex derivative Node)</li>
</ol>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2>]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Backtest</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio Signal Processing for Music Applications</title>
    <url>/2020/04/06/Audio_Signal_Processing_for_Music_Applications/</url>
    <content><![CDATA[<h1 id="Audio-Signal-Processing-for-Music-Applications"><a href="#Audio-Signal-Processing-for-Music-Applications" class="headerlink" title="Audio Signal Processing for Music Applications"></a>Audio Signal Processing for Music Applications</h1><p><a href="https://www.coursera.org/lecture/audio-signal-processing/dft-1-EZRXC">Course Link</a></p>
<blockquote>
<p>Perhaps most importantly, from the point of view of computer music research, is that the human ear is a kind of spectrum analyzer. That is, the cochlea of the inner ear physically splits sound into its (quasi) sinusoidal components. This is accomplished by the basilar membrane in the inner ear: a sound wave injected at the oval window (which is connected via the bones of the middle ear to the ear drum), travels along the basilar membrane inside the coiled cochlea. The membrane starts out thick and stiff, and gradually becomes thinner and more compliant toward its apex (the helicotrema). A stiff membrane has a high resonance frequency while a thin, compliant membrane has a low resonance frequency (assuming comparable mass per unit length, or at least less of a difference in mass than in compliance). Thus, as the sound wave travels, each frequency in the sound resonates at a particular place along the basilar membrane. The highest audible frequencies resonate right at the entrance, while the lowest frequencies travel the farthest and resonate near the helicotrema. The membrane resonance effectively <code>shorts out&#39;&#39; the signal energy at the resonant frequency, and it travels no further. Along the basilar membrane there are hair cells which</code>feel’’ the resonant vibration and transmit an increased firing rate along the auditory nerve to the brain. Thus, the ear is very literally a Fourier analyzer for sound, albeit nonlinear and using ``analysis’’ parameters that are difficult to match exactly. Nevertheless, by looking at spectra (which display the amount of each sinusoidal frequency present in a sound), we are looking at a representation much more like what the brain receives when we hear.</p>
</blockquote>
<span id="more"></span>

<p>Discrete Fourier Transform:</p>
<p>$$X[k]=\sum_{n=0}^{N-1}x[n]e^{-j2\pi kn/N}$$</p>
<p>Where,<br>$n$: discrete time index(normalized time, T = 1)<br>$k$: discrete frequency index<br>$w_k=2\pi k/N$: frequency in radians per seconds<br>$f_k=f_s k/N$: frequency in Hz ($f_s$ is sampling rate)</p>
<p>Complex exponentials:</p>
<p>$$s_k^* = e^{-j2\pi kn/N}$$</p>
<p>Scalar product:</p>
<p>$$&lt;x, s_k&gt; = \sum_{n=0}^{N-1}x[n]s_k^*[n]$$</p>
<p>Real sinusoid:</p>
<p>$$x[n] = Acos(2\pi fnT + \psi)$$</p>
<p>where,</p>
<p>$x$ is the array of real values of the sinusoid<br>$n$ is an integer value expressing the time index<br>$A$ is the amplitude vaclue of the sinusoid<br>$f$ is frequency in Hz<br>$T$ is sampling period, $1/f_s$, $f_s$ is the sampling frequency in Hz<br>$\psi$ is the initial phase in radians</p>
<p>Complex sinusiod:</p>
<p>$$x[n]=Ae^{j(wnT+\psi)} = Acos(wnT+\psi) + jAsin(wnT+\psi)$$</p>
<p>Inverse DFT:</p>
<p>$$x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]s_k[n]$$<br>where, $s$ is the conjugate of $s^*$.</p>
<p>The bridge between analog and digial signal.</p>
<p>$$f = \frac{F_s}{M}$$<br>where, M is period of digital signal, F_s is the sampling frequency in Hz, f is the frequency in analog signal in Hz.</p>
<p>The discrete-time oscillatory heartbeat:</p>
<p>$$x[n] = Ae^{j(wn+\psi)} = A[cos(wn+\psi)+jsin(wn+\psi)]$$</p>
<p>where, $A$ is amplitude, $w$ is frequency in radians, and $\psi$ is initial phase in radians.</p>
<p>The concept here is that a circular movement, the e part, can always be described as a sin and cos function for two dementions movements.</p>
<p>Multiple e part will rotate the point. hence:</p>
<p>$x[n]=e^{jwn}; x[n+1]=e^{jw}x[n]$</p>
<p>:::warning<br>Not every sinusoid is periodic in discrete time! $e^{jwn}$ is periodic in n, only when $w=\frac{M}{N}2\pi$<br>:::</p>
<p>If $w &gt; 2\pi$, we have issues.</p>
<h2 id="Vector-space-in-DSP"><a href="#Vector-space-in-DSP" class="headerlink" title="Vector space in DSP"></a>Vector space in DSP</h2><p>Once we model something in vector space, all the tools in vectors space is open to us!</p>
<p>:::info<br>The item in vectors, can be any thing! such as functions!<br>:::</p>
<p>Some examples of vector spaces:</p>
<ul>
<li>$\mathbb{R}^2: x=[x_0, x_1]^T$</li>
<li>$\mathbb{R}^3: x=[x_0, x_1, x_2]^T$</li>
<li>$L_2(-1, 1): x=x(t), t\in[-1, 1]$</li>
<li>$\mathbb{R}^N$</li>
</ul>
<p>The ingredients of vector space (Data Structure):</p>
<ul>
<li>the set of vectors, V</li>
<li>a set of scalars, say $\mathbb{C}$</li>
</ul>
<p>At least to some methods to apply to these Data:</p>
<ul>
<li>resize vectors</li>
<li>combine vectors</li>
</ul>
<p>So formal properties of a vector space:</p>
<ul>
<li>x + y = y + x</li>
<li>(x+y)+z = x+(y+z)</li>
<li>a(x+y)= ax + ay</li>
<li>inner product, $&lt;.,.&gt;: V*V \to \mathbb{C}$<ul>
<li>&lt;x+y, z&gt; = &lt;x, y+z&gt;</li>
<li>….</li>
</ul>
</li>
<li>…</li>
</ul>
<p>Inner product reflect the similarity of two vectors! If 0, means orgthogno, or no simalarity! We have <code>norm</code> and <code>distance</code> of two vectors. The <code>distance</code> in $L_2$ function vector space, also called mean square error!</p>
<h2 id="Signal-Space"><a href="#Signal-Space" class="headerlink" title="Signal Space"></a>Signal Space</h2><p>Finite-length and periodic signals live in $\mathbb{C}^N$. </p>
<p>The inner product operation is defined:</p>
<p>$$&lt;x, y&gt; = \sum_{n=0}^{N-1}x^{*}[n]y[n]$$</p>
<p>By finite, it requires the sequences to be square-summable: $\sum |x[n]|^2&lt;\infty$. This is energy of signal, so finite energy!</p>
<p>:::info<br>Hilbert Space: $H(V, \mathbb{C})$:</p>
<ul>
<li>an inner product is defined</li>
<li>completeness on all required vector operation<br>:::</li>
</ul>
<h2 id="Bases"><a href="#Bases" class="headerlink" title="Bases"></a>Bases</h2><p>Linear combination is the basic operation in vector spaces. How can we find a set of building blocks, vectors, to express all the other vectors in the space??</p>
<p>Formal definition of bases:</p>
<p>Given: </p>
<ul>
<li>a vector space, H</li>
<li>a set of K vectors from $W= {w^{(k)}}_{k=0,1,…,K-1}$</li>
</ul>
<p>W is a basis for H if:</p>
<ol>
<li>we can write all $x\in H$:<br>$$x = \sum_{k=0}^{K-1}\alpha w^, \alpha_k\in\mathbb{C}$$</li>
<li>$\alpha_k$ are unique</li>
</ol>
<p>Orthogonal basis</p>
<p>Orthonormal basis</p>
<p>By orthonormal basis, </p>
<p>$$\alpha_k=&lt;w, x&gt;$$</p>
<p>Change basis:</p>
<p><img src="https://i.imgur.com/9SdEpoD.png" alt="Change Basis"></p>
<h2 id="Subspace-bases-approximations"><a href="#Subspace-bases-approximations" class="headerlink" title="Subspace bases approximations"></a>Subspace bases approximations</h2><p>Approximate using sub-space.</p>
<h3 id="Least-square-approximation"><a href="#Least-square-approximation" class="headerlink" title="Least square approximation"></a>Least square approximation</h3><p>Given $s^{(k)}<em>{k=0,1,…,K-1}$ are orthonormal basis for S,<br>the orthogonal projection:<br>$$\hat{x}=\sum</em>{}^{}&lt;s^{(k)}, x&gt;s^{(k)}$$</p>
<p>is the best approximation of over S. It has minimum norm error, the error is also orthogonal to approximation, which means this sub space cannot get more information any more.</p>
<p>Gram-Schmidt orthonormlization procedure.</p>
<h2 id="Fouries-Analysis"><a href="#Fouries-Analysis" class="headerlink" title="Fouries Analysis"></a>Fouries Analysis</h2><p>Osillations are everywhere. And system does not move in circles, can’t last long.</p>
<p>Fouries analysis is simply a base change in vector space $\mathbb{C}^N$.</p>
<p>$$w_k[n]=e^{j\frac{2\pi}{N}nk}$$</p>
<p>where $n, k = 0,1,…,N-1$.</p>
<p>Above is an orthogonal basis in $\mathbb{C}$</p>
<h2 id="DFT-Discrete-Fouries-Transformaion"><a href="#DFT-Discrete-Fouries-Transformaion" class="headerlink" title="DFT, Discrete Fouries Transformaion"></a>DFT, Discrete Fouries Transformaion</h2><p>The analysis formular:</p>
<p>$$X_k = &lt;w_k, x&gt;$$</p>
<p>The synthesis formula:</p>
<p>$$x = \frac{1}{N}\sum_{k=0}^{N-1}X_kw^{(k)}$$</p>
<h2 id="Interpreting-DFT"><a href="#Interpreting-DFT" class="headerlink" title="Interpreting DFT"></a>Interpreting DFT</h2><p><img src="https://i.imgur.com/z5XIDHQ.png" alt=""></p>
<p><img src="https://i.imgur.com/aT146UI.png" alt=""></p>
<h3 id="How-to-label-DFT-result"><a href="#How-to-label-DFT-result" class="headerlink" title="How to label DFT result?"></a>How to label DFT result?</h3><p>Given sample number is N, sample frequency is $f_s$, if we find a peak in DFT at k = 500, what is the corresponding frequency in Hz? </p>
<p>The highest freqency in the system is $f_s/2$.</p>
<p>$f = kf_s/N$</p>
<h2 id="DFT-in-Music"><a href="#DFT-in-Music" class="headerlink" title="DFT in Music"></a>DFT in Music</h2><p>Frequency, harmonics. timbre is different because of the harmonics. But the pitch is just the first frequency component. </p>
<p><img src="https://i.imgur.com/UnhGofZ.png" alt=""></p>
<h2 id="DFT-synthesis"><a href="#DFT-synthesis" class="headerlink" title="DFT synthesis"></a>DFT synthesis</h2><p><img src="https://i.imgur.com/KfWDMkE.png" alt=""></p>
<p>Frequency in Hz and in radians:</p>
<p>$$f = \frac{wf_s}{2\pi}$$</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><h2 id="STFT-short-term-fouries-transform"><a href="#STFT-short-term-fouries-transform" class="headerlink" title="STFT, short term fouries transform"></a>STFT, short term fouries transform</h2><p>Spectrogram is a way to show STFT. There are two variables: window and frequency. $X[m;k]$, where m is the window, k is frequency index.</p>
<p>Spectrogram show time, frequency at the same time. Once we know the sample frequency, we can label the spectrogram.</p>
<p>$T_s = 1/F_s$, the frequency resolution is $f_s/L Hz$, and the width of time slices is $LT_s$.</p>
<p>Question to ask:</p>
<ul>
<li>width of window?</li>
<li>position of the window?</li>
<li>shape of the window?</li>
</ul>
<p><img src="https://i.imgur.com/A5PBgce.png" alt=""></p>
<p>Short window gives better time precision, while long window give better frequency precision.</p>
<p><img src="https://i.imgur.com/L2UAe8g.png" alt=""></p>
<p>STFT leads to wavelet transform.</p>
<h1 id="The-DFT-Numerical-Aspects"><a href="#The-DFT-Numerical-Aspects" class="headerlink" title="The DFT: Numerical Aspects"></a>The DFT: Numerical Aspects</h1><p>As a quick reminder, the definitions of the direct and inverse DFT for a length-$N$ signal are:</p>
<p>\begin{align<em>}<br>    X[k] &amp;= \sum_{n=0}^{N-1} x[n], e^{-j\frac{2\pi}{N}nk}, \quad k=0, \ldots, N-1 \<br>    x[n] &amp;= \frac{1}{N}\sum_{k=0}^{N-1} X[k], e^{j\frac{2\pi}{N}nk}, \quad n=0, \ldots, N-1<br>\end{align</em>}</p>
<p>The DFT produces a complex-valued vector that we can represent either via its real and imaginary parts or via its magnitude $|X[k]|$ and phase $\angle X[k] = \arctan \frac{\text{Im}{X[k]}}{\text{Re}{X[k]}}$.</p>
<h3 id="Numerical-errors-in-real-and-imaginary-parts"><a href="#Numerical-errors-in-real-and-imaginary-parts" class="headerlink" title="Numerical errors in real and imaginary parts"></a>Numerical errors in real and imaginary parts</h3><p>The DFT can be easily implemented using the change of basis matrix ${W}_N$. This is an $N\times N$ complex-valued matrix whose elements are </p>
<p>$$<br>    {W}_N(n,k)=e^{-j\frac{2\pi}{N}nk}<br>$$</p>
<p>so that the DFT of a vector $\mathbf{x}$ is simply $\mathbf{X} = W_N\mathbf{x}$. Note that the inverse DFT can be obtained by simply conjugating ${W}_N$ so that $\mathbf{x} = W_N^*\mathbf{X}$.</p>
<p>We can easily generate the matrix ${W}_N$ in Python like so:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft_matrix</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># create a 1xN matrix containing indices 0 to N-1</span></span><br><span class="line">    a = np.expand_dims(np.arange(N), <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># take advantage of numpy broadcasting to create the matrix</span></span><br><span class="line">    W = np.exp(-<span class="number">2j</span> * (np.pi / N) * (a.T * a))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> W</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT matrix</span></span><br><span class="line">N = <span class="built_in">len</span>(x)</span><br><span class="line">W = dft_matrix(N);</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFT</span></span><br><span class="line">X = np.dot(W, x)</span><br><span class="line"><span class="comment"># inverse DFT</span></span><br><span class="line">x_hat = np.dot(W.T.conjugate(), X) / N</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x-x_hat)</span><br></pre></td></tr></table></figure>

<h2 id="Fouries-representation-for-signal-class"><a href="#Fouries-representation-for-signal-class" class="headerlink" title="Fouries representation for signal class"></a>Fouries representation for signal class</h2><ul>
<li>N-point finite-length: DFT</li>
<li>N-point periodic: DFS</li>
<li>infinite length: DTFT</li>
</ul>
<p><img src="https://i.imgur.com/ZnK3RgD.png" alt=""></p>
<p><img src="https://i.imgur.com/uzP9LOM.png" alt=""></p>
<p><img src="https://i.imgur.com/AUUxJbD.png" alt=""></p>
<h2 id="Sinusoidal-modulation"><a href="#Sinusoidal-modulation" class="headerlink" title="Sinusoidal modulation"></a>Sinusoidal modulation</h2><p>Based on where most frequencies are located.</p>
<ul>
<li>lowpass signal</li>
<li>highpass signal</li>
<li>bandpass signal</li>
</ul>
<p>How?</p>
<p><img src="https://i.imgur.com/4VwKahL.png" alt=""></p>
<p>Why?</p>
<p><img src="https://i.imgur.com/JZGmVkB.png" alt=""></p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p><img src="" alt="Uploading file..._kr65l8uvc"></p>
<h3 id="Linear-time-invariant-filters"><a href="#Linear-time-invariant-filters" class="headerlink" title="Linear time-invariant filters"></a>Linear time-invariant filters</h3><p>Linearity</p>
<p><img src="https://i.imgur.com/3qUraJ1.png" alt=""></p>
<p>Time-invariant</p>
<p><img src="https://i.imgur.com/8nz362v.png" alt=""></p>
<p>Add them we have</p>
<p><img src="https://i.imgur.com/HgmAN8f.png" alt=""></p>
<p>In formalar:</p>
<p><img src="https://i.imgur.com/htfvgNy.png" alt=""></p>
<h3 id="Convolution-1"><a href="#Convolution-1" class="headerlink" title="Convolution"></a>Convolution</h3><p>LTI filters are entirely characterized by their impulse reponse, i.e., their response to the impulse delta function $\delta[n]$, the output of an LTI filter y[n]  y[n] can be computed by convolving the input x[n]  x[n] with the impulse response,</p>
<p>$$<br>\delta[n]=\sum_{k=-\inf}^{inf}x[k]h[n-k]<br>$$</p>
<h3 id="Filter-by-examples"><a href="#Filter-by-examples" class="headerlink" title="Filter by examples"></a>Filter by examples</h3><p>Moving average: </p>
<p><img src="https://i.imgur.com/C8gsV6B.png" alt=""></p>
<p>Leaky integrator: </p>
<p><img src="https://i.imgur.com/5UgmloR.png" alt=""></p>
<h3 id="Filter-types"><a href="#Filter-types" class="headerlink" title="Filter types"></a>Filter types</h3><ul>
<li>lowpass, MA, leaky</li>
<li>highpass</li>
<li>bandpass</li>
<li>allpass</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><ul>
<li><a href="https://ccrma.stanford.edu/~jos/mdft/">https://ccrma.stanford.edu/~jos/mdft/</a></li>
<li><a href="https://www.youtube.com/watch?v=MBnnXbOM5S4">The more general uncertainty principle, beyond quantum</a></li>
<li><a href="youtube.com/watch?v=spUNpyF58BY">But what is the Fourier Transform? A visual introduction</a></li>
<li><a href="https://www.youtube.com/watch?v=r6sGWTCMz2k">But what is a Fourier series? From heat flow to circle drawings</a></li>
<li><a href="http://www.jezzamon.com/fourier/index.html">An Interactive Introduction to Fourier Transforms</a></li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Signal Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>配和弦的方法</title>
    <url>/2020/04/05/how-to-chords/</url>
    <content><![CDATA[<h2 id="配和弦的基本规则"><a href="#配和弦的基本规则" class="headerlink" title="配和弦的基本规则"></a>配和弦的基本规则</h2><ol>
<li>选择含有旋律音的调内和弦</li>
<li>多种选择的时候，考虑上下文以及和弦功能<ol>
<li>下一个和弦用什么？增加一些变化</li>
<li>功能和弦：比如G7是属和弦，会制造紧张，回归C</li>
<li>其他附属和弦，比如Dm，F等等</li>
</ol>
</li>
<li>多久换一个和弦？</li>
<li>递归上面的过程</li>
</ol>
<h2 id="和弦有什么功能"><a href="#和弦有什么功能" class="headerlink" title="和弦有什么功能"></a>和弦有什么功能</h2><p>分类1：</p>
<ul>
<li>主和弦，Tonic，I</li>
<li>属和弦，dominant, V。G7，<strong>三全音</strong>产生更加不稳定的感觉</li>
<li>下属和弦，桥梁，去G 或者 G7</li>
<li>附属和弦，你要接的下一个和弦的上面5度音的属7和弦，比如下一个是Em，可以用B7过度到他</li>
</ul>
<p>分类2：</p>
<ul>
<li>家：C, I</li>
<li>外面：G7,Bdim. V,vii</li>
<li>桥：Dm，F，他们很喜欢去外面。ii, iv</li>
<li>暂时的家，或者家的延伸：Em，Am. iii, vi</li>
</ul>
<p><img src="https://i.imgur.com/EFZjJPV.png" alt="功能"></p>
<span id="more"></span>

<h2 id="递归上面的规则！"><a href="#递归上面的规则！" class="headerlink" title="递归上面的规则！"></a>递归上面的规则！</h2><p>可以选定目标和弦作为暂时的１级和弦，然后在前面添加该调的常见回家进行，比如ii -&gt; V -&gt; I.</p>
<p><img src="https://i.imgur.com/n1bl3Ou.png" alt=""><br><img src="https://i.imgur.com/oAuXgIT.png" alt=""><br><img src="https://i.imgur.com/6buXmP8.png" alt=""></p>
<p>当然，使用上面的方法是，临时的V可以被另外一个包含相同三全音的和弦代替，比如比目标I和弦，高半个音的属和弦。比如下面这个例子：</p>
<p><img src="https://i.imgur.com/3EzZzZ8.png" alt=""></p>
<p>还可以通过从平行调中，借用和弦。比如在Ｃ调中，可以借用Ｃｍ中的Ｆｍ和弦，回到Ｃ和弦。</p>
<p><img src="https://i.imgur.com/ymKfpIv.png" alt=""></p>
<h2 id="认识和弦"><a href="#认识和弦" class="headerlink" title="认识和弦"></a>认识和弦</h2><ul>
<li>Major</li>
<li>Minor</li>
<li>Dominant</li>
</ul>
<p><img src="https://i.imgur.com/iJQPvFb.png" alt=""><br><img src="https://i.imgur.com/w4ttqAC.png" alt=""><br><img src="https://i.imgur.com/s2deAcz.png" alt=""><br><img src="https://i.imgur.com/0VhtLrr.png" alt=""></p>
<h3 id="和弦变化"><a href="#和弦变化" class="headerlink" title="和弦变化"></a>和弦变化</h3><ul>
<li>add</li>
<li>sus</li>
<li>omit</li>
<li>()</li>
<li>转位</li>
<li>其他家族</li>
</ul>
<p><img src="https://i.imgur.com/z8ax5Da.png" alt=""><br><img src="https://i.imgur.com/Bg4L8JM.png" alt=""><br><img src="https://i.imgur.com/7lDnl3B.png" alt=""><br><img src="https://i.imgur.com/sokdbbh.png" alt=""><br><img src="https://i.imgur.com/rvK0h7b.png" alt=""><br><img src="https://i.imgur.com/FKhpfiE.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.musictheory.net/products/lessons">Musictheory</a></li>
<li><a href="https://www.youtube.com/channel/UCVXstWyJeO6No3jYELxYrjg">好和弦</a></li>
</ul>
]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Chord</tag>
      </tags>
  </entry>
  <entry>
    <title>Major Update</title>
    <url>/2020/03/29/major-update/</url>
    <content><![CDATA[<p>I updated my blog. Not sure I will move old posts here. But I put them here: <a href="https://github.com/wangzhe3224/wangzhe3224.github.io.backup/tree/master/_posts">Old post</a>.<br>Just in case. </p>
<p>Zhe</p>
]]></content>
      <categories>
        <category>Admin</category>
      </categories>
  </entry>
  <entry>
    <title>Road Map for Investment Tool Box</title>
    <url>/2020/01/01/road_map/</url>
    <content><![CDATA[<h2 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h2><p>Create series of tools to for my investment. Open to public use. </p>
<h2 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h2><p>Build simple and small components, if I cannot see the whole picture. Even I am smart enough to see whole picture, I will do the same.</p>
<h2 id="Software-Engineering"><a href="#Software-Engineering" class="headerlink" title="Software Engineering"></a>Software Engineering</h2><ol>
<li>Composition: Design simple tools in a way that we can chain different tool together.</li>
<li>Test-Driven: Test creats sense of accomplishmen and modularity.</li>
<li>Cloud-Based Deployment: leverage AWS service.<span id="more"></span>

</li>
</ol>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>Follow the philosoph, tools</p>
<ul>
<li><input disabled="" type="checkbox"> Data tools</li>
<li><input disabled="" type="checkbox"> VIX term structures</li>
<li><input disabled="" type="checkbox"> Yield curve</li>
<li><input disabled="" type="checkbox"> Time series statistics</li>
<li><input disabled="" type="checkbox"> Correlation tools</li>
<li><input disabled="" type="checkbox"> MOV tools</li>
<li><input disabled="" type="checkbox"> Option tools</li>
<li><input disabled="" type="checkbox"> Backtesting tools</li>
<li><input disabled="" type="checkbox"> Time series generate tools</li>
</ul>
<h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><ul>
<li>Date/Time</li>
<li>Time series</li>
<li>Term structure</li>
<li>Matrix</li>
</ul>
<h2 id="Presentations"><a href="#Presentations" class="headerlink" title="Presentations"></a>Presentations</h2><ul>
<li>Graph</li>
<li>Table</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/robertmartin8/PyPortfolioOpt">PyPortfolioOpt</a></li>
<li><a href="https://github.com/lballabio/QuantLib-SWIG/tree/master/Python">QuantLib</a></li>
<li><a href="https://www.backtrader.com/">Backtrader</a></li>
<li><a href="https://github.com/pmorissette/bt">Bt</a></li>
<li><a href="http://qoppac.blogspot.com/">Systematic Trading</a></li>
</ul>
]]></content>
      <categories>
        <category>Quant</category>
      </categories>
      <tags>
        <tag>Investing</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2019/12/31/how_to_read/</url>
    <content><![CDATA[<h1 id="如何阅读一本书"><a href="#如何阅读一本书" class="headerlink" title="如何阅读一本书"></a>如何阅读一本书</h1><p>具体的阅读方法：</p>
<ul>
<li>Layer 1 read: 提出一些原认知问题，一边读书，一边补充完善<ul>
<li>这本书的目的</li>
<li>作者想要解决的问题</li>
<li>作者如何组织材料</li>
<li>作者的关键概念有哪些</li>
<li>作者的结论是什么</li>
<li>我学到了什么</li>
<li>与我有什么关系</li>
</ul>
</li>
<li>Layer 2 read: 稍微具体阅读每一个章节，但不会为了不懂得内容停留过长时间，主要在于总结作者每一个章节都在讲什么？<ul>
<li>这一章在讲什么</li>
<li>如何联系到作者的写作目的</li>
<li>如何联系到上一章</li>
<li>关键概念</li>
<li>解决了什么问题</li>
<li>结论</li>
</ul>
</li>
<li>Layer 3 read: 精读感兴趣的地方，甚至动手操作。</li>
</ul>
<span id="more"></span>

<h2 id="如何主动的阅读"><a href="#如何主动的阅读" class="headerlink" title="如何主动的阅读"></a>如何主动的阅读</h2><p>主动阅读涉及到的问题可以在不同的层次被反复提出，比如最高的层次应该针对这一类书提出，然后针对这一本书提出，然后针对每一个章节提出。</p>
<p>问自己如下几个问题：</p>
<ol>
<li>整体来说，这本书在说什么？这本书的主题是什么？作者是如何一步一步阐述这个主题的？</li>
<li>作者细节上都说了什么？他主要的观点、声明是什么？</li>
<li>这本书说的有道理吗？部分有道理？还是全部有道理？</li>
<li>这本书跟我有什么关系？书上的信息对我有什么意义？跟我已有的知识有什么关系？</li>
</ol>
<p>仅仅提出问题还不够，还需要有效的回答问题。</p>
<ol>
<li>在书上做笔记，标注</li>
<li>记录相关的页码</li>
</ol>
<p>在不同的阅读阶段，所提出和记录的问题是不同的。笔记主要可以分成三种：</p>
<ol>
<li>结构笔记：这是什么样的书？结构如何？如何展开陈述？</li>
<li>概念笔记：可以引用别的书籍的解释</li>
<li>辩证笔记：？？？？？？</li>
</ol>
<h2 id="阅读的四个层次"><a href="#阅读的四个层次" class="headerlink" title="阅读的四个层次"></a>阅读的四个层次</h2><ol>
<li>基础阅读：这个句子在说什么？</li>
<li>检视阅读：这本书属于什么分类？是什么架构？包含那些主要部分？</li>
<li>分析阅读：大量的时间，对书中内容进行系统性的提问，以获得深刻的理解</li>
<li>主题阅读：同一类主题的众多书籍之间的联系？那些内容是新的？那些存在矛盾？</li>
</ol>
<p>这四个层次的阅读存在上一级别包含下一级别的关系。</p>
<h3 id="1、基础阅读"><a href="#1、基础阅读" class="headerlink" title="1、基础阅读"></a>1、基础阅读</h3><p>基本相当于美国9年级的阅读水平。可以认识绝大部分的单词，能够无障碍的理解句子的意思</p>
<h3 id="2、检视阅读"><a href="#2、检视阅读" class="headerlink" title="2、检视阅读"></a>2、检视阅读</h3><p>包含两个部分：系统的略读和？？？？</p>
<p><strong>略读</strong></p>
<p>目的是发现这本书是不是我需要的？这个过程最多不会超过1小时，具体操作如下：</p>
<ul>
<li>书名，副标题。为后续的归类做准备</li>
<li>目录，了解书籍的总体架构</li>
<li>索引，了解书籍涵盖的概念范围，寻找那些主题出现频率最高</li>
<li>前言和作者介绍，一般会向读者说明如何阅读本书或者很多写作的上下文，帮助理解</li>
<li>从目录中挑选几段自己觉得感兴趣的快速的读一下</li>
<li>书的结尾，了解主要的结论，一般作者会在最后对全书进行总结</li>
</ul>
<p><strong>粗浅的阅读</strong></p>
<p>由于检视阅读的最终目的是为了从总体上了解书籍的主题和脉络，因此在这个阶段，先要从头到尾的第一遍，即使遇到了不懂的地方，也<strong>不要</strong>停下来查询或者思索。</p>
<h3 id="3、分析阅读"><a href="#3、分析阅读" class="headerlink" title="3、分析阅读"></a>3、分析阅读</h3><p>能够提供读者对一本书架构的认识。总结如下：</p>
<ol>
<li>依照本书的种类与主题，对书籍进行分类</li>
<li>用最短的句子概括本书的主要内容</li>
<li>按照顺序与关系，列出全书的重要部分，总结各部分提纲。</li>
<li>找出作者希望通过本书解决的问题</li>
<li>诠释作者使用的关键字，与作者首先达成共识；</li>
<li>找到重点句子，并且用自己的方式概括主旨；</li>
<li>找出作者的论述段落，重新架构作者的前因后果，以明白作者的主张；</li>
<li>确定作者解决的了那些问题，那些还没有解决；在没有解决的问题中，那些是作者认为无法解决的？</li>
</ol>
<h3 id="一本书的分类"><a href="#一本书的分类" class="headerlink" title="一本书的分类"></a>一本书的分类</h3><p><strong>第一个原则是知道书籍的分类</strong>，根据不同的分类存在不同的阅读分析方法。应该逐渐建立自己的书籍分类标准，比如小说和论述。论述中又包含科学、人文和哲学。</p>
<p>一般来说，书籍可以分成<strong>实用性</strong>和<strong>理论性</strong>。理论性作品会教你这是什么，而实用性作品会叫你如何做想要做的事情或者你认为应该做的事情。<br>实用性的书籍会经常出现，应该、好坏、结果和意义之类的词语。</p>
<p>人文历史类的书籍，关心时间问题；科学书籍不关心时间；哲学比较像科学，也是追求一般真理，但是哲学往往依托的是主观，而科学依靠事实。（那么数学呢？）</p>
<h3 id="透视一本书"><a href="#透视一本书" class="headerlink" title="透视一本书"></a>透视一本书</h3><p><strong>分析阅读的第二个原则是：使用一个简单的句子或者几句话来叙述整本书的内容。</strong>　也就是发现一本书的作者准备做什么。</p>
<p>将总结落实到文字，记录下来。模糊的印象往往没有效果。</p>
<p><strong>分析阅读的第三个原则是：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。</strong> 一本书的各个部分只有有逻辑的链接在一起才会变的对我有意义。</p>
<p>在完成了原则2的任务后，按照如下方法总结书籍整体架构：</p>
<ol>
<li>作者将全书分为x个部分，第一部分谈。。。第二部分谈。。。</li>
<li>第一个部分可以分成y个段落</li>
<li>第一个段落有z个重点问题</li>
</ol>
<p>:::info<br>读者需要在书籍中发现隐藏的骨架，而作者则是先构建了骨架，确用更加丰富的材料隐藏骨架。这一点跟音乐、美术等等很多东西都一样。<br>:::</p>
<p><strong>分析阅读第四个原则：找出作者想要问的问题</strong>。一本书的作者开始写作时通常有一个或者多个问题，全书的推进就是在试图解决这些问题。</p>
<p>找到与作者共通的词义,或者反复出现的词？</p>
<p><strong>第五个原则（部分1）</strong>：抓住书中的单字，搞清楚作者是如何使用这个单字的。一般就是那些最让我头疼的词。或者理解问书中的反复出现的基础概念。这些基础概念往往会在不同的语境下产生不同的意义。</p>
<p>比如，财富，在国富论中就是专门用于，而物种在进化论中才是专门用语。</p>
<p><strong>第五个原则（部分2）</strong>：判断重要的词汇是不是在各种语境下是不是有专门的含义？</p>
<p><strong>第六个原则</strong>：圈出重要的句子，找出其中的主旨。找出主旨的好办法是，用自己的话重写作者的意思。</p>
<p><strong>第七个原则</strong>：从相关文句的关联中，设法架构出一个本书的基本论述。找到文中的论述段落。</p>
<p><strong>第八个原则</strong>：找出作者对于论述问题的解答。</p>
<p>上述的四个原则，能够提供读者对一本书架构的认识。总结如下：</p>
<h3 id="分析阅读的第三阶段"><a href="#分析阅读的第三阶段" class="headerlink" title="分析阅读的第三阶段"></a>分析阅读的第三阶段</h3><p>:::info<br>必须能评论，提出批评，才算真正完成这件事（主动阅读一本书这件事情）。受教是一种美德，但是受教不是盲目服从。<br>:::</p>
<p>这部分主要涉及读者对书籍的评论。但是在对书籍进行评论前，应该先去报自己已经理解作者想要表达的意义了。</p>
<p>批评观点的几个标准：</p>
<ol>
<li>证明作者的知识不足；</li>
<li>证明作者的知识错误；</li>
<li>证明作者不合逻辑；</li>
<li>证明作者分析和理由是不完整的。</li>
</ol>
<h3 id="不同书籍的阅读方法"><a href="#不同书籍的阅读方法" class="headerlink" title="不同书籍的阅读方法"></a>不同书籍的阅读方法</h3><h4 id="实用性的书"><a href="#实用性的书" class="headerlink" title="实用性的书"></a>实用性的书</h4><p>一般就是讲述规则的书，谈论的主题是关于如何做的更好或者如何避免更糟。这种书籍最主要的任务自然是寻找规则。</p>
<p>另一类实用的书籍，主要谈论规则后面的原理，但是它不是纯理论的书籍。其主旨实在说明某件事情的状态，论述就是强调真的如此。 </p>
<p>阅读实用性书籍的两个主要问题：</p>
<ol>
<li>作者的目的是什么？</li>
<li>他建议用什么方法达到这个目的？</li>
</ol>
<h4 id="科学与数学书籍"><a href="#科学与数学书籍" class="headerlink" title="科学与数学书籍"></a>科学与数学书籍</h4><p>数学其实一种语言，学习语言要学习两次，第一次学习如何说话，第二次学习如何阅读。</p>
<p>首先学习语法，然后才是表达理解。</p>
<h4 id="哲学书"><a href="#哲学书" class="headerlink" title="哲学书"></a>哲学书</h4><h4 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h4><h2 id="4、主题阅读"><a href="#4、主题阅读" class="headerlink" title="4、主题阅读"></a>4、主题阅读</h2><p>主题阅读的五个步骤：</p>
<ol>
<li>找到相关章节</li>
<li>用自己的语言表达作者的想法，这样才可以联系不同的作者</li>
<li>厘清问题</li>
<li>界定议题</li>
<li>分析讨论</li>
</ol>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
